/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * OpenAPI spec version: 2.0.4
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.tiledb.com/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Model representing aws keys or service role, service roles are currently ignored, but will be preferred option in the future
 * @export
 * @interface AWSAccessCredentials
 */
export interface AWSAccessCredentials {
    /**
     * aws secret access key, never returned in get requests
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    secretAccessKey?: string;
    /**
     * aws access key
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    accessKeyId?: string;
    /**
     * aws service role to use for access
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    serviceRoleArn?: string;
    /**
     * human readable name
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    name?: string;
    /**
     * true if this is the default credential to be used within this namespace
     * @type {boolean}
     * @memberof AWSAccessCredentials
     */
    _default?: boolean;
    /**
     * a whitelist of one or more buckets this key should access
     * @type {Array<string>}
     * @memberof AWSAccessCredentials
     */
    buckets?: Array<string>;
    /**
     * Time when udf dependencies was created (rfc3339)
     * @type {Date}
     * @memberof AWSAccessCredentials
     */
    createdAt?: Date;
    /**
     * Time when udf dependencies was last updated (rfc3339)
     * @type {Date}
     * @memberof AWSAccessCredentials
     */
    updatedAt?: Date;
}

/**
 * Type of activity logged
 * @export
 * @enum {string}
 */
export enum ActivityEventType {
    ReadSchema = <any> 'read_schema',
    MaxBufferSizes = <any> 'max_buffer_sizes',
    NonEmptyDomain = <any> 'non_empty_domain',
    QueryRead = <any> 'query_read',
    QueryWrite = <any> 'query_write',
    Create = <any> 'create',
    Delete = <any> 'delete',
    Register = <any> 'register',
    Deregister = <any> 'deregister',
    Udf = <any> 'udf',
    ArrayMetadataGet = <any> 'array_metadata_get',
    ArrayMetadataUpdate = <any> 'array_metadata_update',
    EstimatedResultSizes = <any> 'estimated_result_sizes'
}

/**
 * actions a user can take on an array
 * @export
 * @enum {string}
 */
export enum ArrayActions {
    Read = <any> 'read',
    Write = <any> 'write',
    Edit = <any> 'edit',
    ReadArrayLogs = <any> 'read_array_logs',
    ReadArrayInfo = <any> 'read_array_info',
    ReadArraySchema = <any> 'read_array_schema'
}

/**
 * Actvity of an Array
 * @export
 * @interface ArrayActivityLog
 */
export interface ArrayActivityLog {
    /**
     * time event took place (RFC3339)
     * @type {Date}
     * @memberof ArrayActivityLog
     */
    eventAt?: Date;
    /**
     * Type of the event
     * @type {ActivityEventType}
     * @memberof ArrayActivityLog
     */
    action?: ActivityEventType;
    /**
     * User who performed action
     * @type {string}
     * @memberof ArrayActivityLog
     */
    username?: string;
    /**
     * Bytes sent to client
     * @type {number}
     * @memberof ArrayActivityLog
     */
    bytesSent?: number;
    /**
     * Bytes recieved from client
     * @type {number}
     * @memberof ArrayActivityLog
     */
    bytesReceived?: number;
    /**
     * uuid of associated array task
     * @type {string}
     * @memberof ArrayActivityLog
     */
    arrayTaskId?: string;
    /**
     * ranges for query
     * @type {string}
     * @memberof ArrayActivityLog
     */
    queryRanges?: string;
}

/**
 * Object including array info and pagination metadata
 * @export
 * @interface ArrayBrowserData
 */
export interface ArrayBrowserData {
    /**
     * Array Info
     * @type {Array<ArrayInfo>}
     * @memberof ArrayBrowserData
     */
    arrays?: Array<ArrayInfo>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof ArrayBrowserData
     */
    paginationMetadata?: PaginationMetadata;
}

/**
 * Object for ui array tasks browser page
 * @export
 * @interface ArrayBrowserSidebar
 */
export interface ArrayBrowserSidebar {
    /**
     * list of all unique namespaces to display
     * @type {Array<string>}
     * @memberof ArrayBrowserSidebar
     */
    namespaces?: Array<string>;
    /**
     * A count of \"all\" of category
     * @type {number}
     * @memberof ArrayBrowserSidebar
     */
    resultCountForAll?: number;
    /**
     * A map that includes the result count by namespace
     * @type {any}
     * @memberof ArrayBrowserSidebar
     */
    resultCountByNamespace?: any;
}

/**
 * metadata of an array
 * @export
 * @interface ArrayInfo
 */
export interface ArrayInfo {
    /**
     * unique id of registered array
     * @type {string}
     * @memberof ArrayInfo
     */
    id?: string;
    /**
     * uri of array
     * @type {string}
     * @memberof ArrayInfo
     */
    uri?: string;
    /**
     * namespace array is in
     * @type {string}
     * @memberof ArrayInfo
     */
    namespace?: string;
    /**
     * size in bytes of array
     * @type {number}
     * @memberof ArrayInfo
     */
    size?: number;
    /**
     * Datetime array was last accessed in UTC
     * @type {Date}
     * @memberof ArrayInfo
     */
    lastAccessed?: Date;
    /**
     * description of array
     * @type {string}
     * @memberof ArrayInfo
     */
    description?: string;
    /**
     * name of array
     * @type {string}
     * @memberof ArrayInfo
     */
    name?: string;
    /**
     * list of actions user is allowed to do on this array
     * @type {Array<ArrayActions>}
     * @memberof ArrayInfo
     */
    allowedActions?: Array<ArrayActions>;
    /**
     * list of pricing created for this array
     * @type {Array<Pricing>}
     * @memberof ArrayInfo
     */
    pricing?: Array<Pricing>;
    /**
     * list of subscriptions created for this array
     * @type {Array<Subscription>}
     * @memberof ArrayInfo
     */
    subscriptions?: Array<Subscription>;
    /**
     * logo (base64 encoded) for the array. Optional
     * @type {string}
     * @memberof ArrayInfo
     */
    logo?: string;
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used
     * @type {string}
     * @memberof ArrayInfo
     */
    accessCredentialsName?: string;
    /**
     * Array type (dense, key-value, sparse)
     * @type {string}
     * @memberof ArrayInfo
     */
    type?: string;
    /**
     * number of unique namespaces this array is shared with
     * @type {number}
     * @memberof ArrayInfo
     */
    shareCount?: number;
    /**
     * Suggests if the array was shared to public by owner
     * @type {boolean}
     * @memberof ArrayInfo
     */
    publicShare?: boolean;
    /**
     * uri for access through TileDB cloud
     * @type {string}
     * @memberof ArrayInfo
     */
    tiledbUri?: string;
    /**
     * optional tags for array
     * @type {Array<string>}
     * @memberof ArrayInfo
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom
     * @type {string}
     * @memberof ArrayInfo
     */
    licenseId?: string;
    /**
     * License text
     * @type {string}
     * @memberof ArrayInfo
     */
    licenseText?: string;
}

/**
 * metadata of an array
 * @export
 * @interface ArrayInfoUpdate
 */
export interface ArrayInfoUpdate {
    /**
     * description of array
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    description?: string;
    /**
     * description of array
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    name?: string;
    /**
     * uri of array
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    uri?: string;
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    accessCredentialsName?: string;
    /**
     * logo (base64 encoded) for the array. Optional
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    logo?: string;
    /**
     * optional tags for array
     * @type {Array<string>}
     * @memberof ArrayInfoUpdate
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    licenseId?: string;
    /**
     * License text
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    licenseText?: string;
}

/**
 * user's TileDB array metadata
 * @export
 * @interface ArrayMetadata
 */
export interface ArrayMetadata {
    /**
     * List of metadata entries
     * @type {Array<ArrayMetadataEntry>}
     * @memberof ArrayMetadata
     */
    ranges?: Array<ArrayMetadataEntry>;
}

/**
 * key/value pair representing an array metadata map entry
 * @export
 * @interface ArrayMetadataEntry
 */
export interface ArrayMetadataEntry {
    /**
     * 
     * @type {string}
     * @memberof ArrayMetadataEntry
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof ArrayMetadataEntry
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof ArrayMetadataEntry
     */
    valueNum?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ArrayMetadataEntry
     */
    value?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof ArrayMetadataEntry
     */
    del?: boolean;
}

/**
 * Metadata from array in Json format
 * @export
 * @interface ArrayMetadataJson
 */
export interface ArrayMetadataJson {
}

/**
 * Sample data from array
 * @export
 * @interface ArraySample
 */
export interface ArraySample {
    /**
     * 
     * @type {any}
     * @memberof ArraySample
     */
    data?: any;
}

/**
 * ArraySchema during creation or retrieval
 * @export
 * @interface ArraySchema
 */
export interface ArraySchema {
    /**
     * URI of schema
     * @type {string}
     * @memberof ArraySchema
     */
    uri?: string;
    /**
     * file format version
     * @type {Array<number>}
     * @memberof ArraySchema
     */
    version: Array<number>;
    /**
     * Type of array
     * @type {ArrayType}
     * @memberof ArraySchema
     */
    arrayType: ArrayType;
    /**
     * Tile order setting of array
     * @type {Layout}
     * @memberof ArraySchema
     */
    tileOrder: Layout;
    /**
     * Order of cells
     * @type {Layout}
     * @memberof ArraySchema
     */
    cellOrder: Layout;
    /**
     * Capacity of array
     * @type {number}
     * @memberof ArraySchema
     */
    capacity: number;
    /**
     * Filter pipeline used for coordinates (enum)
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    coordsFilterPipeline: FilterPipeline;
    /**
     * Filter pipeline use for variable offsets (enum)
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    offsetFilterPipeline: FilterPipeline;
    /**
     * Domain of array
     * @type {Domain}
     * @memberof ArraySchema
     */
    domain: Domain;
    /**
     * Attributes of array
     * @type {Array<Attribute>}
     * @memberof ArraySchema
     */
    attributes: Array<Attribute>;
    /**
     * True if the array allows coordinate duplicates. Applicable only to sparse arrays.
     * @type {boolean}
     * @memberof ArraySchema
     */
    allowsDuplicates?: boolean;
}

/**
 * details for sharing a given array
 * @export
 * @interface ArraySharing
 */
export interface ArraySharing {
    /**
     * List of permitted actions
     * @type {Array<ArrayActions>}
     * @memberof ArraySharing
     */
    actions?: Array<ArrayActions>;
    /**
     * namespace being granted array access can be a user or organization
     * @type {string}
     * @memberof ArraySharing
     */
    namespace?: string;
    /**
     * details on if the namespace is a organization or user
     * @type {string}
     * @memberof ArraySharing
     */
    namespaceType?: string;
}

/**
 * Synchronous Task to Run
 * @export
 * @interface ArrayTask
 */
export interface ArrayTask {
    /**
     * task id
     * @type {string}
     * @memberof ArrayTask
     */
    id?: string;
    /**
     * Optional task name
     * @type {string}
     * @memberof ArrayTask
     */
    name?: string;
    /**
     * Optional task description (Tasks purpose)
     * @type {string}
     * @memberof ArrayTask
     */
    description?: string;
    /**
     * Metadata of the array used in the context of this task
     * @type {ArrayInfo}
     * @memberof ArrayTask
     */
    arrayMetadata?: ArrayInfo;
    /**
     * A subarray to run the array task on
     * @type {DomainArray}
     * @memberof ArrayTask
     */
    subarray?: DomainArray;
    /**
     * memory allocated to task in bytes
     * @type {number}
     * @memberof ArrayTask
     */
    memory?: number;
    /**
     * millicpu allocated to task
     * @type {number}
     * @memberof ArrayTask
     */
    cpu?: number;
    /**
     * namespace task is tied to
     * @type {string}
     * @memberof ArrayTask
     */
    namespace?: string;
    /**
     * The status of an individual task
     * @type {ArrayTaskStatus}
     * @memberof ArrayTask
     */
    status?: ArrayTaskStatus;
    /**
     * Start time RFC3339 for job
     * @type {Date}
     * @memberof ArrayTask
     */
    startTime?: Date;
    /**
     * Finish time RFC3339 for job
     * @type {Date}
     * @memberof ArrayTask
     */
    finishTime?: Date;
    /**
     * Cost accumulated for task in USD, example is $0.12
     * @type {number}
     * @memberof ArrayTask
     */
    cost?: number;
    /**
     * If task type is query, whether its a read or write query
     * @type {Querytype}
     * @memberof ArrayTask
     */
    queryType?: Querytype;
    /**
     * Optional actual code that is going to be executed
     * @type {string}
     * @memberof ArrayTask
     */
    udfCode?: string;
    /**
     * Optional actual language used to express udf_code
     * @type {string}
     * @memberof ArrayTask
     */
    udfLanguage?: string;
    /**
     * Optional actual sql query that is going to be executed
     * @type {string}
     * @memberof ArrayTask
     */
    sqlQuery?: string;
    /**
     * Type of task
     * @type {ArrayTaskType}
     * @memberof ArrayTask
     */
    type?: ArrayTaskType;
    /**
     * Array activity logs for task
     * @type {Array<ArrayActivityLog>}
     * @memberof ArrayTask
     */
    activity?: Array<ArrayActivityLog>;
    /**
     * logs from array task
     * @type {string}
     * @memberof ArrayTask
     */
    logs?: string;
}

/**
 * Object for ui array tasks browser page
 * @export
 * @interface ArrayTaskBrowserSidebar
 */
export interface ArrayTaskBrowserSidebar {
    /**
     * list of all unique organizations the user is part of that have array tasks
     * @type {Array<string>}
     * @memberof ArrayTaskBrowserSidebar
     */
    organizations?: Array<string>;
    /**
     * A count of \"all\"
     * @type {number}
     * @memberof ArrayTaskBrowserSidebar
     */
    resultCountForAll?: number;
    /**
     * A map that includes the result count by namespace
     * @type {any}
     * @memberof ArrayTaskBrowserSidebar
     */
    resultCountByNamespace?: any;
}

/**
 * Object including array tasks and metadata
 * @export
 * @interface ArrayTaskData
 */
export interface ArrayTaskData {
    /**
     * Array Tasks
     * @type {Array<ArrayTask>}
     * @memberof ArrayTaskData
     */
    arrayTasks?: Array<ArrayTask>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof ArrayTaskData
     */
    paginationMetadata?: PaginationMetadata;
}

/**
 * Array task stderr/stdout logs
 * @export
 * @interface ArrayTaskLog
 */
export interface ArrayTaskLog {
    /**
     * ID of associated task
     * @type {string}
     * @memberof ArrayTaskLog
     */
    arrayTaskId?: string;
    /**
     * logs from array task
     * @type {string}
     * @memberof ArrayTaskLog
     */
    logs?: string;
}

/**
 * Status of array task
 * @export
 * @enum {string}
 */
export enum ArrayTaskStatus {
    FAILED = <any> 'FAILED',
    COMPLETED = <any> 'COMPLETED',
    RUNNING = <any> 'RUNNING'
}

/**
 * Synchronous Task Type
 * @export
 * @enum {string}
 */
export enum ArrayTaskType {
    SQL = <any> 'SQL',
    UDF = <any> 'UDF',
    QUERY = <any> 'QUERY',
    GENERICUDF = <any> 'GENERIC_UDF'
}

/**
 * TileDB array type
 * @export
 * @enum {string}
 */
export enum ArrayType {
    Dense = <any> 'dense',
    Sparse = <any> 'sparse'
}

/**
 * Attribute of array
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * Attribute name
     * @type {string}
     * @memberof Attribute
     */
    name: string;
    /**
     * 
     * @type {Datatype}
     * @memberof Attribute
     */
    type: Datatype;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof Attribute
     */
    filterPipeline: FilterPipeline;
    /**
     * Attribute number of values per cell
     * @type {number}
     * @memberof Attribute
     */
    cellValNum: number;
}

/**
 * Represents an attribute buffer header information
 * @export
 * @interface AttributeBufferHeader
 */
export interface AttributeBufferHeader {
    /**
     * Attribute name
     * @type {string}
     * @memberof AttributeBufferHeader
     */
    name: string;
    /**
     * Number of bytes in the fixed-length attribute data buffer (offsets for var-len attributes)
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    fixedLenBufferSizeInBytes: number;
    /**
     * Number of bytes in the var-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    varLenBufferSizeInBytes: number;
}

/**
 * object representing buffer size of an attribute
 * @export
 * @interface AttributeBufferSize
 */
export interface AttributeBufferSize {
    /**
     * name of attribute
     * @type {string}
     * @memberof AttributeBufferSize
     */
    attribute: string;
    /**
     * buffer size (in bytes) of offset buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    offsetBytes: number;
    /**
     * buffer size (in bytes) of data buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    dataBytes: number;
}

/**
 * TileDB data type
 * @export
 * @enum {string}
 */
export enum Datatype {
    INT32 = <any> 'INT32',
    INT64 = <any> 'INT64',
    FLOAT32 = <any> 'FLOAT32',
    FLOAT64 = <any> 'FLOAT64',
    CHAR = <any> 'CHAR',
    INT8 = <any> 'INT8',
    UINT8 = <any> 'UINT8',
    INT16 = <any> 'INT16',
    UINT16 = <any> 'UINT16',
    UINT32 = <any> 'UINT32',
    UINT64 = <any> 'UINT64',
    STRINGASCII = <any> 'STRING_ASCII',
    STRINGUTF8 = <any> 'STRING_UTF8',
    STRINGUTF16 = <any> 'STRING_UTF16',
    STRINGUTF32 = <any> 'STRING_UTF32',
    STRINGUCS2 = <any> 'STRING_UCS2',
    STRINGUCS4 = <any> 'STRING_UCS4',
    ANY = <any> 'ANY'
}

/**
 * Dimension of array
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * Dimension name
     * @type {string}
     * @memberof Dimension
     */
    name?: string;
    /**
     * 
     * @type {Datatype}
     * @memberof Dimension
     */
    type: Datatype;
    /**
     * extent of domain
     * @type {DomainArray}
     * @memberof Dimension
     */
    domain: DomainArray;
    /**
     * Is tile extent null
     * @type {boolean}
     * @memberof Dimension
     */
    nullTileExtent: boolean;
    /**
     * 
     * @type {DimensionTileExtent}
     * @memberof Dimension
     */
    tileExtent?: DimensionTileExtent;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof Dimension
     */
    filterPipeline?: FilterPipeline;
}

/**
 * A single, typed coordinate for a dimension
 * @export
 * @interface DimensionCoordinate
 */
export interface DimensionCoordinate {
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int8?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint8?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int16?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint16?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int64?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint64?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    float32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    float64?: number;
}

/**
 * Extent of tile
 * @export
 * @interface DimensionTileExtent
 */
export interface DimensionTileExtent {
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int8?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint8?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int16?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint16?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int64?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint64?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    float32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    float64?: number;
}

/**
 * Domain of array
 * @export
 * @interface Domain
 */
export interface Domain {
    /**
     * Domain Type
     * @type {Datatype}
     * @memberof Domain
     */
    type: Datatype;
    /**
     * Tile Order
     * @type {Layout}
     * @memberof Domain
     */
    tileOrder: Layout;
    /**
     * Cell Order
     * @type {Layout}
     * @memberof Domain
     */
    cellOrder: Layout;
    /**
     * Array of dimensions
     * @type {Array<Dimension>}
     * @memberof Domain
     */
    dimensions: Array<Dimension>;
}

/**
 * Domain object for an array of each type
 * @export
 * @interface DomainArray
 */
export interface DomainArray {
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int8?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint8?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int16?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint16?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int32?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint32?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int64?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint64?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float32?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float64?: Array<number>;
}

/**
 * Filter
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * Filter type
     * @type {FilterType}
     * @memberof Filter
     */
    type: FilterType;
    /**
     * 
     * @type {FilterData}
     * @memberof Filter
     */
    data?: FilterData;
}

/**
 * Filter data
 * @export
 * @interface FilterData
 */
export interface FilterData {
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int8?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint8?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int16?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint16?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int32?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint32?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int64?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint64?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    float32?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    float64?: number;
}

/**
 * TileDB filter option
 * @export
 * @enum {string}
 */
export enum FilterOption {
    COMPRESSIONLEVEL = <any> 'COMPRESSION_LEVEL',
    BITWIDTHMAXWINDOW = <any> 'BIT_WIDTH_MAX_WINDOW',
    POSITIVEDELTAMAXWINDOW = <any> 'POSITIVE_DELTA_MAX_WINDOW'
}

/**
 * One or more filters to apply
 * @export
 * @interface FilterPipeline
 */
export interface FilterPipeline {
    /**
     * 
     * @type {Array<Filter>}
     * @memberof FilterPipeline
     */
    filters?: Array<Filter>;
}

/**
 * TileDB filter types
 * @export
 * @enum {string}
 */
export enum FilterType {
    NONE = <any> 'FILTER_NONE',
    GZIP = <any> 'FILTER_GZIP',
    ZSTD = <any> 'FILTER_ZSTD',
    LZ4 = <any> 'FILTER_LZ4',
    RLE = <any> 'FILTER_RLE',
    BZIP2 = <any> 'FILTER_BZIP2',
    DOUBLEDELTA = <any> 'FILTER_DOUBLE_DELTA',
    BITWIDTHREDUCTION = <any> 'FILTER_BIT_WIDTH_REDUCTION',
    BITSHUFFLE = <any> 'FILTER_BITSHUFFLE',
    BYTESHUFFLE = <any> 'FILTER_BYTESHUFFLE',
    POSITIVEDELTA = <any> 'FILTER_POSITIVE_DELTA'
}

/**
 * User-defined function
 * @export
 * @interface GenericUDF
 */
export interface GenericUDF {
    /**
     * name of UDFInfo to run, format is {namespace}/{udf_name}. Can not be used with exec
     * @type {string}
     * @memberof GenericUDF
     */
    udfInfoName?: string;
    /**
     * UDF language
     * @type {UDFLanguage}
     * @memberof GenericUDF
     */
    language?: UDFLanguage;
    /**
     * Type-specific version
     * @type {string}
     * @memberof GenericUDF
     */
    version?: string;
    /**
     * Docker image name to use for udf
     * @type {string}
     * @memberof GenericUDF
     */
    imageName?: string;
    /**
     * Type-specific executable text
     * @type {string}
     * @memberof GenericUDF
     */
    exec?: string;
    /**
     * optional raw text to store of serialized function, used for showing in UI
     * @type {string}
     * @memberof GenericUDF
     */
    execRaw?: string;
    /**
     * Argument to pass to udf function
     * @type {string}
     * @memberof GenericUDF
     */
    argument?: string;
    /**
     * type of results (native, i.e cloud pickle or json)
     * @type {UDFResultType}
     * @memberof GenericUDF
     */
    resultFormat?: UDFResultType;
    /**
     * name of task, optional
     * @type {string}
     * @memberof GenericUDF
     */
    taskName?: string;
}

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * string of stats from tiledb
     * @type {string}
     * @memberof InlineResponse200
     */
    stats?: string;
}

/**
 * Invitations to share or collaborate
 * @export
 * @interface Invitation
 */
export interface Invitation {
    /**
     * Unique id of invitation added to magic link
     * @type {string}
     * @memberof Invitation
     */
    id?: string;
    /**
     * Type of invitation
     * @type {InvitationType}
     * @memberof Invitation
     */
    invitationType?: InvitationType;
    /**
     * Namespace of the owner of the invitation (user or organization)
     * @type {string}
     * @memberof Invitation
     */
    ownerNamespaceUuid?: string;
    /**
     * Unique id of the user accepted the invitation
     * @type {string}
     * @memberof Invitation
     */
    userNamespaceUuid?: string;
    /**
     * Unique id of the organization user accepted the invitation
     * @type {string}
     * @memberof Invitation
     */
    organizationUserUuid?: string;
    /**
     * Name of the organization, does not persist in database
     * @type {string}
     * @memberof Invitation
     */
    organizationName?: string;
    /**
     * Role of the invited namespace in the joined organization
     * @type {OrganizationRoles}
     * @memberof Invitation
     */
    organizationRole?: OrganizationRoles;
    /**
     * Unique id of the array
     * @type {string}
     * @memberof Invitation
     */
    arrayUuid?: string;
    /**
     * Name of the array, does not persist in database
     * @type {string}
     * @memberof Invitation
     */
    arrayName?: string;
    /**
     * Email of the individual we send the invitation to
     * @type {string}
     * @memberof Invitation
     */
    email?: string;
    /**
     * A comma separated list of ArrayActions or NamespaceActions
     * @type {string}
     * @memberof Invitation
     */
    actions?: string;
    /**
     * Status of invitation
     * @type {InvitationStatus}
     * @memberof Invitation
     */
    status?: InvitationStatus;
    /**
     * Datetime the invitation was created in UTC
     * @type {Date}
     * @memberof Invitation
     */
    createdAt?: Date;
    /**
     * Datetime the invitation is expected to expire in UTC
     * @type {Date}
     * @memberof Invitation
     */
    expiresAt?: Date;
    /**
     * Datetime the invitation was accepted in UTC
     * @type {Date}
     * @memberof Invitation
     */
    acceptedAt?: Date;
}

/**
 * Encapsulates information regarding inviting people using email to share array, same permissions for all invitees
 * @export
 * @interface InvitationArrayShareEmail
 */
export interface InvitationArrayShareEmail {
    /**
     * List of permitted actions
     * @type {Array<ArrayActions>}
     * @memberof InvitationArrayShareEmail
     */
    actions: Array<ArrayActions>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InvitationArrayShareEmail
     */
    inviteeEmail: Array<string>;
}

/**
 * Object including invitations and metadata
 * @export
 * @interface InvitationData
 */
export interface InvitationData {
    /**
     * List of invitations
     * @type {Array<Invitation>}
     * @memberof InvitationData
     */
    invitations?: Array<Invitation>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof InvitationData
     */
    paginationMetadata?: PaginationMetadata;
}

/**
 * Encapsulates information regarding inviting people using email to join organization, same permissions for all invitees
 * @export
 * @interface InvitationOrganizationJoinEmail
 */
export interface InvitationOrganizationJoinEmail {
    /**
     * List of permitted actions
     * @type {Array<NamespaceActions>}
     * @memberof InvitationOrganizationJoinEmail
     */
    actions?: Array<NamespaceActions>;
    /**
     * Role of the invited namespace in the joined organization
     * @type {OrganizationRoles}
     * @memberof InvitationOrganizationJoinEmail
     */
    organizationRole: OrganizationRoles;
    /**
     * 
     * @type {Array<string>}
     * @memberof InvitationOrganizationJoinEmail
     */
    inviteeEmail: Array<string>;
}

/**
 * List of values that InvitationStatus can take
 * @export
 * @enum {string}
 */
export enum InvitationStatus {
    PENDING = <any> 'PENDING',
    ACCEPTED = <any> 'ACCEPTED'
}

/**
 * List of values that InvitationType can take
 * @export
 * @enum {string}
 */
export enum InvitationType {
    ARRAYSHARE = <any> 'ARRAY_SHARE',
    JOINORGANIZATION = <any> 'JOIN_ORGANIZATION'
}

/**
 * Information related to last access of an array
 * @export
 * @interface LastAccessedArray
 */
export interface LastAccessedArray {
    /**
     * unique id of array
     * @type {string}
     * @memberof LastAccessedArray
     */
    arrayId?: string;
    /**
     * name of the array
     * @type {string}
     * @memberof LastAccessedArray
     */
    arrayName?: string;
    /**
     * namespace of a user or organization
     * @type {string}
     * @memberof LastAccessedArray
     */
    namespace?: string;
    /**
     * timestamp (epoch milliseconds) array is last accessed
     * @type {number}
     * @memberof LastAccessedArray
     */
    accessedTime?: number;
    /**
     * Type of the event
     * @type {ActivityEventType}
     * @memberof LastAccessedArray
     */
    accessType?: ActivityEventType;
}

/**
 * Layout of array
 * @export
 * @enum {string}
 */
export enum Layout {
    RowMajor = <any> 'row-major',
    ColMajor = <any> 'col-major',
    GlobalOrder = <any> 'global-order',
    Unordered = <any> 'unordered'
}

/**
 * a list of max buffer sizes, one per attribute
 * @export
 * @interface MaxBufferSizes
 */
export interface MaxBufferSizes {
    /**
     * 
     * @type {Array<AttributeBufferSize>}
     * @memberof MaxBufferSizes
     */
    maxBufferSizes?: Array<AttributeBufferSize>;
}

/**
 * Represents an open array
 * @export
 * @interface ModelArray
 */
export interface ModelArray {
    /**
     * timestamp (epoch milliseconds) array is opened at
     * @type {number}
     * @memberof ModelArray
     */
    timestamp: number;
    /**
     * Array opened for query type
     * @type {Querytype}
     * @memberof ModelArray
     */
    queryType: Querytype;
    /**
     * Array uri
     * @type {string}
     * @memberof ModelArray
     */
    uri: string;
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
}

/**
 * actions a user can take on an organization
 * @export
 * @enum {string}
 */
export enum NamespaceActions {
    Read = <any> 'read',
    Write = <any> 'write',
    Create = <any> 'create',
    Delete = <any> 'delete',
    Edit = <any> 'edit',
    ReadArrayLogs = <any> 'read_array_logs',
    ReadJobLogs = <any> 'read_job_logs',
    ReadObjectLogs = <any> 'read_object_logs',
    RunJob = <any> 'run_job',
    DeleteOrganization = <any> 'delete_organization',
    EditOrganization = <any> 'edit_organization',
    EditBilling = <any> 'edit_billing'
}

/**
 * object representing a non-empty domain
 * @export
 * @interface NonEmptyDomain
 */
export interface NonEmptyDomain {
    /**
     * Non Empty Domain of array
     * @type {DomainArray}
     * @memberof NonEmptyDomain
     */
    nonEmptyDomain: DomainArray;
    /**
     * Is non-empty domain really empty?
     * @type {boolean}
     * @memberof NonEmptyDomain
     */
    isEmpty: boolean;
}

/**
 * Settings for a namespace's notebooks
 * @export
 * @interface NotebookSettings
 */
export interface NotebookSettings {
    /**
     * default s3 path to store newly created notebooks
     * @type {string}
     * @memberof NotebookSettings
     */
    defaultS3Path?: string;
}

/**
 * Status details of a notebook server
 * @export
 * @interface NotebookStatus
 */
export interface NotebookStatus {
    /**
     * namespace of notebook
     * @type {string}
     * @memberof NotebookStatus
     */
    namespace?: string;
    /**
     * duration notebook has been running in seconds
     * @type {number}
     * @memberof NotebookStatus
     */
    uptime?: number;
    /**
     * current cpu usage in millicpu
     * @type {number}
     * @memberof NotebookStatus
     */
    cpuUsage?: number;
    /**
     * memory usage in bytes
     * @type {number}
     * @memberof NotebookStatus
     */
    memoryUsage?: number;
    /**
     * memory allocated to notebook server in bytes
     * @type {number}
     * @memberof NotebookStatus
     */
    memoryLimit?: number;
    /**
     * millicpu allocated to notebook server
     * @type {number}
     * @memberof NotebookStatus
     */
    cpuCount?: number;
}

/**
 * Organization
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * unique id of organization
     * @type {string}
     * @memberof Organization
     */
    id?: string;
    /**
     * role of requested user within this organization
     * @type {OrganizationRoles}
     * @memberof Organization
     */
    role?: OrganizationRoles;
    /**
     * organization name must be unique
     * @type {string}
     * @memberof Organization
     */
    name: string;
    /**
     * Datetime organization was created in UTC
     * @type {Date}
     * @memberof Organization
     */
    createdAt?: Date;
    /**
     * Datetime organization was updated in UTC
     * @type {Date}
     * @memberof Organization
     */
    updatedAt?: Date;
    /**
     * Organization logo
     * @type {string}
     * @memberof Organization
     */
    logo?: string;
    /**
     * Organization description
     * @type {string}
     * @memberof Organization
     */
    description?: string;
    /**
     * 
     * @type {Array<OrganizationUser>}
     * @memberof Organization
     */
    users?: Array<OrganizationUser>;
    /**
     * list of actions user is allowed to do on this organization
     * @type {Array<NamespaceActions>}
     * @memberof Organization
     */
    allowedActions?: Array<NamespaceActions>;
    /**
     * number of registered arrays for this organization
     * @type {number}
     * @memberof Organization
     */
    numOfArrays?: number;
    /**
     * List of extra/optional/beta features to enable for namespace
     * @type {Array<string>}
     * @memberof Organization
     */
    enabledFeatures?: Array<string>;
    /**
     * A notice that the user has an unpaid subscription
     * @type {boolean}
     * @memberof Organization
     */
    unpaidSubscription?: boolean;
    /**
     * 
     * @type {NotebookSettings}
     * @memberof Organization
     */
    notebookSettings?: NotebookSettings;
}

/**
 * role user has in organization
 * @export
 * @enum {string}
 */
export enum OrganizationRoles {
    Owner = <any> 'owner',
    Admin = <any> 'admin',
    ReadWrite = <any> 'read_write',
    ReadOnly = <any> 'read_only'
}

/**
 * user in an organization
 * @export
 * @interface OrganizationUser
 */
export interface OrganizationUser {
    /**
     * unique id of user
     * @type {string}
     * @memberof OrganizationUser
     */
    userId?: string;
    /**
     * unique id of organization
     * @type {string}
     * @memberof OrganizationUser
     */
    organizationId?: string;
    /**
     * username for user
     * @type {string}
     * @memberof OrganizationUser
     */
    username?: string;
    /**
     * name of organization
     * @type {string}
     * @memberof OrganizationUser
     */
    organizationName?: string;
    /**
     * 
     * @type {OrganizationRoles}
     * @memberof OrganizationUser
     */
    role?: OrganizationRoles;
    /**
     * list of actions user is allowed to do on this organization
     * @type {Array<NamespaceActions>}
     * @memberof OrganizationUser
     */
    allowedActions?: Array<NamespaceActions>;
}

/**
 * 
 * @export
 * @interface PaginationMetadata
 */
export interface PaginationMetadata {
    /**
     * pagination offset
     * @type {number}
     * @memberof PaginationMetadata
     */
    page?: number;
    /**
     * pagination limit
     * @type {number}
     * @memberof PaginationMetadata
     */
    perPage?: number;
    /**
     * number of total pages with current limit
     * @type {number}
     * @memberof PaginationMetadata
     */
    totalPages?: number;
    /**
     * number of total available items
     * @type {number}
     * @memberof PaginationMetadata
     */
    totalItems?: number;
}

/**
 * Pricing created by converting an array to product
 * @export
 * @interface Pricing
 */
export interface Pricing {
    /**
     * Unique id of plan as defined by Stripe
     * @type {string}
     * @memberof Pricing
     */
    id?: string;
    /**
     * Unique id of registered array
     * @type {string}
     * @memberof Pricing
     */
    arrayUuid?: string;
    /**
     * Name of pricing
     * @type {string}
     * @memberof Pricing
     */
    pricingName?: string;
    /**
     * Type of pricing
     * @type {PricingType}
     * @memberof Pricing
     */
    pricingType?: PricingType;
    /**
     * Name of product
     * @type {string}
     * @memberof Pricing
     */
    productName?: string;
    /**
     * Extra information about a product which will appear on the credit card statement of the customer
     * @type {string}
     * @memberof Pricing
     */
    productStatementDescriptor?: string;
    /**
     * A label that represents units of this product in Stripe and receipts and invoices of the customer
     * @type {PricingUnitLabel}
     * @memberof Pricing
     */
    productUnitLabel?: PricingUnitLabel;
    /**
     * Currency of pricing
     * @type {PricingCurrency}
     * @memberof Pricing
     */
    currency?: PricingCurrency;
    /**
     * Specifies a usage aggregation strategy for pricings of usage_type=metered
     * @type {PricingAggregateUsage}
     * @memberof Pricing
     */
    aggregateUsage?: PricingAggregateUsage;
    /**
     * The frequency with which a subscription should be billed
     * @type {PricingInterval}
     * @memberof Pricing
     */
    interval?: PricingInterval;
    /**
     * Group of n product unit labels
     * @type {number}
     * @memberof Pricing
     */
    dividedBy?: number;
    /**
     * Price in cents (decimal) per unitlabel
     * @type {number}
     * @memberof Pricing
     */
    charge?: number;
    /**
     * If pricing is activated
     * @type {boolean}
     * @memberof Pricing
     */
    activated?: boolean;
}

/**
 * Specifies a usage aggregation strategy for pricings of usage_type=metered
 * @export
 * @enum {string}
 */
export enum PricingAggregateUsage {
    Sum = <any> 'sum'
}

/**
 * Currency of pricing
 * @export
 * @enum {string}
 */
export enum PricingCurrency {
    USD = <any> 'USD'
}

/**
 * Interval for pricing
 * @export
 * @enum {string}
 */
export enum PricingInterval {
    Month = <any> 'month'
}

/**
 * Pricing types
 * @export
 * @enum {string}
 */
export enum PricingType {
    Egress = <any> 'egress',
    Access = <any> 'access'
}

/**
 * Unit label
 * @export
 * @enum {string}
 */
export enum PricingUnitLabel {
    Byte = <any> 'byte',
    Second = <any> 'second'
}

/**
 * Query parameter to get array metadatas
 * @export
 * @enum {string}
 */
export enum PublicShareFilter {
    Exclude = <any> 'exclude',
    Only = <any> 'only'
}

/**
 * 
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * 
     * @type {Querytype}
     * @memberof Query
     */
    type: Querytype;
    /**
     * 
     * @type {Layout}
     * @memberof Query
     */
    layout: Layout;
    /**
     * 
     * @type {Querystatus}
     * @memberof Query
     */
    status: Querystatus;
    /**
     * List of attribute buffer headers
     * @type {Array<AttributeBufferHeader>}
     * @memberof Query
     */
    attributeBufferHeaders: Array<AttributeBufferHeader>;
    /**
     * writer contains data needed for continuation of global write order queries
     * @type {Writer}
     * @memberof Query
     */
    writer?: Writer;
    /**
     * reader contains data needed for continuation of reads
     * @type {QueryReader}
     * @memberof Query
     */
    reader?: QueryReader;
    /**
     * Represents an open array
     * @type {any}
     * @memberof Query
     */
    array: any;
    /**
     * Total number of bytes in fixed size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalFixedLengthBufferBytes: number;
    /**
     * Total number of bytes in variable size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalVarLenBufferBytes: number;
}

/**
 * Read struct (can't be called reader due to class name conflict)
 * @export
 * @interface QueryReader
 */
export interface QueryReader {
    /**
     * 
     * @type {Layout}
     * @memberof QueryReader
     */
    layout?: Layout;
    /**
     * 
     * @type {Subarray}
     * @memberof QueryReader
     */
    subarray?: Subarray;
    /**
     * To handle incomplete read queries.
     * @type {ReadState}
     * @memberof QueryReader
     */
    readState?: ReadState;
}

/**
 * Status of query
 * @export
 * @enum {string}
 */
export enum Querystatus {
    FAILED = <any> 'FAILED',
    COMPLETED = <any> 'COMPLETED',
    INPROGRESS = <any> 'INPROGRESS',
    INCOMPLETE = <any> 'INCOMPLETE',
    UNINITIALIZED = <any> 'UNINITIALIZED'
}

/**
 * Type of query
 * @export
 * @enum {string}
 */
export enum Querytype {
    READ = <any> 'READ',
    WRITE = <any> 'WRITE'
}

/**
 * state for reads
 * @export
 * @interface ReadState
 */
export interface ReadState {
    /**
     * True if the reader has been initialized.
     * @type {boolean}
     * @memberof ReadState
     */
    initialized?: boolean;
    /**
     * True if the query produced results that could not fit in some buffer.
     * @type {boolean}
     * @memberof ReadState
     */
    overflowed?: boolean;
    /**
     * True if the current subarray partition is unsplittable.
     * @type {boolean}
     * @memberof ReadState
     */
    unsplittable?: boolean;
    /**
     * 
     * @type {SubarrayPartitioner}
     * @memberof ReadState
     */
    subarrayPartitioner?: SubarrayPartitioner;
}

/**
 * Parameters for running sql query
 * @export
 * @interface SQLParameters
 */
export interface SQLParameters {
    /**
     * name of task, optional
     * @type {string}
     * @memberof SQLParameters
     */
    name?: string;
    /**
     * query to run
     * @type {string}
     * @memberof SQLParameters
     */
    query?: string;
    /**
     * Output array uri
     * @type {string}
     * @memberof SQLParameters
     */
    outputUri?: string;
}

/**
 * Single sign on provider
 * @export
 * @enum {string}
 */
export enum SSOProvider {
    Github = <any> 'github',
    Google = <any> 'google',
    Stripe = <any> 'stripe'
}

/**
 * A Subarray
 * @export
 * @interface Subarray
 */
export interface Subarray {
    /**
     * 
     * @type {Layout}
     * @memberof Subarray
     */
    layout?: Layout;
    /**
     * List of 1D ranges, one per dimension
     * @type {Array<SubarrayRanges>}
     * @memberof Subarray
     */
    ranges?: Array<SubarrayRanges>;
}

/**
 * The subarray partitioner
 * @export
 * @interface SubarrayPartitioner
 */
export interface SubarrayPartitioner {
    /**
     * 
     * @type {Subarray}
     * @memberof SubarrayPartitioner
     */
    subarray?: Subarray;
    /**
     * Result size budget (in bytes) for all attributes.
     * @type {Array<AttributeBufferSize>}
     * @memberof SubarrayPartitioner
     */
    budget?: Array<AttributeBufferSize>;
    /**
     * 
     * @type {SubarrayPartitionerCurrent}
     * @memberof SubarrayPartitioner
     */
    current?: SubarrayPartitionerCurrent;
    /**
     * 
     * @type {SubarrayPartitionerState}
     * @memberof SubarrayPartitioner
     */
    state?: SubarrayPartitionerState;
    /**
     * The memory budget for the fixed-sized attributes and the offsets of the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudget?: number;
    /**
     * The memory budget for the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudgetVar?: number;
}

/**
 * The current partition info
 * @export
 * @interface SubarrayPartitionerCurrent
 */
export interface SubarrayPartitionerCurrent {
    /**
     * 
     * @type {Subarray}
     * @memberof SubarrayPartitionerCurrent
     */
    subarray?: Subarray;
    /**
     * PartitionInfo start
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    start?: number;
    /**
     * PartitionInfo end
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    end?: number;
    /**
     * PartitionInfo splitMultiRange
     * @type {boolean}
     * @memberof SubarrayPartitionerCurrent
     */
    splitMultiRange?: boolean;
}

/**
 * The state information for the remaining partitions to be produced
 * @export
 * @interface SubarrayPartitionerState
 */
export interface SubarrayPartitionerState {
    /**
     * State start
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    start?: number;
    /**
     * State end
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    end?: number;
    /**
     * State singleRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    singleRange?: Array<Subarray>;
    /**
     * State multiRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    multiRange?: Array<Subarray>;
}

/**
 * A set of 1D ranges for a subarray
 * @export
 * @interface SubarrayRanges
 */
export interface SubarrayRanges {
    /**
     * 
     * @type {Datatype}
     * @memberof SubarrayRanges
     */
    type?: Datatype;
    /**
     * True if the range is the default range
     * @type {boolean}
     * @memberof SubarrayRanges
     */
    hasDefaultRange?: boolean;
    /**
     * The bytes of the ranges
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    buffer?: Array<number>;
}

/**
 * Subscription of a user (customer) to another user's arrays
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * Unique id of subscription as defined by Stripe
     * @type {string}
     * @memberof Subscription
     */
    id?: string;
    /**
     * Unique id of the array (product) owner
     * @type {string}
     * @memberof Subscription
     */
    ownerNamespaceUuid?: string;
    /**
     * Unique id of the array (product) user (customer)
     * @type {string}
     * @memberof Subscription
     */
    customerNamespaceUuid?: string;
    /**
     * list of pricing used by this subscription
     * @type {Array<Pricing>}
     * @memberof Subscription
     */
    pricing?: Array<Pricing>;
}

/**
 * A api token and its metadata
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * A api token
     * @type {string}
     * @memberof Token
     */
    token?: string;
    /**
     * Name of token to revoke
     * @type {string}
     * @memberof Token
     */
    name?: string;
    /**
     * datetime the token was created at
     * @type {Date}
     * @memberof Token
     */
    issuedAt?: Date;
    /**
     * datetime the token when token will expire
     * @type {Date}
     * @memberof Token
     */
    expiresAt?: Date;
    /**
     * Optional scope to limit token, defaults to all permissions, current supported values are password_reset or *
     * @type {string}
     * @memberof Token
     */
    scope?: string;
}

/**
 * A request from a user for an api token
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
    /**
     * Expiration date for token, if empty token defaults to 30 minutes
     * @type {Date}
     * @memberof TokenRequest
     */
    expires?: Date;
    /**
     * Optional name for token, if the name already exists for the user it will be auto incremented (i.e. myToken-1)
     * @type {string}
     * @memberof TokenRequest
     */
    name?: string;
    /**
     * Optional scope to limit token, defaults to all permissions, current supported values are password_reset or *
     * @type {string}
     * @memberof TokenRequest
     */
    scope?: string;
}

/**
 * User-defined function
 * @export
 * @interface UDF
 */
export interface UDF {
    /**
     * name of UDFInfo to run, format is {namespace}/{udf_name}. Can not be used with exec
     * @type {string}
     * @memberof UDF
     */
    udfInfoName?: string;
    /**
     * UDF language
     * @type {UDFLanguage}
     * @memberof UDF
     */
    language?: UDFLanguage;
    /**
     * Type-specific version
     * @type {string}
     * @memberof UDF
     */
    version?: string;
    /**
     * Docker image name to use for udf
     * @type {string}
     * @memberof UDF
     */
    imageName?: string;
    /**
     * ranges to run against, generic format
     * @type {UDFRanges}
     * @memberof UDF
     */
    ranges?: UDFRanges;
    /**
     * Subarray ranges to query, this is deprecate and `ranges` should be used instead.
     * @type {UDFSubarray}
     * @memberof UDF
     */
    subarray?: UDFSubarray;
    /**
     * Type-specific executable text
     * @type {string}
     * @memberof UDF
     */
    exec?: string;
    /**
     * optional raw text to store of serialized function, used for showing in UI
     * @type {string}
     * @memberof UDF
     */
    execRaw?: string;
    /**
     * List of buffers to fetch (attributes + coordinates)
     * @type {Array<string>}
     * @memberof UDF
     */
    buffers?: Array<string>;
    /**
     * type of results (native, i.e cloud pickle or json)
     * @type {UDFResultType}
     * @memberof UDF
     */
    resultFormat?: UDFResultType;
    /**
     * name of task, optional
     * @type {string}
     * @memberof UDF
     */
    taskName?: string;
}

/**
 * actions a user can take on an udf
 * @export
 * @enum {string}
 */
export enum UDFActions {
    FetchUdf = <any> 'fetch_udf',
    ShareUdf = <any> 'share_udf'
}

/**
 * Defines a set of images related to a specific name
 * @export
 * @interface UDFImage
 */
export interface UDFImage {
    /**
     * Unique id of set of images
     * @type {string}
     * @memberof UDFImage
     */
    id?: string;
    /**
     * name of udf
     * @type {string}
     * @memberof UDFImage
     */
    name?: string;
    /**
     * UDF language
     * @type {UDFLanguage}
     * @memberof UDFImage
     */
    language?: UDFLanguage;
}

/**
 * Defines an image that belongs to a set of images having a version
 * @export
 * @interface UDFImageVersion
 */
export interface UDFImageVersion {
    /**
     * Unique id of a versioned image
     * @type {string}
     * @memberof UDFImageVersion
     */
    id?: string;
    /**
     * name of UDFImageVersion
     * @type {string}
     * @memberof UDFImageVersion
     */
    name?: string;
    /**
     * Unique id of the udf image set
     * @type {string}
     * @memberof UDFImageVersion
     */
    udfImageUuid?: string;
    /**
     * Uri of docker image related to current entry
     * @type {string}
     * @memberof UDFImageVersion
     */
    dockerImage?: string;
    /**
     * Image-specific version
     * @type {number}
     * @memberof UDFImageVersion
     */
    version?: number;
    /**
     * If current image is default version
     * @type {boolean}
     * @memberof UDFImageVersion
     */
    _default?: boolean;
    /**
     * If current image is latest version
     * @type {boolean}
     * @memberof UDFImageVersion
     */
    latest?: boolean;
}

/**
 * User-defined function that can persist in db, used and shared multiple times
 * @export
 * @interface UDFInfo
 */
export interface UDFInfo {
    /**
     * Unique id of udf
     * @type {string}
     * @memberof UDFInfo
     */
    id?: string;
    /**
     * name of udf
     * @type {string}
     * @memberof UDFInfo
     */
    name?: string;
    /**
     * UDF language
     * @type {UDFLanguage}
     * @memberof UDFInfo
     */
    language?: UDFLanguage;
    /**
     * UDF type
     * @type {UDFType}
     * @memberof UDFInfo
     */
    type?: UDFType;
    /**
     * Markdown readme of udfs
     * @type {string}
     * @memberof UDFInfo
     */
    readme?: string;
    /**
     * License identifier from SPDX License List or Custom
     * @type {string}
     * @memberof UDFInfo
     */
    licenseId?: string;
    /**
     * License text
     * @type {string}
     * @memberof UDFInfo
     */
    licenseText?: string;
    /**
     * optional tags for udf
     * @type {Array<string>}
     * @memberof UDFInfo
     */
    tags?: Array<string>;
}

/**
 * User-defined function that can persist in db, used and shared multiple times
 * @export
 * @interface UDFInfoUpdate
 */
export interface UDFInfoUpdate {
    /**
     * name of udf
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    name?: string;
    /**
     * UDF language
     * @type {UDFLanguage}
     * @memberof UDFInfoUpdate
     */
    language?: UDFLanguage;
    /**
     * Type-specific version
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    version?: string;
    /**
     * Docker image name to use for udf
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    imageName?: string;
    /**
     * UDF type
     * @type {UDFType}
     * @memberof UDFInfoUpdate
     */
    type?: UDFType;
    /**
     * Type-specific executable text
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    exec?: string;
    /**
     * optional raw text to store of serialized function, used for showing in UI
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    execRaw?: string;
    /**
     * Markdown readme of udfs
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    readme?: string;
    /**
     * License identifier from SPDX License List or Custom
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    licenseId?: string;
    /**
     * License text
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    licenseText?: string;
    /**
     * optional tags for udf
     * @type {Array<string>}
     * @memberof UDFInfoUpdate
     */
    tags?: Array<string>;
}

/**
 * Version of User-defined function that can persist in db
 * @export
 * @interface UDFInfoVersion
 */
export interface UDFInfoVersion {
    /**
     * Unique id of a versioned udf
     * @type {string}
     * @memberof UDFInfoVersion
     */
    id?: string;
    /**
     * Unique id of the versioned image used by current udf version
     * @type {string}
     * @memberof UDFInfoVersion
     */
    udfImageUuid?: string;
    /**
     * name of udf version
     * @type {string}
     * @memberof UDFInfoVersion
     */
    name?: string;
    /**
     * Type-specific version
     * @type {string}
     * @memberof UDFInfoVersion
     */
    version?: string;
    /**
     * Docker image name to use for udf
     * @type {string}
     * @memberof UDFInfoVersion
     */
    imageName?: string;
    /**
     * Type-specific executable text
     * @type {string}
     * @memberof UDFInfoVersion
     */
    exec?: string;
    /**
     * optional raw text to store of serialized function, used for showing in UI
     * @type {string}
     * @memberof UDFInfoVersion
     */
    execRaw?: string;
    /**
     * If current image version is default version
     * @type {boolean}
     * @memberof UDFInfoVersion
     */
    _default?: boolean;
}

/**
 * UDF Type
 * @export
 * @enum {string}
 */
export enum UDFLanguage {
    Python = <any> 'python'
}

/**
 * Object including udfs and metadata
 * @export
 * @interface UDFListingData
 */
export interface UDFListingData {
    /**
     * List of UDFInfo
     * @type {Array<UDFInfo>}
     * @memberof UDFListingData
     */
    udfInfoList?: Array<UDFInfo>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof UDFListingData
     */
    paginationMetadata?: PaginationMetadata;
}

/**
 * Subarray bounds to query for a UDF to operate on
 * @export
 * @interface UDFRanges
 */
export interface UDFRanges {
    /**
     * 
     * @type {Layout}
     * @memberof UDFRanges
     */
    layout?: Layout;
    /**
     * List of ranges,
     * @type {Array<Array<number>>}
     * @memberof UDFRanges
     */
    ranges?: Array<Array<number>>;
}

/**
 * Results type
 * @export
 * @enum {string}
 */
export enum UDFResultType {
    Native = <any> 'native',
    Json = <any> 'json'
}

/**
 * details for sharing a given udf
 * @export
 * @interface UDFSharing
 */
export interface UDFSharing {
    /**
     * List of permitted actions
     * @type {Array<UDFActions>}
     * @memberof UDFSharing
     */
    actions?: Array<UDFActions>;
    /**
     * namespace being granted array access can be a user or organization
     * @type {string}
     * @memberof UDFSharing
     */
    namespace?: string;
    /**
     * details on if the namespace is a organization or user
     * @type {string}
     * @memberof UDFSharing
     */
    namespaceType?: string;
}

/**
 * Subarray bounds to query for a UDF to operate on
 * @export
 * @interface UDFSubarray
 */
export interface UDFSubarray {
    /**
     * 
     * @type {Layout}
     * @memberof UDFSubarray
     */
    layout?: Layout;
    /**
     * List of ranges,
     * @type {Array<UDFSubarrayRange>}
     * @memberof UDFSubarray
     */
    ranges?: Array<UDFSubarrayRange>;
}

/**
 * A dimension range to query
 * @export
 * @interface UDFSubarrayRange
 */
export interface UDFSubarrayRange {
    /**
     * The dimension index
     * @type {number}
     * @memberof UDFSubarrayRange
     */
    dimensionId?: number;
    /**
     * The range start index
     * @type {DimensionCoordinate}
     * @memberof UDFSubarrayRange
     */
    rangeStart?: DimensionCoordinate;
    /**
     * The range end index
     * @type {DimensionCoordinate}
     * @memberof UDFSubarrayRange
     */
    rangeEnd?: DimensionCoordinate;
}

/**
 * UDF Type
 * @export
 * @enum {string}
 */
export enum UDFType {
    SingleArray = <any> 'single_array',
    Generic = <any> 'generic'
}

/**
 * Password to update
 * @export
 * @interface User
 */
export interface User {
    /**
     * password
     * @type {string}
     * @memberof User
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface Writer
 */
export interface Writer {
    /**
     * 
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordDups?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordOOB?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Writer
     */
    dedupCoords?: boolean;
    /**
     * 
     * @type {DomainArray}
     * @memberof Writer
     */
    subarray?: DomainArray;
}


/**
 * ArrayApi - fetch parameter creator
 * @export
 */
export const ArrayApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling arrayActivityLog.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling arrayActivityLog.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/activity`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (eventTypes !== undefined) {
                localVarQueryParameter['event_types'] = eventTypes;
            }

            if (taskId !== undefined) {
                localVarQueryParameter['task_id'] = taskId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all arrays that are owned directly by user or user's organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/arrays/browser/owned`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user's organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet(options: any = {}): FetchArgs {
            const localVarPath = `/arrays/browser/owned/sidebar`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/arrays/browser/public`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet(options: any = {}): FetchArgs {
            const localVarPath = `/arrays/browser/public/sidebar`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/arrays/browser/shared`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet(options: any = {}): FetchArgs {
            const localVarPath = `/arrays/browser/shared/sidebar`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray(namespace: string, array: string, contentType: string, arraySchema: ArraySchema, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createArray.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling createArray.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling createArray.');
            }
            // verify required parameter 'arraySchema' is not null or undefined
            if (arraySchema === null || arraySchema === undefined) {
                throw new RequiredError('arraySchema','Required parameter arraySchema was null or undefined when calling createArray.');
            }
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ArraySchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(arraySchema || {}) : (arraySchema || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray(namespace: string, array: string, contentType: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteArray.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling deleteArray.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling deleteArray.');
            }
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray(namespace: string, array: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deregisterArray.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling deregisterArray.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/deregister`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata(publicShare?: string, options: any = {}): FetchArgs {
            const localVarPath = `/arrays`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (publicShare !== undefined) {
                localVarQueryParameter['public_share'] = publicShare;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray(namespace: string, array: string, contentType: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getArray.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling getArray.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling getArray.');
            }
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes(namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getArrayMaxBufferSizes.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling getArrayMaxBufferSizes.');
            }
            // verify required parameter 'subarray' is not null or undefined
            if (subarray === null || subarray === undefined) {
                throw new RequiredError('subarray','Required parameter subarray was null or undefined when calling getArrayMaxBufferSizes.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling getArrayMaxBufferSizes.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/max_buffer_sizes`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (subarray !== undefined) {
                localVarQueryParameter['subarray'] = subarray;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get metadata from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson(namespace: string, array: string, length?: number, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getArrayMetaDataJson.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling getArrayMetaDataJson.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/metadata_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata(namespace: string, array: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getArrayMetadata.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling getArrayMetadata.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain(namespace: string, array: string, contentType: string, xPayer?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getArrayNonEmptyDomain.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling getArrayNonEmptyDomain.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling getArrayNonEmptyDomain.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/non_empty_domain`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData(namespace: string, array: string, samples?: number, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getArraySampleData.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling getArraySampleData.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/sample`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (samples !== undefined) {
                localVarQueryParameter['samples'] = samples;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies(namespace: string, array: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getArraySharingPolicies.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling getArraySharingPolicies.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace(namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getArraysInNamespace.');
            }
            const localVarPath = `/arrays/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays(options: any = {}): FetchArgs {
            const localVarPath = `/arrays/last_accessed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling registerArray.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling registerArray.');
            }
            // verify required parameter 'arrayMetadata' is not null or undefined
            if (arrayMetadata === null || arrayMetadata === undefined) {
                throw new RequiredError('arrayMetadata','Required parameter arrayMetadata was null or undefined when calling registerArray.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/register`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ArrayInfoUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(arrayMetadata || {}) : (arrayMetadata || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray(namespace: string, array: string, arraySharing: ArraySharing, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling shareArray.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling shareArray.');
            }
            // verify required parameter 'arraySharing' is not null or undefined
            if (arraySharing === null || arraySharing === undefined) {
                throw new RequiredError('arraySharing','Required parameter arraySharing was null or undefined when calling shareArray.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ArraySharing" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(arraySharing || {}) : (arraySharing || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateArrayMetadata.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling updateArrayMetadata.');
            }
            // verify required parameter 'arrayMetadata' is not null or undefined
            if (arrayMetadata === null || arrayMetadata === undefined) {
                throw new RequiredError('arrayMetadata','Required parameter arrayMetadata was null or undefined when calling updateArrayMetadata.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ArrayInfoUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(arrayMetadata || {}) : (arrayMetadata || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArrayApi - functional programming interface
 * @export
 */
export const ArrayApiFp = function(configuration?: Configuration) {
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ArrayActivityLog>> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).arrayActivityLog(namespace, array, start, end, eventTypes, taskId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a list of all arrays that are owned directly by user or user's organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArrayBrowserData> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user's organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArrayBrowserSidebar> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).arraysBrowserOwnedSidebarGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArrayBrowserData> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArrayBrowserSidebar> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).arraysBrowserPublicSidebarGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArrayBrowserData> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArrayBrowserSidebar> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).arraysBrowserSharedSidebarGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray(namespace: string, array: string, contentType: string, arraySchema: ArraySchema, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).createArray(namespace, array, contentType, arraySchema, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray(namespace: string, array: string, contentType: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).deleteArray(namespace, array, contentType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray(namespace: string, array: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).deregisterArray(namespace, array, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata(publicShare?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ArrayInfo>> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).getAllArrayMetadata(publicShare, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray(namespace: string, array: string, contentType: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArraySchema> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).getArray(namespace, array, contentType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes(namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MaxBufferSizes> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get metadata from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson(namespace: string, array: string, length?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArrayMetadataJson> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).getArrayMetaDataJson(namespace, array, length, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata(namespace: string, array: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArrayInfo> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).getArrayMetadata(namespace, array, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NonEmptyDomain> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData(namespace: string, array: string, samples?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArraySample> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).getArraySampleData(namespace, array, samples, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies(namespace: string, array: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ArraySharing>> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).getArraySharingPolicies(namespace, array, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace(namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ArrayInfo>> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).getArraysInNamespace(namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LastAccessedArray>> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).getLastAccessedArrays(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).registerArray(namespace, array, arrayMetadata, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray(namespace: string, array: string, arraySharing: ArraySharing, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).shareArray(namespace, array, arraySharing, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArrayApiFetchParamCreator(configuration).updateArrayMetadata(namespace, array, arrayMetadata, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArrayApi - factory interface
 * @export
 */
export const ArrayApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, options?: any) {
            return ArrayApiFp(configuration).arrayActivityLog(namespace, array, start, end, eventTypes, taskId, options)(fetch, basePath);
        },
        /**
         * Fetch a list of all arrays that are owned directly by user or user's organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, options?: any) {
            return ArrayApiFp(configuration).arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, options)(fetch, basePath);
        },
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user's organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet(options?: any) {
            return ArrayApiFp(configuration).arraysBrowserOwnedSidebarGet(options)(fetch, basePath);
        },
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, options?: any) {
            return ArrayApiFp(configuration).arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, options)(fetch, basePath);
        },
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet(options?: any) {
            return ArrayApiFp(configuration).arraysBrowserPublicSidebarGet(options)(fetch, basePath);
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, options?: any) {
            return ArrayApiFp(configuration).arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, options)(fetch, basePath);
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet(options?: any) {
            return ArrayApiFp(configuration).arraysBrowserSharedSidebarGet(options)(fetch, basePath);
        },
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray(namespace: string, array: string, contentType: string, arraySchema: ArraySchema, options?: any) {
            return ArrayApiFp(configuration).createArray(namespace, array, contentType, arraySchema, options)(fetch, basePath);
        },
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray(namespace: string, array: string, contentType: string, options?: any) {
            return ArrayApiFp(configuration).deleteArray(namespace, array, contentType, options)(fetch, basePath);
        },
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray(namespace: string, array: string, options?: any) {
            return ArrayApiFp(configuration).deregisterArray(namespace, array, options)(fetch, basePath);
        },
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata(publicShare?: string, options?: any) {
            return ArrayApiFp(configuration).getAllArrayMetadata(publicShare, options)(fetch, basePath);
        },
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray(namespace: string, array: string, contentType: string, options?: any) {
            return ArrayApiFp(configuration).getArray(namespace, array, contentType, options)(fetch, basePath);
        },
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes(namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options?: any) {
            return ArrayApiFp(configuration).getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options)(fetch, basePath);
        },
        /**
         * get metadata from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson(namespace: string, array: string, length?: number, options?: any) {
            return ArrayApiFp(configuration).getArrayMetaDataJson(namespace, array, length, options)(fetch, basePath);
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata(namespace: string, array: string, options?: any) {
            return ArrayApiFp(configuration).getArrayMetadata(namespace, array, options)(fetch, basePath);
        },
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain(namespace: string, array: string, contentType: string, xPayer?: string, options?: any) {
            return ArrayApiFp(configuration).getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options)(fetch, basePath);
        },
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData(namespace: string, array: string, samples?: number, options?: any) {
            return ArrayApiFp(configuration).getArraySampleData(namespace, array, samples, options)(fetch, basePath);
        },
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies(namespace: string, array: string, options?: any) {
            return ArrayApiFp(configuration).getArraySharingPolicies(namespace, array, options)(fetch, basePath);
        },
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace(namespace: string, options?: any) {
            return ArrayApiFp(configuration).getArraysInNamespace(namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays(options?: any) {
            return ArrayApiFp(configuration).getLastAccessedArrays(options)(fetch, basePath);
        },
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any) {
            return ArrayApiFp(configuration).registerArray(namespace, array, arrayMetadata, options)(fetch, basePath);
        },
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray(namespace: string, array: string, arraySharing: ArraySharing, options?: any) {
            return ArrayApiFp(configuration).shareArray(namespace, array, arraySharing, options)(fetch, basePath);
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any) {
            return ArrayApiFp(configuration).updateArrayMetadata(namespace, array, arrayMetadata, options)(fetch, basePath);
        },
    };
};

/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
export class ArrayApi extends BaseAPI {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, options?: any) {
        return ArrayApiFp(this.configuration).arrayActivityLog(namespace, array, start, end, eventTypes, taskId, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a list of all arrays that are owned directly by user or user's organizations
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arraysBrowserOwnedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, options?: any) {
        return ArrayApiFp(this.configuration).arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a sidebar for arrays that are owned directly by user or user's organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arraysBrowserOwnedSidebarGet(options?: any) {
        return ArrayApiFp(this.configuration).arraysBrowserOwnedSidebarGet(options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a list of all arrays that have been shared publically
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arraysBrowserPublicGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, options?: any) {
        return ArrayApiFp(this.configuration).arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a sidebar of all arrays that have been shared publically
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arraysBrowserPublicSidebarGet(options?: any) {
        return ArrayApiFp(this.configuration).arraysBrowserPublicSidebarGet(options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arraysBrowserSharedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, options?: any) {
        return ArrayApiFp(this.configuration).arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arraysBrowserSharedSidebarGet(options?: any) {
        return ArrayApiFp(this.configuration).arraysBrowserSharedSidebarGet(options)(this.fetch, this.basePath);
    }

    /**
     * create a array schema at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArraySchema} arraySchema ArraySchema being created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public createArray(namespace: string, array: string, contentType: string, arraySchema: ArraySchema, options?: any) {
        return ArrayApiFp(this.configuration).createArray(namespace, array, contentType, arraySchema, options)(this.fetch, this.basePath);
    }

    /**
     * delete a array
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public deleteArray(namespace: string, array: string, contentType: string, options?: any) {
        return ArrayApiFp(this.configuration).deleteArray(namespace, array, contentType, options)(this.fetch, this.basePath);
    }

    /**
     * deregister a array
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public deregisterArray(namespace: string, array: string, options?: any) {
        return ArrayApiFp(this.configuration).deregisterArray(namespace, array, options)(this.fetch, this.basePath);
    }

    /**
     * get all array metadata user has access to
     * @param {string} [publicShare] Public share values can be one of exclude, only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getAllArrayMetadata(publicShare?: string, options?: any) {
        return ArrayApiFp(this.configuration).getAllArrayMetadata(publicShare, options)(this.fetch, this.basePath);
    }

    /**
     * get an ArraySchema using a url encoded uri
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArray(namespace: string, array: string, contentType: string, options?: any) {
        return ArrayApiFp(this.configuration).getArray(namespace, array, contentType, options)(this.fetch, this.basePath);
    }

    /**
     * get the max buffer sizes of an array for a subarray
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} subarray CSV string of subarray to get max buffer sizes for
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArrayMaxBufferSizes(namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options?: any) {
        return ArrayApiFp(this.configuration).getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options)(this.fetch, this.basePath);
    }

    /**
     * get metadata from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [length] (optional) limit character length of returned values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArrayMetaDataJson(namespace: string, array: string, length?: number, options?: any) {
        return ArrayApiFp(this.configuration).getArrayMetaDataJson(namespace, array, length, options)(this.fetch, this.basePath);
    }

    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArrayMetadata(namespace: string, array: string, options?: any) {
        return ArrayApiFp(this.configuration).getArrayMetadata(namespace, array, options)(this.fetch, this.basePath);
    }

    /**
     * get the non empty domain of an array
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArrayNonEmptyDomain(namespace: string, array: string, contentType: string, xPayer?: string, options?: any) {
        return ArrayApiFp(this.configuration).getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options)(this.fetch, this.basePath);
    }

    /**
     * get an sample set of data from the array
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [samples] Number of sample results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArraySampleData(namespace: string, array: string, samples?: number, options?: any) {
        return ArrayApiFp(this.configuration).getArraySampleData(namespace, array, samples, options)(this.fetch, this.basePath);
    }

    /**
     * Get all sharing details of the array
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArraySharingPolicies(namespace: string, array: string, options?: any) {
        return ArrayApiFp(this.configuration).getArraySharingPolicies(namespace, array, options)(this.fetch, this.basePath);
    }

    /**
     * get metadata on all arrays in a namespace
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArraysInNamespace(namespace: string, options?: any) {
        return ArrayApiFp(this.configuration).getArraysInNamespace(namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getLastAccessedArrays(options?: any) {
        return ArrayApiFp(this.configuration).getLastAccessedArrays(options)(this.fetch, this.basePath);
    }

    /**
     * register an array at a specified URI registered to the given namespace
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any) {
        return ArrayApiFp(this.configuration).registerArray(namespace, array, arrayMetadata, options)(this.fetch, this.basePath);
    }

    /**
     * Share an array with a user
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public shareArray(namespace: string, array: string, arraySharing: ArraySharing, options?: any) {
        return ArrayApiFp(this.configuration).shareArray(namespace, array, arraySharing, options)(this.fetch, this.basePath);
    }

    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public updateArrayMetadata(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any) {
        return ArrayApiFp(this.configuration).updateArrayMetadata(namespace, array, arrayMetadata, options)(this.fetch, this.basePath);
    }

}

/**
 * ArrayTasksApi - fetch parameter creator
 * @export
 */
export const ArrayTasksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar(start?: number, end?: number, options: any = {}): FetchArgs {
            const localVarPath = `/tasks/sidebar`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArrayTasksApi - functional programming interface
 * @export
 */
export const ArrayTasksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar(start?: number, end?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArrayTaskBrowserSidebar> {
            const localVarFetchArgs = ArrayTasksApiFetchParamCreator(configuration).getArrayTasksSidebar(start, end, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArrayTasksApi - factory interface
 * @export
 */
export const ArrayTasksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar(start?: number, end?: number, options?: any) {
            return ArrayTasksApiFp(configuration).getArrayTasksSidebar(start, end, options)(fetch, basePath);
        },
    };
};

/**
 * ArrayTasksApi - object-oriented interface
 * @export
 * @class ArrayTasksApi
 * @extends {BaseAPI}
 */
export class ArrayTasksApi extends BaseAPI {
    /**
     * 
     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayTasksApi
     */
    public getArrayTasksSidebar(start?: number, end?: number, options?: any) {
        return ArrayTasksApiFp(this.configuration).getArrayTasksSidebar(start, end, options)(this.fetch, this.basePath);
    }

}

/**
 * InvitationApi - fetch parameter creator
 * @export
 */
export const InvitationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the id of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(invitation: string, options: any = {}): FetchArgs {
            // verify required parameter 'invitation' is not null or undefined
            if (invitation === null || invitation === undefined) {
                throw new RequiredError('invitation','Required parameter invitation was null or undefined when calling acceptInvitation.');
            }
            const localVarPath = `/invitations/{invitation}`
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels join organization invitation
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} organization name or uuid of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization(invitation: string, organization: string, options: any = {}): FetchArgs {
            // verify required parameter 'invitation' is not null or undefined
            if (invitation === null || invitation === undefined) {
                throw new RequiredError('invitation','Required parameter invitation was null or undefined when calling cancelJoinOrganization.');
            }
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling cancelJoinOrganization.');
            }
            const localVarPath = `/invitations/{invitation}/{organization}/join`
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)))
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite(namespace: string, invitation: string, array: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling cancelShareArrayByInvite.');
            }
            // verify required parameter 'invitation' is not null or undefined
            if (invitation === null || invitation === undefined) {
                throw new RequiredError('invitation','Required parameter invitation was null or undefined when calling cancelShareArrayByInvite.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling cancelShareArrayByInvite.');
            }
            const localVarPath = `/invitations/{invitation}/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or id of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations(organization?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, orderby?: string, options: any = {}): FetchArgs {
            const localVarPath = `/invitations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (organization !== undefined) {
                localVarQueryParameter['organization'] = organization;
            }

            if (array !== undefined) {
                localVarQueryParameter['array'] = array;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or uuid of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization(organization: string, emailInvite: InvitationOrganizationJoinEmail, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling joinOrganization.');
            }
            // verify required parameter 'emailInvite' is not null or undefined
            if (emailInvite === null || emailInvite === undefined) {
                throw new RequiredError('emailInvite','Required parameter emailInvite was null or undefined when calling joinOrganization.');
            }
            const localVarPath = `/invitations/{organization}/join`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InvitationOrganizationJoinEmail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailInvite || {}) : (emailInvite || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite(namespace: string, array: string, emailInvite: InvitationArrayShareEmail, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling shareArrayByInvite.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling shareArrayByInvite.');
            }
            // verify required parameter 'emailInvite' is not null or undefined
            if (emailInvite === null || emailInvite === undefined) {
                throw new RequiredError('emailInvite','Required parameter emailInvite was null or undefined when calling shareArrayByInvite.');
            }
            const localVarPath = `/invitations/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InvitationArrayShareEmail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailInvite || {}) : (emailInvite || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitationApi - functional programming interface
 * @export
 */
export const InvitationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the id of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(invitation: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvitationApiFetchParamCreator(configuration).acceptInvitation(invitation, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Cancels join organization invitation
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} organization name or uuid of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization(invitation: string, organization: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvitationApiFetchParamCreator(configuration).cancelJoinOrganization(invitation, organization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite(namespace: string, invitation: string, array: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvitationApiFetchParamCreator(configuration).cancelShareArrayByInvite(namespace, invitation, array, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or id of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations(organization?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, orderby?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvitationData> {
            const localVarFetchArgs = InvitationApiFetchParamCreator(configuration).fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or uuid of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization(organization: string, emailInvite: InvitationOrganizationJoinEmail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvitationApiFetchParamCreator(configuration).joinOrganization(organization, emailInvite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite(namespace: string, array: string, emailInvite: InvitationArrayShareEmail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvitationApiFetchParamCreator(configuration).shareArrayByInvite(namespace, array, emailInvite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InvitationApi - factory interface
 * @export
 */
export const InvitationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the id of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(invitation: string, options?: any) {
            return InvitationApiFp(configuration).acceptInvitation(invitation, options)(fetch, basePath);
        },
        /**
         * Cancels join organization invitation
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} organization name or uuid of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization(invitation: string, organization: string, options?: any) {
            return InvitationApiFp(configuration).cancelJoinOrganization(invitation, organization, options)(fetch, basePath);
        },
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite(namespace: string, invitation: string, array: string, options?: any) {
            return InvitationApiFp(configuration).cancelShareArrayByInvite(namespace, invitation, array, options)(fetch, basePath);
        },
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or id of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations(organization?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, orderby?: string, options?: any) {
            return InvitationApiFp(configuration).fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options)(fetch, basePath);
        },
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or uuid of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization(organization: string, emailInvite: InvitationOrganizationJoinEmail, options?: any) {
            return InvitationApiFp(configuration).joinOrganization(organization, emailInvite, options)(fetch, basePath);
        },
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite(namespace: string, array: string, emailInvite: InvitationArrayShareEmail, options?: any) {
            return InvitationApiFp(configuration).shareArrayByInvite(namespace, array, emailInvite, options)(fetch, basePath);
        },
    };
};

/**
 * InvitationApi - object-oriented interface
 * @export
 * @class InvitationApi
 * @extends {BaseAPI}
 */
export class InvitationApi extends BaseAPI {
    /**
     * Accepts invitation
     * @param {string} invitation the id of invitation about to be accepted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public acceptInvitation(invitation: string, options?: any) {
        return InvitationApiFp(this.configuration).acceptInvitation(invitation, options)(this.fetch, this.basePath);
    }

    /**
     * Cancels join organization invitation
     * @param {string} invitation the id of invitation about to be cancelled
     * @param {string} organization name or uuid of organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public cancelJoinOrganization(invitation: string, organization: string, options?: any) {
        return InvitationApiFp(this.configuration).cancelJoinOrganization(invitation, organization, options)(this.fetch, this.basePath);
    }

    /**
     * Cancels array sharing invitation
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} invitation the id of invitation about to be cancelled
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public cancelShareArrayByInvite(namespace: string, invitation: string, array: string, options?: any) {
        return InvitationApiFp(this.configuration).cancelShareArrayByInvite(namespace, invitation, array, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a list of invitations
     * @param {string} [organization] name or id of organization to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
     * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
     * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public fetchInvitations(organization?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, orderby?: string, options?: any) {
        return InvitationApiFp(this.configuration).fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options)(this.fetch, this.basePath);
    }

    /**
     * Sends email to multiple recipients with joining information regarding an organization
     * @param {string} organization name or uuid of organization
     * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public joinOrganization(organization: string, emailInvite: InvitationOrganizationJoinEmail, options?: any) {
        return InvitationApiFp(this.configuration).joinOrganization(organization, emailInvite, options)(this.fetch, this.basePath);
    }

    /**
     * Sends email to multiple recipients with sharing information regarding an array
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {InvitationArrayShareEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public shareArrayByInvite(namespace: string, array: string, emailInvite: InvitationArrayShareEmail, options?: any) {
        return InvitationApiFp(this.configuration).shareArrayByInvite(namespace, array, emailInvite, options)(this.fetch, this.basePath);
    }

}

/**
 * NotebookApi - fetch parameter creator
 * @export
 */
export const NotebookApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus(namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getNotebookServerStatus.');
            }
            const localVarPath = `/notebooks/server/{namespace}/status`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer(namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling shutdownNotebookServer.');
            }
            const localVarPath = `/notebooks/server/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotebookApi - functional programming interface
 * @export
 */
export const NotebookApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus(namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotebookStatus> {
            const localVarFetchArgs = NotebookApiFetchParamCreator(configuration).getNotebookServerStatus(namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer(namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NotebookApiFetchParamCreator(configuration).shutdownNotebookServer(namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotebookApi - factory interface
 * @export
 */
export const NotebookApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus(namespace: string, options?: any) {
            return NotebookApiFp(configuration).getNotebookServerStatus(namespace, options)(fetch, basePath);
        },
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer(namespace: string, options?: any) {
            return NotebookApiFp(configuration).shutdownNotebookServer(namespace, options)(fetch, basePath);
        },
    };
};

/**
 * NotebookApi - object-oriented interface
 * @export
 * @class NotebookApi
 * @extends {BaseAPI}
 */
export class NotebookApi extends BaseAPI {
    /**
     * Get status of the notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    public getNotebookServerStatus(namespace: string, options?: any) {
        return NotebookApiFp(this.configuration).getNotebookServerStatus(namespace, options)(this.fetch, this.basePath);
    }

    /**
     * Shutdown a notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    public shutdownNotebookServer(namespace: string, options?: any) {
        return NotebookApiFp(this.configuration).shutdownNotebookServer(namespace, options)(this.fetch, this.basePath);
    }

}

/**
 * OrganizationApi - fetch parameter creator
 * @export
 */
export const OrganizationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling addAWSAccessCredentials.');
            }
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            if (awsAccessCredentials === null || awsAccessCredentials === undefined) {
                throw new RequiredError('awsAccessCredentials','Required parameter awsAccessCredentials was null or undefined when calling addAWSAccessCredentials.');
            }
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AWSAccessCredentials" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(awsAccessCredentials || {}) : (awsAccessCredentials || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization: string, user: OrganizationUser, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling addUserToOrganization.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling addUserToOrganization.');
            }
            const localVarPath = `/organizations/{organization}/user`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrganizationUser" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling checkAWSAccessCredentials.');
            }
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling checkAWSAccessCredentialsByName.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling checkAWSAccessCredentialsByName.');
            }
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organization: Organization, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling createOrganization.');
            }
            const localVarPath = `/organization`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(organization || {}) : (organization || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteAWSAccessCredentials.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteAWSAccessCredentials.');
            }
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organization: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling deleteOrganization.');
            }
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization: string, username: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling deleteUserFromOrganization.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling deleteUserFromOrganization.');
            }
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations(options: any = {}): FetchArgs {
            const localVarPath = `/organizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organization: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getOrganization.');
            }
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization: string, username: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getOrganizationUser.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling getOrganizationUser.');
            }
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateAWSAccessCredentials.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateAWSAccessCredentials.');
            }
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            if (awsAccessCredentials === null || awsAccessCredentials === undefined) {
                throw new RequiredError('awsAccessCredentials','Required parameter awsAccessCredentials was null or undefined when calling updateAWSAccessCredentials.');
            }
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AWSAccessCredentials" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(awsAccessCredentials || {}) : (awsAccessCredentials || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a organization
         * @param {string} organization organization name or id
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organization: string, organizationDetails: Organization, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling updateOrganization.');
            }
            // verify required parameter 'organizationDetails' is not null or undefined
            if (organizationDetails === null || organizationDetails === undefined) {
                throw new RequiredError('organizationDetails','Required parameter organizationDetails was null or undefined when calling updateOrganization.');
            }
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(organizationDetails || {}) : (organizationDetails || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling updateUserInOrganization.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling updateUserInOrganization.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling updateUserInOrganization.');
            }
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrganizationUser" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization: string, user: OrganizationUser, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).addUserToOrganization(organization, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AWSAccessCredentials>> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).checkAWSAccessCredentials(namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AWSAccessCredentials> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).checkAWSAccessCredentialsByName(namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organization: Organization, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).createOrganization(organization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).deleteAWSAccessCredentials(namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * delete a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organization: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).deleteOrganization(organization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization: string, username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).deleteUserFromOrganization(organization, username, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Organization>> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).getAllOrganizations(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organization: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Organization> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).getOrganization(organization, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization: string, username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationUser> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).getOrganizationUser(organization, username, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * update a organization
         * @param {string} organization organization name or id
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organization: string, organizationDetails: Organization, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).updateOrganization(organization, organizationDetails, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).updateUserInOrganization(organization, username, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any) {
            return OrganizationApiFp(configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options)(fetch, basePath);
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization: string, user: OrganizationUser, options?: any) {
            return OrganizationApiFp(configuration).addUserToOrganization(organization, user, options)(fetch, basePath);
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace: string, options?: any) {
            return OrganizationApiFp(configuration).checkAWSAccessCredentials(namespace, options)(fetch, basePath);
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any) {
            return OrganizationApiFp(configuration).checkAWSAccessCredentialsByName(namespace, name, options)(fetch, basePath);
        },
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organization: Organization, options?: any) {
            return OrganizationApiFp(configuration).createOrganization(organization, options)(fetch, basePath);
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace: string, name: string, options?: any) {
            return OrganizationApiFp(configuration).deleteAWSAccessCredentials(namespace, name, options)(fetch, basePath);
        },
        /**
         * delete a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organization: string, options?: any) {
            return OrganizationApiFp(configuration).deleteOrganization(organization, options)(fetch, basePath);
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization: string, username: string, options?: any) {
            return OrganizationApiFp(configuration).deleteUserFromOrganization(organization, username, options)(fetch, basePath);
        },
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations(options?: any) {
            return OrganizationApiFp(configuration).getAllOrganizations(options)(fetch, basePath);
        },
        /**
         * get a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organization: string, options?: any) {
            return OrganizationApiFp(configuration).getOrganization(organization, options)(fetch, basePath);
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization: string, username: string, options?: any) {
            return OrganizationApiFp(configuration).getOrganizationUser(organization, username, options)(fetch, basePath);
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any) {
            return OrganizationApiFp(configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options)(fetch, basePath);
        },
        /**
         * update a organization
         * @param {string} organization organization name or id
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organization: string, organizationDetails: Organization, options?: any) {
            return OrganizationApiFp(configuration).updateOrganization(organization, organizationDetails, options)(fetch, basePath);
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any) {
            return OrganizationApiFp(configuration).updateUserInOrganization(organization, username, user, options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any) {
        return OrganizationApiFp(this.configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options)(this.fetch, this.basePath);
    }

    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public addUserToOrganization(organization: string, user: OrganizationUser, options?: any) {
        return OrganizationApiFp(this.configuration).addUserToOrganization(organization, user, options)(this.fetch, this.basePath);
    }

    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public checkAWSAccessCredentials(namespace: string, options?: any) {
        return OrganizationApiFp(this.configuration).checkAWSAccessCredentials(namespace, options)(this.fetch, this.basePath);
    }

    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any) {
        return OrganizationApiFp(this.configuration).checkAWSAccessCredentialsByName(namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * create a organization, the user creating will be listed as owner
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrganization(organization: Organization, options?: any) {
        return OrganizationApiFp(this.configuration).createOrganization(organization, options)(this.fetch, this.basePath);
    }

    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteAWSAccessCredentials(namespace: string, name: string, options?: any) {
        return OrganizationApiFp(this.configuration).deleteAWSAccessCredentials(namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * delete a organization
     * @param {string} organization organization name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteOrganization(organization: string, options?: any) {
        return OrganizationApiFp(this.configuration).deleteOrganization(organization, options)(this.fetch, this.basePath);
    }

    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteUserFromOrganization(organization: string, username: string, options?: any) {
        return OrganizationApiFp(this.configuration).deleteUserFromOrganization(organization, username, options)(this.fetch, this.basePath);
    }

    /**
     * get all organizations that the user is member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getAllOrganizations(options?: any) {
        return OrganizationApiFp(this.configuration).getAllOrganizations(options)(this.fetch, this.basePath);
    }

    /**
     * get a organization
     * @param {string} organization organization name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganization(organization: string, options?: any) {
        return OrganizationApiFp(this.configuration).getOrganization(organization, options)(this.fetch, this.basePath);
    }

    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationUser(organization: string, username: string, options?: any) {
        return OrganizationApiFp(this.configuration).getOrganizationUser(organization, username, options)(this.fetch, this.basePath);
    }

    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any) {
        return OrganizationApiFp(this.configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options)(this.fetch, this.basePath);
    }

    /**
     * update a organization
     * @param {string} organization organization name or id
     * @param {Organization} organizationDetails organization details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganization(organization: string, organizationDetails: Organization, options?: any) {
        return OrganizationApiFp(this.configuration).updateOrganization(organization, organizationDetails, options)(this.fetch, this.basePath);
    }

    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any) {
        return OrganizationApiFp(this.configuration).updateUserInOrganization(organization, username, user, options)(this.fetch, this.basePath);
    }

}

/**
 * QueryApi - fetch parameter creator
 * @export
 */
export const QueryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling finalizeQuery.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling finalizeQuery.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling finalizeQuery.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling finalizeQuery.');
            }
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling finalizeQuery.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/query/finalize`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Query" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getEstResultSizes.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling getEstResultSizes.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getEstResultSizes.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling getEstResultSizes.');
            }
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling getEstResultSizes.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/query/est_result_sizes`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Query" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling submitQuery.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling submitQuery.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling submitQuery.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling submitQuery.');
            }
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling submitQuery.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/query/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Query" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Query> {
            const localVarFetchArgs = QueryApiFetchParamCreator(configuration).finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Query> {
            const localVarFetchArgs = QueryApiFetchParamCreator(configuration).getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Query> {
            const localVarFetchArgs = QueryApiFetchParamCreator(configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any) {
            return QueryApiFp(configuration).finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options)(fetch, basePath);
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any) {
            return QueryApiFp(configuration).getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options)(fetch, basePath);
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any) {
            return QueryApiFp(configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options)(fetch, basePath);
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public finalizeQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any) {
        return QueryApiFp(this.configuration).finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options)(this.fetch, this.basePath);
    }

    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public getEstResultSizes(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any) {
        return QueryApiFp(this.configuration).getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options)(this.fetch, this.basePath);
    }

    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any) {
        return QueryApiFp(this.configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options)(this.fetch, this.basePath);
    }

}

/**
 * SqlApi - fetch parameter creator
 * @export
 */
export const SqlApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling runSQL.');
            }
            // verify required parameter 'sql' is not null or undefined
            if (sql === null || sql === undefined) {
                throw new RequiredError('sql','Required parameter sql was null or undefined when calling runSQL.');
            }
            const localVarPath = `/sql/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SQLParameters" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sql || {}) : (sql || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SqlApi - functional programming interface
 * @export
 */
export const SqlApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = SqlApiFetchParamCreator(configuration).runSQL(namespace, sql, acceptEncoding, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SqlApi - factory interface
 * @export
 */
export const SqlApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any) {
            return SqlApiFp(configuration).runSQL(namespace, sql, acceptEncoding, options)(fetch, basePath);
        },
    };
};

/**
 * SqlApi - object-oriented interface
 * @export
 * @class SqlApi
 * @extends {BaseAPI}
 */
export class SqlApi extends BaseAPI {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SqlApi
     */
    public runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any) {
        return SqlApiFp(this.configuration).runSQL(namespace, sql, acceptEncoding, options)(this.fetch, this.basePath);
    }

}

/**
 * StatsApi - fetch parameter creator
 * @export
 */
export const StatsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats(options: any = {}): FetchArgs {
            const localVarPath = `/.stats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = StatsApiFetchParamCreator(configuration).getTiledbStats(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats(options?: any) {
            return StatsApiFp(configuration).getTiledbStats(options)(fetch, basePath);
        },
    };
};

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI {
    /**
     * Fetch libtiledb stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public getTiledbStats(options?: any) {
        return StatsApiFp(this.configuration).getTiledbStats(options)(this.fetch, this.basePath);
    }

}

/**
 * TasksApi - fetch parameter creator
 * @export
 */
export const TasksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling runSQL.');
            }
            // verify required parameter 'sql' is not null or undefined
            if (sql === null || sql === undefined) {
                throw new RequiredError('sql','Required parameter sql was null or undefined when calling runSQL.');
            }
            const localVarPath = `/sql/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SQLParameters" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sql || {}) : (sql || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch an array task
         * @param {string} id task id to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling taskIdGet.');
            }
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, search?: string, orderby?: string, options: any = {}): FetchArgs {
            const localVarPath = `/tasks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (array !== undefined) {
                localVarQueryParameter['array'] = array;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = TasksApiFetchParamCreator(configuration).runSQL(namespace, sql, acceptEncoding, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch an array task
         * @param {string} id task id to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArrayTask> {
            const localVarFetchArgs = TasksApiFetchParamCreator(configuration).taskIdGet(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, search?: string, orderby?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArrayTaskData> {
            const localVarFetchArgs = TasksApiFetchParamCreator(configuration).tasksGet(namespace, createdBy, array, start, end, page, perPage, type, status, search, orderby, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any) {
            return TasksApiFp(configuration).runSQL(namespace, sql, acceptEncoding, options)(fetch, basePath);
        },
        /**
         * Fetch an array task
         * @param {string} id task id to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet(id: string, options?: any) {
            return TasksApiFp(configuration).taskIdGet(id, options)(fetch, basePath);
        },
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, search?: string, orderby?: string, options?: any) {
            return TasksApiFp(configuration).tasksGet(namespace, createdBy, array, start, end, page, perPage, type, status, search, orderby, options)(fetch, basePath);
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any) {
        return TasksApiFp(this.configuration).runSQL(namespace, sql, acceptEncoding, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch an array task
     * @param {string} id task id to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public taskIdGet(id: string, options?: any) {
        return TasksApiFp(this.configuration).taskIdGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a list of all array tasks a user has access to
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;
     * @param {string} [status] Filter to only return these statuses
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include start_time, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksGet(namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, search?: string, orderby?: string, options?: any) {
        return TasksApiFp(this.configuration).tasksGet(namespace, createdBy, array, start, end, page, perPage, type, status, search, orderby, options)(this.fetch, this.basePath);
    }

}

/**
 * UdfApi - fetch parameter creator
 * @export
 */
export const UdfApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo(namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getUDFInfo.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getUDFInfo.');
            }
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a all UDFs accessible to the user
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] udf type, \&quot;generic\&quot;, \&quot;single_array\&quot;
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include created_at, last_used, name
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoList(namespace?: string, createdBy?: string, page?: number, perPage?: number, type?: string, search?: string, orderby?: string, tag?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/udfs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all sharing details of the udf
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies(namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getUDFInfoSharingPolicies.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getUDFInfoSharingPolicies.');
            }
            const localVarPath = `/udf/{namespace}/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling registerUDFInfo.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling registerUDFInfo.');
            }
            // verify required parameter 'udf' is not null or undefined
            if (udf === null || udf === undefined) {
                throw new RequiredError('udf','Required parameter udf was null or undefined when calling registerUDFInfo.');
            }
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UDFInfoUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(udf || {}) : (udf || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo(namespace: string, name: string, udfSharing: UDFSharing, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling shareUDFInfo.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling shareUDFInfo.');
            }
            // verify required parameter 'udfSharing' is not null or undefined
            if (udfSharing === null || udfSharing === undefined) {
                throw new RequiredError('udfSharing','Required parameter udfSharing was null or undefined when calling shareUDFInfo.');
            }
            const localVarPath = `/udf/{namespace}/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UDFSharing" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(udfSharing || {}) : (udfSharing || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {GenericUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF(namespace: string, udf: GenericUDF, acceptEncoding?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling submitGenericUDF.');
            }
            // verify required parameter 'udf' is not null or undefined
            if (udf === null || udf === undefined) {
                throw new RequiredError('udf','Required parameter udf was null or undefined when calling submitGenericUDF.');
            }
            const localVarPath = `/udfs/generic/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GenericUDF" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(udf || {}) : (udf || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {UDF} udf udf to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF(namespace: string, array: string, udf: UDF, xPayer?: string, acceptEncoding?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling submitUDF.');
            }
            // verify required parameter 'array' is not null or undefined
            if (array === null || array === undefined) {
                throw new RequiredError('array','Required parameter array was null or undefined when calling submitUDF.');
            }
            // verify required parameter 'udf' is not null or undefined
            if (udf === null || udf === undefined) {
                throw new RequiredError('udf','Required parameter udf was null or undefined when calling submitUDF.');
            }
            const localVarPath = `/arrays/{namespace}/{array}/udf/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UDF" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(udf || {}) : (udf || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * updated an existing registerd UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateUDFInfo.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateUDFInfo.');
            }
            // verify required parameter 'udf' is not null or undefined
            if (udf === null || udf === undefined) {
                throw new RequiredError('udf','Required parameter udf was null or undefined when calling updateUDFInfo.');
            }
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UDFInfoUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(udf || {}) : (udf || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UdfApi - functional programming interface
 * @export
 */
export const UdfApiFp = function(configuration?: Configuration) {
    return {
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo(namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UDFInfo> {
            const localVarFetchArgs = UdfApiFetchParamCreator(configuration).getUDFInfo(namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get a all UDFs accessible to the user
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] udf type, \&quot;generic\&quot;, \&quot;single_array\&quot;
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include created_at, last_used, name
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoList(namespace?: string, createdBy?: string, page?: number, perPage?: number, type?: string, search?: string, orderby?: string, tag?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UDFListingData> {
            const localVarFetchArgs = UdfApiFetchParamCreator(configuration).getUDFInfoList(namespace, createdBy, page, perPage, type, search, orderby, tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all sharing details of the udf
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies(namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UDFSharing>> {
            const localVarFetchArgs = UdfApiFetchParamCreator(configuration).getUDFInfoSharingPolicies(namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UdfApiFetchParamCreator(configuration).registerUDFInfo(namespace, name, udf, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo(namespace: string, name: string, udfSharing: UDFSharing, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UdfApiFetchParamCreator(configuration).shareUDFInfo(namespace, name, udfSharing, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {GenericUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF(namespace: string, udf: GenericUDF, acceptEncoding?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = UdfApiFetchParamCreator(configuration).submitGenericUDF(namespace, udf, acceptEncoding, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {UDF} udf udf to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF(namespace: string, array: string, udf: UDF, xPayer?: string, acceptEncoding?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = UdfApiFetchParamCreator(configuration).submitUDF(namespace, array, udf, xPayer, acceptEncoding, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * updated an existing registerd UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UdfApiFetchParamCreator(configuration).updateUDFInfo(namespace, name, udf, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UdfApi - factory interface
 * @export
 */
export const UdfApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo(namespace: string, name: string, options?: any) {
            return UdfApiFp(configuration).getUDFInfo(namespace, name, options)(fetch, basePath);
        },
        /**
         * get a all UDFs accessible to the user
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] udf type, \&quot;generic\&quot;, \&quot;single_array\&quot;
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include created_at, last_used, name
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoList(namespace?: string, createdBy?: string, page?: number, perPage?: number, type?: string, search?: string, orderby?: string, tag?: Array<string>, options?: any) {
            return UdfApiFp(configuration).getUDFInfoList(namespace, createdBy, page, perPage, type, search, orderby, tag, options)(fetch, basePath);
        },
        /**
         * Get all sharing details of the udf
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies(namespace: string, name: string, options?: any) {
            return UdfApiFp(configuration).getUDFInfoSharingPolicies(namespace, name, options)(fetch, basePath);
        },
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any) {
            return UdfApiFp(configuration).registerUDFInfo(namespace, name, udf, options)(fetch, basePath);
        },
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo(namespace: string, name: string, udfSharing: UDFSharing, options?: any) {
            return UdfApiFp(configuration).shareUDFInfo(namespace, name, udfSharing, options)(fetch, basePath);
        },
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {GenericUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF(namespace: string, udf: GenericUDF, acceptEncoding?: string, options?: any) {
            return UdfApiFp(configuration).submitGenericUDF(namespace, udf, acceptEncoding, options)(fetch, basePath);
        },
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {UDF} udf udf to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF(namespace: string, array: string, udf: UDF, xPayer?: string, acceptEncoding?: string, options?: any) {
            return UdfApiFp(configuration).submitUDF(namespace, array, udf, xPayer, acceptEncoding, options)(fetch, basePath);
        },
        /**
         * updated an existing registerd UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any) {
            return UdfApiFp(configuration).updateUDFInfo(namespace, name, udf, options)(fetch, basePath);
        },
    };
};

/**
 * UdfApi - object-oriented interface
 * @export
 * @class UdfApi
 * @extends {BaseAPI}
 */
export class UdfApi extends BaseAPI {
    /**
     * get a specific UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} name name to register udf under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public getUDFInfo(namespace: string, name: string, options?: any) {
        return UdfApiFp(this.configuration).getUDFInfo(namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * get a all UDFs accessible to the user
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] udf type, \&quot;generic\&quot;, \&quot;single_array\&quot;
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include created_at, last_used, name
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public getUDFInfoList(namespace?: string, createdBy?: string, page?: number, perPage?: number, type?: string, search?: string, orderby?: string, tag?: Array<string>, options?: any) {
        return UdfApiFp(this.configuration).getUDFInfoList(namespace, createdBy, page, perPage, type, search, orderby, tag, options)(this.fetch, this.basePath);
    }

    /**
     * Get all sharing details of the udf
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public getUDFInfoSharingPolicies(namespace: string, name: string, options?: any) {
        return UdfApiFp(this.configuration).getUDFInfoSharingPolicies(namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * register a UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} name name to register udf under
     * @param {UDFInfoUpdate} udf udf to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public registerUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any) {
        return UdfApiFp(this.configuration).registerUDFInfo(namespace, name, udf, options)(this.fetch, this.basePath);
    }

    /**
     * Share a UDF with a user
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public shareUDFInfo(namespace: string, name: string, udfSharing: UDFSharing, options?: any) {
        return UdfApiFp(this.configuration).shareUDFInfo(namespace, name, udfSharing, options)(this.fetch, this.basePath);
    }

    /**
     * submit a generic UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {GenericUDF} udf udf to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public submitGenericUDF(namespace: string, udf: GenericUDF, acceptEncoding?: string, options?: any) {
        return UdfApiFp(this.configuration).submitGenericUDF(namespace, udf, acceptEncoding, options)(this.fetch, this.basePath);
    }

    /**
     * send a UDF to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {UDF} udf udf to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public submitUDF(namespace: string, array: string, udf: UDF, xPayer?: string, acceptEncoding?: string, options?: any) {
        return UdfApiFp(this.configuration).submitUDF(namespace, array, udf, xPayer, acceptEncoding, options)(this.fetch, this.basePath);
    }

    /**
     * updated an existing registerd UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user&#39;s username)
     * @param {string} name name to register udf under
     * @param {UDFInfoUpdate} udf udf to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public updateUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any) {
        return UdfApiFp(this.configuration).updateUDFInfo(namespace, name, udf, options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling addAWSAccessCredentials.');
            }
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            if (awsAccessCredentials === null || awsAccessCredentials === undefined) {
                throw new RequiredError('awsAccessCredentials','Required parameter awsAccessCredentials was null or undefined when calling addAWSAccessCredentials.');
            }
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AWSAccessCredentials" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(awsAccessCredentials || {}) : (awsAccessCredentials || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization: string, user: OrganizationUser, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling addUserToOrganization.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling addUserToOrganization.');
            }
            const localVarPath = `/organizations/{organization}/user`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrganizationUser" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling checkAWSAccessCredentials.');
            }
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling checkAWSAccessCredentialsByName.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling checkAWSAccessCredentialsByName.');
            }
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail(options: any = {}): FetchArgs {
            const localVarPath = `/user/confirm_email`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: User, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling createUser.');
            }
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteAWSAccessCredentials.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteAWSAccessCredentials.');
            }
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization: string, username: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling deleteUserFromOrganization.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling deleteUserFromOrganization.');
            }
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization: string, username: string, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling getOrganizationUser.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling getOrganizationUser.');
            }
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(rememberMe?: string, options: any = {}): FetchArgs {
            const localVarPath = `/session`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (rememberMe !== undefined) {
                localVarQueryParameter['remember_me'] = rememberMe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options: any = {}): FetchArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername(username: string, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling getUserWithUsername.');
            }
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken(tokenRequest?: TokenRequest, options: any = {}): FetchArgs {
            const localVarPath = `/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TokenRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tokenRequest || {}) : (tokenRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * reset user password
         * @param {User} user password to update for user requesting update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(user: User, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling resetUserPassword.');
            }
            const localVarPath = `/user/password_reset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling revokeToken.');
            }
            const localVarPath = `/tokens/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options: any = {}): FetchArgs {
            const localVarPath = `/tokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updateAWSAccessCredentials.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateAWSAccessCredentials.');
            }
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            if (awsAccessCredentials === null || awsAccessCredentials === undefined) {
                throw new RequiredError('awsAccessCredentials','Required parameter awsAccessCredentials was null or undefined when calling updateAWSAccessCredentials.');
            }
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AWSAccessCredentials" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(awsAccessCredentials || {}) : (awsAccessCredentials || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a user
         * @param {string} username username or id
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username: string, user: User, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling updateUser.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling updateUser.');
            }
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options: any = {}): FetchArgs {
            // verify required parameter 'organization' is not null or undefined
            if (organization === null || organization === undefined) {
                throw new RequiredError('organization','Required parameter organization was null or undefined when calling updateUserInOrganization.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling updateUserInOrganization.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling updateUserInOrganization.');
            }
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-TILEDB-REST-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-TILEDB-REST-API-KEY"] = localVarApiKeyValue;
            }

            // authentication BasicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrganizationUser" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization: string, user: OrganizationUser, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).addUserToOrganization(organization, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AWSAccessCredentials>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).checkAWSAccessCredentials(namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AWSAccessCredentials> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).checkAWSAccessCredentialsByName(namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).confirmEmail(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).createUser(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).deleteAWSAccessCredentials(namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * delete a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).deleteUser(username, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization: string, username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).deleteUserFromOrganization(organization, username, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization: string, username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationUser> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getOrganizationUser(organization, username, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(rememberMe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Token> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getSession(rememberMe, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername(username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUserWithUsername(username, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken(tokenRequest?: TokenRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Token> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).requestToken(tokenRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * reset user password
         * @param {User} user password to update for user requesting update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(user: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).resetUserPassword(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).revokeToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Token>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).tokensGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * update a user
         * @param {string} username username or id
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username: string, user: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateUser(username, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateUserInOrganization(organization, username, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any) {
            return UserApiFp(configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options)(fetch, basePath);
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization: string, user: OrganizationUser, options?: any) {
            return UserApiFp(configuration).addUserToOrganization(organization, user, options)(fetch, basePath);
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace: string, options?: any) {
            return UserApiFp(configuration).checkAWSAccessCredentials(namespace, options)(fetch, basePath);
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any) {
            return UserApiFp(configuration).checkAWSAccessCredentialsByName(namespace, name, options)(fetch, basePath);
        },
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail(options?: any) {
            return UserApiFp(configuration).confirmEmail(options)(fetch, basePath);
        },
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: User, options?: any) {
            return UserApiFp(configuration).createUser(user, options)(fetch, basePath);
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace: string, name: string, options?: any) {
            return UserApiFp(configuration).deleteAWSAccessCredentials(namespace, name, options)(fetch, basePath);
        },
        /**
         * delete a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, options?: any) {
            return UserApiFp(configuration).deleteUser(username, options)(fetch, basePath);
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization: string, username: string, options?: any) {
            return UserApiFp(configuration).deleteUserFromOrganization(organization, username, options)(fetch, basePath);
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization: string, username: string, options?: any) {
            return UserApiFp(configuration).getOrganizationUser(organization, username, options)(fetch, basePath);
        },
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(rememberMe?: string, options?: any) {
            return UserApiFp(configuration).getSession(rememberMe, options)(fetch, basePath);
        },
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any) {
            return UserApiFp(configuration).getUser(options)(fetch, basePath);
        },
        /**
         * get a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername(username: string, options?: any) {
            return UserApiFp(configuration).getUserWithUsername(username, options)(fetch, basePath);
        },
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken(tokenRequest?: TokenRequest, options?: any) {
            return UserApiFp(configuration).requestToken(tokenRequest, options)(fetch, basePath);
        },
        /**
         * reset user password
         * @param {User} user password to update for user requesting update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(user: User, options?: any) {
            return UserApiFp(configuration).resetUserPassword(user, options)(fetch, basePath);
        },
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(token: string, options?: any) {
            return UserApiFp(configuration).revokeToken(token, options)(fetch, basePath);
        },
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options?: any) {
            return UserApiFp(configuration).tokensGet(options)(fetch, basePath);
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any) {
            return UserApiFp(configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options)(fetch, basePath);
        },
        /**
         * update a user
         * @param {string} username username or id
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username: string, user: User, options?: any) {
            return UserApiFp(configuration).updateUser(username, user, options)(fetch, basePath);
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any) {
            return UserApiFp(configuration).updateUserInOrganization(organization, username, user, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any) {
        return UserApiFp(this.configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options)(this.fetch, this.basePath);
    }

    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUserToOrganization(organization: string, user: OrganizationUser, options?: any) {
        return UserApiFp(this.configuration).addUserToOrganization(organization, user, options)(this.fetch, this.basePath);
    }

    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public checkAWSAccessCredentials(namespace: string, options?: any) {
        return UserApiFp(this.configuration).checkAWSAccessCredentials(namespace, options)(this.fetch, this.basePath);
    }

    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any) {
        return UserApiFp(this.configuration).checkAWSAccessCredentialsByName(namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * confirm user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public confirmEmail(options?: any) {
        return UserApiFp(this.configuration).confirmEmail(options)(this.fetch, this.basePath);
    }

    /**
     * create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(user: User, options?: any) {
        return UserApiFp(this.configuration).createUser(user, options)(this.fetch, this.basePath);
    }

    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteAWSAccessCredentials(namespace: string, name: string, options?: any) {
        return UserApiFp(this.configuration).deleteAWSAccessCredentials(namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * delete a user
     * @param {string} username username or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(username: string, options?: any) {
        return UserApiFp(this.configuration).deleteUser(username, options)(this.fetch, this.basePath);
    }

    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUserFromOrganization(organization: string, username: string, options?: any) {
        return UserApiFp(this.configuration).deleteUserFromOrganization(organization, username, options)(this.fetch, this.basePath);
    }

    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getOrganizationUser(organization: string, username: string, options?: any) {
        return UserApiFp(this.configuration).getOrganizationUser(organization, username, options)(this.fetch, this.basePath);
    }

    /**
     * Get session token for user
     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getSession(rememberMe?: string, options?: any) {
        return UserApiFp(this.configuration).getSession(rememberMe, options)(this.fetch, this.basePath);
    }

    /**
     * get a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(options?: any) {
        return UserApiFp(this.configuration).getUser(options)(this.fetch, this.basePath);
    }

    /**
     * get a user
     * @param {string} username username or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserWithUsername(username: string, options?: any) {
        return UserApiFp(this.configuration).getUserWithUsername(username, options)(this.fetch, this.basePath);
    }

    /**
     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
     * @param {TokenRequest} [tokenRequest] token request object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public requestToken(tokenRequest?: TokenRequest, options?: any) {
        return UserApiFp(this.configuration).requestToken(tokenRequest, options)(this.fetch, this.basePath);
    }

    /**
     * reset user password
     * @param {User} user password to update for user requesting update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public resetUserPassword(user: User, options?: any) {
        return UserApiFp(this.configuration).resetUserPassword(user, options)(this.fetch, this.basePath);
    }

    /**
     * revoke an authorization token
     * @param {string} token token name or token itself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public revokeToken(token: string, options?: any) {
        return UserApiFp(this.configuration).revokeToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a list of user tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public tokensGet(options?: any) {
        return UserApiFp(this.configuration).tokensGet(options)(this.fetch, this.basePath);
    }

    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any) {
        return UserApiFp(this.configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options)(this.fetch, this.basePath);
    }

    /**
     * update a user
     * @param {string} username username or id
     * @param {User} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(username: string, user: User, options?: any) {
        return UserApiFp(this.configuration).updateUser(username, user, options)(this.fetch, this.basePath);
    }

    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any) {
        return UserApiFp(this.configuration).updateUserInOrganization(organization, username, user, options)(this.fetch, this.basePath);
    }

}

