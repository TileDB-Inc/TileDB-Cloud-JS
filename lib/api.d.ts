/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.5.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Configuration } from './configuration';
import { AxiosPromise, AxiosInstance } from 'axios';
import { RequestArgs, BaseAPI } from './base';
/**
 * Model representing aws keys or service role, service roles are currently ignored, but will be preferred option in the future
 * @export
 * @interface AWSAccessCredentials
 */
export interface AWSAccessCredentials {
    /**
     * aws secret access key, never returned in get requests
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    secretAccessKey?: string;
    /**
     * aws access key
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    accessKeyId?: string;
    /**
     * aws service role to use for access
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    serviceRoleArn?: string;
    /**
     * human readable name
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    name?: string;
    /**
     * true if this is the default credential to be used within this namespace
     * @type {boolean}
     * @memberof AWSAccessCredentials
     */
    _default?: boolean;
    /**
     * a whitelist of one or more buckets this key should access
     * @type {Array<string>}
     * @memberof AWSAccessCredentials
     */
    buckets?: Array<string>;
    /**
     * Time when udf dependencies was created (rfc3339)
     * @type {Date}
     * @memberof AWSAccessCredentials
     */
    createdAt?: Date;
    /**
     * Time when udf dependencies was last updated (rfc3339)
     * @type {Date}
     * @memberof AWSAccessCredentials
     */
    updatedAt?: Date;
}
/**
 * Type of activity logged
 * @export
 * @enum {string}
 */
export declare enum ActivityEventType {
    ReadSchema = "read_schema",
    MaxBufferSizes = "max_buffer_sizes",
    NonEmptyDomain = "non_empty_domain",
    QueryRead = "query_read",
    QueryWrite = "query_write",
    Create = "create",
    Delete = "delete",
    Register = "register",
    Deregister = "deregister",
    Udf = "udf",
    ArrayMetadataGet = "array_metadata_get",
    ArrayMetadataUpdate = "array_metadata_update"
}
/**
 * actions a user can take on an array
 * @export
 * @enum {string}
 */
export declare enum ArrayActions {
    Read = "read",
    Write = "write",
    Edit = "edit",
    ReadArrayLogs = "read_array_logs"
}
/**
 * Actvity of an Array
 * @export
 * @interface ArrayActivityLog
 */
export interface ArrayActivityLog {
    /**
     * time event took place (RFC3339)
     * @type {Date}
     * @memberof ArrayActivityLog
     */
    eventAt?: Date;
    /**
     *
     * @type {ActivityEventType}
     * @memberof ArrayActivityLog
     */
    action?: ActivityEventType;
    /**
     * User who performed action
     * @type {string}
     * @memberof ArrayActivityLog
     */
    username?: string;
    /**
     * Bytes sent to client
     * @type {number}
     * @memberof ArrayActivityLog
     */
    bytesSent?: number;
    /**
     * Bytes recieved from client
     * @type {number}
     * @memberof ArrayActivityLog
     */
    bytesReceived?: number;
    /**
     * uuid of associated array task
     * @type {string}
     * @memberof ArrayActivityLog
     */
    arrayTaskId?: string;
    /**
     * ranges for query
     * @type {string}
     * @memberof ArrayActivityLog
     */
    queryRanges?: string;
}
/**
 * metadata of an array
 * @export
 * @interface ArrayInfo
 */
export interface ArrayInfo {
    /**
     * unique id of registered array
     * @type {string}
     * @memberof ArrayInfo
     */
    id?: string;
    /**
     * uri of array
     * @type {string}
     * @memberof ArrayInfo
     */
    uri?: string;
    /**
     * namespace array is in
     * @type {string}
     * @memberof ArrayInfo
     */
    namespace?: string;
    /**
     * size in bytes of array
     * @type {number}
     * @memberof ArrayInfo
     */
    size?: number;
    /**
     * Datetime array was last accessed in UTC
     * @type {Date}
     * @memberof ArrayInfo
     */
    lastAccessed?: Date;
    /**
     * description of array
     * @type {string}
     * @memberof ArrayInfo
     */
    description?: string;
    /**
     * name of array
     * @type {string}
     * @memberof ArrayInfo
     */
    name?: string;
    /**
     * list of actions user is allowed to do on this array
     * @type {Array<ArrayActions>}
     * @memberof ArrayInfo
     */
    allowedActions?: Array<ArrayActions>;
    /**
     * logo (base64 encoded) for the array. Optional
     * @type {string}
     * @memberof ArrayInfo
     */
    logo?: string;
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used
     * @type {string}
     * @memberof ArrayInfo
     */
    accessCredentialsName?: string;
    /**
     * Array type (dense, key-value, sparse)
     * @type {string}
     * @memberof ArrayInfo
     */
    type?: string;
    /**
     * number of unique namespaces this array is shared with
     * @type {number}
     * @memberof ArrayInfo
     */
    shareCount?: number;
    /**
     * Suggests if the array was shared to public by owner
     * @type {boolean}
     * @memberof ArrayInfo
     */
    publicShare?: boolean;
    /**
     * uri for access through TileDB cloud
     * @type {string}
     * @memberof ArrayInfo
     */
    tiledbUri?: string;
}
/**
 * metadata of an array
 * @export
 * @interface ArrayInfoUpdate
 */
export interface ArrayInfoUpdate {
    /**
     * description of array
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    description?: string;
    /**
     * description of array
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    name?: string;
    /**
     * uri of array
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    uri?: string;
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    accessCredentialsName?: string;
}
/**
 * user\'s TileDB array metadata
 * @export
 * @interface ArrayMetadata
 */
export interface ArrayMetadata {
    /**
     * List of metadata entries
     * @type {Array<ArrayMetadataEntry>}
     * @memberof ArrayMetadata
     */
    ranges?: Array<ArrayMetadataEntry>;
}
/**
 * key/value pair representing an array metadata map entry
 * @export
 * @interface ArrayMetadataEntry
 */
export interface ArrayMetadataEntry {
    /**
     *
     * @type {string}
     * @memberof ArrayMetadataEntry
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof ArrayMetadataEntry
     */
    type?: string;
    /**
     *
     * @type {number}
     * @memberof ArrayMetadataEntry
     */
    valueNum?: number;
    /**
     *
     * @type {Array<number>}
     * @memberof ArrayMetadataEntry
     */
    value?: Array<number>;
    /**
     *
     * @type {boolean}
     * @memberof ArrayMetadataEntry
     */
    del?: boolean;
}
/**
 * Sample data from array
 * @export
 * @interface ArraySample
 */
export interface ArraySample {
    /**
     *
     * @type {object}
     * @memberof ArraySample
     */
    data?: object;
}
/**
 * ArraySchema during creation or retrieval
 * @export
 * @interface ArraySchema
 */
export interface ArraySchema {
    /**
     * URI of schema
     * @type {string}
     * @memberof ArraySchema
     */
    uri?: string;
    /**
     * file format version
     * @type {Array<number>}
     * @memberof ArraySchema
     */
    version: Array<number>;
    /**
     *
     * @type {ArrayType}
     * @memberof ArraySchema
     */
    arrayType: ArrayType;
    /**
     *
     * @type {Layout}
     * @memberof ArraySchema
     */
    tileOrder: Layout;
    /**
     *
     * @type {Layout}
     * @memberof ArraySchema
     */
    cellOrder: Layout;
    /**
     * Capacity of array
     * @type {number}
     * @memberof ArraySchema
     */
    capacity: number;
    /**
     *
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    coordsFilterPipeline: FilterPipeline;
    /**
     *
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    offsetFilterPipeline: FilterPipeline;
    /**
     *
     * @type {Domain}
     * @memberof ArraySchema
     */
    domain: Domain;
    /**
     * Attributes of array
     * @type {Array<Attribute>}
     * @memberof ArraySchema
     */
    attributes: Array<Attribute>;
    /**
     * True if the array allows coordinate duplicates. Applicable only to sparse arrays.
     * @type {boolean}
     * @memberof ArraySchema
     */
    allowsDuplicates?: boolean;
}
/**
 * details for sharing a given array
 * @export
 * @interface ArraySharing
 */
export interface ArraySharing {
    /**
     * List of permitted actions
     * @type {Array<ArrayActions>}
     * @memberof ArraySharing
     */
    actions?: Array<ArrayActions>;
    /**
     * namespace being granted array access can be a user or organization
     * @type {string}
     * @memberof ArraySharing
     */
    namespace?: string;
    /**
     * details on if the namespace is a organization or user
     * @type {string}
     * @memberof ArraySharing
     */
    namespaceType?: string;
}
/**
 * Synchronous Task to Run
 * @export
 * @interface ArrayTask
 */
export interface ArrayTask {
    /**
     * task id
     * @type {string}
     * @memberof ArrayTask
     */
    id?: string;
    /**
     * Optional task name
     * @type {string}
     * @memberof ArrayTask
     */
    name?: string;
    /**
     * Optional task description (Tasks purpose)
     * @type {string}
     * @memberof ArrayTask
     */
    description?: string;
    /**
     *
     * @type {ArrayInfo}
     * @memberof ArrayTask
     */
    arrayMetadata?: ArrayInfo;
    /**
     *
     * @type {DomainArray}
     * @memberof ArrayTask
     */
    subarray?: DomainArray;
    /**
     * memory allocated to task in bytes
     * @type {number}
     * @memberof ArrayTask
     */
    memory?: number;
    /**
     * millicpu allocated to task
     * @type {number}
     * @memberof ArrayTask
     */
    cpu?: number;
    /**
     * namespace task is tied to
     * @type {string}
     * @memberof ArrayTask
     */
    namespace?: string;
    /**
     *
     * @type {ArrayTaskStatus}
     * @memberof ArrayTask
     */
    status?: ArrayTaskStatus;
    /**
     * Start time RFC3339 for job
     * @type {Date}
     * @memberof ArrayTask
     */
    startTime?: Date;
    /**
     * Finish time RFC3339 for job
     * @type {Date}
     * @memberof ArrayTask
     */
    finishTime?: Date;
    /**
     * Cost accumulated for task in 0.01 USD, example is 1 USD
     * @type {number}
     * @memberof ArrayTask
     */
    cost?: number;
    /**
     *
     * @type {Querytype}
     * @memberof ArrayTask
     */
    queryType?: Querytype;
    /**
     * Optional actual code that is going to be executed
     * @type {string}
     * @memberof ArrayTask
     */
    udfCode?: string;
    /**
     * Optional actual language used to express udf_code
     * @type {string}
     * @memberof ArrayTask
     */
    udfLanguage?: string;
    /**
     * Optional actual sql query that is going to be executed
     * @type {string}
     * @memberof ArrayTask
     */
    sqlQuery?: string;
    /**
     *
     * @type {ArrayTaskType}
     * @memberof ArrayTask
     */
    type?: ArrayTaskType;
    /**
     * Array activity logs for task
     * @type {Array<ArrayActivityLog>}
     * @memberof ArrayTask
     */
    activity?: Array<ArrayActivityLog>;
    /**
     * logs from array task
     * @type {string}
     * @memberof ArrayTask
     */
    logs?: string;
}
/**
 * Object for ui array tasks browser page
 * @export
 * @interface ArrayTaskBrowserSidebar
 */
export interface ArrayTaskBrowserSidebar {
    /**
     * list of all unique organizations the user is part of that have array tasks
     * @type {Array<string>}
     * @memberof ArrayTaskBrowserSidebar
     */
    organizations?: Array<string>;
    /**
     * A count of \"all\"
     * @type {number}
     * @memberof ArrayTaskBrowserSidebar
     */
    resultCountForAll?: number;
    /**
     * A map that includes the result count by namespace
     * @type {object}
     * @memberof ArrayTaskBrowserSidebar
     */
    resultCountByNamespace?: object;
}
/**
 * Object including array tasks and metadata
 * @export
 * @interface ArrayTaskData
 */
export interface ArrayTaskData {
    /**
     * Array Tasks
     * @type {Array<ArrayTask>}
     * @memberof ArrayTaskData
     */
    arrayTasks?: Array<ArrayTask>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof ArrayTaskData
     */
    paginationMetadata?: PaginationMetadata;
}
/**
 * Array task stderr/stdout logs
 * @export
 * @interface ArrayTaskLog
 */
export interface ArrayTaskLog {
    /**
     * ID of associated task
     * @type {string}
     * @memberof ArrayTaskLog
     */
    arrayTaskId?: string;
    /**
     * logs from array task
     * @type {string}
     * @memberof ArrayTaskLog
     */
    logs?: string;
}
/**
 * Status of array task
 * @export
 * @enum {string}
 */
export declare enum ArrayTaskStatus {
    FAILED = "FAILED",
    COMPLETED = "COMPLETED",
    RUNNING = "RUNNING"
}
/**
 * Synchronous Task Type
 * @export
 * @enum {string}
 */
export declare enum ArrayTaskType {
    SQL = "SQL",
    UDF = "UDF",
    QUERY = "QUERY",
    GENERICUDF = "GENERIC_UDF"
}
/**
 * TileDB array type
 * @export
 * @enum {string}
 */
export declare enum ArrayType {
    Dense = "dense",
    Sparse = "sparse"
}
/**
 * Attribute of array
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * Attribute name
     * @type {string}
     * @memberof Attribute
     */
    name: string;
    /**
     *
     * @type {Datatype}
     * @memberof Attribute
     */
    type: Datatype;
    /**
     *
     * @type {FilterPipeline}
     * @memberof Attribute
     */
    filterPipeline: FilterPipeline;
    /**
     * Attribute number of values per cell
     * @type {number}
     * @memberof Attribute
     */
    cellValNum: number;
}
/**
 * Represents an attribute buffer header information
 * @export
 * @interface AttributeBufferHeader
 */
export interface AttributeBufferHeader {
    /**
     * Attribute name
     * @type {string}
     * @memberof AttributeBufferHeader
     */
    name: string;
    /**
     * Number of bytes in the fixed-length attribute data buffer (offsets for var-len attributes)
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    fixedLenBufferSizeInBytes: number;
    /**
     * Number of bytes in the var-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    varLenBufferSizeInBytes: number;
}
/**
 * object representing buffer size of an attribute
 * @export
 * @interface AttributeBufferSize
 */
export interface AttributeBufferSize {
    /**
     * name of attribute
     * @type {string}
     * @memberof AttributeBufferSize
     */
    attribute: string;
    /**
     * buffer size (in bytes) of offset buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    offsetBytes: number;
    /**
     * buffer size (in bytes) of data buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    dataBytes: number;
}
/**
 * TileDB data type
 * @export
 * @enum {string}
 */
export declare enum Datatype {
    INT32 = "INT32",
    INT64 = "INT64",
    FLOAT32 = "FLOAT32",
    FLOAT64 = "FLOAT64",
    CHAR = "CHAR",
    INT8 = "INT8",
    UINT8 = "UINT8",
    INT16 = "INT16",
    UINT16 = "UINT16",
    UINT32 = "UINT32",
    UINT64 = "UINT64",
    STRINGASCII = "STRING_ASCII",
    STRINGUTF8 = "STRING_UTF8",
    STRINGUTF16 = "STRING_UTF16",
    STRINGUTF32 = "STRING_UTF32",
    STRINGUCS2 = "STRING_UCS2",
    STRINGUCS4 = "STRING_UCS4",
    ANY = "ANY"
}
/**
 * Dimension of array
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * Dimension name
     * @type {string}
     * @memberof Dimension
     */
    name?: string;
    /**
     *
     * @type {Datatype}
     * @memberof Dimension
     */
    type: Datatype;
    /**
     *
     * @type {DomainArray}
     * @memberof Dimension
     */
    domain: DomainArray;
    /**
     * Is tile extent null
     * @type {boolean}
     * @memberof Dimension
     */
    nullTileExtent: boolean;
    /**
     *
     * @type {DimensionTileExtent}
     * @memberof Dimension
     */
    tileExtent?: DimensionTileExtent;
}
/**
 * A single, typed coordinate for a dimension
 * @export
 * @interface DimensionCoordinate
 */
export interface DimensionCoordinate {
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int8?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint8?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int16?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint16?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int64?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint64?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    float32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    float64?: number;
}
/**
 * Extent of tile
 * @export
 * @interface DimensionTileExtent
 */
export interface DimensionTileExtent {
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int8?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint8?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int16?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint16?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int64?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint64?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    float32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    float64?: number;
}
/**
 * Domain of array
 * @export
 * @interface Domain
 */
export interface Domain {
    /**
     *
     * @type {Datatype}
     * @memberof Domain
     */
    type: Datatype;
    /**
     *
     * @type {Layout}
     * @memberof Domain
     */
    tileOrder: Layout;
    /**
     *
     * @type {Layout}
     * @memberof Domain
     */
    cellOrder: Layout;
    /**
     * Array of dimensions
     * @type {Array<Dimension>}
     * @memberof Domain
     */
    dimensions: Array<Dimension>;
}
/**
 * Domain object for an array of each type
 * @export
 * @interface DomainArray
 */
export interface DomainArray {
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int8?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint8?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int16?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint16?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int32?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint32?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int64?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint64?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float32?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float64?: Array<number>;
}
/**
 * Filter
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     *
     * @type {FilterType}
     * @memberof Filter
     */
    type: FilterType;
    /**
     *
     * @type {FilterData}
     * @memberof Filter
     */
    data?: FilterData;
}
/**
 * Filter data
 * @export
 * @interface FilterData
 */
export interface FilterData {
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    int8?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    uint8?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    int16?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    uint16?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    int32?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    uint32?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    int64?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    uint64?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    float32?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    float64?: number;
}
/**
 * TileDB filter option
 * @export
 * @enum {string}
 */
export declare enum FilterOption {
    COMPRESSIONLEVEL = "COMPRESSION_LEVEL",
    BITWIDTHMAXWINDOW = "BIT_WIDTH_MAX_WINDOW",
    POSITIVEDELTAMAXWINDOW = "POSITIVE_DELTA_MAX_WINDOW"
}
/**
 * One or more filters to apply
 * @export
 * @interface FilterPipeline
 */
export interface FilterPipeline {
    /**
     *
     * @type {Array<Filter>}
     * @memberof FilterPipeline
     */
    filters?: Array<Filter>;
}
/**
 * TileDB filter types
 * @export
 * @enum {string}
 */
export declare enum FilterType {
    NONE = "FILTER_NONE",
    GZIP = "FILTER_GZIP",
    ZSTD = "FILTER_ZSTD",
    LZ4 = "FILTER_LZ4",
    RLE = "FILTER_RLE",
    BZIP2 = "FILTER_BZIP2",
    DOUBLEDELTA = "FILTER_DOUBLE_DELTA",
    BITWIDTHREDUCTION = "FILTER_BIT_WIDTH_REDUCTION",
    BITSHUFFLE = "FILTER_BITSHUFFLE",
    BYTESHUFFLE = "FILTER_BYTESHUFFLE",
    POSITIVEDELTA = "FILTER_POSITIVE_DELTA"
}
/**
 * User-defined function
 * @export
 * @interface GenericUDF
 */
export interface GenericUDF {
    /**
     * name of registered udf to run, format is {namespace}/{udf_name}. Can not be used with exec
     * @type {string}
     * @memberof GenericUDF
     */
    registeredUdf?: string;
    /**
     *
     * @type {UDFLanguage}
     * @memberof GenericUDF
     */
    language?: UDFLanguage;
    /**
     * Type-specific version
     * @type {string}
     * @memberof GenericUDF
     */
    version?: string;
    /**
     * Docker image name to use for udf
     * @type {string}
     * @memberof GenericUDF
     */
    imageName?: string;
    /**
     * Type-specific executable text
     * @type {string}
     * @memberof GenericUDF
     */
    exec?: string;
    /**
     * optional raw text to store of serialized function, used for showing in UI
     * @type {string}
     * @memberof GenericUDF
     */
    execRaw?: string;
    /**
     * Argument to pass to udf function
     * @type {string}
     * @memberof GenericUDF
     */
    argument?: string;
    /**
     *
     * @type {UDFResultType}
     * @memberof GenericUDF
     */
    resultFormat?: UDFResultType;
}
/**
 * Password to update
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * password
     * @type {string}
     * @memberof InlineObject
     */
    password?: string;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * string of stats from tiledb
     * @type {string}
     * @memberof InlineResponse200
     */
    stats?: string;
}
/**
 * Information related to last access of an array
 * @export
 * @interface LastAccessedArray
 */
export interface LastAccessedArray {
    /**
     * unique id of array
     * @type {string}
     * @memberof LastAccessedArray
     */
    arrayId?: string;
    /**
     * name of the array
     * @type {string}
     * @memberof LastAccessedArray
     */
    arrayName?: string;
    /**
     * namespace of a user or organization
     * @type {string}
     * @memberof LastAccessedArray
     */
    namespace?: string;
    /**
     * timestamp (epoch milliseconds) array is last accessed
     * @type {number}
     * @memberof LastAccessedArray
     */
    accessedTime?: number;
    /**
     *
     * @type {ActivityEventType}
     * @memberof LastAccessedArray
     */
    accessType?: ActivityEventType;
}
/**
 * Layout of array
 * @export
 * @enum {string}
 */
export declare enum Layout {
    RowMajor = "row-major",
    ColMajor = "col-major",
    GlobalOrder = "global-order",
    Unordered = "unordered"
}
/**
 * a list of max buffer sizes, one per attribute
 * @export
 * @interface MaxBufferSizes
 */
export interface MaxBufferSizes {
    /**
     *
     * @type {Array<AttributeBufferSize>}
     * @memberof MaxBufferSizes
     */
    maxBufferSizes?: Array<AttributeBufferSize>;
}
/**
 * Represents an open array
 * @export
 * @interface ModelArray
 */
export interface ModelArray {
    /**
     * timestamp (epoch milliseconds) array is opened at
     * @type {number}
     * @memberof ModelArray
     */
    timestamp: number;
    /**
     *
     * @type {Querytype}
     * @memberof ModelArray
     */
    queryType: Querytype;
    /**
     * Array uri
     * @type {string}
     * @memberof ModelArray
     */
    uri: string;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     *
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
}
/**
 * actions a user can take on an organization
 * @export
 * @enum {string}
 */
export declare enum NamespaceActions {
    Read = "read",
    Write = "write",
    Create = "create",
    Delete = "delete",
    Edit = "edit",
    ReadArrayLogs = "read_array_logs",
    ReadJobLogs = "read_job_logs",
    ReadObjectLogs = "read_object_logs",
    RunJob = "run_job",
    DeleteOrganization = "delete_organization",
    EditOrganization = "edit_organization",
    EditBilling = "edit_billing"
}
/**
 * object representing a non-empty domain
 * @export
 * @interface NonEmptyDomain
 */
export interface NonEmptyDomain {
    /**
     *
     * @type {DomainArray}
     * @memberof NonEmptyDomain
     */
    nonEmptyDomain: DomainArray;
    /**
     * Is non-empty domain really empty?
     * @type {boolean}
     * @memberof NonEmptyDomain
     */
    isEmpty: boolean;
}
/**
 * Organization
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * unique id of organization
     * @type {string}
     * @memberof Organization
     */
    id?: string;
    /**
     *
     * @type {OrganizationRoles}
     * @memberof Organization
     */
    role?: OrganizationRoles;
    /**
     * organization name must be unique
     * @type {string}
     * @memberof Organization
     */
    name: string;
    /**
     * Datetime organization was created in UTC
     * @type {Date}
     * @memberof Organization
     */
    createdAt?: Date;
    /**
     * Datetime organization was updated in UTC
     * @type {Date}
     * @memberof Organization
     */
    updatedAt?: Date;
    /**
     * Organization logo
     * @type {string}
     * @memberof Organization
     */
    logo?: string;
    /**
     * Organization description
     * @type {string}
     * @memberof Organization
     */
    description?: string;
    /**
     *
     * @type {Array<OrganizationUser>}
     * @memberof Organization
     */
    users?: Array<OrganizationUser>;
    /**
     * list of actions user is allowed to do on this organization
     * @type {Array<NamespaceActions>}
     * @memberof Organization
     */
    allowedActions?: Array<NamespaceActions>;
    /**
     * number of registered arrays for this organization
     * @type {number}
     * @memberof Organization
     */
    numOfArrays?: number;
    /**
     * List of extra/optional/beta features to enable for namespace
     * @type {Array<string>}
     * @memberof Organization
     */
    enabledFeatures?: Array<string>;
}
/**
 * role user has in organization
 * @export
 * @enum {string}
 */
export declare enum OrganizationRoles {
    Owner = "owner",
    Admin = "admin",
    User = "user",
    ReadOnly = "read_only"
}
/**
 * user in an organization
 * @export
 * @interface OrganizationUser
 */
export interface OrganizationUser {
    /**
     * unique id of user
     * @type {string}
     * @memberof OrganizationUser
     */
    userId?: string;
    /**
     * unique id of organization
     * @type {string}
     * @memberof OrganizationUser
     */
    organizationId?: string;
    /**
     * username for user
     * @type {string}
     * @memberof OrganizationUser
     */
    username?: string;
    /**
     * name of organization
     * @type {string}
     * @memberof OrganizationUser
     */
    organizationName?: string;
    /**
     *
     * @type {OrganizationRoles}
     * @memberof OrganizationUser
     */
    role?: OrganizationRoles;
    /**
     * list of actions user is allowed to do on this organization
     * @type {Array<NamespaceActions>}
     * @memberof OrganizationUser
     */
    allowedActions?: Array<NamespaceActions>;
}
/**
 *
 * @export
 * @interface PaginationMetadata
 */
export interface PaginationMetadata {
    /**
     * pagination offset
     * @type {number}
     * @memberof PaginationMetadata
     */
    page?: number;
    /**
     * pagination limit
     * @type {number}
     * @memberof PaginationMetadata
     */
    perPage?: number;
    /**
     * number of total pages with current limit
     * @type {number}
     * @memberof PaginationMetadata
     */
    totalPages?: number;
    /**
     * number of total available items
     * @type {number}
     * @memberof PaginationMetadata
     */
    totalItems?: number;
}
/**
 * Query parameter to get array metadatas
 * @export
 * @enum {string}
 */
export declare enum PublicShareFilter {
    Exclude = "exclude",
    Only = "only"
}
/**
 *
 * @export
 * @interface Query
 */
export interface Query {
    /**
     *
     * @type {Querytype}
     * @memberof Query
     */
    type: Querytype;
    /**
     *
     * @type {Layout}
     * @memberof Query
     */
    layout: Layout;
    /**
     *
     * @type {Querystatus}
     * @memberof Query
     */
    status: Querystatus;
    /**
     * List of attribute buffer headers
     * @type {Array<AttributeBufferHeader>}
     * @memberof Query
     */
    attributeBufferHeaders: Array<AttributeBufferHeader>;
    /**
     *
     * @type {Writer}
     * @memberof Query
     */
    writer?: Writer;
    /**
     *
     * @type {QueryReader}
     * @memberof Query
     */
    reader?: QueryReader;
    /**
     *
     * @type {any}
     * @memberof Query
     */
    array: any;
    /**
     * Total number of bytes in fixed size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalFixedLengthBufferBytes: number;
    /**
     * Total number of bytes in variable size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalVarLenBufferBytes: number;
}
/**
 * Read struct (can\'t be called reader due to class name conflict)
 * @export
 * @interface QueryReader
 */
export interface QueryReader {
    /**
     *
     * @type {Layout}
     * @memberof QueryReader
     */
    layout?: Layout;
    /**
     *
     * @type {Subarray}
     * @memberof QueryReader
     */
    subarray?: Subarray;
    /**
     *
     * @type {ReadState}
     * @memberof QueryReader
     */
    readState?: ReadState;
}
/**
 * Status of query
 * @export
 * @enum {string}
 */
export declare enum Querystatus {
    FAILED = "FAILED",
    COMPLETED = "COMPLETED",
    INPROGRESS = "INPROGRESS",
    INCOMPLETE = "INCOMPLETE",
    UNINITIALIZED = "UNINITIALIZED"
}
/**
 * Type of query
 * @export
 * @enum {string}
 */
export declare enum Querytype {
    READ = "READ",
    WRITE = "WRITE"
}
/**
 * state for reads
 * @export
 * @interface ReadState
 */
export interface ReadState {
    /**
     * True if the reader has been initialized.
     * @type {boolean}
     * @memberof ReadState
     */
    initialized?: boolean;
    /**
     * True if the query produced results that could not fit in some buffer.
     * @type {boolean}
     * @memberof ReadState
     */
    overflowed?: boolean;
    /**
     * True if the current subarray partition is unsplittable.
     * @type {boolean}
     * @memberof ReadState
     */
    unsplittable?: boolean;
    /**
     *
     * @type {SubarrayPartitioner}
     * @memberof ReadState
     */
    subarrayPartitioner?: SubarrayPartitioner;
}
/**
 * Parameters for running sql query
 * @export
 * @interface SQLParameters
 */
export interface SQLParameters {
    /**
     * name of task, optional
     * @type {string}
     * @memberof SQLParameters
     */
    name?: string;
    /**
     * query to run
     * @type {string}
     * @memberof SQLParameters
     */
    query?: string;
    /**
     * Output array uri
     * @type {string}
     * @memberof SQLParameters
     */
    outputUri?: string;
}
/**
 * Single sign on provider
 * @export
 * @enum {string}
 */
export declare enum SSOProvider {
    Github = "github",
    Google = "google"
}
/**
 * A Subarray
 * @export
 * @interface Subarray
 */
export interface Subarray {
    /**
     *
     * @type {Layout}
     * @memberof Subarray
     */
    layout?: Layout;
    /**
     * List of 1D ranges, one per dimension
     * @type {Array<SubarrayRanges>}
     * @memberof Subarray
     */
    ranges?: Array<SubarrayRanges>;
}
/**
 * The subarray partitioner
 * @export
 * @interface SubarrayPartitioner
 */
export interface SubarrayPartitioner {
    /**
     *
     * @type {Subarray}
     * @memberof SubarrayPartitioner
     */
    subarray?: Subarray;
    /**
     * Result size budget (in bytes) for all attributes.
     * @type {Array<AttributeBufferSize>}
     * @memberof SubarrayPartitioner
     */
    budget?: Array<AttributeBufferSize>;
    /**
     *
     * @type {SubarrayPartitionerCurrent}
     * @memberof SubarrayPartitioner
     */
    current?: SubarrayPartitionerCurrent;
    /**
     *
     * @type {SubarrayPartitionerState}
     * @memberof SubarrayPartitioner
     */
    state?: SubarrayPartitionerState;
    /**
     * The memory budget for the fixed-sized attributes and the offsets of the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudget?: number;
    /**
     * The memory budget for the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudgetVar?: number;
}
/**
 * The current partition info
 * @export
 * @interface SubarrayPartitionerCurrent
 */
export interface SubarrayPartitionerCurrent {
    /**
     *
     * @type {Subarray}
     * @memberof SubarrayPartitionerCurrent
     */
    subarray?: Subarray;
    /**
     * PartitionInfo start
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    start?: number;
    /**
     * PartitionInfo end
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    end?: number;
    /**
     * PartitionInfo splitMultiRange
     * @type {boolean}
     * @memberof SubarrayPartitionerCurrent
     */
    splitMultiRange?: boolean;
}
/**
 * The state information for the remaining partitions to be produced
 * @export
 * @interface SubarrayPartitionerState
 */
export interface SubarrayPartitionerState {
    /**
     * State start
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    start?: number;
    /**
     * State end
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    end?: number;
    /**
     * State singleRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    singleRange?: Array<Subarray>;
    /**
     * State multiRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    multiRange?: Array<Subarray>;
}
/**
 * A set of 1D ranges for a subarray
 * @export
 * @interface SubarrayRanges
 */
export interface SubarrayRanges {
    /**
     *
     * @type {Datatype}
     * @memberof SubarrayRanges
     */
    type?: Datatype;
    /**
     * True if the range is the default range
     * @type {boolean}
     * @memberof SubarrayRanges
     */
    hasDefaultRange?: boolean;
    /**
     * The bytes of the ranges
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    buffer?: Array<number>;
}
/**
 * A api token and its metadata
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * A api token
     * @type {string}
     * @memberof Token
     */
    token?: string;
    /**
     * Name of token to revoke
     * @type {string}
     * @memberof Token
     */
    name?: string;
    /**
     * datetime the token was created at
     * @type {Date}
     * @memberof Token
     */
    issuedAt?: Date;
    /**
     * datetime the token when token will expire
     * @type {Date}
     * @memberof Token
     */
    expiresAt?: Date;
    /**
     * Optional scope to limit token, defaults to all permissions, current supported values are password_reset or *
     * @type {string}
     * @memberof Token
     */
    scope?: string;
}
/**
 * A request from a user for an api token
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
    /**
     * Expiration date for token, if empty token defaults to 30 minutes
     * @type {Date}
     * @memberof TokenRequest
     */
    expires?: Date;
    /**
     * Optional name for token, if the name already exists for the user it will be auto incremented (i.e. myToken-1)
     * @type {string}
     * @memberof TokenRequest
     */
    name?: string;
    /**
     * Optional scope to limit token, defaults to all permissions, current supported values are password_reset or *
     * @type {string}
     * @memberof TokenRequest
     */
    scope?: string;
}
/**
 * User-defined function
 * @export
 * @interface UDF
 */
export interface UDF {
    /**
     * name of registered udf to run, format is {namespace}/{udf_name}. Can not be used with exec
     * @type {string}
     * @memberof UDF
     */
    registeredUdf?: string;
    /**
     *
     * @type {UDFLanguage}
     * @memberof UDF
     */
    language?: UDFLanguage;
    /**
     * Type-specific version
     * @type {string}
     * @memberof UDF
     */
    version?: string;
    /**
     * Docker image name to use for udf
     * @type {string}
     * @memberof UDF
     */
    imageName?: string;
    /**
     *
     * @type {UDFRanges}
     * @memberof UDF
     */
    ranges?: UDFRanges;
    /**
     *
     * @type {UDFSubarray}
     * @memberof UDF
     */
    subarray?: UDFSubarray;
    /**
     * Type-specific executable text
     * @type {string}
     * @memberof UDF
     */
    exec?: string;
    /**
     * optional raw text to store of serialized function, used for showing in UI
     * @type {string}
     * @memberof UDF
     */
    execRaw?: string;
    /**
     * List of buffers to fetch (attributes + coordinates)
     * @type {Array<string>}
     * @memberof UDF
     */
    buffers?: Array<string>;
    /**
     *
     * @type {UDFResultType}
     * @memberof UDF
     */
    resultFormat?: UDFResultType;
}
/**
 * actions a user can take on an udf
 * @export
 * @enum {string}
 */
export declare enum UDFActions {
    FetchUdf = "fetch_udf",
    ShareUdf = "share_udf"
}
/**
 * UDF Type
 * @export
 * @enum {string}
 */
export declare enum UDFLanguage {
    Python = "python"
}
/**
 * Object including udfs and metadata
 * @export
 * @interface UDFListingData
 */
export interface UDFListingData {
    /**
     * Registered UDFs
     * @type {Array<UDFRegistration>}
     * @memberof UDFListingData
     */
    udfs?: Array<UDFRegistration>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof UDFListingData
     */
    paginationMetadata?: PaginationMetadata;
}
/**
 * Subarray bounds to query for a UDF to operate on
 * @export
 * @interface UDFRanges
 */
export interface UDFRanges {
    /**
     *
     * @type {Layout}
     * @memberof UDFRanges
     */
    layout?: Layout;
    /**
     * List of ranges,
     * @type {Array<Array<number>>}
     * @memberof UDFRanges
     */
    ranges?: Array<Array<number>>;
}
/**
 * User-defined function
 * @export
 * @interface UDFRegistration
 */
export interface UDFRegistration {
    /**
     * name of udf
     * @type {string}
     * @memberof UDFRegistration
     */
    name?: string;
    /**
     *
     * @type {UDFLanguage}
     * @memberof UDFRegistration
     */
    language?: UDFLanguage;
    /**
     * Type-specific version
     * @type {string}
     * @memberof UDFRegistration
     */
    version?: string;
    /**
     * Docker image name to use for udf
     * @type {string}
     * @memberof UDFRegistration
     */
    imageName?: string;
    /**
     *
     * @type {UDFType}
     * @memberof UDFRegistration
     */
    type?: UDFType;
    /**
     * Type-specific executable text
     * @type {string}
     * @memberof UDFRegistration
     */
    exec?: string;
    /**
     * optional raw text to store of serialized function, used for showing in UI
     * @type {string}
     * @memberof UDFRegistration
     */
    execRaw?: string;
    /**
     * Markdown readme of udfs
     * @type {string}
     * @memberof UDFRegistration
     */
    readme?: string;
}
/**
 * Results type
 * @export
 * @enum {string}
 */
export declare enum UDFResultType {
    Native = "native",
    Json = "json"
}
/**
 * details for sharing a given udf
 * @export
 * @interface UDFSharing
 */
export interface UDFSharing {
    /**
     * List of permitted actions
     * @type {Array<UDFActions>}
     * @memberof UDFSharing
     */
    actions?: Array<UDFActions>;
    /**
     * namespace being granted array access can be a user or organization
     * @type {string}
     * @memberof UDFSharing
     */
    namespace?: string;
    /**
     * details on if the namespace is a organization or user
     * @type {string}
     * @memberof UDFSharing
     */
    namespaceType?: string;
}
/**
 * Subarray bounds to query for a UDF to operate on
 * @export
 * @interface UDFSubarray
 */
export interface UDFSubarray {
    /**
     *
     * @type {Layout}
     * @memberof UDFSubarray
     */
    layout?: Layout;
    /**
     * List of ranges,
     * @type {Array<UDFSubarrayRange>}
     * @memberof UDFSubarray
     */
    ranges?: Array<UDFSubarrayRange>;
}
/**
 * A dimension range to query
 * @export
 * @interface UDFSubarrayRange
 */
export interface UDFSubarrayRange {
    /**
     * The dimension index
     * @type {number}
     * @memberof UDFSubarrayRange
     */
    dimensionId?: number;
    /**
     *
     * @type {DimensionCoordinate}
     * @memberof UDFSubarrayRange
     */
    rangeStart?: DimensionCoordinate;
    /**
     *
     * @type {DimensionCoordinate}
     * @memberof UDFSubarrayRange
     */
    rangeEnd?: DimensionCoordinate;
}
/**
 * UDF Type
 * @export
 * @enum {string}
 */
export declare enum UDFType {
    SingleArray = "single_array",
    Generic = "generic"
}
/**
 * User
 * @export
 * @interface User
 */
export interface User {
    /**
     * unique id of user
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * username must be unique
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * password
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * the user\'s full, real name
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * the user\'s email
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * user\'s email is validated to be correct
     * @type {boolean}
     * @memberof User
     */
    isValidEmail?: boolean;
    /**
     * the user\'s logo
     * @type {string}
     * @memberof User
     */
    logo?: string;
    /**
     * when the user last logged in (set by the server)
     * @type {Date}
     * @memberof User
     */
    lastActivityDate?: Date;
    /**
     *
     * @type {string}
     * @memberof User
     */
    timezone?: string;
    /**
     * Array of organizations a user is part of and their roles
     * @type {Array<OrganizationUser>}
     * @memberof User
     */
    organizations?: Array<OrganizationUser>;
    /**
     * list of actions user is allowed to do on this organization
     * @type {Array<NamespaceActions>}
     * @memberof User
     */
    allowedActions?: Array<NamespaceActions>;
    /**
     * List of extra/optional/beta features to enable for namespace
     * @type {Array<string>}
     * @memberof User
     */
    enabledFeatures?: Array<string>;
}
/**
 *
 * @export
 * @interface Writer
 */
export interface Writer {
    /**
     *
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordDups?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordOOB?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Writer
     */
    dedupCoords?: boolean;
    /**
     *
     * @type {DomainArray}
     * @memberof Writer
     */
    subarray?: DomainArray;
}
/**
 * ArrayApi - axios parameter creator
 * @export
 */
export declare const ArrayApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, options?: any): RequestArgs;
    /**
     * create a array schema at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArraySchema} arraySchema ArraySchema being created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArray(namespace: string, array: string, contentType: string, arraySchema: ArraySchema, options?: any): RequestArgs;
    /**
     * delete a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArray(namespace: string, array: string, contentType: string, options?: any): RequestArgs;
    /**
     * deregister a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterArray(namespace: string, array: string, options?: any): RequestArgs;
    /**
     * get all array metadata user has access to
     * @param {string} [publicShare] Public share values can be one of exclude, only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllArrayMetadata(publicShare?: string, options?: any): RequestArgs;
    /**
     * get an ArraySchema using a url encoded uri
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArray(namespace: string, array: string, contentType: string, options?: any): RequestArgs;
    /**
     * get the max buffer sizes of an array for a subarray
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} subarray CSV string of subarray to get max buffer sizes for
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMaxBufferSizes(namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options?: any): RequestArgs;
    /**
     * get metadata from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetaDataJson(namespace: string, array: string, options?: any): RequestArgs;
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetadata(namespace: string, array: string, options?: any): RequestArgs;
    /**
     * get the non empty domain of an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayNonEmptyDomain(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): RequestArgs;
    /**
     * get an sample set of data from the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [samples] Number of sample results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraySampleData(namespace: string, array: string, samples?: number, options?: any): RequestArgs;
    /**
     * Get all sharing details of the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraySharingPolicies(namespace: string, array: string, options?: any): RequestArgs;
    /**
     * get metadata on all arrays in a namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraysInNamespace(namespace: string, options?: any): RequestArgs;
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastAccessedArrays(options?: any): RequestArgs;
    /**
     * register an array at a specified URI registered to the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): RequestArgs;
    /**
     * Share an array with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareArray(namespace: string, array: string, arraySharing: ArraySharing, options?: any): RequestArgs;
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArrayMetadata(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): RequestArgs;
};
/**
 * ArrayApi - functional programming interface
 * @export
 */
export declare const ArrayApiFp: (configuration?: Configuration) => {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayActivityLog[]>;
    /**
     * create a array schema at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArraySchema} arraySchema ArraySchema being created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArray(namespace: string, array: string, contentType: string, arraySchema: ArraySchema, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * delete a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArray(namespace: string, array: string, contentType: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * deregister a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterArray(namespace: string, array: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * get all array metadata user has access to
     * @param {string} [publicShare] Public share values can be one of exclude, only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllArrayMetadata(publicShare?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayInfo[]>;
    /**
     * get an ArraySchema using a url encoded uri
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArray(namespace: string, array: string, contentType: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArraySchema>;
    /**
     * get the max buffer sizes of an array for a subarray
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} subarray CSV string of subarray to get max buffer sizes for
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMaxBufferSizes(namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaxBufferSizes>;
    /**
     * get metadata from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetaDataJson(namespace: string, array: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>;
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetadata(namespace: string, array: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayInfo>;
    /**
     * get the non empty domain of an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayNonEmptyDomain(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmptyDomain>;
    /**
     * get an sample set of data from the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [samples] Number of sample results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraySampleData(namespace: string, array: string, samples?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArraySample>;
    /**
     * Get all sharing details of the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraySharingPolicies(namespace: string, array: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArraySharing[]>;
    /**
     * get metadata on all arrays in a namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraysInNamespace(namespace: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayInfo[]>;
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastAccessedArrays(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastAccessedArray[]>;
    /**
     * register an array at a specified URI registered to the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * Share an array with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareArray(namespace: string, array: string, arraySharing: ArraySharing, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArrayMetadata(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
};
/**
 * ArrayApi - factory interface
 * @export
 */
export declare const ArrayApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, options?: any): AxiosPromise<ArrayActivityLog[]>;
    /**
     * create a array schema at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArraySchema} arraySchema ArraySchema being created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArray(namespace: string, array: string, contentType: string, arraySchema: ArraySchema, options?: any): AxiosPromise<void>;
    /**
     * delete a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArray(namespace: string, array: string, contentType: string, options?: any): AxiosPromise<void>;
    /**
     * deregister a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterArray(namespace: string, array: string, options?: any): AxiosPromise<void>;
    /**
     * get all array metadata user has access to
     * @param {string} [publicShare] Public share values can be one of exclude, only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllArrayMetadata(publicShare?: string, options?: any): AxiosPromise<ArrayInfo[]>;
    /**
     * get an ArraySchema using a url encoded uri
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArray(namespace: string, array: string, contentType: string, options?: any): AxiosPromise<ArraySchema>;
    /**
     * get the max buffer sizes of an array for a subarray
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} subarray CSV string of subarray to get max buffer sizes for
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMaxBufferSizes(namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options?: any): AxiosPromise<MaxBufferSizes>;
    /**
     * get metadata from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetaDataJson(namespace: string, array: string, options?: any): AxiosPromise<object>;
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetadata(namespace: string, array: string, options?: any): AxiosPromise<ArrayInfo>;
    /**
     * get the non empty domain of an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayNonEmptyDomain(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): AxiosPromise<NonEmptyDomain>;
    /**
     * get an sample set of data from the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [samples] Number of sample results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraySampleData(namespace: string, array: string, samples?: number, options?: any): AxiosPromise<ArraySample>;
    /**
     * Get all sharing details of the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraySharingPolicies(namespace: string, array: string, options?: any): AxiosPromise<ArraySharing[]>;
    /**
     * get metadata on all arrays in a namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraysInNamespace(namespace: string, options?: any): AxiosPromise<ArrayInfo[]>;
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastAccessedArrays(options?: any): AxiosPromise<LastAccessedArray[]>;
    /**
     * register an array at a specified URI registered to the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): AxiosPromise<void>;
    /**
     * Share an array with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareArray(namespace: string, array: string, arraySharing: ArraySharing, options?: any): AxiosPromise<void>;
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArrayMetadata(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): AxiosPromise<void>;
};
/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
export declare class ArrayApi extends BaseAPI {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, options?: any): AxiosPromise<ArrayActivityLog[]>;
    /**
     * create a array schema at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArraySchema} arraySchema ArraySchema being created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    createArray(namespace: string, array: string, contentType: string, arraySchema: ArraySchema, options?: any): AxiosPromise<void>;
    /**
     * delete a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    deleteArray(namespace: string, array: string, contentType: string, options?: any): AxiosPromise<void>;
    /**
     * deregister a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    deregisterArray(namespace: string, array: string, options?: any): AxiosPromise<void>;
    /**
     * get all array metadata user has access to
     * @param {string} [publicShare] Public share values can be one of exclude, only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getAllArrayMetadata(publicShare?: string, options?: any): AxiosPromise<ArrayInfo[]>;
    /**
     * get an ArraySchema using a url encoded uri
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArray(namespace: string, array: string, contentType: string, options?: any): AxiosPromise<ArraySchema>;
    /**
     * get the max buffer sizes of an array for a subarray
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} subarray CSV string of subarray to get max buffer sizes for
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMaxBufferSizes(namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options?: any): AxiosPromise<MaxBufferSizes>;
    /**
     * get metadata from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetaDataJson(namespace: string, array: string, options?: any): AxiosPromise<object>;
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetadata(namespace: string, array: string, options?: any): AxiosPromise<ArrayInfo>;
    /**
     * get the non empty domain of an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayNonEmptyDomain(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): AxiosPromise<NonEmptyDomain>;
    /**
     * get an sample set of data from the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [samples] Number of sample results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraySampleData(namespace: string, array: string, samples?: number, options?: any): AxiosPromise<ArraySample>;
    /**
     * Get all sharing details of the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraySharingPolicies(namespace: string, array: string, options?: any): AxiosPromise<ArraySharing[]>;
    /**
     * get metadata on all arrays in a namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraysInNamespace(namespace: string, options?: any): AxiosPromise<ArrayInfo[]>;
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getLastAccessedArrays(options?: any): AxiosPromise<LastAccessedArray[]>;
    /**
     * register an array at a specified URI registered to the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): AxiosPromise<void>;
    /**
     * Share an array with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    shareArray(namespace: string, array: string, arraySharing: ArraySharing, options?: any): AxiosPromise<void>;
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    updateArrayMetadata(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): AxiosPromise<void>;
}
/**
 * ArrayTasksApi - axios parameter creator
 * @export
 */
export declare const ArrayTasksApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayTasksSidebar(start?: number, end?: number, options?: any): RequestArgs;
};
/**
 * ArrayTasksApi - functional programming interface
 * @export
 */
export declare const ArrayTasksApiFp: (configuration?: Configuration) => {
    /**
     *
     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayTasksSidebar(start?: number, end?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayTaskBrowserSidebar>;
};
/**
 * ArrayTasksApi - factory interface
 * @export
 */
export declare const ArrayTasksApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayTasksSidebar(start?: number, end?: number, options?: any): AxiosPromise<ArrayTaskBrowserSidebar>;
};
/**
 * ArrayTasksApi - object-oriented interface
 * @export
 * @class ArrayTasksApi
 * @extends {BaseAPI}
 */
export declare class ArrayTasksApi extends BaseAPI {
    /**
     *
     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayTasksApi
     */
    getArrayTasksSidebar(start?: number, end?: number, options?: any): AxiosPromise<ArrayTaskBrowserSidebar>;
}
/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export declare const OrganizationApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): RequestArgs;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToOrganization(organization: string, user: OrganizationUser, options?: any): RequestArgs;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentials(namespace: string, options?: any): RequestArgs;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): RequestArgs;
    /**
     * create a organization, the user creating will be listed as owner
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganization(organization: Organization, options?: any): RequestArgs;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAWSAccessCredentials(namespace: string, name: string, options?: any): RequestArgs;
    /**
     * delete a organization
     * @param {string} organization organization name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrganization(organization: string, options?: any): RequestArgs;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserFromOrganization(organization: string, username: string, options?: any): RequestArgs;
    /**
     * get all organizations that the user is member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOrganizations(options?: any): RequestArgs;
    /**
     * get a organization
     * @param {string} organization organization name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization(organization: string, options?: any): RequestArgs;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUser(organization: string, username: string, options?: any): RequestArgs;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): RequestArgs;
    /**
     * update a organization
     * @param {string} organization organization name or id
     * @param {Organization} organizationDetails organization details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOrganization(organization: string, organizationDetails: Organization, options?: any): RequestArgs;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): RequestArgs;
};
/**
 * OrganizationApi - functional programming interface
 * @export
 */
export declare const OrganizationApiFp: (configuration?: Configuration) => {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToOrganization(organization: string, user: OrganizationUser, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentials(namespace: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSAccessCredentials[]>;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSAccessCredentials>;
    /**
     * create a organization, the user creating will be listed as owner
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganization(organization: Organization, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAWSAccessCredentials(namespace: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * delete a organization
     * @param {string} organization organization name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrganization(organization: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserFromOrganization(organization: string, username: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * get all organizations that the user is member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOrganizations(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization[]>;
    /**
     * get a organization
     * @param {string} organization organization name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization(organization: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUser(organization: string, username: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationUser>;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * update a organization
     * @param {string} organization organization name or id
     * @param {Organization} organizationDetails organization details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOrganization(organization: string, organizationDetails: Organization, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
};
/**
 * OrganizationApi - factory interface
 * @export
 */
export declare const OrganizationApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void>;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToOrganization(organization: string, user: OrganizationUser, options?: any): AxiosPromise<void>;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentials(namespace: string, options?: any): AxiosPromise<AWSAccessCredentials[]>;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): AxiosPromise<AWSAccessCredentials>;
    /**
     * create a organization, the user creating will be listed as owner
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganization(organization: Organization, options?: any): AxiosPromise<void>;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAWSAccessCredentials(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * delete a organization
     * @param {string} organization organization name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrganization(organization: string, options?: any): AxiosPromise<void>;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserFromOrganization(organization: string, username: string, options?: any): AxiosPromise<void>;
    /**
     * get all organizations that the user is member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOrganizations(options?: any): AxiosPromise<Organization[]>;
    /**
     * get a organization
     * @param {string} organization organization name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization(organization: string, options?: any): AxiosPromise<Organization>;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUser(organization: string, username: string, options?: any): AxiosPromise<OrganizationUser>;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void>;
    /**
     * update a organization
     * @param {string} organization organization name or id
     * @param {Organization} organizationDetails organization details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOrganization(organization: string, organizationDetails: Organization, options?: any): AxiosPromise<void>;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): AxiosPromise<void>;
};
/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export declare class OrganizationApi extends BaseAPI {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void>;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addUserToOrganization(organization: string, user: OrganizationUser, options?: any): AxiosPromise<void>;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    checkAWSAccessCredentials(namespace: string, options?: any): AxiosPromise<AWSAccessCredentials[]>;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): AxiosPromise<AWSAccessCredentials>;
    /**
     * create a organization, the user creating will be listed as owner
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    createOrganization(organization: Organization, options?: any): AxiosPromise<void>;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteAWSAccessCredentials(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * delete a organization
     * @param {string} organization organization name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteOrganization(organization: string, options?: any): AxiosPromise<void>;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteUserFromOrganization(organization: string, username: string, options?: any): AxiosPromise<void>;
    /**
     * get all organizations that the user is member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getAllOrganizations(options?: any): AxiosPromise<Organization[]>;
    /**
     * get a organization
     * @param {string} organization organization name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getOrganization(organization: string, options?: any): AxiosPromise<Organization>;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getOrganizationUser(organization: string, username: string, options?: any): AxiosPromise<OrganizationUser>;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void>;
    /**
     * update a organization
     * @param {string} organization organization name or id
     * @param {Organization} organizationDetails organization details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateOrganization(organization: string, organizationDetails: Organization, options?: any): AxiosPromise<void>;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): AxiosPromise<void>;
}
/**
 * QueryApi - axios parameter creator
 * @export
 */
export declare const QueryApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    finalizeQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): RequestArgs;
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): RequestArgs;
};
/**
 * QueryApi - functional programming interface
 * @export
 */
export declare const QueryApiFp: (configuration?: Configuration) => {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    finalizeQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Query>;
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Query>;
};
/**
 * QueryApi - factory interface
 * @export
 */
export declare const QueryApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    finalizeQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): AxiosPromise<Query>;
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): AxiosPromise<Query>;
};
/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export declare class QueryApi extends BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    finalizeQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): AxiosPromise<Query>;
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): AxiosPromise<Query>;
}
/**
 * SqlApi - axios parameter creator
 * @export
 */
export declare const SqlApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): RequestArgs;
};
/**
 * SqlApi - functional programming interface
 * @export
 */
export declare const SqlApiFp: (configuration?: Configuration) => {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object[]>;
};
/**
 * SqlApi - factory interface
 * @export
 */
export declare const SqlApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): AxiosPromise<object[]>;
};
/**
 * SqlApi - object-oriented interface
 * @export
 * @class SqlApi
 * @extends {BaseAPI}
 */
export declare class SqlApi extends BaseAPI {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SqlApi
     */
    runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): AxiosPromise<object[]>;
}
/**
 * StatsApi - axios parameter creator
 * @export
 */
export declare const StatsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Fetch libtiledb stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTiledbStats(options?: any): RequestArgs;
};
/**
 * StatsApi - functional programming interface
 * @export
 */
export declare const StatsApiFp: (configuration?: Configuration) => {
    /**
     * Fetch libtiledb stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTiledbStats(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>;
};
/**
 * StatsApi - factory interface
 * @export
 */
export declare const StatsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Fetch libtiledb stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTiledbStats(options?: any): AxiosPromise<InlineResponse200>;
};
/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export declare class StatsApi extends BaseAPI {
    /**
     * Fetch libtiledb stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    getTiledbStats(options?: any): AxiosPromise<InlineResponse200>;
}
/**
 * TasksApi - axios parameter creator
 * @export
 */
export declare const TasksApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): RequestArgs;
    /**
     * Fetch an array task
     * @param {string} id task id to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskIdGet(id: string, options?: any): RequestArgs;
    /**
     * Fetch a list of all array tasks a user has access to
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;
     * @param {string} [status] Filter to only return these statuses
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include start_time, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksGet(namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, search?: string, orderby?: string, options?: any): RequestArgs;
};
/**
 * TasksApi - functional programming interface
 * @export
 */
export declare const TasksApiFp: (configuration?: Configuration) => {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object[]>;
    /**
     * Fetch an array task
     * @param {string} id task id to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskIdGet(id: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayTask>;
    /**
     * Fetch a list of all array tasks a user has access to
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;
     * @param {string} [status] Filter to only return these statuses
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include start_time, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksGet(namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, search?: string, orderby?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayTaskData>;
};
/**
 * TasksApi - factory interface
 * @export
 */
export declare const TasksApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): AxiosPromise<object[]>;
    /**
     * Fetch an array task
     * @param {string} id task id to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskIdGet(id: string, options?: any): AxiosPromise<ArrayTask>;
    /**
     * Fetch a list of all array tasks a user has access to
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;
     * @param {string} [status] Filter to only return these statuses
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include start_time, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksGet(namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, search?: string, orderby?: string, options?: any): AxiosPromise<ArrayTaskData>;
};
/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export declare class TasksApi extends BaseAPI {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): AxiosPromise<object[]>;
    /**
     * Fetch an array task
     * @param {string} id task id to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    taskIdGet(id: string, options?: any): AxiosPromise<ArrayTask>;
    /**
     * Fetch a list of all array tasks a user has access to
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;
     * @param {string} [status] Filter to only return these statuses
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include start_time, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    tasksGet(namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, search?: string, orderby?: string, options?: any): AxiosPromise<ArrayTaskData>;
}
/**
 * UdfApi - axios parameter creator
 * @export
 */
export declare const UdfApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * get a specific UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDF(namespace: string, name: string, options?: any): RequestArgs;
    /**
     * Get all sharing details of the udf
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of registered ud
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFSharingPolicies(namespace: string, name: string, options?: any): RequestArgs;
    /**
     * get a all UDFs accessible to the user
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] udf type, \&quot;generic\&quot;, \&quot;single_array\&quot;
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include created_at, last_used, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFs(namespace?: string, createdBy?: string, page?: number, perPage?: number, type?: string, search?: string, orderby?: string, options?: any): RequestArgs;
    /**
     * register a UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {UDFRegistration} udf udf to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUDF(namespace: string, name: string, udf: UDFRegistration, options?: any): RequestArgs;
    /**
     * Share a UDF with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of registered ud
     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareUDF(namespace: string, name: string, udfSharing: UDFSharing, options?: any): RequestArgs;
    /**
     * send a generic UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {GenericUDF} udf udf to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitGenericUDF(namespace: string, udf: GenericUDF, acceptEncoding?: string, options?: any): RequestArgs;
    /**
     * send a UDF to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {UDF} udf udf to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitUDF(namespace: string, array: string, udf: UDF, xPayer?: string, acceptEncoding?: string, options?: any): RequestArgs;
    /**
     * updated an existing registerd UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {UDFRegistration} udf udf to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatedRegisteredUDF(namespace: string, name: string, udf: UDFRegistration, options?: any): RequestArgs;
};
/**
 * UdfApi - functional programming interface
 * @export
 */
export declare const UdfApiFp: (configuration?: Configuration) => {
    /**
     * get a specific UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDF(namespace: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UDFRegistration>;
    /**
     * Get all sharing details of the udf
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of registered ud
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFSharingPolicies(namespace: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UDFSharing[]>;
    /**
     * get a all UDFs accessible to the user
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] udf type, \&quot;generic\&quot;, \&quot;single_array\&quot;
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include created_at, last_used, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFs(namespace?: string, createdBy?: string, page?: number, perPage?: number, type?: string, search?: string, orderby?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UDFListingData>;
    /**
     * register a UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {UDFRegistration} udf udf to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUDF(namespace: string, name: string, udf: UDFRegistration, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * Share a UDF with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of registered ud
     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareUDF(namespace: string, name: string, udfSharing: UDFSharing, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * send a generic UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {GenericUDF} udf udf to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitGenericUDF(namespace: string, udf: GenericUDF, acceptEncoding?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>;
    /**
     * send a UDF to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {UDF} udf udf to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitUDF(namespace: string, array: string, udf: UDF, xPayer?: string, acceptEncoding?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>;
    /**
     * updated an existing registerd UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {UDFRegistration} udf udf to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatedRegisteredUDF(namespace: string, name: string, udf: UDFRegistration, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
};
/**
 * UdfApi - factory interface
 * @export
 */
export declare const UdfApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * get a specific UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDF(namespace: string, name: string, options?: any): AxiosPromise<UDFRegistration>;
    /**
     * Get all sharing details of the udf
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of registered ud
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFSharingPolicies(namespace: string, name: string, options?: any): AxiosPromise<UDFSharing[]>;
    /**
     * get a all UDFs accessible to the user
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] udf type, \&quot;generic\&quot;, \&quot;single_array\&quot;
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include created_at, last_used, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFs(namespace?: string, createdBy?: string, page?: number, perPage?: number, type?: string, search?: string, orderby?: string, options?: any): AxiosPromise<UDFListingData>;
    /**
     * register a UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {UDFRegistration} udf udf to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUDF(namespace: string, name: string, udf: UDFRegistration, options?: any): AxiosPromise<void>;
    /**
     * Share a UDF with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of registered ud
     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareUDF(namespace: string, name: string, udfSharing: UDFSharing, options?: any): AxiosPromise<void>;
    /**
     * send a generic UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {GenericUDF} udf udf to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitGenericUDF(namespace: string, udf: GenericUDF, acceptEncoding?: string, options?: any): AxiosPromise<any>;
    /**
     * send a UDF to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {UDF} udf udf to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitUDF(namespace: string, array: string, udf: UDF, xPayer?: string, acceptEncoding?: string, options?: any): AxiosPromise<any>;
    /**
     * updated an existing registerd UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {UDFRegistration} udf udf to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatedRegisteredUDF(namespace: string, name: string, udf: UDFRegistration, options?: any): AxiosPromise<void>;
};
/**
 * UdfApi - object-oriented interface
 * @export
 * @class UdfApi
 * @extends {BaseAPI}
 */
export declare class UdfApi extends BaseAPI {
    /**
     * get a specific UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    getUDF(namespace: string, name: string, options?: any): AxiosPromise<UDFRegistration>;
    /**
     * Get all sharing details of the udf
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of registered ud
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    getUDFSharingPolicies(namespace: string, name: string, options?: any): AxiosPromise<UDFSharing[]>;
    /**
     * get a all UDFs accessible to the user
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] udf type, \&quot;generic\&quot;, \&quot;single_array\&quot;
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include created_at, last_used, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    getUDFs(namespace?: string, createdBy?: string, page?: number, perPage?: number, type?: string, search?: string, orderby?: string, options?: any): AxiosPromise<UDFListingData>;
    /**
     * register a UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {UDFRegistration} udf udf to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    registerUDF(namespace: string, name: string, udf: UDFRegistration, options?: any): AxiosPromise<void>;
    /**
     * Share a UDF with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of registered ud
     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    shareUDF(namespace: string, name: string, udfSharing: UDFSharing, options?: any): AxiosPromise<void>;
    /**
     * send a generic UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {GenericUDF} udf udf to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitGenericUDF(namespace: string, udf: GenericUDF, acceptEncoding?: string, options?: any): AxiosPromise<any>;
    /**
     * send a UDF to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {UDF} udf udf to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitUDF(namespace: string, array: string, udf: UDF, xPayer?: string, acceptEncoding?: string, options?: any): AxiosPromise<any>;
    /**
     * updated an existing registerd UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {UDFRegistration} udf udf to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    updatedRegisteredUDF(namespace: string, name: string, udf: UDFRegistration, options?: any): AxiosPromise<void>;
}
/**
 * UserApi - axios parameter creator
 * @export
 */
export declare const UserApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): RequestArgs;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToOrganization(organization: string, user: OrganizationUser, options?: any): RequestArgs;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentials(namespace: string, options?: any): RequestArgs;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): RequestArgs;
    /**
     * confirm user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmEmail(options?: any): RequestArgs;
    /**
     * create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(user: User, options?: any): RequestArgs;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAWSAccessCredentials(namespace: string, name: string, options?: any): RequestArgs;
    /**
     * delete a user
     * @param {string} username username or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(username: string, options?: any): RequestArgs;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserFromOrganization(organization: string, username: string, options?: any): RequestArgs;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUser(organization: string, username: string, options?: any): RequestArgs;
    /**
     * Get session token for user
     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession(rememberMe?: string, options?: any): RequestArgs;
    /**
     * get a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options?: any): RequestArgs;
    /**
     * get a user
     * @param {string} username username or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserWithUsername(username: string, options?: any): RequestArgs;
    /**
     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
     * @param {TokenRequest} [tokenRequest] token request object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestToken(tokenRequest?: TokenRequest, options?: any): RequestArgs;
    /**
     * reset user password
     * @param {InlineObject} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUserPassword(user: InlineObject, options?: any): RequestArgs;
    /**
     * revoke an authorization token
     * @param {string} token token name or token itself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken(token: string, options?: any): RequestArgs;
    /**
     * Fetch a list of user tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensGet(options?: any): RequestArgs;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): RequestArgs;
    /**
     * update a user
     * @param {string} username username or id
     * @param {User} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(username: string, user: User, options?: any): RequestArgs;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): RequestArgs;
};
/**
 * UserApi - functional programming interface
 * @export
 */
export declare const UserApiFp: (configuration?: Configuration) => {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToOrganization(organization: string, user: OrganizationUser, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentials(namespace: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSAccessCredentials[]>;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSAccessCredentials>;
    /**
     * confirm user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmEmail(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAWSAccessCredentials(namespace: string, name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * delete a user
     * @param {string} username username or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(username: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserFromOrganization(organization: string, username: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUser(organization: string, username: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationUser>;
    /**
     * Get session token for user
     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession(rememberMe?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>;
    /**
     * get a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>;
    /**
     * get a user
     * @param {string} username username or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserWithUsername(username: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>;
    /**
     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
     * @param {TokenRequest} [tokenRequest] token request object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestToken(tokenRequest?: TokenRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>;
    /**
     * reset user password
     * @param {InlineObject} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUserPassword(user: InlineObject, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * revoke an authorization token
     * @param {string} token token name or token itself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken(token: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * Fetch a list of user tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token[]>;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * update a user
     * @param {string} username username or id
     * @param {User} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(username: string, user: User, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>;
};
/**
 * UserApi - factory interface
 * @export
 */
export declare const UserApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void>;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToOrganization(organization: string, user: OrganizationUser, options?: any): AxiosPromise<void>;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentials(namespace: string, options?: any): AxiosPromise<AWSAccessCredentials[]>;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): AxiosPromise<AWSAccessCredentials>;
    /**
     * confirm user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmEmail(options?: any): AxiosPromise<void>;
    /**
     * create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(user: User, options?: any): AxiosPromise<void>;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAWSAccessCredentials(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * delete a user
     * @param {string} username username or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(username: string, options?: any): AxiosPromise<void>;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserFromOrganization(organization: string, username: string, options?: any): AxiosPromise<void>;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUser(organization: string, username: string, options?: any): AxiosPromise<OrganizationUser>;
    /**
     * Get session token for user
     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession(rememberMe?: string, options?: any): AxiosPromise<Token>;
    /**
     * get a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options?: any): AxiosPromise<User>;
    /**
     * get a user
     * @param {string} username username or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserWithUsername(username: string, options?: any): AxiosPromise<User>;
    /**
     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
     * @param {TokenRequest} [tokenRequest] token request object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestToken(tokenRequest?: TokenRequest, options?: any): AxiosPromise<Token>;
    /**
     * reset user password
     * @param {InlineObject} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUserPassword(user: InlineObject, options?: any): AxiosPromise<void>;
    /**
     * revoke an authorization token
     * @param {string} token token name or token itself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken(token: string, options?: any): AxiosPromise<void>;
    /**
     * Fetch a list of user tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensGet(options?: any): AxiosPromise<Token[]>;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void>;
    /**
     * update a user
     * @param {string} username username or id
     * @param {User} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(username: string, user: User, options?: any): AxiosPromise<void>;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): AxiosPromise<void>;
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export declare class UserApi extends BaseAPI {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void>;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addUserToOrganization(organization: string, user: OrganizationUser, options?: any): AxiosPromise<void>;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    checkAWSAccessCredentials(namespace: string, options?: any): AxiosPromise<AWSAccessCredentials[]>;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): AxiosPromise<AWSAccessCredentials>;
    /**
     * confirm user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    confirmEmail(options?: any): AxiosPromise<void>;
    /**
     * create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createUser(user: User, options?: any): AxiosPromise<void>;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteAWSAccessCredentials(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * delete a user
     * @param {string} username username or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUser(username: string, options?: any): AxiosPromise<void>;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUserFromOrganization(organization: string, username: string, options?: any): AxiosPromise<void>;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getOrganizationUser(organization: string, username: string, options?: any): AxiosPromise<OrganizationUser>;
    /**
     * Get session token for user
     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getSession(rememberMe?: string, options?: any): AxiosPromise<Token>;
    /**
     * get a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(options?: any): AxiosPromise<User>;
    /**
     * get a user
     * @param {string} username username or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserWithUsername(username: string, options?: any): AxiosPromise<User>;
    /**
     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
     * @param {TokenRequest} [tokenRequest] token request object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    requestToken(tokenRequest?: TokenRequest, options?: any): AxiosPromise<Token>;
    /**
     * reset user password
     * @param {InlineObject} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    resetUserPassword(user: InlineObject, options?: any): AxiosPromise<void>;
    /**
     * revoke an authorization token
     * @param {string} token token name or token itself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    revokeToken(token: string, options?: any): AxiosPromise<void>;
    /**
     * Fetch a list of user tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokensGet(options?: any): AxiosPromise<Token[]>;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void>;
    /**
     * update a user
     * @param {string} username username or id
     * @param {User} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUser(username: string, user: User, options?: any): AxiosPromise<void>;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): AxiosPromise<void>;
}
