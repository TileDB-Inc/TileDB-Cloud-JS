import * as axios from 'axios';
import { AxiosRequestConfig, AxiosInstance, AxiosPromise } from 'axios';
import * as capnp from 'capnp-ts';

/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
interface ConfigurationParameters$1 {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    baseOptions?: any;
    formDataCtor?: new () => any;
}
declare class Configuration$1 {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;
    constructor(param?: ConfigurationParameters$1);
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime?(mime: string): boolean;
    /**
     * Check if the given MIME is a capnp MIME.
     * JSON MIME examples:
     *   application/capnp
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is capnp, false otherwise.
     */
    isCapnpMime?(mime: string): boolean;
}

/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface RequestArgs
 */
interface RequestArgs$1 {
    url: string;
    options: AxiosRequestConfig;
}
/**
 *
 * @export
 * @class BaseAPI
 */
declare class BaseAPI$1 {
    protected basePath: string;
    protected axios: AxiosInstance;
    protected configuration: Configuration$1 | undefined;
    constructor(configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance);
}

/**
 * Model representing aws keys or service role, service roles are currently ignored, but will be preferred option in the future
 * @export
 * @interface AWSAccessCredentials
 */
interface AWSAccessCredentials {
    /**
     * aws secret access key, never returned in get requests
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    secret_access_key?: string;
    /**
     * aws access key
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    access_key_id?: string;
    /**
     * aws service role to use for access
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    service_role_arn?: string;
    /**
     * human readable name
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    name?: string;
    /**
     * true if this is the default credential to be used within this namespace
     * @type {boolean}
     * @memberof AWSAccessCredentials
     */
    default?: boolean;
    /**
     * a whitelist of one or more buckets this key should access
     * @type {Array<string>}
     * @memberof AWSAccessCredentials
     */
    buckets?: Array<string>;
    /**
     * Time when UDF dependencies were created (rfc3339)
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    created_at?: string;
    /**
     * Time when UDF dependencies was last updated (rfc3339)
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    updated_at?: string;
}
/**
 * Type of activity logged
 * @export
 * @enum {string}
 */
declare enum ActivityEventType$1 {
    ReadSchema = "read_schema",
    MaxBufferSizes = "max_buffer_sizes",
    NonEmptyDomain = "non_empty_domain",
    QueryRead = "query_read",
    QueryWrite = "query_write",
    Create = "create",
    Delete = "delete",
    Register = "register",
    Deregister = "deregister",
    Udf = "udf",
    ArrayMetadataGet = "array_metadata_get",
    ArrayMetadataUpdate = "array_metadata_update",
    EstimatedResultSizes = "estimated_result_sizes"
}
/**
 * actions a user can take on an array
 * @export
 * @enum {string}
 */
declare enum ArrayActions {
    Read = "read",
    Write = "write",
    Edit = "edit",
    ReadArrayLogs = "read_array_logs",
    ReadArrayInfo = "read_array_info",
    ReadArraySchema = "read_array_schema"
}
/**
 * Actvity of an Array
 * @export
 * @interface ArrayActivityLog
 */
interface ArrayActivityLog$1 {
    /**
     * time event took place (RFC3339)
     * @type {string}
     * @memberof ArrayActivityLog
     */
    event_at?: string;
    /**
     *
     * @type {ActivityEventType}
     * @memberof ArrayActivityLog
     */
    action?: ActivityEventType$1;
    /**
     * User who performed action
     * @type {string}
     * @memberof ArrayActivityLog
     */
    username?: string;
    /**
     * Bytes sent to client
     * @type {number}
     * @memberof ArrayActivityLog
     */
    bytes_sent?: number;
    /**
     * Bytes recieved from client
     * @type {number}
     * @memberof ArrayActivityLog
     */
    bytes_received?: number;
    /**
     * UUID of associated array task
     * @type {string}
     * @memberof ArrayActivityLog
     */
    array_task_id?: string;
    /**
     * ID of the activity
     * @type {string}
     * @memberof ArrayActivityLog
     */
    id?: string;
    /**
     * ranges for query
     * @type {string}
     * @memberof ArrayActivityLog
     */
    query_ranges?: string;
    /**
     * stats for query
     * @type {string}
     * @memberof ArrayActivityLog
     */
    query_stats?: string;
}
/**
 * Object including array info and pagination metadata
 * @export
 * @interface ArrayBrowserData
 */
interface ArrayBrowserData {
    /**
     * Array Info
     * @type {Array<ArrayInfo>}
     * @memberof ArrayBrowserData
     */
    arrays?: Array<ArrayInfo>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof ArrayBrowserData
     */
    pagination_metadata?: PaginationMetadata$1;
}
/**
 * Object for ui array tasks browser page
 * @export
 * @interface ArrayBrowserSidebar
 */
interface ArrayBrowserSidebar {
    /**
     * list of all unique namespaces to display
     * @type {Array<string>}
     * @memberof ArrayBrowserSidebar
     */
    namespaces?: Array<string>;
    /**
     * A count of \"all\" of category
     * @type {number}
     * @memberof ArrayBrowserSidebar
     */
    result_count_for_all?: number;
    /**
     * A map that includes the result count by namespace
     * @type {object}
     * @memberof ArrayBrowserSidebar
     */
    result_count_by_namespace?: object;
}
/**
 * Object including array end_timestamps (list of Unix epoch timestamps in milliseconds) and pagination metadata
 * @export
 * @interface ArrayEndTimestampData
 */
interface ArrayEndTimestampData {
    /**
     * List of timestamps expressed in milliseconds since Unix epoch
     * @type {Array<number>}
     * @memberof ArrayEndTimestampData
     */
    end_timestamps?: Array<number>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof ArrayEndTimestampData
     */
    pagination_metadata?: PaginationMetadata$1;
}
/**
 * A user-favorite array item
 * @export
 * @interface ArrayFavorite
 */
interface ArrayFavorite {
    /**
     * unique UUID of the array
     * @type {string}
     * @memberof ArrayFavorite
     */
    array_uuid?: string;
    /**
     * the namespace of the array
     * @type {string}
     * @memberof ArrayFavorite
     */
    namespace?: string;
    /**
     * the name of the array
     * @type {string}
     * @memberof ArrayFavorite
     */
    name?: string;
}
/**
 * Object including array favorites and pagination metadata
 * @export
 * @interface ArrayFavoritesData
 */
interface ArrayFavoritesData {
    /**
     * List of array infos
     * @type {Array<ArrayInfo>}
     * @memberof ArrayFavoritesData
     */
    arrays?: Array<ArrayInfo>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof ArrayFavoritesData
     */
    pagination_metadata?: PaginationMetadata$1;
}
/**
 * metadata of an array
 * @export
 * @interface ArrayInfo
 */
interface ArrayInfo {
    /**
     * unique ID of registered array
     * @type {string}
     * @memberof ArrayInfo
     */
    id?: string;
    /**
     *
     * @type {FileType}
     * @memberof ArrayInfo
     */
    file_type?: FileType;
    /**
     * map of file properties created for this array
     * @type {{ [key: string]: string; }}
     * @memberof ArrayInfo
     */
    file_properties?: {
        [key: string]: string;
    };
    /**
     * uri of array
     * @type {string}
     * @memberof ArrayInfo
     */
    uri?: string;
    /**
     * namespace array is in
     * @type {string}
     * @memberof ArrayInfo
     */
    namespace?: string;
    /**
     * size in bytes of array
     * @type {number}
     * @memberof ArrayInfo
     */
    size?: number | null;
    /**
     * Datetime array was last accessed in UTC
     * @type {string}
     * @memberof ArrayInfo
     */
    last_accessed?: string;
    /**
     * description of array
     * @type {string}
     * @memberof ArrayInfo
     */
    description?: string | null;
    /**
     * name of array
     * @type {string}
     * @memberof ArrayInfo
     */
    name?: string;
    /**
     * list of actions user is allowed to do on this array
     * @type {Array<ArrayActions>}
     * @memberof ArrayInfo
     */
    allowed_actions?: Array<ArrayActions>;
    /**
     * list of pricing created for this array
     * @type {Array<Pricing>}
     * @memberof ArrayInfo
     */
    pricing?: Array<Pricing>;
    /**
     * list of subscriptions created for this array
     * @type {Array<Subscription>}
     * @memberof ArrayInfo
     */
    subscriptions?: Array<Subscription>;
    /**
     * logo (base64 encoded) for the array. Optional
     * @type {string}
     * @memberof ArrayInfo
     */
    logo?: string;
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used
     * @type {string}
     * @memberof ArrayInfo
     */
    access_credentials_name?: string;
    /**
     * Array type (dense, key-value, sparse)
     * @type {string}
     * @memberof ArrayInfo
     */
    type?: string;
    /**
     * number of unique namespaces this array is shared with
     * @type {number}
     * @memberof ArrayInfo
     */
    share_count?: number;
    /**
     * Suggests if the array was shared to public by owner
     * @type {boolean}
     * @memberof ArrayInfo
     */
    public_share?: boolean;
    /**
     * Depends on the namespace asking, denotes the existence of subscription of namespace to this array
     * @type {boolean}
     * @memberof ArrayInfo
     */
    namespace_subscribed?: boolean;
    /**
     * uri for access through TileDB cloud
     * @type {string}
     * @memberof ArrayInfo
     */
    tiledb_uri?: string;
    /**
     * optional tags for array
     * @type {Array<string>}
     * @memberof ArrayInfo
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom
     * @type {string}
     * @memberof ArrayInfo
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof ArrayInfo
     */
    license_text?: string;
    /**
     * Suggests if the array is in read_only mode
     * @type {boolean}
     * @memberof ArrayInfo
     */
    read_only?: boolean | null;
    /**
     * Indicates whether the array is in user favorites
     * @type {boolean}
     * @memberof ArrayInfo
     */
    is_favorite?: boolean;
}
/**
 * metadata of an array
 * @export
 * @interface ArrayInfoUpdate
 */
interface ArrayInfoUpdate {
    /**
     * description of array
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    description?: string | null;
    /**
     * description of array
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    name?: string;
    /**
     * uri of array
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    uri?: string;
    /**
     *
     * @type {FileType}
     * @memberof ArrayInfoUpdate
     */
    file_type?: FileType;
    /**
     * map of file properties created for this array
     * @type {{ [key: string]: string; }}
     * @memberof ArrayInfoUpdate
     */
    file_properties?: {
        [key: string]: string;
    };
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    access_credentials_name?: string;
    /**
     * logo (base64 encoded) for the array. Optional
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    logo?: string;
    /**
     * optional tags for array
     * @type {Array<string>}
     * @memberof ArrayInfoUpdate
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    license_text?: string;
    /**
     * Suggests if the array is in read_only mode
     * @type {boolean}
     * @memberof ArrayInfoUpdate
     */
    read_only?: boolean;
}
/**
 * user\'s TileDB array metadata
 * @export
 * @interface ArrayMetadata
 */
interface ArrayMetadata {
    /**
     * List of metadata entries
     * @type {Array<ArrayMetadataEntry>}
     * @memberof ArrayMetadata
     */
    entries?: Array<ArrayMetadataEntry>;
}
/**
 * key/value pair representing an array metadata map entry
 * @export
 * @interface ArrayMetadataEntry
 */
interface ArrayMetadataEntry {
    /**
     *
     * @type {string}
     * @memberof ArrayMetadataEntry
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof ArrayMetadataEntry
     */
    type?: string;
    /**
     *
     * @type {number}
     * @memberof ArrayMetadataEntry
     */
    valueNum?: number;
    /**
     *
     * @type {Array<number>}
     * @memberof ArrayMetadataEntry
     */
    value?: Array<number>;
    /**
     *
     * @type {boolean}
     * @memberof ArrayMetadataEntry
     */
    del?: boolean;
}
/**
 * Sample data from array
 * @export
 * @interface ArraySample
 */
interface ArraySample {
    /**
     *
     * @type {object}
     * @memberof ArraySample
     */
    data?: object;
}
/**
 * ArraySchema during creation or retrieval
 * @export
 * @interface ArraySchema
 */
interface ArraySchema {
    /**
     * URI of schema
     * @type {string}
     * @memberof ArraySchema
     */
    uri?: string;
    /**
     * file format version
     * @type {Array<number>}
     * @memberof ArraySchema
     */
    version: Array<number>;
    /**
     *
     * @type {ArrayType}
     * @memberof ArraySchema
     */
    arrayType: ArrayType;
    /**
     *
     * @type {Layout}
     * @memberof ArraySchema
     */
    tileOrder: Layout$1;
    /**
     *
     * @type {Layout}
     * @memberof ArraySchema
     */
    cellOrder: Layout$1;
    /**
     * Capacity of array
     * @type {number}
     * @memberof ArraySchema
     */
    capacity: number;
    /**
     *
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    coordsFilterPipeline: FilterPipeline;
    /**
     *
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    offsetFilterPipeline: FilterPipeline;
    /**
     *
     * @type {Domain}
     * @memberof ArraySchema
     */
    domain: Domain;
    /**
     * Attributes of array
     * @type {Array<Attribute>}
     * @memberof ArraySchema
     */
    attributes: Array<Attribute>;
    /**
     * True if the array allows coordinate duplicates. Applicable only to sparse arrays.
     * @type {boolean}
     * @memberof ArraySchema
     */
    allowsDuplicates?: boolean;
}
/**
 * details for sharing a given array
 * @export
 * @interface ArraySharing
 */
interface ArraySharing {
    /**
     * List of permitted actions
     * @type {Array<ArrayActions>}
     * @memberof ArraySharing
     */
    actions?: Array<ArrayActions>;
    /**
     * namespace being granted array access can be a user or organization
     * @type {string}
     * @memberof ArraySharing
     */
    namespace?: string;
    /**
     * details on if the namespace is a organization or user
     * @type {string}
     * @memberof ArraySharing
     */
    namespace_type?: string;
}
/**
 * Synchronous Task to Run
 * @export
 * @interface ArrayTask
 */
interface ArrayTask {
    /**
     * task ID
     * @type {string}
     * @memberof ArrayTask
     */
    id?: string;
    /**
     * Optional task name
     * @type {string}
     * @memberof ArrayTask
     */
    name?: string;
    /**
     * Optional task description (Tasks purpose)
     * @type {string}
     * @memberof ArrayTask
     */
    description?: string;
    /**
     *
     * @type {ArrayInfo}
     * @memberof ArrayTask
     */
    array_metadata?: ArrayInfo;
    /**
     *
     * @type {DomainArray}
     * @memberof ArrayTask
     */
    subarray?: DomainArray$1;
    /**
     * memory allocated to task in bytes
     * @type {number}
     * @memberof ArrayTask
     */
    memory?: number;
    /**
     * millicpu allocated to task
     * @type {number}
     * @memberof ArrayTask
     */
    cpu?: number;
    /**
     * namespace task is tied to
     * @type {string}
     * @memberof ArrayTask
     */
    namespace?: string;
    /**
     *
     * @type {ArrayTaskStatus}
     * @memberof ArrayTask
     */
    status?: ArrayTaskStatus;
    /**
     * Start time RFC3339 for job
     * @type {string}
     * @memberof ArrayTask
     */
    start_time?: string;
    /**
     * Finish time RFC3339 for job
     * @type {string}
     * @memberof ArrayTask
     */
    finish_time?: string | null;
    /**
     * Total accumulated for task in USD, example is $0.12
     * @type {number}
     * @memberof ArrayTask
     */
    cost?: number;
    /**
     * Total accumulated for egress task in USD, example is $0.12
     * @type {number}
     * @memberof ArrayTask
     */
    egress_cost?: number;
    /**
     * Cost accumulated for access task in USD, example is $0.12
     * @type {number}
     * @memberof ArrayTask
     */
    access_cost?: number;
    /**
     *
     * @type {Querytype}
     * @memberof ArrayTask
     */
    query_type?: Querytype$1;
    /**
     * Optional actual code that is going to be executed
     * @type {string}
     * @memberof ArrayTask
     */
    udf_code?: string;
    /**
     * Optional actual language used to express udf_code
     * @type {string}
     * @memberof ArrayTask
     */
    udf_language?: string;
    /**
     * Optional actual sql query that is going to be executed
     * @type {string}
     * @memberof ArrayTask
     */
    sql_query?: string;
    /**
     *
     * @type {ArrayTaskType}
     * @memberof ArrayTask
     */
    type?: ArrayTaskType;
    /**
     * Array activity logs for task
     * @type {Array<ArrayActivityLog>}
     * @memberof ArrayTask
     */
    activity?: Array<ArrayActivityLog$1>;
    /**
     * logs from array task
     * @type {string}
     * @memberof ArrayTask
     */
    logs?: string;
    /**
     * duration in nanoseconds of an array task
     * @type {number}
     * @memberof ArrayTask
     */
    duration?: number;
    /**
     * SQL queries or commands to run before main sql query
     * @type {Array<string>}
     * @memberof ArrayTask
     */
    sql_init_commands?: Array<string>;
    /**
     * SQL query parameters
     * @type {Array<object>}
     * @memberof ArrayTask
     */
    sql_parameters?: Array<object>;
    /**
     *
     * @type {ResultFormat}
     * @memberof ArrayTask
     */
    result_format?: ResultFormat;
    /**
     * If set, the ID of the log for the task graph that this was part of.
     * @type {string}
     * @memberof ArrayTask
     */
    task_graph_uuid?: string;
    /**
     * If set, the client-defined ID of the node within this task\'s graph.
     * @type {string}
     * @memberof ArrayTask
     */
    client_node_uuid?: string;
}
/**
 * Object for ui array tasks browser page
 * @export
 * @interface ArrayTaskBrowserSidebar
 */
interface ArrayTaskBrowserSidebar {
    /**
     * list of all unique organizations the user is part of that have array tasks
     * @type {Array<string>}
     * @memberof ArrayTaskBrowserSidebar
     */
    organizations?: Array<string>;
    /**
     * A count of \"all\"
     * @type {number}
     * @memberof ArrayTaskBrowserSidebar
     */
    result_count_for_all?: number;
    /**
     * A map that includes the result count by namespace
     * @type {object}
     * @memberof ArrayTaskBrowserSidebar
     */
    result_count_by_namespace?: object;
}
/**
 * Object including array tasks and metadata
 * @export
 * @interface ArrayTaskData
 */
interface ArrayTaskData {
    /**
     * Array Tasks
     * @type {Array<ArrayTask>}
     * @memberof ArrayTaskData
     */
    array_tasks?: Array<ArrayTask>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof ArrayTaskData
     */
    pagination_metadata?: PaginationMetadata$1;
}
/**
 * Array task stderr/stdout logs
 * @export
 * @interface ArrayTaskLog
 */
interface ArrayTaskLog {
    /**
     * ID of associated task
     * @type {string}
     * @memberof ArrayTaskLog
     */
    array_task_id?: string;
    /**
     * logs from array task
     * @type {string}
     * @memberof ArrayTaskLog
     */
    logs?: string;
}
/**
 * Status of array task
 * @export
 * @enum {string}
 */
declare enum ArrayTaskStatus {
    Queued = "QUEUED",
    Failed = "FAILED",
    Completed = "COMPLETED",
    Running = "RUNNING",
    ResourcesUnavailable = "RESOURCES_UNAVAILABLE",
    Unknown = "UNKNOWN",
    Cancelled = "CANCELLED",
    Denied = "DENIED"
}
/**
 * Synchronous Task Type
 * @export
 * @enum {string}
 */
declare enum ArrayTaskType {
    Sql = "SQL",
    Udf = "UDF",
    Query = "QUERY",
    GenericUdf = "GENERIC_UDF",
    ClientComputation = "CLIENT_COMPUTATION"
}
/**
 * TileDB array type
 * @export
 * @enum {string}
 */
declare enum ArrayType {
    Dense = "dense",
    Sparse = "sparse"
}
/**
 * Custom storage locations on a per–asset type basis. If any is unset, a suffix of the owning (user/organization) `default_s3_path` is used.
 * @export
 * @interface AssetLocations
 */
interface AssetLocations {
    /**
     *
     * @type {StorageLocation}
     * @memberof AssetLocations
     */
    arrays?: StorageLocation;
    /**
     *
     * @type {StorageLocation}
     * @memberof AssetLocations
     */
    files?: StorageLocation;
    /**
     *
     * @type {StorageLocation}
     * @memberof AssetLocations
     */
    groups?: StorageLocation;
    /**
     *
     * @type {StorageLocation}
     * @memberof AssetLocations
     */
    ml_models?: StorageLocation;
    /**
     *
     * @type {StorageLocation}
     * @memberof AssetLocations
     */
    notebooks?: StorageLocation;
    /**
     *
     * @type {StorageLocation}
     * @memberof AssetLocations
     */
    task_graphs?: StorageLocation;
    /**
     *
     * @type {StorageLocation}
     * @memberof AssetLocations
     */
    udfs?: StorageLocation;
}
/**
 * Attribute of array
 * @export
 * @interface Attribute
 */
interface Attribute {
    /**
     * Attribute name
     * @type {string}
     * @memberof Attribute
     */
    name: string;
    /**
     *
     * @type {Datatype}
     * @memberof Attribute
     */
    type: Datatype$1;
    /**
     *
     * @type {FilterPipeline}
     * @memberof Attribute
     */
    filterPipeline: FilterPipeline;
    /**
     * Attribute number of values per cell
     * @type {number}
     * @memberof Attribute
     */
    cellValNum: number;
    /**
     * Is attribute nullable
     * @type {boolean}
     * @memberof Attribute
     */
    nullable?: boolean;
    /**
     * The default fill value
     * @type {Array<number>}
     * @memberof Attribute
     */
    fillValue?: Array<number>;
}
/**
 * Represents an attribute buffer header information
 * @export
 * @interface AttributeBufferHeader
 */
interface AttributeBufferHeader$1 {
    /**
     * Attribute name
     * @type {string}
     * @memberof AttributeBufferHeader
     */
    name: string;
    /**
     * Number of bytes in the fixed-length attribute data buffer (offsets for var-len attributes)
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    fixedLenBufferSizeInBytes: number;
    /**
     * Number of bytes in the var-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    varLenBufferSizeInBytes: number;
}
/**
 * object representing buffer size of an attribute
 * @export
 * @interface AttributeBufferSize
 */
interface AttributeBufferSize$1 {
    /**
     * name of attribute
     * @type {string}
     * @memberof AttributeBufferSize
     */
    attribute: string;
    /**
     * buffer size (in bytes) of offset buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    offsetBytes: number;
    /**
     * buffer size (in bytes) of data buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    dataBytes: number;
}
/**
 * TileDB data type
 * @export
 * @enum {string}
 */
declare enum Datatype$1 {
    Int32 = "INT32",
    Int64 = "INT64",
    Float32 = "FLOAT32",
    Float64 = "FLOAT64",
    Char = "CHAR",
    Int8 = "INT8",
    Uint8 = "UINT8",
    Int16 = "INT16",
    Uint16 = "UINT16",
    Uint32 = "UINT32",
    Uint64 = "UINT64",
    StringAscii = "STRING_ASCII",
    StringUtf8 = "STRING_UTF8",
    StringUtf16 = "STRING_UTF16",
    StringUtf32 = "STRING_UTF32",
    StringUcs2 = "STRING_UCS2",
    StringUcs4 = "STRING_UCS4",
    Any = "ANY"
}
/**
 * Dimension of array
 * @export
 * @interface Dimension
 */
interface Dimension {
    /**
     * Dimension name
     * @type {string}
     * @memberof Dimension
     */
    name?: string;
    /**
     *
     * @type {Datatype}
     * @memberof Dimension
     */
    type: Datatype$1;
    /**
     *
     * @type {DomainArray}
     * @memberof Dimension
     */
    domain: DomainArray$1;
    /**
     * Is tile extent null
     * @type {boolean}
     * @memberof Dimension
     */
    nullTileExtent: boolean;
    /**
     *
     * @type {DimensionTileExtent}
     * @memberof Dimension
     */
    tileExtent?: DimensionTileExtent;
    /**
     *
     * @type {FilterPipeline}
     * @memberof Dimension
     */
    filterPipeline?: FilterPipeline;
}
/**
 * A single, typed coordinate for a dimension
 * @export
 * @interface DimensionCoordinate
 */
interface DimensionCoordinate {
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int8?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint8?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int16?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint16?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int64?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint64?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    float32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionCoordinate
     */
    float64?: number;
}
/**
 * Extent of tile
 * @export
 * @interface DimensionTileExtent
 */
interface DimensionTileExtent {
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int8?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint8?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int16?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint16?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int64?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint64?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    float32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    float64?: number;
}
/**
 * Domain of array
 * @export
 * @interface Domain
 */
interface Domain {
    /**
     *
     * @type {Datatype}
     * @memberof Domain
     */
    type: Datatype$1;
    /**
     *
     * @type {Layout}
     * @memberof Domain
     */
    tileOrder: Layout$1;
    /**
     *
     * @type {Layout}
     * @memberof Domain
     */
    cellOrder: Layout$1;
    /**
     * Array of dimensions
     * @type {Array<Dimension>}
     * @memberof Domain
     */
    dimensions: Array<Dimension>;
}
/**
 * Domain object for an array of each type
 * @export
 * @interface DomainArray
 */
interface DomainArray$1 {
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int8?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint8?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int16?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint16?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int32?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint32?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int64?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint64?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float32?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float64?: Array<number>;
}
/**
 * Input/Output information required to create a new file
 * @export
 * @interface FileCreate
 */
interface FileCreate {
    /**
     * storage URI of the input file
     * @type {string}
     * @memberof FileCreate
     */
    input_uri?: string;
    /**
     * output location of the TileDB File
     * @type {string}
     * @memberof FileCreate
     */
    output_uri?: string;
    /**
     * name to set for registered file
     * @type {string}
     * @memberof FileCreate
     */
    name?: string;
}
/**
 * Created file name and information
 * @export
 * @interface FileCreated
 */
interface FileCreated {
    /**
     * output location of the TileDB File
     * @type {string}
     * @memberof FileCreated
     */
    output_uri?: string;
    /**
     * name of the file created
     * @type {string}
     * @memberof FileCreated
     */
    file_name?: string;
}
/**
 * Output information required to export a file
 * @export
 * @interface FileExport
 */
interface FileExport {
    /**
     * output location of the TileDB File
     * @type {string}
     * @memberof FileExport
     */
    output_uri?: string;
}
/**
 * Output uri of the exported file
 * @export
 * @interface FileExported
 */
interface FileExported {
    /**
     * output location of the exported file
     * @type {string}
     * @memberof FileExported
     */
    output_uri?: string;
}
/**
 * File property assigned to a specific file (array)
 * @export
 * @enum {string}
 */
declare enum FilePropertyName {
    Image = "image",
    Size = "size",
    CodeBlock = "code_block",
    UdfLanguage = "udf_language",
    IsDashboard = "is_dashboard"
}
/**
 * File types represented as TileDB arrays
 * @export
 * @enum {string}
 */
declare enum FileType {
    Notebook = "notebook",
    UserDefinedFunction = "user_defined_function",
    MlModel = "ml_model",
    File = "file",
    RegisteredTaskGraph = "registered_task_graph"
}
/**
 * Uploaded file name and information
 * @export
 * @interface FileUploaded
 */
interface FileUploaded {
    /**
     * output location of the TileDB File
     * @type {string}
     * @memberof FileUploaded
     */
    output_uri?: string;
    /**
     * name of the file uploaded
     * @type {string}
     * @memberof FileUploaded
     */
    file_name?: string;
    /**
     * unique ID of the uploaded file
     * @type {string}
     * @memberof FileUploaded
     */
    id: string;
}
/**
 * Filter
 * @export
 * @interface Filter
 */
interface Filter {
    /**
     *
     * @type {FilterType}
     * @memberof Filter
     */
    type: FilterType;
    /**
     *
     * @type {FilterData}
     * @memberof Filter
     */
    data?: FilterData;
}
/**
 * Filter data
 * @export
 * @interface FilterData
 */
interface FilterData {
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    int8?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    uint8?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    int16?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    uint16?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    int32?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    uint32?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    int64?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    uint64?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    float32?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    float64?: number;
}
/**
 * TileDB filter option
 * @export
 * @enum {string}
 */
declare enum FilterOption {
    CompressionLevel = "COMPRESSION_LEVEL",
    BitWidthMaxWindow = "BIT_WIDTH_MAX_WINDOW",
    PositiveDeltaMaxWindow = "POSITIVE_DELTA_MAX_WINDOW"
}
/**
 * One or more filters to apply
 * @export
 * @interface FilterPipeline
 */
interface FilterPipeline {
    /**
     *
     * @type {Array<Filter>}
     * @memberof FilterPipeline
     */
    filters?: Array<Filter>;
}
/**
 * TileDB filter types
 * @export
 * @enum {string}
 */
declare enum FilterType {
    None = "FILTER_NONE",
    Gzip = "FILTER_GZIP",
    Zstd = "FILTER_ZSTD",
    Lz4 = "FILTER_LZ4",
    Rle = "FILTER_RLE",
    Bzip2 = "FILTER_BZIP2",
    DoubleDelta = "FILTER_DOUBLE_DELTA",
    BitWidthReduction = "FILTER_BIT_WIDTH_REDUCTION",
    Bitshuffle = "FILTER_BITSHUFFLE",
    Byteshuffle = "FILTER_BYTESHUFFLE",
    PositiveDelta = "FILTER_POSITIVE_DELTA"
}
/**
 * User-defined function
 * @export
 * @interface GenericUDF
 */
interface GenericUDF {
    /**
     * name of UDFInfo to run, format is {namespace}/{udf_name}. Can not be used with exec
     * @type {string}
     * @memberof GenericUDF
     */
    udf_info_name?: string;
    /**
     *
     * @type {UDFLanguage}
     * @memberof GenericUDF
     */
    language?: UDFLanguage;
    /**
     * Type-specific version
     * @type {string}
     * @memberof GenericUDF
     */
    version?: string;
    /**
     * Docker image name to use for UDF
     * @type {string}
     * @memberof GenericUDF
     */
    image_name?: string;
    /**
     * The resource class to use for the UDF execution. Resource classes define resource limits for memory and CPUs. If this is empty, then the UDF will execute in the standard resource class of the TileDB Cloud provider.
     * @type {string}
     * @memberof GenericUDF
     */
    resource_class?: string;
    /**
     * Type-specific executable text
     * @type {string}
     * @memberof GenericUDF
     */
    exec?: string;
    /**
     * optional raw text to store of serialized function, used for showing in UI
     * @type {string}
     * @memberof GenericUDF
     */
    exec_raw?: string;
    /**
     * Argument(s) to pass to UDF function, tuple or list of args/kwargs which can be in native or JSON format
     * @type {string}
     * @memberof GenericUDF
     */
    argument?: string;
    /**
     * The UUIDs of stored input parameters (passed in a language-specific format within \"argument\") to be retrieved from the server-side cache. Serialized in standard hex format with no {}.
     * @type {Array<string>}
     * @memberof GenericUDF
     */
    stored_param_uuids?: Array<string>;
    /**
     *
     * @type {ResultFormat}
     * @memberof GenericUDF
     */
    result_format?: ResultFormat;
    /**
     * name of task, optional
     * @type {string}
     * @memberof GenericUDF
     */
    task_name?: string;
    /**
     * store results for later retrieval
     * @type {boolean}
     * @memberof GenericUDF
     */
    store_results?: boolean;
    /**
     * UDF-type timeout in seconds (default: 900)
     * @type {number}
     * @memberof GenericUDF
     */
    timeout?: number;
    /**
     * Set to true to avoid downloading the results of this UDF. Useful for intermediate nodes in a task graph where you will not be using the results of your function. Defaults to false (\"yes download results\").
     * @type {boolean}
     * @memberof GenericUDF
     */
    dont_download_results?: boolean;
    /**
     * If set, the ID of the log for the task graph that this was part of.
     * @type {string}
     * @memberof GenericUDF
     */
    task_graph_uuid?: string;
    /**
     * If set, the client-defined ID of the node within this task\'s graph.
     * @type {string}
     * @memberof GenericUDF
     */
    client_node_uuid?: string;
}
/**
 * actions a user can take on a group
 * @export
 * @enum {string}
 */
declare enum GroupActions {
    Read = "read",
    Write = "write",
    Edit = "edit"
}
/**
 * Object including group info and pagination metadata
 * @export
 * @interface GroupBrowserData
 */
interface GroupBrowserData {
    /**
     * Groups Info
     * @type {Array<GroupInfo>}
     * @memberof GroupBrowserData
     */
    groups?: Array<GroupInfo>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof GroupBrowserData
     */
    pagination_metadata?: PaginationMetadata$1;
}
/**
 * Object with data to fill browser filter
 * @export
 * @interface GroupBrowserFilterData
 */
interface GroupBrowserFilterData {
    /**
     * list of all unique namespaces to display
     * @type {Array<string>}
     * @memberof GroupBrowserFilterData
     */
    namespaces?: Array<string>;
}
/**
 * A request to change the members of a group. Contains assets to add or remove.
 * @export
 * @interface GroupChanges
 */
interface GroupChanges {
    /**
     * the assets, arrays or groups, to add to the group.
     * @type {Array<GroupMember>}
     * @memberof GroupChanges
     */
    add?: Array<GroupMember$1>;
    /**
     * the assets, arrays or groups, to remove from the group.
     * @type {Array<GroupMember>}
     * @memberof GroupChanges
     */
    remove?: Array<GroupMember$1>;
}
/**
 * Object including a page of members of a group and pagination metadata
 * @export
 * @interface GroupContents
 */
interface GroupContents {
    /**
     * Groups members
     * @type {Array<GroupEntry>}
     * @memberof GroupContents
     */
    entries?: Array<GroupEntry>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof GroupContents
     */
    pagination_metadata?: PaginationMetadata$1;
}
/**
 * Object with data to fill contents filter
 * @export
 * @interface GroupContentsFilterData
 */
interface GroupContentsFilterData {
    /**
     * list of all unique namespaces to display
     * @type {Array<string>}
     * @memberof GroupContentsFilterData
     */
    namespaces?: Array<string>;
}
/**
 * Initial attributes for the creation of a group.
 * @export
 * @interface GroupCreate
 */
interface GroupCreate {
    /**
     * A human readable description of the contents of the group.
     * @type {string}
     * @memberof GroupCreate
     */
    description?: string;
    /**
     * The name of the group. If must be unique within the group.
     * @type {string}
     * @memberof GroupCreate
     */
    name?: string;
    /**
     * The unique name or id of the parent of the group. If empty, then the new group will be a top level group.
     * @type {string}
     * @memberof GroupCreate
     */
    parent?: string;
    /**
     * uri of group.
     * @type {string}
     * @memberof GroupCreate
     */
    uri?: string;
    /**
     * logo (base64 encoded) for the group. Optional
     * @type {string}
     * @memberof GroupCreate
     */
    logo?: string;
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used.
     * @type {string}
     * @memberof GroupCreate
     */
    access_credentials_name?: string;
    /**
     * optional tags for groups.
     * @type {Array<string>}
     * @memberof GroupCreate
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom.
     * @type {string}
     * @memberof GroupCreate
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof GroupCreate
     */
    license_text?: string;
}
/**
 * Object describing a single member of a group, which can be an array or a group
 * @export
 * @interface GroupEntry
 */
interface GroupEntry {
    /**
     * The unique member id for the entry
     * @type {string}
     * @memberof GroupEntry
     */
    member_id?: string;
    /**
     *
     * @type {GroupInfo}
     * @memberof GroupEntry
     */
    group?: GroupInfo;
    /**
     *
     * @type {ArrayInfo}
     * @memberof GroupEntry
     */
    array?: ArrayInfo;
}
/**
 * metadata of a group
 * @export
 * @interface GroupInfo
 */
interface GroupInfo {
    /**
     * unique ID of registered group
     * @type {string}
     * @memberof GroupInfo
     */
    id?: string;
    /**
     * namespace group is in
     * @type {string}
     * @memberof GroupInfo
     */
    namespace?: string;
    /**
     * name of group
     * @type {string}
     * @memberof GroupInfo
     */
    name?: string;
    /**
     * description of group
     * @type {string}
     * @memberof GroupInfo
     */
    description?: string | null;
    /**
     * uri of group
     * @type {string}
     * @memberof GroupInfo
     */
    uri?: string;
    /**
     * uri for access through TileDB cloud
     * @type {string}
     * @memberof GroupInfo
     */
    tiledb_uri?: string;
    /**
     * A count of direct array members
     * @type {number}
     * @memberof GroupInfo
     */
    asset_count?: number;
    /**
     * A count of direct group members
     * @type {number}
     * @memberof GroupInfo
     */
    group_count?: number;
    /**
     * A count of direct members. This is the sum of asset_count and group_count
     * @type {number}
     * @memberof GroupInfo
     */
    size?: number;
    /**
     * Datetime groups was last accessed in UTC
     * @type {string}
     * @memberof GroupInfo
     */
    last_accessed?: string;
    /**
     * list of actions user is allowed to do on this group
     * @type {Array<GroupActions>}
     * @memberof GroupInfo
     */
    allowed_actions?: Array<GroupActions>;
    /**
     * logo (base64 encoded) for the gruop. Optional
     * @type {string}
     * @memberof GroupInfo
     */
    logo?: string;
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used
     * @type {string}
     * @memberof GroupInfo
     */
    access_credentials_name?: string;
    /**
     * number of unique namespaces this group is shared with
     * @type {number}
     * @memberof GroupInfo
     */
    share_count?: number;
    /**
     * Suggests if the group was shared to public by owner
     * @type {boolean}
     * @memberof GroupInfo
     */
    public_share?: boolean;
    /**
     * optional tags for group
     * @type {Array<string>}
     * @memberof GroupInfo
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom
     * @type {string}
     * @memberof GroupInfo
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof GroupInfo
     */
    license_text?: string;
}
/**
 * A groups member, array or another groups, to add or remove from an existing group.
 * @export
 * @interface GroupMember
 */
interface GroupMember$1 {
    /**
     * The namespace of the asset.
     * @type {string}
     * @memberof GroupMember
     */
    namespace?: string;
    /**
     * The name or id of the asset.
     * @type {string}
     * @memberof GroupMember
     */
    name?: string;
    /**
     *
     * @type {GroupMemberType}
     * @memberof GroupMember
     */
    member_type?: GroupMemberType$1;
}
/**
 * Specific file types of group members
 * @export
 * @enum {string}
 */
declare enum GroupMemberAssetType$1 {
    Group = "group",
    Array = "array",
    Notebook = "notebook",
    Dashboard = "dashboard",
    UserDefinedFunction = "user_defined_function",
    MlModel = "ml_model",
    File = "file"
}
/**
 * File types that can be included in groups
 * @export
 * @enum {string}
 */
declare enum GroupMemberType$1 {
    Group = "group",
    Array = "array"
}
/**
 * Initial attributes for the registration of a an existing group.
 * @export
 * @interface GroupRegister
 */
interface GroupRegister {
    /**
     * A human readable description of the contents of the group.
     * @type {string}
     * @memberof GroupRegister
     */
    description?: string;
    /**
     * The name of the group. If must be unique within the group.
     * @type {string}
     * @memberof GroupRegister
     */
    name?: string;
    /**
     * The unique name or id of the parent of the group. If empty, then the new group will be a top level group.
     * @type {string}
     * @memberof GroupRegister
     */
    parent?: string;
    /**
     * uri of group.
     * @type {string}
     * @memberof GroupRegister
     */
    uri?: string;
    /**
     * logo (base64 encoded) for the group. Optional
     * @type {string}
     * @memberof GroupRegister
     */
    logo?: string;
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used.
     * @type {string}
     * @memberof GroupRegister
     */
    access_credentials_name?: string;
    /**
     * optional tags for groups.
     * @type {Array<string>}
     * @memberof GroupRegister
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom.
     * @type {string}
     * @memberof GroupRegister
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof GroupRegister
     */
    license_text?: string;
}
/**
 * sharing state of a group with a namespace
 * @export
 * @interface GroupSharing
 */
interface GroupSharing {
    /**
     * List of permitted actions for the group and all subgroups
     * @type {Array<GroupActions>}
     * @memberof GroupSharing
     */
    group_actions?: Array<GroupActions>;
    /**
     * List of permitted actions for all the subarrays of the group
     * @type {Array<ArrayActions>}
     * @memberof GroupSharing
     */
    array_actions?: Array<ArrayActions>;
    /**
     * namespace being granted group access can be a user or organization
     * @type {string}
     * @memberof GroupSharing
     */
    namespace?: string;
    /**
     * details on if the namespace is a organization or user
     * @type {string}
     * @memberof GroupSharing
     */
    namespace_type?: string;
}
/**
 * a request to share a group and all the contents with a namespace
 * @export
 * @interface GroupSharingRequest
 */
interface GroupSharingRequest {
    /**
     * List of permitted actions for the group and all subgroups
     * @type {Array<GroupActions>}
     * @memberof GroupSharingRequest
     */
    group_actions?: Array<GroupActions>;
    /**
     * List of permitted actions for all the subarrays of the group
     * @type {Array<ArrayActions>}
     * @memberof GroupSharingRequest
     */
    array_actions?: Array<ArrayActions>;
    /**
     * namespace being granted group access can be a user or organization
     * @type {string}
     * @memberof GroupSharingRequest
     */
    namespace?: string;
}
/**
 * Updates for a group. New values for the attributes.
 * @export
 * @interface GroupUpdate
 */
interface GroupUpdate {
    /**
     * A human readable description of the content of the group
     * @type {string}
     * @memberof GroupUpdate
     */
    description?: string | null;
    /**
     * The name of the group. If must be unique within the group.
     * @type {string}
     * @memberof GroupUpdate
     */
    name?: string;
    /**
     * logo (base64 encoded) for the group. Optional
     * @type {string}
     * @memberof GroupUpdate
     */
    logo?: string;
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used
     * @type {string}
     * @memberof GroupUpdate
     */
    access_credentials_name?: string;
    /**
     * optional tags for groups
     * @type {Array<string>}
     * @memberof GroupUpdate
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom
     * @type {string}
     * @memberof GroupUpdate
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof GroupUpdate
     */
    license_text?: string;
}
/**
 * Password to update
 * @export
 * @interface InlineObject
 */
interface InlineObject {
    /**
     * password
     * @type {string}
     * @memberof InlineObject
     */
    password?: string;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
interface InlineResponse200 {
    /**
     * string of stats from tiledb
     * @type {string}
     * @memberof InlineResponse200
     */
    stats?: string;
}
/**
 * Invitations to share or collaborate
 * @export
 * @interface Invitation
 */
interface Invitation {
    /**
     * Unique ID of invitation added to magic link
     * @type {string}
     * @memberof Invitation
     */
    id?: string;
    /**
     *
     * @type {InvitationType}
     * @memberof Invitation
     */
    invitation_type?: InvitationType;
    /**
     * Namespace of the owner of the invitation (user or organization)
     * @type {string}
     * @memberof Invitation
     */
    owner_namespace_uuid?: string;
    /**
     * Unique ID of the user accepted the invitation
     * @type {string}
     * @memberof Invitation
     */
    user_namespace_uuid?: string;
    /**
     * Unique ID of the organization user accepted the invitation
     * @type {string}
     * @memberof Invitation
     */
    organization_user_uuid?: string;
    /**
     * Name of the organization, does not persist in database
     * @type {string}
     * @memberof Invitation
     */
    organization_name?: string;
    /**
     *
     * @type {OrganizationRoles}
     * @memberof Invitation
     */
    organization_role?: OrganizationRoles;
    /**
     * Unique ID of the array
     * @type {string}
     * @memberof Invitation
     */
    array_uuid?: string;
    /**
     * Name of the array, does not persist in database
     * @type {string}
     * @memberof Invitation
     */
    array_name?: string;
    /**
     * Email of the individual we send the invitation to
     * @type {string}
     * @memberof Invitation
     */
    email?: string;
    /**
     * A comma separated list of ArrayActions or NamespaceActions
     * @type {string}
     * @memberof Invitation
     */
    actions?: string;
    /**
     *
     * @type {InvitationStatus}
     * @memberof Invitation
     */
    status?: InvitationStatus;
    /**
     * Datetime the invitation was created in UTC
     * @type {string}
     * @memberof Invitation
     */
    created_at?: string;
    /**
     * Datetime the invitation is expected to expire in UTC
     * @type {string}
     * @memberof Invitation
     */
    expires_at?: string;
    /**
     * Datetime the invitation was accepted in UTC
     * @type {string}
     * @memberof Invitation
     */
    accepted_at?: string;
}
/**
 * Encapsulates information regarding inviting people using email to share array, same permissions for all invitees
 * @export
 * @interface InvitationArrayShareEmail
 */
interface InvitationArrayShareEmail {
    /**
     * List of permitted actions
     * @type {Array<ArrayActions>}
     * @memberof InvitationArrayShareEmail
     */
    actions: Array<ArrayActions>;
    /**
     *
     * @type {Array<string>}
     * @memberof InvitationArrayShareEmail
     */
    invitee_email: Array<string>;
}
/**
 * Object including invitations and metadata
 * @export
 * @interface InvitationData
 */
interface InvitationData {
    /**
     * List of invitations
     * @type {Array<Invitation>}
     * @memberof InvitationData
     */
    invitations?: Array<Invitation>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof InvitationData
     */
    pagination_metadata?: PaginationMetadata$1;
}
/**
 * Encapsulates information regarding inviting people using email to join organization, same permissions for all invitees
 * @export
 * @interface InvitationOrganizationJoinEmail
 */
interface InvitationOrganizationJoinEmail {
    /**
     * List of permitted actions
     * @type {Array<NamespaceActions>}
     * @memberof InvitationOrganizationJoinEmail
     */
    actions?: Array<NamespaceActions>;
    /**
     *
     * @type {OrganizationRoles}
     * @memberof InvitationOrganizationJoinEmail
     */
    organization_role: OrganizationRoles;
    /**
     *
     * @type {Array<string>}
     * @memberof InvitationOrganizationJoinEmail
     */
    invitee_email: Array<string>;
}
/**
 * List of values that InvitationStatus can take
 * @export
 * @enum {string}
 */
declare enum InvitationStatus {
    Pending = "PENDING",
    Accepted = "ACCEPTED"
}
/**
 * List of values that InvitationType can take
 * @export
 * @enum {string}
 */
declare enum InvitationType {
    ArrayShare = "ARRAY_SHARE",
    JoinOrganization = "JOIN_ORGANIZATION"
}
/**
 * Information related to last access of an array
 * @export
 * @interface LastAccessedArray
 */
interface LastAccessedArray {
    /**
     * unique ID of array
     * @type {string}
     * @memberof LastAccessedArray
     */
    array_id?: string;
    /**
     * name of the array
     * @type {string}
     * @memberof LastAccessedArray
     */
    array_name?: string;
    /**
     * namespace of a user or organization
     * @type {string}
     * @memberof LastAccessedArray
     */
    namespace?: string;
    /**
     * timestamp (epoch milliseconds) array is last accessed
     * @type {number}
     * @memberof LastAccessedArray
     */
    accessed_time?: number;
    /**
     *
     * @type {ActivityEventType}
     * @memberof LastAccessedArray
     */
    access_type?: ActivityEventType$1;
}
/**
 * Layout of array
 * @export
 * @enum {string}
 */
declare enum Layout$1 {
    RowMajor = "row-major",
    ColMajor = "col-major",
    GlobalOrder = "global-order",
    Unordered = "unordered"
}
/**
 * A user-favorite MLModel item
 * @export
 * @interface MLModelFavorite
 */
interface MLModelFavorite {
    /**
     * unique UUID of the MLModel
     * @type {string}
     * @memberof MLModelFavorite
     */
    mlmodel_uuid?: string;
    /**
     * the namespace of the MLModel
     * @type {string}
     * @memberof MLModelFavorite
     */
    namespace?: string;
    /**
     * the name of the MLModel
     * @type {string}
     * @memberof MLModelFavorite
     */
    name?: string;
}
/**
 * Object including MLModel favorites and pagination metadata
 * @export
 * @interface MLModelFavoritesData
 */
interface MLModelFavoritesData {
    /**
     * List of MLModel infos
     * @type {Array<ArrayInfo>}
     * @memberof MLModelFavoritesData
     */
    mlmodels?: Array<ArrayInfo>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof MLModelFavoritesData
     */
    pagination_metadata?: PaginationMetadata$1;
}
/**
 * a list of max buffer sizes, one per attribute
 * @export
 * @interface MaxBufferSizes
 */
interface MaxBufferSizes {
    /**
     *
     * @type {Array<AttributeBufferSize>}
     * @memberof MaxBufferSizes
     */
    maxBufferSizes?: Array<AttributeBufferSize$1>;
}
/**
 * Represents an open array
 * @export
 * @interface ModelArray
 */
interface ModelArray$1 {
    /**
     * timestamp (epoch milliseconds) array is opened at
     * @type {number}
     * @memberof ModelArray
     */
    timestamp: number;
    /**
     *
     * @type {Querytype}
     * @memberof ModelArray
     */
    queryType: Querytype$1;
    /**
     * Array uri
     * @type {string}
     * @memberof ModelArray
     */
    uri: string;
}
/**
 *
 * @export
 * @interface ModelError
 */
interface ModelError$1 {
    /**
     *
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    request_id?: string;
}
/**
 * User-defined function
 * @export
 * @interface MultiArrayUDF
 */
interface MultiArrayUDF {
    /**
     * name of UDFInfo to run, format is {namespace}/{udf_name}. Can not be used with exec
     * @type {string}
     * @memberof MultiArrayUDF
     */
    udf_info_name?: string;
    /**
     *
     * @type {UDFLanguage}
     * @memberof MultiArrayUDF
     */
    language?: UDFLanguage;
    /**
     * Type-specific version
     * @type {string}
     * @memberof MultiArrayUDF
     */
    version?: string;
    /**
     * Docker image name to use for UDF
     * @type {string}
     * @memberof MultiArrayUDF
     */
    image_name?: string;
    /**
     * The resource class to use for the UDF execution. Resource classes define resource limits for memory and CPUs. If this is empty, then the UDF will execute in the standard resource class of the TileDB Cloud provider.
     * @type {string}
     * @memberof MultiArrayUDF
     */
    resource_class?: string;
    /**
     * Type-specific executable text
     * @type {string}
     * @memberof MultiArrayUDF
     */
    exec?: string;
    /**
     * optional raw text to store of serialized function, used for showing in UI
     * @type {string}
     * @memberof MultiArrayUDF
     */
    exec_raw?: string;
    /**
     *
     * @type {ResultFormat}
     * @memberof MultiArrayUDF
     */
    result_format?: ResultFormat;
    /**
     * name of task, optional
     * @type {string}
     * @memberof MultiArrayUDF
     */
    task_name?: string;
    /**
     * Deprecated: Prefer to use `argument_json` instead. Argument(s) to pass to UDF function, tuple or list of args/kwargs which can be in native or JSON format
     * @type {string}
     * @memberof MultiArrayUDF
     */
    argument?: string;
    /**
     * A series of key-value pairs to be passed as arguments into the UDF. See `TGUDFNodeData.arguments` for more information. If this format is used to pass arguments, arrays will be passed into the UDF as specified by the Node placeholders passed in here, rather than the classic method of putting all array arguments in the first parameter. Either this or `argument` should be set.
     * @type {Array<TGUDFArgument>}
     * @memberof MultiArrayUDF
     */
    arguments_json?: Array<TGUDFArgument> | null;
    /**
     * The UUIDs of stored input parameters (passed in a language-specific format within \"argument\") to be retrieved from the server-side cache. Serialized in standard hex format with no {}.
     * @type {Array<string>}
     * @memberof MultiArrayUDF
     */
    stored_param_uuids?: Array<string>;
    /**
     * store results for later retrieval
     * @type {boolean}
     * @memberof MultiArrayUDF
     */
    store_results?: boolean;
    /**
     * Set to true to avoid downloading the results of this UDF. Useful for intermediate nodes in a task graph where you will not be using the results of your function. Defaults to false (\"yes download results\").
     * @type {boolean}
     * @memberof MultiArrayUDF
     */
    dont_download_results?: boolean;
    /**
     *
     * @type {QueryRanges}
     * @memberof MultiArrayUDF
     */
    ranges?: QueryRanges;
    /**
     *
     * @type {UDFSubarray}
     * @memberof MultiArrayUDF
     */
    subarray?: UDFSubarray;
    /**
     * List of buffers to fetch (attributes + dimensions). Deprecated; please set arrays with `UDFArrayDetails`.
     * @type {Array<string>}
     * @memberof MultiArrayUDF
     */
    buffers?: Array<string>;
    /**
     * Array ranges/buffer into to run UDF on
     * @type {Array<UDFArrayDetails>}
     * @memberof MultiArrayUDF
     */
    arrays?: Array<UDFArrayDetails>;
    /**
     * UDF-type timeout in seconds (default: 900)
     * @type {number}
     * @memberof MultiArrayUDF
     */
    timeout?: number;
    /**
     * If set, the ID of the log for the task graph that this was part of.
     * @type {string}
     * @memberof MultiArrayUDF
     */
    task_graph_uuid?: string;
    /**
     * If set, the client-defined ID of the node within this task\'s graph.
     * @type {string}
     * @memberof MultiArrayUDF
     */
    client_node_uuid?: string;
}
/**
 * actions a user can take on an organization
 * @export
 * @enum {string}
 */
declare enum NamespaceActions {
    Read = "read",
    Write = "write",
    Create = "create",
    Delete = "delete",
    Edit = "edit",
    ReadArrayLogs = "read_array_logs",
    ReadJobLogs = "read_job_logs",
    ReadObjectLogs = "read_object_logs",
    RunJob = "run_job",
    DeleteOrganization = "delete_organization",
    EditOrganization = "edit_organization",
    EditBilling = "edit_billing"
}
/**
 * object representing a non-empty domain
 * @export
 * @interface NonEmptyDomain
 */
interface NonEmptyDomain {
    /**
     *
     * @type {DomainArray}
     * @memberof NonEmptyDomain
     */
    nonEmptyDomain: DomainArray$1;
    /**
     * Is non-empty domain really empty?
     * @type {boolean}
     * @memberof NonEmptyDomain
     */
    isEmpty: boolean;
}
/**
 * Copied notebook uri and information
 * @export
 * @interface NotebookCopied
 */
interface NotebookCopied {
    /**
     * output location of the TileDB Notebook
     * @type {string}
     * @memberof NotebookCopied
     */
    output_uri?: string;
    /**
     * name of the notebook created
     * @type {string}
     * @memberof NotebookCopied
     */
    name?: string;
    /**
     * namespace copied to
     * @type {string}
     * @memberof NotebookCopied
     */
    namespace?: string;
    /**
     * unique ID of the copied notebook
     * @type {string}
     * @memberof NotebookCopied
     */
    id: string;
}
/**
 * Output information required to copy a notebook
 * @export
 * @interface NotebookCopy
 */
interface NotebookCopy {
    /**
     * output location of the TileDB File
     * @type {string}
     * @memberof NotebookCopy
     */
    output_uri?: string;
    /**
     * name to set for registered notebook
     * @type {string}
     * @memberof NotebookCopy
     */
    name?: string;
    /**
     * namespace to copy to
     * @type {string}
     * @memberof NotebookCopy
     */
    namespace?: string;
}
/**
 * A user-favorite notebook item
 * @export
 * @interface NotebookFavorite
 */
interface NotebookFavorite {
    /**
     * unique UUID of the notebook
     * @type {string}
     * @memberof NotebookFavorite
     */
    notebook_uuid?: string;
    /**
     * the namespace of the notebook
     * @type {string}
     * @memberof NotebookFavorite
     */
    namespace?: string;
    /**
     * the name of the notebook
     * @type {string}
     * @memberof NotebookFavorite
     */
    name?: string;
}
/**
 * Object including notebook favorites and pagination metadata
 * @export
 * @interface NotebookFavoritesData
 */
interface NotebookFavoritesData {
    /**
     * List of notebook infos
     * @type {Array<ArrayInfo>}
     * @memberof NotebookFavoritesData
     */
    notebooks?: Array<ArrayInfo>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof NotebookFavoritesData
     */
    pagination_metadata?: PaginationMetadata$1;
}
/**
 * Status details of a notebook server
 * @export
 * @interface NotebookStatus
 */
interface NotebookStatus {
    /**
     * namespace of notebook
     * @type {string}
     * @memberof NotebookStatus
     */
    namespace?: string;
    /**
     * duration notebook has been running in seconds
     * @type {number}
     * @memberof NotebookStatus
     */
    uptime?: number;
    /**
     * current cpu usage in millicpu
     * @type {number}
     * @memberof NotebookStatus
     */
    cpu_usage?: number;
    /**
     * memory usage in bytes
     * @type {number}
     * @memberof NotebookStatus
     */
    memory_usage?: number;
    /**
     * memory allocated to notebook server in bytes
     * @type {number}
     * @memberof NotebookStatus
     */
    memory_limit?: number;
    /**
     * storage usage in bytes
     * @type {number}
     * @memberof NotebookStatus
     */
    storage_usage?: number;
    /**
     * storage allocated to notebook server in bytes
     * @type {number}
     * @memberof NotebookStatus
     */
    storage_limit?: number;
    /**
     * millicpu allocated to notebook server
     * @type {number}
     * @memberof NotebookStatus
     */
    cpu_count?: number;
}
/**
 * Organization
 * @export
 * @interface Organization
 */
interface Organization {
    /**
     * unique ID of organization
     * @type {string}
     * @memberof Organization
     */
    id?: string;
    /**
     *
     * @type {OrganizationRoles}
     * @memberof Organization
     */
    role?: OrganizationRoles;
    /**
     * organization name must be unique
     * @type {string}
     * @memberof Organization
     */
    name: string;
    /**
     * Datetime organization was created in UTC
     * @type {string}
     * @memberof Organization
     */
    created_at?: string;
    /**
     * Datetime organization was updated in UTC
     * @type {string}
     * @memberof Organization
     */
    updated_at?: string;
    /**
     * Organization logo
     * @type {string}
     * @memberof Organization
     */
    logo?: string | null;
    /**
     * Organization description
     * @type {string}
     * @memberof Organization
     */
    description?: string | null;
    /**
     *
     * @type {Array<OrganizationUser>}
     * @memberof Organization
     */
    users?: Array<OrganizationUser>;
    /**
     * list of actions user is allowed to do on this organization
     * @type {Array<NamespaceActions>}
     * @memberof Organization
     */
    allowed_actions?: Array<NamespaceActions>;
    /**
     * number of registered arrays for this organization
     * @type {number}
     * @memberof Organization
     */
    num_of_arrays?: number;
    /**
     * List of extra/optional/beta features to enable for namespace
     * @type {Array<string>}
     * @memberof Organization
     */
    enabled_features?: Array<string>;
    /**
     * A notice that the user has an unpaid subscription
     * @type {boolean}
     * @memberof Organization
     */
    unpaid_subscription?: boolean;
    /**
     * The default location to store newly-created notebooks and other assets like UDFs. The name `default_s3_path` is a legacy holdover; it may refer to any supported storage location.
     * @type {string}
     * @memberof Organization
     */
    default_s3_path?: string;
    /**
     * The name of the credentials used to create and access files in the `default_s3_path`, if needed.
     * @type {string}
     * @memberof Organization
     */
    default_s3_path_credentials_name?: string;
    /**
     *
     * @type {AssetLocations}
     * @memberof Organization
     */
    asset_locations?: AssetLocations;
    /**
     * Denotes that the organization is able to apply pricing to arrays by means of Stripe Connect
     * @type {boolean}
     * @memberof Organization
     */
    stripe_connect?: boolean;
}
/**
 * role user has in organization
 * @export
 * @enum {string}
 */
declare enum OrganizationRoles {
    Owner = "owner",
    Admin = "admin",
    ReadWrite = "read_write",
    ReadOnly = "read_only"
}
/**
 * user in an organization
 * @export
 * @interface OrganizationUser
 */
interface OrganizationUser {
    /**
     * unique ID of user
     * @type {string}
     * @memberof OrganizationUser
     */
    user_id?: string;
    /**
     * unique ID of organization
     * @type {string}
     * @memberof OrganizationUser
     */
    organization_id?: string;
    /**
     * username for user
     * @type {string}
     * @memberof OrganizationUser
     */
    username?: string;
    /**
     * name of organization
     * @type {string}
     * @memberof OrganizationUser
     */
    organization_name?: string;
    /**
     *
     * @type {OrganizationRoles}
     * @memberof OrganizationUser
     */
    role?: OrganizationRoles;
    /**
     * list of actions user is allowed to do on this organization
     * @type {Array<NamespaceActions>}
     * @memberof OrganizationUser
     */
    allowed_actions?: Array<NamespaceActions>;
}
/**
 *
 * @export
 * @interface PaginationMetadata
 */
interface PaginationMetadata$1 {
    /**
     * pagination offset. Use it to skip the first ((page - 1) * per_page) items
     * @type {number}
     * @memberof PaginationMetadata
     */
    page?: number;
    /**
     * pagination limit (page size)
     * @type {number}
     * @memberof PaginationMetadata
     */
    per_page?: number;
    /**
     * number of total pages with current limit
     * @type {number}
     * @memberof PaginationMetadata
     */
    total_pages?: number;
    /**
     * number of total available items
     * @type {number}
     * @memberof PaginationMetadata
     */
    total_items?: number;
}
/**
 * Pricing created by converting an array to product
 * @export
 * @interface Pricing
 */
interface Pricing {
    /**
     * Unique ID of plan as defined by Stripe
     * @type {string}
     * @memberof Pricing
     */
    id?: string;
    /**
     * Unique ID of registered array
     * @type {string}
     * @memberof Pricing
     */
    array_uuid?: string;
    /**
     * Name of pricing
     * @type {string}
     * @memberof Pricing
     */
    pricing_name?: string;
    /**
     *
     * @type {PricingType}
     * @memberof Pricing
     */
    pricing_type?: PricingType;
    /**
     * Name of product
     * @type {string}
     * @memberof Pricing
     */
    product_name?: string;
    /**
     * Extra information about a product which will appear on the credit card statement of the customer
     * @type {string}
     * @memberof Pricing
     */
    product_statement_descriptor?: string;
    /**
     *
     * @type {PricingUnitLabel}
     * @memberof Pricing
     */
    product_unit_label?: PricingUnitLabel;
    /**
     *
     * @type {PricingCurrency}
     * @memberof Pricing
     */
    currency?: PricingCurrency;
    /**
     *
     * @type {PricingAggregateUsage}
     * @memberof Pricing
     */
    aggregate_usage?: PricingAggregateUsage;
    /**
     *
     * @type {PricingInterval}
     * @memberof Pricing
     */
    interval?: PricingInterval;
    /**
     * Group of n product unit labels
     * @type {number}
     * @memberof Pricing
     */
    divided_by?: number;
    /**
     * Price in cents (decimal) per unitlabel
     * @type {number}
     * @memberof Pricing
     */
    charge?: number;
    /**
     * If pricing is activated
     * @type {boolean}
     * @memberof Pricing
     */
    activated?: boolean;
}
/**
 * Specifies a usage aggregation strategy for pricings of usage_type=metered
 * @export
 * @enum {string}
 */
declare enum PricingAggregateUsage {
    Sum = "sum"
}
/**
 * Currency of pricing
 * @export
 * @enum {string}
 */
declare enum PricingCurrency {
    Usd = "USD"
}
/**
 * Interval for pricing
 * @export
 * @enum {string}
 */
declare enum PricingInterval {
    Month = "month"
}
/**
 * Pricing types
 * @export
 * @enum {string}
 */
declare enum PricingType {
    Egress = "egress",
    Access = "access"
}
/**
 * Unit label
 * @export
 * @enum {string}
 */
declare enum PricingUnitLabel {
    Byte = "byte",
    Second = "second"
}
/**
 * Query parameter to get array metadatas
 * @export
 * @enum {string}
 */
declare enum PublicShareFilter {
    Exclude = "exclude",
    Only = "only"
}
/**
 *
 * @export
 * @interface Query
 */
interface Query$1 {
    /**
     *
     * @type {Querytype}
     * @memberof Query
     */
    type: Querytype$1;
    /**
     *
     * @type {Layout}
     * @memberof Query
     */
    layout: Layout$1;
    /**
     *
     * @type {Querystatus}
     * @memberof Query
     */
    status: Querystatus$1;
    /**
     * List of attribute buffer headers
     * @type {Array<AttributeBufferHeader>}
     * @memberof Query
     */
    attributeBufferHeaders: Array<AttributeBufferHeader$1>;
    /**
     *
     * @type {Writer}
     * @memberof Query
     */
    writer?: Writer$1;
    /**
     *
     * @type {QueryReader}
     * @memberof Query
     */
    reader?: QueryReader$1;
    /**
     *
     * @type {any}
     * @memberof Query
     */
    array: any;
    /**
     * Total number of bytes in fixed size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalFixedLengthBufferBytes: number;
    /**
     * Total number of bytes in variable size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalVarLenBufferBytes: number;
}
/**
 * Query returning results as JSON
 * @export
 * @interface QueryJson
 */
interface QueryJson {
    /**
     *
     * @type {QueryRanges}
     * @memberof QueryJson
     */
    query_ranges?: QueryRanges;
    /**
     * List of fields to return data from, empty means return data for all fields
     * @type {Array<string>}
     * @memberof QueryJson
     */
    fields?: Array<string>;
}
/**
 * Subarray bounds to query
 * @export
 * @interface QueryRanges
 */
interface QueryRanges {
    /**
     *
     * @type {Layout}
     * @memberof QueryRanges
     */
    layout?: Layout$1;
    /**
     * List of ranges,
     * @type {Array<Array<number>>}
     * @memberof QueryRanges
     */
    ranges?: Array<Array<number>>;
}
/**
 * Read struct (can\'t be called reader due to class name conflict)
 * @export
 * @interface QueryReader
 */
interface QueryReader$1 {
    /**
     *
     * @type {Layout}
     * @memberof QueryReader
     */
    layout?: Layout$1;
    /**
     *
     * @type {Subarray}
     * @memberof QueryReader
     */
    subarray?: Subarray$1;
    /**
     *
     * @type {ReadState}
     * @memberof QueryReader
     */
    readState?: ReadState$1;
    /**
     * The offsets format (bytes or elements) to be used.
     * @type {string}
     * @memberof QueryReader
     */
    varOffsetsMode?: string;
    /**
     * True if an extra element will be added to the end of the offsets buffer.
     * @type {boolean}
     * @memberof QueryReader
     */
    varOffsetsAddExtraElement?: boolean;
    /**
     * The offsets bitsize (32 or 64) to be used.
     * @type {number}
     * @memberof QueryReader
     */
    varOffsetsBitsize?: number;
}
/**
 * Status of query
 * @export
 * @enum {string}
 */
declare enum Querystatus$1 {
    Failed = "FAILED",
    Completed = "COMPLETED",
    Inprogress = "INPROGRESS",
    Incomplete = "INCOMPLETE",
    Uninitialized = "UNINITIALIZED"
}
/**
 * Type of query
 * @export
 * @enum {string}
 */
declare enum Querytype$1 {
    Read = "READ",
    Write = "WRITE"
}
/**
 * state for reads
 * @export
 * @interface ReadState
 */
interface ReadState$1 {
    /**
     * True if the reader has been initialized.
     * @type {boolean}
     * @memberof ReadState
     */
    initialized?: boolean;
    /**
     * True if the query produced results that could not fit in some buffer.
     * @type {boolean}
     * @memberof ReadState
     */
    overflowed?: boolean;
    /**
     * True if the current subarray partition is unsplittable.
     * @type {boolean}
     * @memberof ReadState
     */
    unsplittable?: boolean;
    /**
     *
     * @type {SubarrayPartitioner}
     * @memberof ReadState
     */
    subarrayPartitioner?: SubarrayPartitioner$1;
}
/**
 * The structure and metadata of a task graph that can be stored on TileDB Cloud and executed by users who have access to it.
 * @export
 * @interface RegisteredTaskGraph
 */
interface RegisteredTaskGraph {
    /**
     * A server-assigned unique ID for the UDF, in UUID format.
     * @type {string}
     * @memberof RegisteredTaskGraph
     */
    uuid?: string;
    /**
     * The namespace that owns this task graph log.
     * @type {string}
     * @memberof RegisteredTaskGraph
     */
    namespace?: string;
    /**
     * The name of this graph, to appear in URLs. Must be unique per-namespace.
     * @type {string}
     * @memberof RegisteredTaskGraph
     */
    name?: string;
    /**
     * Documentation for the task graph, in Markdown format.
     * @type {string}
     * @memberof RegisteredTaskGraph
     */
    readme?: string;
    /**
     * SPDX license identifier.
     * @type {string}
     * @memberof RegisteredTaskGraph
     */
    license_id?: string | null;
    /**
     * Full text of the license.
     * @type {string}
     * @memberof RegisteredTaskGraph
     */
    license_text?: string | null;
    /**
     * Optional tags to classify the graph.
     * @type {Array<string>}
     * @memberof RegisteredTaskGraph
     */
    tags?: Array<string>;
    /**
     * The structure of the graph, in the form of the nodes that make it up. As with `TaskGraphLog`, nodes must topologically sorted, so that any node appears after all the nodes it depends on.
     * @type {Array<RegisteredTaskGraphNode>}
     * @memberof RegisteredTaskGraph
     */
    nodes?: Array<RegisteredTaskGraphNode>;
}
/**
 * Information about a single node within a registered task graph. A single node represents one piece of data or a computational step; either as an input value, a data source, or a computation that acts upon earlier nodes. The structure parallels the existing `TaskGraphNodeMetadata`.
 * @export
 * @interface RegisteredTaskGraphNode
 */
interface RegisteredTaskGraphNode {
    /**
     * The client-generated UUID of the given graph node.
     * @type {string}
     * @memberof RegisteredTaskGraphNode
     */
    client_node_id?: string;
    /**
     * A client-specified name for the node. If provided, this must be unique.
     * @type {string}
     * @memberof RegisteredTaskGraphNode
     */
    name?: string | null;
    /**
     * The client_node_uuid of each node that this node depends upon. Used to define the structure of the graph.
     * @type {Array<string>}
     * @memberof RegisteredTaskGraphNode
     */
    depends_on?: Array<string>;
    /**
     *
     * @type {UDFArrayDetails}
     * @memberof RegisteredTaskGraphNode
     */
    array_node?: UDFArrayDetails;
    /**
     *
     * @type {TGInputNodeData}
     * @memberof RegisteredTaskGraphNode
     */
    input_node?: TGInputNodeData | null;
    /**
     *
     * @type {TGSQLNodeData}
     * @memberof RegisteredTaskGraphNode
     */
    sql_node?: TGSQLNodeData | null;
    /**
     *
     * @type {TGUDFNodeData}
     * @memberof RegisteredTaskGraphNode
     */
    udf_node?: TGUDFNodeData | null;
}
/**
 * Data format of a result
 * @export
 * @enum {string}
 */
declare enum ResultFormat {
    PythonPickle = "python_pickle",
    RSerialization = "r_serialization",
    Json = "json",
    Arrow = "arrow",
    Bytes = "bytes",
    TiledbJson = "tiledb_json",
    Native = "native"
}
/**
 * Parameters for running sql query
 * @export
 * @interface SQLParameters
 */
interface SQLParameters {
    /**
     * name of task, optional
     * @type {string}
     * @memberof SQLParameters
     */
    name?: string;
    /**
     * query to run
     * @type {string}
     * @memberof SQLParameters
     */
    query?: string;
    /**
     * Output array uri
     * @type {string}
     * @memberof SQLParameters
     */
    output_uri?: string;
    /**
     * store results for later retrieval
     * @type {boolean}
     * @memberof SQLParameters
     */
    store_results?: boolean;
    /**
     * Set to true to avoid downloading the results of this UDF. Useful for intermediate nodes in a task graph where you will not be using the results of your function. Defaults to false (\"yes download results\").
     * @type {boolean}
     * @memberof SQLParameters
     */
    dont_download_results?: boolean;
    /**
     * The resource class to use for the SQL execution. Resource classes define resource limits for memory and CPUs. If this is empty, then the SQL will execute in the standard resource class of the TileDB Cloud provider.
     * @type {string}
     * @memberof SQLParameters
     */
    resource_class?: string;
    /**
     *
     * @type {ResultFormat}
     * @memberof SQLParameters
     */
    result_format?: ResultFormat;
    /**
     * Queries or commands to run before main query
     * @type {Array<string>}
     * @memberof SQLParameters
     */
    init_commands?: Array<string>;
    /**
     * SQL query parameters
     * @type {Array<object>}
     * @memberof SQLParameters
     */
    parameters?: Array<object>;
    /**
     * If set, the ID of the log for the task graph that this was part of.
     * @type {string}
     * @memberof SQLParameters
     */
    task_graph_uuid?: string;
    /**
     * If set, the client-defined ID of the node within this task\'s graph.
     * @type {string}
     * @memberof SQLParameters
     */
    client_node_uuid?: string;
}
/**
 * Single sign on provider
 * @export
 * @enum {string}
 */
declare enum SSOProvider {
    Github = "github",
    Google = "google",
    Stripe = "stripe",
    Okta = "okta"
}
/**
 * The path at which a given asset will be stored, and the credentials used to access that asset.
 * @export
 * @interface StorageLocation
 */
interface StorageLocation {
    /**
     * The path to store this asset type. If unset, a suffix of the user\'s `default_s3_path` is used. When updating, explicitly set to `\"\"`, the empty string, to clear this path; leaving it `null` (or absent) will leave the path unchanged.
     * @type {string}
     * @memberof StorageLocation
     */
    path?: string | null;
    /**
     * The name of the credentials used to acess this storage path. If unset, the `default_s3_path_credentials_name` is used. When updating, explicitly set to `\"\"`, the empty string, to clear this name; leaving it `null` (or absent) will leave the name unchanged.
     * @type {string}
     * @memberof StorageLocation
     */
    credentials_name?: string | null;
}
/**
 * A Subarray
 * @export
 * @interface Subarray
 */
interface Subarray$1 {
    /**
     *
     * @type {Layout}
     * @memberof Subarray
     */
    layout?: Layout$1;
    /**
     * List of 1D ranges, one per dimension
     * @type {Array<SubarrayRanges>}
     * @memberof Subarray
     */
    ranges?: Array<SubarrayRanges$1>;
}
/**
 * The subarray partitioner
 * @export
 * @interface SubarrayPartitioner
 */
interface SubarrayPartitioner$1 {
    /**
     *
     * @type {Subarray}
     * @memberof SubarrayPartitioner
     */
    subarray?: Subarray$1;
    /**
     * Result size budget (in bytes) for all attributes.
     * @type {Array<AttributeBufferSize>}
     * @memberof SubarrayPartitioner
     */
    budget?: Array<AttributeBufferSize$1>;
    /**
     *
     * @type {SubarrayPartitionerCurrent}
     * @memberof SubarrayPartitioner
     */
    current?: SubarrayPartitionerCurrent$1;
    /**
     *
     * @type {SubarrayPartitionerState}
     * @memberof SubarrayPartitioner
     */
    state?: SubarrayPartitionerState$1;
    /**
     * The memory budget for the fixed-sized attributes and the offsets of the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudget?: number;
    /**
     * The memory budget for the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudgetVar?: number;
}
/**
 * The current partition info
 * @export
 * @interface SubarrayPartitionerCurrent
 */
interface SubarrayPartitionerCurrent$1 {
    /**
     *
     * @type {Subarray}
     * @memberof SubarrayPartitionerCurrent
     */
    subarray?: Subarray$1;
    /**
     * PartitionInfo start
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    start?: number;
    /**
     * PartitionInfo end
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    end?: number;
    /**
     * PartitionInfo splitMultiRange
     * @type {boolean}
     * @memberof SubarrayPartitionerCurrent
     */
    splitMultiRange?: boolean;
}
/**
 * The state information for the remaining partitions to be produced
 * @export
 * @interface SubarrayPartitionerState
 */
interface SubarrayPartitionerState$1 {
    /**
     * State start
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    start?: number;
    /**
     * State end
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    end?: number;
    /**
     * State singleRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    singleRange?: Array<Subarray$1>;
    /**
     * State multiRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    multiRange?: Array<Subarray$1>;
}
/**
 * A set of 1D ranges for a subarray
 * @export
 * @interface SubarrayRanges
 */
interface SubarrayRanges$1 {
    /**
     *
     * @type {Datatype}
     * @memberof SubarrayRanges
     */
    type?: Datatype$1;
    /**
     * True if the range is the default range
     * @type {boolean}
     * @memberof SubarrayRanges
     */
    hasDefaultRange?: boolean;
    /**
     * The bytes of the ranges
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    buffer?: Array<number>;
}
/**
 * Subscription of a user (customer) to another user\'s arrays
 * @export
 * @interface Subscription
 */
interface Subscription {
    /**
     * Unique ID of subscription as defined by Stripe
     * @type {string}
     * @memberof Subscription
     */
    id?: string;
    /**
     * Unique ID of the array (product) owner
     * @type {string}
     * @memberof Subscription
     */
    owner_namespace_uuid?: string;
    /**
     * Unique ID of the array (product) user (customer)
     * @type {string}
     * @memberof Subscription
     */
    customer_namespace_uuid?: string;
    /**
     * list of pricing used by this subscription
     * @type {Array<Pricing>}
     * @memberof Subscription
     */
    pricing?: Array<Pricing>;
}
/**
 * Specifies that a node is an “input value”, allowing for parameterized task graphs. An input node may not depend upon any other nodes.
 * @export
 * @interface TGInputNodeData
 */
interface TGInputNodeData {
    /**
     * An argument provided to a node. This is one of a direct value (i.e., a raw JSON value) or a `TGSentinel`. For example this Python value:      {\"a\": [1, \"pipe\", range(30), None], \"b\": b\"bytes\"}  is encoded thusly (with included comments):      {  // A dictionary with string keys is JSON-encodable.       \"a\": [  // As is a list.         1,         \"pipe\",         {  // A `range` is replaced with its pickle.           \"__tdbudf__\": \"immediate\",           \"format\": \"python_pickle\",           \"base64_data\": \"gASVIAAAAAAAAACMCGJ1aWx0aW5zlIwFcmFuZ2WUk5RLAEseSwGHlFKULg==\"         },         null       ],       \"b\": {  // Raw binary data is encoded into base64.         \"__tdbudf__\": \"immediate\"         \"format\": \"bytes\",         \"base64_data\": \"Ynl0ZXM=\"       }     }
     * @type {object}
     * @memberof TGInputNodeData
     */
    default_value?: object;
    /**
     * An annotation of what datatype this node is supposed to be. Conventionally, this is a Python-format type annotation, but it’s purely for documentation purposes and not validated.
     * @type {string}
     * @memberof TGInputNodeData
     */
    datatype?: string | null;
}
/**
 * A node specifying an SQL query to execute in TileDB Cloud.
 * @export
 * @interface TGSQLNodeData
 */
interface TGSQLNodeData {
    /**
     * The commands to execute before running the query itself.
     * @type {Array<string>}
     * @memberof TGSQLNodeData
     */
    init_commands?: Array<string>;
    /**
     * The text of the SQL query to execute. Parameters are substituted in for `?`s, just as in a regular MariaDB query.
     * @type {string}
     * @memberof TGSQLNodeData
     */
    query?: string;
    /**
     * The parameters to substitute in for arguments in the `query`. Fixed-length. Arguments must be in JSON format.
     * @type {Array<object>}
     * @memberof TGSQLNodeData
     */
    parameters?: Array<object>;
    /**
     *
     * @type {ResultFormat}
     * @memberof TGSQLNodeData
     */
    result_format?: ResultFormat;
    /**
     * If set, the non-default namespace to execute this SQL query under.
     * @type {string}
     * @memberof TGSQLNodeData
     */
    namespace?: string | null;
}
/**
 * A single argument to a UDF. This may represent a positional argument or a named argument, depending upon whether `name` is set.
 * @export
 * @interface TGUDFArgument
 */
interface TGUDFArgument {
    /**
     * The name of the argument, if present.
     * @type {string}
     * @memberof TGUDFArgument
     */
    name?: string | null;
    /**
     * An argument provided to a node. This is one of a direct value (i.e., a raw JSON value) or a `TGSentinel`. For example this Python value:      {\"a\": [1, \"pipe\", range(30), None], \"b\": b\"bytes\"}  is encoded thusly (with included comments):      {  // A dictionary with string keys is JSON-encodable.       \"a\": [  // As is a list.         1,         \"pipe\",         {  // A `range` is replaced with its pickle.           \"__tdbudf__\": \"immediate\",           \"format\": \"python_pickle\",           \"base64_data\": \"gASVIAAAAAAAAACMCGJ1aWx0aW5zlIwFcmFuZ2WUk5RLAEseSwGHlFKULg==\"         },         null       ],       \"b\": {  // Raw binary data is encoded into base64.         \"__tdbudf__\": \"immediate\"         \"format\": \"bytes\",         \"base64_data\": \"Ynl0ZXM=\"       }     }
     * @type {object}
     * @memberof TGUDFArgument
     */
    value?: object;
}
/**
 * Metadata about the environment where we want to execute a UDF.
 * @export
 * @interface TGUDFEnvironment
 */
interface TGUDFEnvironment {
    /**
     *
     * @type {UDFLanguage}
     * @memberof TGUDFEnvironment
     */
    language?: UDFLanguage;
    /**
     * The language version used to execute this UDF. Neither this nor `language` needs to be set for registered UDFs, since the language and version are stored server-side with the UDF itself.
     * @type {string}
     * @memberof TGUDFEnvironment
     */
    language_version?: string;
    /**
     * The name of the image to use for the execution environment.
     * @type {string}
     * @memberof TGUDFEnvironment
     */
    image_name?: string;
    /**
     * If set, the non-default namespace to execute this UDF under (and to query any Array Nodes that are used as inputs to this UDF).
     * @type {string}
     * @memberof TGUDFEnvironment
     */
    namespace?: string | null;
    /**
     * The resource class to use for the UDF execution. Resource classes define resource limits for memory and CPUs. If this is empty, then the UDF will execute in the standard resource class of the TileDB Cloud provider.
     * @type {string}
     * @memberof TGUDFEnvironment
     */
    resource_class?: string;
    /**
     * A hint that, if possible, this function should be executed on the client side rather than on the server. Registered UDFs and functions which take arrays as inputs can never be executed client-side. If the client’s environment is incompatible, or the client does not support client-side execution, the function will be executed on the server.
     * @type {boolean}
     * @memberof TGUDFEnvironment
     */
    run_client_side?: boolean;
}
/**
 * A node specifying the execution of a user-defined function.
 * @export
 * @interface TGUDFNodeData
 */
interface TGUDFNodeData {
    /**
     * If set, the name of the registered UDF to execute, in the format `namespace/name`. Either this or `executable_code` should be set, but not both.
     * @type {string}
     * @memberof TGUDFNodeData
     */
    registered_udf_name?: string | null;
    /**
     * If set, the base64 serialization of the code for this step, encoded in a language-specific format (e.g. Pickle for Python, serialization for R).
     * @type {string}
     * @memberof TGUDFNodeData
     */
    executable_code?: string | null;
    /**
     * Optionally, the source text for the code passed in `executable_code`. *For reference only; only the code in `executable_code` is actually executed.* This will be included in activity logs and may be useful for debugging.
     * @type {string}
     * @memberof TGUDFNodeData
     */
    source_text?: string;
    /**
     *
     * @type {TGUDFEnvironment}
     * @memberof TGUDFNodeData
     */
    environment?: TGUDFEnvironment;
    /**
     * The arguments to a UDF function. This encompasses both named and positional arguments. The format is designed to provide compatibility across languages like Python which have a fairly traditional split between positional arguments and named arguments, and languages like R which has a rather unique way of specifying arguments. For Python (and most other languages), all positional arguments will come before all named arguments (if any are present):      // fn(arg1, arg2, arg3)     [       {value: arg1},       {value: arg2},       {value: arg3},     ]     // fn(arg1, arg2, n=kw1, a=kw2)     [       {value: arg1},       {value: arg2},       {name: \"n\", value: kw1},       {name: \"a\", value: kw2},     ]     // fn(kw=k1, only=k2)     [       {name: \"kw\", value: k1},       {name: \"only\", value: k2},     ]  However, in R, named and positional arguments may be intermixed freely:      // fn(arg, n=kw1, arg2)     [       {value: arg},       {name: \"n\", value: kw1},       {value: arg2},     ]
     * @type {Array<TGUDFArgument>}
     * @memberof TGUDFNodeData
     */
    arguments?: Array<TGUDFArgument>;
    /**
     *
     * @type {ResultFormat}
     * @memberof TGUDFNodeData
     */
    result_format?: ResultFormat;
}
/**
 * actions a user can take on a UDF
 * @export
 * @enum {string}
 */
declare enum TaskGraphActions {
    FetchTaskGraph = "fetch_task_graph",
    ShareTaskGraph = "share_task_graph"
}
/**
 * A report of the execution status of a node that ran on the client side.
 * @export
 * @interface TaskGraphClientNodeStatus
 */
interface TaskGraphClientNodeStatus {
    /**
     *
     * @type {string}
     * @memberof TaskGraphClientNodeStatus
     */
    client_node_uuid?: string;
    /**
     *
     * @type {ArrayTaskStatus}
     * @memberof TaskGraphClientNodeStatus
     */
    status?: ArrayTaskStatus;
}
/**
 * Logging information about the execution of a task graph.
 * @export
 * @interface TaskGraphLog
 */
interface TaskGraphLog {
    /**
     * The server-generated UUID of the task graph.
     * @type {string}
     * @memberof TaskGraphLog
     */
    uuid?: string;
    /**
     * The namespace that owns this task graph log. When creating a task graph log, this is used as the namespace to create the log in; thereafter it is read-only.
     * @type {string}
     * @memberof TaskGraphLog
     */
    namespace?: string;
    /**
     * The name of the user who created this task graph log.
     * @type {string}
     * @memberof TaskGraphLog
     */
    created_by?: string;
    /**
     * A name for this task graph log, displayed in the UI. Does not need to be unique.
     * @type {string}
     * @memberof TaskGraphLog
     */
    name?: string;
    /**
     * The date/time when this task graph log was originally created. This is distinct from the execution start_time.
     * @type {string}
     * @memberof TaskGraphLog
     */
    created_at?: string;
    /**
     * The start time of the task graph, recorded when the server starts executing the first node.
     * @type {string}
     * @memberof TaskGraphLog
     */
    start_time?: string | null;
    /**
     * The end time of the task graph, recorded when the client reports completion.
     * @type {string}
     * @memberof TaskGraphLog
     */
    end_time?: string | null;
    /**
     *
     * @type {TaskGraphLogStatus}
     * @memberof TaskGraphLog
     */
    status?: TaskGraphLogStatus;
    /**
     * If present, the total cost of executing all nodes in this task graph.
     * @type {number}
     * @memberof TaskGraphLog
     */
    total_cost?: number | null;
    /**
     * If present, the total cost of access from execution of the nodes in this task graph.
     * @type {number}
     * @memberof TaskGraphLog
     */
    access_cost?: number | null;
    /**
     * If present, the total cost of access from execution of the nodes in this task graph.
     * @type {number}
     * @memberof TaskGraphLog
     */
    egress_cost?: number | null;
    /**
     * The total execution time of all the nodes in this graph, in ISO 8601 format with hours, minutes, and seconds.
     * @type {string}
     * @memberof TaskGraphLog
     */
    execution_time?: string;
    /**
     * A mapping from `ArrayTaskStatus` string value to the number of nodes in this graph that are in that status.
     * @type {{ [key: string]: number; }}
     * @memberof TaskGraphLog
     */
    status_count?: {
        [key: string]: number;
    };
    /**
     * The structure of the graph. This is provided by the client when first setting up the task graph. Thereafter, it is read-only. This must be topographically sorted; that is, each node must appear after all nodes that it depends upon.
     * @type {Array<TaskGraphNodeMetadata>}
     * @memberof TaskGraphLog
     */
    nodes?: Array<TaskGraphNodeMetadata>;
}
/**
 * The location where an individual node of a task graph is executed.
 * @export
 * @enum {string}
 */
declare enum TaskGraphLogRunLocation {
    Server = "server",
    Client = "client",
    Virtual = "virtual"
}
/**
 * The status of a given task graph execution.
 * @export
 * @enum {string}
 */
declare enum TaskGraphLogStatus {
    Submitted = "submitted",
    Running = "running",
    Idle = "idle",
    Abandoned = "abandoned",
    Succeeded = "succeeded",
    Failed = "failed",
    Cancelled = "cancelled"
}
/**
 * Response data for a task graph list, including pagination metadata.
 * @export
 * @interface TaskGraphLogsData
 */
interface TaskGraphLogsData {
    /**
     * The requested task graph logs.
     * @type {Array<TaskGraphLog>}
     * @memberof TaskGraphLogsData
     */
    task_graph_logs?: Array<TaskGraphLog>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof TaskGraphLogsData
     */
    pagination_metadata?: PaginationMetadata$1;
}
/**
 * Metadata about an individual node in a task graph.
 * @export
 * @interface TaskGraphNodeMetadata
 */
interface TaskGraphNodeMetadata {
    /**
     * The client-generated UUID of the given graph node.
     * @type {string}
     * @memberof TaskGraphNodeMetadata
     */
    client_node_uuid?: string;
    /**
     * The client-generated name of the node. This is not guaranteed to be unique.
     * @type {string}
     * @memberof TaskGraphNodeMetadata
     */
    name?: string;
    /**
     * The client_node_uuid of each node that this node depends upon. Used to define the structure of the graph.
     * @type {Array<string>}
     * @memberof TaskGraphNodeMetadata
     */
    depends_on?: Array<string>;
    /**
     *
     * @type {TaskGraphLogRunLocation}
     * @memberof TaskGraphNodeMetadata
     */
    run_location?: TaskGraphLogRunLocation;
    /**
     *
     * @type {ArrayTaskStatus}
     * @memberof TaskGraphNodeMetadata
     */
    status?: ArrayTaskStatus;
    /**
     * ArrayTasks representing each execution attempt for this node. For nodes that have never been submitted, this will be empty. For nodes that have been retried, this may have multiple entries. The last one in the list represents the most recent execution. This is read-only and generated by the server based on the tasks it has actually executed.
     * @type {Array<ArrayTask>}
     * @memberof TaskGraphNodeMetadata
     */
    executions?: Array<ArrayTask>;
}
/**
 * details for sharing a given registered task graph
 * @export
 * @interface TaskGraphSharing
 */
interface TaskGraphSharing {
    /**
     * List of permitted actions
     * @type {Array<TaskGraphActions>}
     * @memberof TaskGraphSharing
     */
    actions?: Array<TaskGraphActions>;
    /**
     * namespace being granted array access can be a user or organization
     * @type {string}
     * @memberof TaskGraphSharing
     */
    namespace?: string;
    /**
     * details on if the namespace is a organization or user
     * @type {string}
     * @memberof TaskGraphSharing
     */
    namespace_type?: string;
}
/**
 * user\'s TileDB config
 * @export
 * @interface TileDBConfig
 */
interface TileDBConfig$1 {
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof TileDBConfig
     */
    configs?: {
        [key: string]: string;
    };
}
/**
 * A api token and its metadata
 * @export
 * @interface Token
 */
interface Token {
    /**
     * A api token
     * @type {string}
     * @memberof Token
     */
    token?: string;
    /**
     * Name of token to revoke
     * @type {string}
     * @memberof Token
     */
    name?: string;
    /**
     * datetime the token was created
     * @type {string}
     * @memberof Token
     */
    issued_at?: string;
    /**
     * datetime the token when token will expire
     * @type {string}
     * @memberof Token
     */
    expires_at?: string;
    /**
     * Optional scope to limit token, defaults to all permissions, current supported values are password_reset or *
     * @type {string}
     * @memberof Token
     */
    scope?: string;
}
/**
 * A request from a user for an api token
 * @export
 * @interface TokenRequest
 */
interface TokenRequest {
    /**
     * Expiration date for token, if empty token defaults to 30 minutes
     * @type {string}
     * @memberof TokenRequest
     */
    expires?: string;
    /**
     * Optional name for token, if the name already exists for the user it will be auto incremented (i.e. myToken-1)
     * @type {string}
     * @memberof TokenRequest
     */
    name?: string;
    /**
     * Optional scope to limit token, defaults to all permissions, current supported values are password_reset or *
     * @type {string}
     * @memberof TokenRequest
     */
    scope?: string;
}
/**
 * An api token scope available for creation
 * @export
 * @enum {string}
 */
declare enum TokenScope {
    PasswordReset = "password_reset",
    ConfirmEmail = "confirm_email",
    Star = "*",
    Userread = "user:read",
    UserreadWrite = "user:read-write",
    Useradmin = "user:admin",
    Arrayread = "array:read",
    ArrayreadWrite = "array:read-write",
    Arrayadmin = "array:admin",
    Organizationread = "organization:read",
    OrganizationreadWrite = "organization:read-write",
    Organizationadmin = "organization:admin",
    Groupread = "group:read",
    GroupreadWrite = "group:read-write",
    Groupadmin = "group:admin"
}
/**
 * actions a user can take on a UDF
 * @export
 * @enum {string}
 */
declare enum UDFActions {
    FetchUdf = "fetch_udf",
    ShareUdf = "share_udf"
}
/**
 * Contains array details for multi-array query including uri, ranges buffers
 * @export
 * @interface UDFArrayDetails
 */
interface UDFArrayDetails {
    /**
     * An optional client-generated identifier to distinguish between multiple range/buffer requests from the same array in the same call. This may be set for MultiArrayUDFs that use the `argument_json` style of passing arrays.
     * @type {string}
     * @memberof UDFArrayDetails
     */
    parameter_id?: string | null;
    /**
     * array to set ranges and buffers on, must be in tiledb:// format
     * @type {string}
     * @memberof UDFArrayDetails
     */
    uri?: string;
    /**
     *
     * @type {QueryRanges}
     * @memberof UDFArrayDetails
     */
    ranges?: QueryRanges;
    /**
     * List of buffers to fetch (attributes + dimensions)
     * @type {Array<string>}
     * @memberof UDFArrayDetails
     */
    buffers?: Array<string>;
}
/**
 * Copied udf uri and information
 * @export
 * @interface UDFCopied
 */
interface UDFCopied {
    /**
     * output location of the TileDB udf
     * @type {string}
     * @memberof UDFCopied
     */
    output_uri?: string;
    /**
     * namespace of the copied udf
     * @type {string}
     * @memberof UDFCopied
     */
    namespace?: string;
    /**
     * name of the copied udf
     * @type {string}
     * @memberof UDFCopied
     */
    name?: string;
    /**
     * unique ID of the copied udf
     * @type {string}
     * @memberof UDFCopied
     */
    id: string;
}
/**
 * information required to copy a udf
 * @export
 * @interface UDFCopy
 */
interface UDFCopy {
    /**
     * output location of the TileDB File
     * @type {string}
     * @memberof UDFCopy
     */
    output_uri?: string;
    /**
     * namespace to register the copy. If empty use the namespace of the request user
     * @type {string}
     * @memberof UDFCopy
     */
    namespace?: string;
    /**
     * name to set for the copy. If empty use the name as the original udf, if it not already used in the namespace
     * @type {string}
     * @memberof UDFCopy
     */
    name?: string;
}
/**
 * A user-favorite UDF item
 * @export
 * @interface UDFFavorite
 */
interface UDFFavorite {
    /**
     * unique UUID of the UDF
     * @type {string}
     * @memberof UDFFavorite
     */
    udf_uuid?: string;
    /**
     * the namespace of the UDF
     * @type {string}
     * @memberof UDFFavorite
     */
    namespace?: string;
    /**
     * the name of the UDF
     * @type {string}
     * @memberof UDFFavorite
     */
    name?: string;
}
/**
 * Object including UDF favorites and pagination metadata
 * @export
 * @interface UDFFavoritesData
 */
interface UDFFavoritesData {
    /**
     * List of UDF infos
     * @type {Array<ArrayInfo>}
     * @memberof UDFFavoritesData
     */
    udfs?: Array<ArrayInfo>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof UDFFavoritesData
     */
    pagination_metadata?: PaginationMetadata$1;
}
/**
 * Defines a set of images related to a specific name
 * @export
 * @interface UDFImage
 */
interface UDFImage {
    /**
     * Unique ID of set of images
     * @type {string}
     * @memberof UDFImage
     */
    id?: string;
    /**
     * name of UDF
     * @type {string}
     * @memberof UDFImage
     */
    name?: string;
    /**
     *
     * @type {UDFLanguage}
     * @memberof UDFImage
     */
    language?: UDFLanguage;
}
/**
 * Defines an image that belongs to a set of images having a version
 * @export
 * @interface UDFImageVersion
 */
interface UDFImageVersion {
    /**
     * Unique ID of a versioned image
     * @type {string}
     * @memberof UDFImageVersion
     */
    id?: string;
    /**
     * name of UDFImageVersion
     * @type {string}
     * @memberof UDFImageVersion
     */
    name?: string;
    /**
     * Unique ID of the UDF image set
     * @type {string}
     * @memberof UDFImageVersion
     */
    udf_image_uuid?: string;
    /**
     * Uri of docker image related to current entry
     * @type {string}
     * @memberof UDFImageVersion
     */
    docker_image?: string;
    /**
     * Image-specific version
     * @type {number}
     * @memberof UDFImageVersion
     */
    version?: number;
    /**
     * If current image is default version
     * @type {boolean}
     * @memberof UDFImageVersion
     */
    default?: boolean;
    /**
     * If current image is latest version
     * @type {boolean}
     * @memberof UDFImageVersion
     */
    latest?: boolean;
}
/**
 * User-defined function that can persist in db, used and shared multiple times
 * @export
 * @interface UDFInfo
 */
interface UDFInfo {
    /**
     * Unique ID of UDF
     * @type {string}
     * @memberof UDFInfo
     */
    id?: string;
    /**
     * name of UDF
     * @type {string}
     * @memberof UDFInfo
     */
    name?: string;
    /**
     *
     * @type {UDFLanguage}
     * @memberof UDFInfo
     */
    language?: UDFLanguage;
    /**
     *
     * @type {UDFType}
     * @memberof UDFInfo
     */
    type?: UDFType;
    /**
     * Markdown readme of UDFs
     * @type {string}
     * @memberof UDFInfo
     */
    readme?: string;
    /**
     * License identifier from SPDX License List or Custom
     * @type {string}
     * @memberof UDFInfo
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof UDFInfo
     */
    license_text?: string;
    /**
     * optional tags for UDF
     * @type {Array<string>}
     * @memberof UDFInfo
     */
    tags?: Array<string>;
}
/**
 * User-defined function that can persist in db, used and shared multiple times
 * @export
 * @interface UDFInfoUpdate
 */
interface UDFInfoUpdate {
    /**
     * name of UDF
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    name?: string;
    /**
     *
     * @type {UDFLanguage}
     * @memberof UDFInfoUpdate
     */
    language?: UDFLanguage;
    /**
     * Type-specific version
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    version?: string;
    /**
     * Docker image name to use for UDF
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    image_name?: string;
    /**
     *
     * @type {UDFType}
     * @memberof UDFInfoUpdate
     */
    type?: UDFType;
    /**
     * Type-specific executable text
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    exec?: string;
    /**
     * optional raw text to store of serialized function, used for showing in UI
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    exec_raw?: string;
    /**
     * Markdown readme of UDFs
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    readme?: string;
    /**
     * License identifier from SPDX License List or Custom
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    license_text?: string;
    /**
     * optional tags for UDF
     * @type {Array<string>}
     * @memberof UDFInfoUpdate
     */
    tags?: Array<string>;
}
/**
 * UDF Type
 * @export
 * @enum {string}
 */
declare enum UDFLanguage {
    Python = "python",
    R = "r"
}
/**
 * details for sharing a given UDF
 * @export
 * @interface UDFSharing
 */
interface UDFSharing {
    /**
     * List of permitted actions
     * @type {Array<UDFActions>}
     * @memberof UDFSharing
     */
    actions?: Array<UDFActions>;
    /**
     * namespace being granted array access can be a user or organization
     * @type {string}
     * @memberof UDFSharing
     */
    namespace?: string;
    /**
     * details on if the namespace is a organization or user
     * @type {string}
     * @memberof UDFSharing
     */
    namespace_type?: string;
}
/**
 * Subarray bounds to query for a UDF to operate on
 * @export
 * @interface UDFSubarray
 */
interface UDFSubarray {
    /**
     *
     * @type {Layout}
     * @memberof UDFSubarray
     */
    layout?: Layout$1;
    /**
     * List of ranges,
     * @type {Array<UDFSubarrayRange>}
     * @memberof UDFSubarray
     */
    ranges?: Array<UDFSubarrayRange>;
}
/**
 * A dimension range to query
 * @export
 * @interface UDFSubarrayRange
 */
interface UDFSubarrayRange {
    /**
     * The dimension index
     * @type {number}
     * @memberof UDFSubarrayRange
     */
    dimension_id?: number;
    /**
     *
     * @type {DimensionCoordinate}
     * @memberof UDFSubarrayRange
     */
    range_start?: DimensionCoordinate;
    /**
     *
     * @type {DimensionCoordinate}
     * @memberof UDFSubarrayRange
     */
    range_end?: DimensionCoordinate;
}
/**
 * UDF Type
 * @export
 * @enum {string}
 */
declare enum UDFType {
    MultiArray = "multi_array",
    SingleArray = "single_array",
    Generic = "generic"
}
/**
 * User
 * @export
 * @interface User
 */
interface User {
    /**
     * unique ID of user
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * username must be unique
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * password
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * the user\'s full, real name
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * the user\'s email
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * user\'s email is validated to be correct
     * @type {boolean}
     * @memberof User
     */
    is_valid_email?: boolean;
    /**
     * Denotes that the user is able to apply pricing to arrays by means of Stripe Connect
     * @type {boolean}
     * @memberof User
     */
    stripe_connect?: boolean;
    /**
     * the user\'s company
     * @type {string}
     * @memberof User
     */
    company?: string;
    /**
     * the user\'s logo
     * @type {string}
     * @memberof User
     */
    logo?: string | null;
    /**
     * when the user last logged in (set by the server)
     * @type {string}
     * @memberof User
     */
    last_activity_date?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    timezone?: string;
    /**
     * Array of organizations a user is part of and their roles
     * @type {Array<OrganizationUser>}
     * @memberof User
     */
    organizations?: Array<OrganizationUser>;
    /**
     * list of actions user is allowed to do on this organization
     * @type {Array<NamespaceActions>}
     * @memberof User
     */
    allowed_actions?: Array<NamespaceActions>;
    /**
     * List of extra/optional/beta features to enable for namespace
     * @type {Array<string>}
     * @memberof User
     */
    enabled_features?: Array<string>;
    /**
     * A notice that the user has an unpaid subscription
     * @type {boolean}
     * @memberof User
     */
    unpaid_subscription?: boolean;
    /**
     * The default location to store newly-created notebooks and other assets like UDFs. The name `default_s3_path` is a legacy holdover; it may refer to any supported storage location.
     * @type {string}
     * @memberof User
     */
    default_s3_path?: string;
    /**
     * The name of the credentials used to create and access files in the `default_s3_path`, if needed.
     * @type {object}
     * @memberof User
     */
    default_s3_path_credentials_name?: object;
    /**
     *
     * @type {AssetLocations}
     * @memberof User
     */
    asset_locations?: AssetLocations;
    /**
     * Override the default namespace charged for actions when no namespace is specified
     * @type {string}
     * @memberof User
     */
    default_namespace_charged?: string;
}
/**
 *
 * @export
 * @interface Writer
 */
interface Writer$1 {
    /**
     *
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordDups?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordOOB?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Writer
     */
    dedupCoords?: boolean;
    /**
     *
     * @type {DomainArray}
     * @memberof Writer
     */
    subarray?: DomainArray$1;
}
/**
 * ArrayApi - axios parameter creator
 * @export
 */
declare const ArrayApiAxiosParamCreator$1: (configuration?: Configuration$1) => {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task ID To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arrayActivityLog: (namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, hasTaskId?: boolean, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch a list of all arrays that are owned directly by user or user\'s organizations
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserOwnedGet: (page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserOwnedSidebarGet: (options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch a list of all arrays that have been shared publically
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserPublicGet: (page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch a sidebar of all arrays that have been shared publically
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserPublicSidebarGet: (options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {Array<string>} [sharedTo] namespaces to filter results of where there arrays were shared to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserSharedGet: (page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, sharedTo?: Array<string>, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserSharedSidebarGet: (options?: any) => Promise<RequestArgs$1>;
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysNamespaceArrayEndTimestampsGet: (namespace: string, array: string, page?: number, perPage?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     * consolidate an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    consolidateArray: (namespace: string, array: string, tiledbConfig: TileDBConfig$1, options?: any) => Promise<RequestArgs$1>;
    /**
     * create a array schema at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArraySchema} arraySchema ArraySchema being created
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArray: (namespace: string, array: string, contentType: string, arraySchema: ArraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * delete a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArray: (namespace: string, array: string, contentType: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * deregister a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterArray: (namespace: string, array: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * get activity log by ID
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} id ID of the activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityLogById: (namespace: string, array: string, id: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * get all array metadata user has access to
     * @param {string} [publicShare] Public share values can be one of exclude, only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllArrayMetadata: (publicShare?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * get an ArraySchema using a url encoded uri
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArray: (namespace: string, array: string, contentType: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * get the max buffer sizes of an array for a subarray
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} subarray CSV string of subarray to get max buffer sizes for
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMaxBufferSizes: (namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * get metadata from the array in JSON format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [length] (optional) limit character length of returned values
     * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetaDataJson: (namespace: string, array: string, length?: number, endTimestamp?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetadata: (namespace: string, array: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetadataCapnp: (namespace: string, array: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * get the non empty domain of an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayNonEmptyDomain: (namespace: string, array: string, contentType: string, xPayer?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * get non-empty domain from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayNonEmptyDomainJson: (namespace: string, array: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * get an sample set of data from the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [samples] Number of sample results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraySampleData: (namespace: string, array: string, samples?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     * Get all sharing details of the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraySharingPolicies: (namespace: string, array: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * get metadata on all arrays in a namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraysInNamespace: (namespace: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [endTimestamp] Milliseconds since Unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFragmentEndTimestamp: (namespace: string, array: string, endTimestamp?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastAccessedArrays: (options?: any) => Promise<RequestArgs$1>;
    /**
     * register an array at a specified URI registered to the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerArray: (namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any) => Promise<RequestArgs$1>;
    /**
     * Share an array with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareArray: (namespace: string, array: string, arraySharing: ArraySharing, options?: any) => Promise<RequestArgs$1>;
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArrayMetadata: (namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any) => Promise<RequestArgs$1>;
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArrayMetadataCapnp: (namespace: string, array: string, arrayMetadataEntries: ArrayMetadata, options?: any) => Promise<RequestArgs$1>;
    /**
     * vacuum an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vacuumArray: (namespace: string, array: string, tiledbConfig: TileDBConfig$1, options?: any) => Promise<RequestArgs$1>;
};
/**
 * ArrayApi - functional programming interface
 * @export
 */
declare const ArrayApiFp$1: (configuration?: Configuration$1) => {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task ID To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, hasTaskId?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArrayActivityLog$1>>>;
    /**
     * Fetch a list of all arrays that are owned directly by user or user\'s organizations
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserOwnedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayBrowserData>>;
    /**
     * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserOwnedSidebarGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayBrowserSidebar>>;
    /**
     * Fetch a list of all arrays that have been shared publically
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserPublicGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayBrowserData>>;
    /**
     * Fetch a sidebar of all arrays that have been shared publically
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserPublicSidebarGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayBrowserSidebar>>;
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {Array<string>} [sharedTo] namespaces to filter results of where there arrays were shared to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserSharedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, sharedTo?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayBrowserData>>;
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserSharedSidebarGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayBrowserSidebar>>;
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayEndTimestampData>>;
    /**
     * consolidate an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    consolidateArray(namespace: string, array: string, tiledbConfig: TileDBConfig$1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * create a array schema at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArraySchema} arraySchema ArraySchema being created
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArray(namespace: string, array: string, contentType: string, arraySchema: ArraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * delete a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArray(namespace: string, array: string, contentType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * deregister a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterArray(namespace: string, array: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * get activity log by ID
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} id ID of the activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityLogById(namespace: string, array: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayActivityLog$1>>;
    /**
     * get all array metadata user has access to
     * @param {string} [publicShare] Public share values can be one of exclude, only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllArrayMetadata(publicShare?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArrayInfo>>>;
    /**
     * get an ArraySchema using a url encoded uri
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArray(namespace: string, array: string, contentType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArraySchema>>;
    /**
     * get the max buffer sizes of an array for a subarray
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} subarray CSV string of subarray to get max buffer sizes for
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMaxBufferSizes(namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaxBufferSizes>>;
    /**
     * get metadata from the array in JSON format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [length] (optional) limit character length of returned values
     * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetaDataJson(namespace: string, array: string, length?: number, endTimestamp?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>>;
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetadata(namespace: string, array: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayInfo>>;
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetadataCapnp(namespace: string, array: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayMetadata>>;
    /**
     * get the non empty domain of an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayNonEmptyDomain(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmptyDomain>>;
    /**
     * get non-empty domain from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayNonEmptyDomainJson(namespace: string, array: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>>;
    /**
     * get an sample set of data from the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [samples] Number of sample results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraySampleData(namespace: string, array: string, samples?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArraySample>>;
    /**
     * Get all sharing details of the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraySharingPolicies(namespace: string, array: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArraySharing>>>;
    /**
     * get metadata on all arrays in a namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraysInNamespace(namespace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArrayInfo>>>;
    /**
     * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [endTimestamp] Milliseconds since Unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFragmentEndTimestamp(namespace: string, array: string, endTimestamp?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>>;
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastAccessedArrays(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LastAccessedArray>>>;
    /**
     * register an array at a specified URI registered to the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayInfo>>;
    /**
     * Share an array with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareArray(namespace: string, array: string, arraySharing: ArraySharing, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArrayMetadata(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArrayMetadataCapnp(namespace: string, array: string, arrayMetadataEntries: ArrayMetadata, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * vacuum an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vacuumArray(namespace: string, array: string, tiledbConfig: TileDBConfig$1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * ArrayApi - factory interface
 * @export
 */
declare const ArrayApiFactory$1: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task ID To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, hasTaskId?: boolean, options?: any): AxiosPromise<Array<ArrayActivityLog$1>>;
    /**
     * Fetch a list of all arrays that are owned directly by user or user\'s organizations
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserOwnedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any): AxiosPromise<ArrayBrowserData>;
    /**
     * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserOwnedSidebarGet(options?: any): AxiosPromise<ArrayBrowserSidebar>;
    /**
     * Fetch a list of all arrays that have been shared publically
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserPublicGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any): AxiosPromise<ArrayBrowserData>;
    /**
     * Fetch a sidebar of all arrays that have been shared publically
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserPublicSidebarGet(options?: any): AxiosPromise<ArrayBrowserSidebar>;
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {Array<string>} [sharedTo] namespaces to filter results of where there arrays were shared to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserSharedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, sharedTo?: Array<string>, options?: any): AxiosPromise<ArrayBrowserData>;
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysBrowserSharedSidebarGet(options?: any): AxiosPromise<ArrayBrowserSidebar>;
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arraysNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): AxiosPromise<ArrayEndTimestampData>;
    /**
     * consolidate an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    consolidateArray(namespace: string, array: string, tiledbConfig: TileDBConfig$1, options?: any): AxiosPromise<void>;
    /**
     * create a array schema at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArraySchema} arraySchema ArraySchema being created
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createArray(namespace: string, array: string, contentType: string, arraySchema: ArraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): AxiosPromise<void>;
    /**
     * delete a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArray(namespace: string, array: string, contentType: string, options?: any): AxiosPromise<void>;
    /**
     * deregister a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterArray(namespace: string, array: string, options?: any): AxiosPromise<void>;
    /**
     * get activity log by ID
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} id ID of the activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityLogById(namespace: string, array: string, id: string, options?: any): AxiosPromise<ArrayActivityLog$1>;
    /**
     * get all array metadata user has access to
     * @param {string} [publicShare] Public share values can be one of exclude, only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllArrayMetadata(publicShare?: string, options?: any): AxiosPromise<Array<ArrayInfo>>;
    /**
     * get an ArraySchema using a url encoded uri
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArray(namespace: string, array: string, contentType: string, options?: any): AxiosPromise<ArraySchema>;
    /**
     * get the max buffer sizes of an array for a subarray
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} subarray CSV string of subarray to get max buffer sizes for
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMaxBufferSizes(namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options?: any): AxiosPromise<MaxBufferSizes>;
    /**
     * get metadata from the array in JSON format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [length] (optional) limit character length of returned values
     * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetaDataJson(namespace: string, array: string, length?: number, endTimestamp?: number, options?: any): AxiosPromise<object>;
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetadata(namespace: string, array: string, options?: any): AxiosPromise<ArrayInfo>;
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayMetadataCapnp(namespace: string, array: string, options?: any): AxiosPromise<ArrayMetadata>;
    /**
     * get the non empty domain of an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayNonEmptyDomain(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): AxiosPromise<NonEmptyDomain>;
    /**
     * get non-empty domain from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayNonEmptyDomainJson(namespace: string, array: string, options?: any): AxiosPromise<object>;
    /**
     * get an sample set of data from the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [samples] Number of sample results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraySampleData(namespace: string, array: string, samples?: number, options?: any): AxiosPromise<ArraySample>;
    /**
     * Get all sharing details of the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraySharingPolicies(namespace: string, array: string, options?: any): AxiosPromise<Array<ArraySharing>>;
    /**
     * get metadata on all arrays in a namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArraysInNamespace(namespace: string, options?: any): AxiosPromise<Array<ArrayInfo>>;
    /**
     * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [endTimestamp] Milliseconds since Unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFragmentEndTimestamp(namespace: string, array: string, endTimestamp?: number, options?: any): AxiosPromise<number>;
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLastAccessedArrays(options?: any): AxiosPromise<Array<LastAccessedArray>>;
    /**
     * register an array at a specified URI registered to the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): AxiosPromise<ArrayInfo>;
    /**
     * Share an array with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareArray(namespace: string, array: string, arraySharing: ArraySharing, options?: any): AxiosPromise<void>;
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArrayMetadata(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): AxiosPromise<void>;
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArrayMetadataCapnp(namespace: string, array: string, arrayMetadataEntries: ArrayMetadata, options?: any): AxiosPromise<void>;
    /**
     * vacuum an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vacuumArray(namespace: string, array: string, tiledbConfig: TileDBConfig$1, options?: any): AxiosPromise<void>;
};
/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
declare class ArrayApi$1 extends BaseAPI$1 {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task ID To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, hasTaskId?: boolean, options?: any): Promise<axios.AxiosResponse<ArrayActivityLog$1[]>>;
    /**
     * Fetch a list of all arrays that are owned directly by user or user\'s organizations
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserOwnedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any): Promise<axios.AxiosResponse<ArrayBrowserData>>;
    /**
     * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserOwnedSidebarGet(options?: any): Promise<axios.AxiosResponse<ArrayBrowserSidebar>>;
    /**
     * Fetch a list of all arrays that have been shared publically
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserPublicGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any): Promise<axios.AxiosResponse<ArrayBrowserData>>;
    /**
     * Fetch a sidebar of all arrays that have been shared publically
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserPublicSidebarGet(options?: any): Promise<axios.AxiosResponse<ArrayBrowserSidebar>>;
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {Array<string>} [sharedTo] namespaces to filter results of where there arrays were shared to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserSharedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, sharedTo?: Array<string>, options?: any): Promise<axios.AxiosResponse<ArrayBrowserData>>;
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserSharedSidebarGet(options?: any): Promise<axios.AxiosResponse<ArrayBrowserSidebar>>;
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): Promise<axios.AxiosResponse<ArrayEndTimestampData>>;
    /**
     * consolidate an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    consolidateArray(namespace: string, array: string, tiledbConfig: TileDBConfig$1, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * create a array schema at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArraySchema} arraySchema ArraySchema being created
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    createArray(namespace: string, array: string, contentType: string, arraySchema: ArraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * delete a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    deleteArray(namespace: string, array: string, contentType: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * deregister a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    deregisterArray(namespace: string, array: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * get activity log by ID
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} id ID of the activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getActivityLogById(namespace: string, array: string, id: string, options?: any): Promise<axios.AxiosResponse<ArrayActivityLog$1>>;
    /**
     * get all array metadata user has access to
     * @param {string} [publicShare] Public share values can be one of exclude, only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getAllArrayMetadata(publicShare?: string, options?: any): Promise<axios.AxiosResponse<ArrayInfo[]>>;
    /**
     * get an ArraySchema using a url encoded uri
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArray(namespace: string, array: string, contentType: string, options?: any): Promise<axios.AxiosResponse<ArraySchema>>;
    /**
     * get the max buffer sizes of an array for a subarray
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} subarray CSV string of subarray to get max buffer sizes for
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMaxBufferSizes(namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options?: any): Promise<axios.AxiosResponse<MaxBufferSizes>>;
    /**
     * get metadata from the array in JSON format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [length] (optional) limit character length of returned values
     * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetaDataJson(namespace: string, array: string, length?: number, endTimestamp?: number, options?: any): Promise<axios.AxiosResponse<object>>;
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetadata(namespace: string, array: string, options?: any): Promise<axios.AxiosResponse<ArrayInfo>>;
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetadataCapnp(namespace: string, array: string, options?: any): Promise<axios.AxiosResponse<ArrayMetadata>>;
    /**
     * get the non empty domain of an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayNonEmptyDomain(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): Promise<axios.AxiosResponse<NonEmptyDomain>>;
    /**
     * get non-empty domain from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayNonEmptyDomainJson(namespace: string, array: string, options?: any): Promise<axios.AxiosResponse<object>>;
    /**
     * get an sample set of data from the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [samples] Number of sample results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraySampleData(namespace: string, array: string, samples?: number, options?: any): Promise<axios.AxiosResponse<ArraySample>>;
    /**
     * Get all sharing details of the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraySharingPolicies(namespace: string, array: string, options?: any): Promise<axios.AxiosResponse<ArraySharing[]>>;
    /**
     * get metadata on all arrays in a namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraysInNamespace(namespace: string, options?: any): Promise<axios.AxiosResponse<ArrayInfo[]>>;
    /**
     * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [endTimestamp] Milliseconds since Unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getFragmentEndTimestamp(namespace: string, array: string, endTimestamp?: number, options?: any): Promise<axios.AxiosResponse<number>>;
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getLastAccessedArrays(options?: any): Promise<axios.AxiosResponse<LastAccessedArray[]>>;
    /**
     * register an array at a specified URI registered to the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): Promise<axios.AxiosResponse<ArrayInfo>>;
    /**
     * Share an array with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    shareArray(namespace: string, array: string, arraySharing: ArraySharing, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    updateArrayMetadata(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    updateArrayMetadataCapnp(namespace: string, array: string, arrayMetadataEntries: ArrayMetadata, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * vacuum an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    vacuumArray(namespace: string, array: string, tiledbConfig: TileDBConfig$1, options?: any): Promise<axios.AxiosResponse<void>>;
}
/**
 * ArrayTasksApi - axios parameter creator
 * @export
 */
declare const ArrayTasksApiAxiosParamCreator: (configuration?: Configuration$1) => {
    /**
     *
     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayTasksSidebar: (start?: number, end?: number, options?: any) => Promise<RequestArgs$1>;
};
/**
 * ArrayTasksApi - functional programming interface
 * @export
 */
declare const ArrayTasksApiFp: (configuration?: Configuration$1) => {
    /**
     *
     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayTasksSidebar(start?: number, end?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayTaskBrowserSidebar>>;
};
/**
 * ArrayTasksApi - factory interface
 * @export
 */
declare const ArrayTasksApiFactory: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayTasksSidebar(start?: number, end?: number, options?: any): AxiosPromise<ArrayTaskBrowserSidebar>;
};
/**
 * ArrayTasksApi - object-oriented interface
 * @export
 * @class ArrayTasksApi
 * @extends {BaseAPI}
 */
declare class ArrayTasksApi extends BaseAPI$1 {
    /**
     *
     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayTasksApi
     */
    getArrayTasksSidebar(start?: number, end?: number, options?: any): Promise<axios.AxiosResponse<ArrayTaskBrowserSidebar>>;
}
/**
 * FavoritesApi - axios parameter creator
 * @export
 */
declare const FavoritesApiAxiosParamCreator: (configuration?: Configuration$1) => {
    /**
     * Add a new array favorite
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addArrayFavorite: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Add a new ML model favorite
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMLModelFavorite: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Add a new notebook favorite
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNotebookFavorite: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Add a new UDF favorite
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUDFFavorite: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Delete specific array favorite
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArrayFavorite: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Delete specific ML model favorite
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMLModelFavorite: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Delete specific notebook favorite
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotebookFavorite: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Delete specific UDF favorite
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUDFFavorite: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch array favorite of a specific array
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayFavorite: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch ML model favorite of a specific ML model
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMLModelFavorite: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch notebook favorite of a specific notebook
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotebookFavorite: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch UDF favorite of a specific UDF
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFFavorite: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch a page of array favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listArrayFavorites: (page?: number, perPage?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch all favorite array uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listArrayFavoritesUUIDs: (options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch a page of ML models favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMLModelFavorites: (page?: number, perPage?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch all favorite ML models uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMLModelFavoritesUUIDs: (options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch a page of notebook favorites of connected user
     * @param {boolean} [isDashboard] return only dashboards
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNotebookFavorites: (isDashboard?: boolean, page?: number, perPage?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch all favorite notebook uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNotebookFavoritesUUIDs: (options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch a page of UDF favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUDFFavorites: (page?: number, perPage?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch all favorite UDF uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUDFFavoritesUUIDs: (options?: any) => Promise<RequestArgs$1>;
};
/**
 * FavoritesApi - functional programming interface
 * @export
 */
declare const FavoritesApiFp: (configuration?: Configuration$1) => {
    /**
     * Add a new array favorite
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addArrayFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Add a new ML model favorite
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMLModelFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Add a new notebook favorite
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNotebookFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Add a new UDF favorite
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUDFFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Delete specific array favorite
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArrayFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Delete specific ML model favorite
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMLModelFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Delete specific notebook favorite
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotebookFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Delete specific UDF favorite
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUDFFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Fetch array favorite of a specific array
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayFavorite>>;
    /**
     * Fetch ML model favorite of a specific ML model
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMLModelFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MLModelFavorite>>;
    /**
     * Fetch notebook favorite of a specific notebook
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotebookFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotebookFavorite>>;
    /**
     * Fetch UDF favorite of a specific UDF
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UDFFavorite>>;
    /**
     * Fetch a page of array favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listArrayFavorites(page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayFavoritesData>>;
    /**
     * Fetch all favorite array uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listArrayFavoritesUUIDs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArrayFavorite>>>;
    /**
     * Fetch a page of ML models favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMLModelFavorites(page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MLModelFavoritesData>>;
    /**
     * Fetch all favorite ML models uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMLModelFavoritesUUIDs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MLModelFavorite>>>;
    /**
     * Fetch a page of notebook favorites of connected user
     * @param {boolean} [isDashboard] return only dashboards
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNotebookFavorites(isDashboard?: boolean, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotebookFavoritesData>>;
    /**
     * Fetch all favorite notebook uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNotebookFavoritesUUIDs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotebookFavorite>>>;
    /**
     * Fetch a page of UDF favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUDFFavorites(page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UDFFavoritesData>>;
    /**
     * Fetch all favorite UDF uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUDFFavoritesUUIDs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UDFFavorite>>>;
};
/**
 * FavoritesApi - factory interface
 * @export
 */
declare const FavoritesApiFactory: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Add a new array favorite
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addArrayFavorite(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * Add a new ML model favorite
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMLModelFavorite(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * Add a new notebook favorite
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNotebookFavorite(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * Add a new UDF favorite
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUDFFavorite(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * Delete specific array favorite
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteArrayFavorite(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * Delete specific ML model favorite
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMLModelFavorite(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * Delete specific notebook favorite
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotebookFavorite(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * Delete specific UDF favorite
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUDFFavorite(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * Fetch array favorite of a specific array
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArrayFavorite(namespace: string, name: string, options?: any): AxiosPromise<ArrayFavorite>;
    /**
     * Fetch ML model favorite of a specific ML model
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMLModelFavorite(namespace: string, name: string, options?: any): AxiosPromise<MLModelFavorite>;
    /**
     * Fetch notebook favorite of a specific notebook
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotebookFavorite(namespace: string, name: string, options?: any): AxiosPromise<NotebookFavorite>;
    /**
     * Fetch UDF favorite of a specific UDF
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFFavorite(namespace: string, name: string, options?: any): AxiosPromise<UDFFavorite>;
    /**
     * Fetch a page of array favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listArrayFavorites(page?: number, perPage?: number, options?: any): AxiosPromise<ArrayFavoritesData>;
    /**
     * Fetch all favorite array uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listArrayFavoritesUUIDs(options?: any): AxiosPromise<Array<ArrayFavorite>>;
    /**
     * Fetch a page of ML models favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMLModelFavorites(page?: number, perPage?: number, options?: any): AxiosPromise<MLModelFavoritesData>;
    /**
     * Fetch all favorite ML models uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMLModelFavoritesUUIDs(options?: any): AxiosPromise<Array<MLModelFavorite>>;
    /**
     * Fetch a page of notebook favorites of connected user
     * @param {boolean} [isDashboard] return only dashboards
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNotebookFavorites(isDashboard?: boolean, page?: number, perPage?: number, options?: any): AxiosPromise<NotebookFavoritesData>;
    /**
     * Fetch all favorite notebook uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNotebookFavoritesUUIDs(options?: any): AxiosPromise<Array<NotebookFavorite>>;
    /**
     * Fetch a page of UDF favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUDFFavorites(page?: number, perPage?: number, options?: any): AxiosPromise<UDFFavoritesData>;
    /**
     * Fetch all favorite UDF uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUDFFavoritesUUIDs(options?: any): AxiosPromise<Array<UDFFavorite>>;
};
/**
 * FavoritesApi - object-oriented interface
 * @export
 * @class FavoritesApi
 * @extends {BaseAPI}
 */
declare class FavoritesApi extends BaseAPI$1 {
    /**
     * Add a new array favorite
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    addArrayFavorite(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Add a new ML model favorite
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    addMLModelFavorite(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Add a new notebook favorite
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    addNotebookFavorite(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Add a new UDF favorite
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    addUDFFavorite(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Delete specific array favorite
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    deleteArrayFavorite(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Delete specific ML model favorite
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    deleteMLModelFavorite(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Delete specific notebook favorite
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    deleteNotebookFavorite(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Delete specific UDF favorite
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    deleteUDFFavorite(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Fetch array favorite of a specific array
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getArrayFavorite(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<ArrayFavorite>>;
    /**
     * Fetch ML model favorite of a specific ML model
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getMLModelFavorite(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<MLModelFavorite>>;
    /**
     * Fetch notebook favorite of a specific notebook
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getNotebookFavorite(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<NotebookFavorite>>;
    /**
     * Fetch UDF favorite of a specific UDF
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getUDFFavorite(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<UDFFavorite>>;
    /**
     * Fetch a page of array favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listArrayFavorites(page?: number, perPage?: number, options?: any): Promise<axios.AxiosResponse<ArrayFavoritesData>>;
    /**
     * Fetch all favorite array uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listArrayFavoritesUUIDs(options?: any): Promise<axios.AxiosResponse<ArrayFavorite[]>>;
    /**
     * Fetch a page of ML models favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listMLModelFavorites(page?: number, perPage?: number, options?: any): Promise<axios.AxiosResponse<MLModelFavoritesData>>;
    /**
     * Fetch all favorite ML models uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listMLModelFavoritesUUIDs(options?: any): Promise<axios.AxiosResponse<MLModelFavorite[]>>;
    /**
     * Fetch a page of notebook favorites of connected user
     * @param {boolean} [isDashboard] return only dashboards
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listNotebookFavorites(isDashboard?: boolean, page?: number, perPage?: number, options?: any): Promise<axios.AxiosResponse<NotebookFavoritesData>>;
    /**
     * Fetch all favorite notebook uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listNotebookFavoritesUUIDs(options?: any): Promise<axios.AxiosResponse<NotebookFavorite[]>>;
    /**
     * Fetch a page of UDF favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listUDFFavorites(page?: number, perPage?: number, options?: any): Promise<axios.AxiosResponse<UDFFavoritesData>>;
    /**
     * Fetch all favorite UDF uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listUDFFavoritesUUIDs(options?: any): Promise<axios.AxiosResponse<UDFFavorite[]>>;
}
/**
 * FilesApi - axios parameter creator
 * @export
 */
declare const FilesApiAxiosParamCreator: (configuration?: Configuration$1) => {
    /**
     * Create a tiledb file at the specified location
     * @param {string} namespace The namespace of the file
     * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleCreateFile: (namespace: string, fileCreate: FileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Export a TileDB File back to its original file format
     * @param {string} namespace The namespace of the file
     * @param {string} file The file identifier
     * @param {FileExport} fileExport Export configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleExportFile: (namespace: string, file: string, fileExport: FileExport, options?: any) => Promise<RequestArgs$1>;
    /**
     * Upload a tiledb file at the specified location
     * @param {string} namespace The namespace of the file
     * @param {any} inputFile the file to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [outputUri] output location of the TileDB File
     * @param {string} [name] name to set for registered file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleUploadFile: (namespace: string, inputFile: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, outputUri?: string, name?: string, options?: any) => Promise<RequestArgs$1>;
};
/**
 * FilesApi - functional programming interface
 * @export
 */
declare const FilesApiFp: (configuration?: Configuration$1) => {
    /**
     * Create a tiledb file at the specified location
     * @param {string} namespace The namespace of the file
     * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleCreateFile(namespace: string, fileCreate: FileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileCreated>>;
    /**
     * Export a TileDB File back to its original file format
     * @param {string} namespace The namespace of the file
     * @param {string} file The file identifier
     * @param {FileExport} fileExport Export configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleExportFile(namespace: string, file: string, fileExport: FileExport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileExported>>;
    /**
     * Upload a tiledb file at the specified location
     * @param {string} namespace The namespace of the file
     * @param {any} inputFile the file to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [outputUri] output location of the TileDB File
     * @param {string} [name] name to set for registered file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleUploadFile(namespace: string, inputFile: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, outputUri?: string, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploaded>>;
};
/**
 * FilesApi - factory interface
 * @export
 */
declare const FilesApiFactory: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a tiledb file at the specified location
     * @param {string} namespace The namespace of the file
     * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleCreateFile(namespace: string, fileCreate: FileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): AxiosPromise<FileCreated>;
    /**
     * Export a TileDB File back to its original file format
     * @param {string} namespace The namespace of the file
     * @param {string} file The file identifier
     * @param {FileExport} fileExport Export configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleExportFile(namespace: string, file: string, fileExport: FileExport, options?: any): AxiosPromise<FileExported>;
    /**
     * Upload a tiledb file at the specified location
     * @param {string} namespace The namespace of the file
     * @param {any} inputFile the file to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [outputUri] output location of the TileDB File
     * @param {string} [name] name to set for registered file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleUploadFile(namespace: string, inputFile: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, outputUri?: string, name?: string, options?: any): AxiosPromise<FileUploaded>;
};
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
declare class FilesApi extends BaseAPI$1 {
    /**
     * Create a tiledb file at the specified location
     * @param {string} namespace The namespace of the file
     * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    handleCreateFile(namespace: string, fileCreate: FileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<axios.AxiosResponse<FileCreated>>;
    /**
     * Export a TileDB File back to its original file format
     * @param {string} namespace The namespace of the file
     * @param {string} file The file identifier
     * @param {FileExport} fileExport Export configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    handleExportFile(namespace: string, file: string, fileExport: FileExport, options?: any): Promise<axios.AxiosResponse<FileExported>>;
    /**
     * Upload a tiledb file at the specified location
     * @param {string} namespace The namespace of the file
     * @param {any} inputFile the file to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [outputUri] output location of the TileDB File
     * @param {string} [name] name to set for registered file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    handleUploadFile(namespace: string, inputFile: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, outputUri?: string, name?: string, options?: any): Promise<axios.AxiosResponse<FileUploaded>>;
}
/**
 * GroupsApi - axios parameter creator
 * @export
 */
declare const GroupsApiAxiosParamCreator$1: (configuration?: Configuration$1) => {
    /**
     * Changes the contents of the group by adding/removing members.
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupChanges} [groupChanges]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeGroupContents: (groupNamespace: string, groupName: string, groupChanges?: GroupChanges, options?: any) => Promise<RequestArgs$1>;
    /**
     * Creates a new group in the namespace.
     * @param {string} namespace The namespace of the group
     * @param {GroupCreate} [groupCreate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup: (namespace: string, groupCreate?: GroupCreate, options?: any) => Promise<RequestArgs$1>;
    /**
     * Deletes the group. The assets are not deleted nor are not relocated to any other group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup: (groupNamespace: string, groupName: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Returns the the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroup: (groupNamespace: string, groupName: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Returns the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {number} [page] pagination offset for assets
     * @param {number} [perPage] pagination limit for assets
     * @param {string} [namespace] namespace to search for
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [memberType] member type to search for, more than one can be included
     * @param {Array<string>} [excludeMemberType] member type to exclude matching groups in results, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupContents: (groupNamespace: string, groupName: string, page?: number, perPage?: number, namespace?: string, search?: string, orderby?: string, tag?: Array<string>, excludeTag?: Array<string>, memberType?: Array<string>, excludeMemberType?: Array<string>, options?: any) => Promise<RequestArgs$1>;
    /**
     * Get all sharing details of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupSharingPolicies: (groupNamespace: string, groupName: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsBrowserOwnedFiltersGet: (options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsBrowserPublicFiltersGet: (options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsBrowserSharedFiltersGet: (options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch data to initialize filters for the group contents
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsGroupNamespaceGroupNameContentsFiltersGet: (groupNamespace: string, groupName: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Returns one page of owned groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOwnedGroups: (page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, flat?: boolean, parent?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Returns one page of public groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPublicGroups: (page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, flat?: boolean, parent?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Returns one page of shared groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {Array<string>} [sharedTo] namespaces to filter results of where there groups were shared to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSharedGroups: (page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, flat?: boolean, parent?: string, sharedTo?: Array<string>, options?: any) => Promise<RequestArgs$1>;
    /**
     * Registers an existing group in the namespace.
     * @param {string} namespace The namespace of the group
     * @param {string} array The unique name or id of the group
     * @param {GroupRegister} [groupRegister]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGroup: (namespace: string, array: string, groupRegister?: GroupRegister, options?: any) => Promise<RequestArgs$1>;
    /**
     * Share a group with a namespace
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupSharingRequest} groupSharingRequest Namespace and list of permissions to share with. Sharing is recursive, it is applied to all reachable subgroups and arrays of the group. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the group will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareGroup: (groupNamespace: string, groupName: string, groupSharingRequest: GroupSharingRequest, options?: any) => Promise<RequestArgs$1>;
    /**
     * Changes attributes of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupUpdate} [groupUpdate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroup: (groupNamespace: string, groupName: string, groupUpdate?: GroupUpdate, options?: any) => Promise<RequestArgs$1>;
};
/**
 * GroupsApi - functional programming interface
 * @export
 */
declare const GroupsApiFp$1: (configuration?: Configuration$1) => {
    /**
     * Changes the contents of the group by adding/removing members.
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupChanges} [groupChanges]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeGroupContents(groupNamespace: string, groupName: string, groupChanges?: GroupChanges, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Creates a new group in the namespace.
     * @param {string} namespace The namespace of the group
     * @param {GroupCreate} [groupCreate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(namespace: string, groupCreate?: GroupCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deletes the group. The assets are not deleted nor are not relocated to any other group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup(groupNamespace: string, groupName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Returns the the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroup(groupNamespace: string, groupName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupInfo>>;
    /**
     * Returns the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {number} [page] pagination offset for assets
     * @param {number} [perPage] pagination limit for assets
     * @param {string} [namespace] namespace to search for
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [memberType] member type to search for, more than one can be included
     * @param {Array<string>} [excludeMemberType] member type to exclude matching groups in results, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupContents(groupNamespace: string, groupName: string, page?: number, perPage?: number, namespace?: string, search?: string, orderby?: string, tag?: Array<string>, excludeTag?: Array<string>, memberType?: Array<string>, excludeMemberType?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupContents>>;
    /**
     * Get all sharing details of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupSharingPolicies(groupNamespace: string, groupName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupSharing>>>;
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsBrowserOwnedFiltersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupBrowserFilterData>>;
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsBrowserPublicFiltersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupBrowserFilterData>>;
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsBrowserSharedFiltersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupBrowserFilterData>>;
    /**
     * Fetch data to initialize filters for the group contents
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace: string, groupName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupContentsFilterData>>;
    /**
     * Returns one page of owned groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOwnedGroups(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, flat?: boolean, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupBrowserData>>;
    /**
     * Returns one page of public groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPublicGroups(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, flat?: boolean, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupBrowserData>>;
    /**
     * Returns one page of shared groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {Array<string>} [sharedTo] namespaces to filter results of where there groups were shared to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSharedGroups(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, flat?: boolean, parent?: string, sharedTo?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupBrowserData>>;
    /**
     * Registers an existing group in the namespace.
     * @param {string} namespace The namespace of the group
     * @param {string} array The unique name or id of the group
     * @param {GroupRegister} [groupRegister]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGroup(namespace: string, array: string, groupRegister?: GroupRegister, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Share a group with a namespace
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupSharingRequest} groupSharingRequest Namespace and list of permissions to share with. Sharing is recursive, it is applied to all reachable subgroups and arrays of the group. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the group will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareGroup(groupNamespace: string, groupName: string, groupSharingRequest: GroupSharingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Changes attributes of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupUpdate} [groupUpdate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroup(groupNamespace: string, groupName: string, groupUpdate?: GroupUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * GroupsApi - factory interface
 * @export
 */
declare const GroupsApiFactory$1: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Changes the contents of the group by adding/removing members.
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupChanges} [groupChanges]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeGroupContents(groupNamespace: string, groupName: string, groupChanges?: GroupChanges, options?: any): AxiosPromise<void>;
    /**
     * Creates a new group in the namespace.
     * @param {string} namespace The namespace of the group
     * @param {GroupCreate} [groupCreate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(namespace: string, groupCreate?: GroupCreate, options?: any): AxiosPromise<void>;
    /**
     * Deletes the group. The assets are not deleted nor are not relocated to any other group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup(groupNamespace: string, groupName: string, options?: any): AxiosPromise<void>;
    /**
     * Returns the the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroup(groupNamespace: string, groupName: string, options?: any): AxiosPromise<GroupInfo>;
    /**
     * Returns the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {number} [page] pagination offset for assets
     * @param {number} [perPage] pagination limit for assets
     * @param {string} [namespace] namespace to search for
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [memberType] member type to search for, more than one can be included
     * @param {Array<string>} [excludeMemberType] member type to exclude matching groups in results, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupContents(groupNamespace: string, groupName: string, page?: number, perPage?: number, namespace?: string, search?: string, orderby?: string, tag?: Array<string>, excludeTag?: Array<string>, memberType?: Array<string>, excludeMemberType?: Array<string>, options?: any): AxiosPromise<GroupContents>;
    /**
     * Get all sharing details of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupSharingPolicies(groupNamespace: string, groupName: string, options?: any): AxiosPromise<Array<GroupSharing>>;
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsBrowserOwnedFiltersGet(options?: any): AxiosPromise<GroupBrowserFilterData>;
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsBrowserPublicFiltersGet(options?: any): AxiosPromise<GroupBrowserFilterData>;
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsBrowserSharedFiltersGet(options?: any): AxiosPromise<GroupBrowserFilterData>;
    /**
     * Fetch data to initialize filters for the group contents
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace: string, groupName: string, options?: any): AxiosPromise<GroupContentsFilterData>;
    /**
     * Returns one page of owned groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOwnedGroups(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, flat?: boolean, parent?: string, options?: any): AxiosPromise<GroupBrowserData>;
    /**
     * Returns one page of public groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPublicGroups(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, flat?: boolean, parent?: string, options?: any): AxiosPromise<GroupBrowserData>;
    /**
     * Returns one page of shared groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {Array<string>} [sharedTo] namespaces to filter results of where there groups were shared to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSharedGroups(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, flat?: boolean, parent?: string, sharedTo?: Array<string>, options?: any): AxiosPromise<GroupBrowserData>;
    /**
     * Registers an existing group in the namespace.
     * @param {string} namespace The namespace of the group
     * @param {string} array The unique name or id of the group
     * @param {GroupRegister} [groupRegister]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGroup(namespace: string, array: string, groupRegister?: GroupRegister, options?: any): AxiosPromise<void>;
    /**
     * Share a group with a namespace
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupSharingRequest} groupSharingRequest Namespace and list of permissions to share with. Sharing is recursive, it is applied to all reachable subgroups and arrays of the group. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the group will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareGroup(groupNamespace: string, groupName: string, groupSharingRequest: GroupSharingRequest, options?: any): AxiosPromise<void>;
    /**
     * Changes attributes of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupUpdate} [groupUpdate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroup(groupNamespace: string, groupName: string, groupUpdate?: GroupUpdate, options?: any): AxiosPromise<void>;
};
/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
declare class GroupsApi$1 extends BaseAPI$1 {
    /**
     * Changes the contents of the group by adding/removing members.
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupChanges} [groupChanges]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    changeGroupContents(groupNamespace: string, groupName: string, groupChanges?: GroupChanges, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Creates a new group in the namespace.
     * @param {string} namespace The namespace of the group
     * @param {GroupCreate} [groupCreate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    createGroup(namespace: string, groupCreate?: GroupCreate, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Deletes the group. The assets are not deleted nor are not relocated to any other group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deleteGroup(groupNamespace: string, groupName: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Returns the the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroup(groupNamespace: string, groupName: string, options?: any): Promise<axios.AxiosResponse<GroupInfo>>;
    /**
     * Returns the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {number} [page] pagination offset for assets
     * @param {number} [perPage] pagination limit for assets
     * @param {string} [namespace] namespace to search for
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [memberType] member type to search for, more than one can be included
     * @param {Array<string>} [excludeMemberType] member type to exclude matching groups in results, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupContents(groupNamespace: string, groupName: string, page?: number, perPage?: number, namespace?: string, search?: string, orderby?: string, tag?: Array<string>, excludeTag?: Array<string>, memberType?: Array<string>, excludeMemberType?: Array<string>, options?: any): Promise<axios.AxiosResponse<GroupContents>>;
    /**
     * Get all sharing details of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupSharingPolicies(groupNamespace: string, groupName: string, options?: any): Promise<axios.AxiosResponse<GroupSharing[]>>;
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsBrowserOwnedFiltersGet(options?: any): Promise<axios.AxiosResponse<GroupBrowserFilterData>>;
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsBrowserPublicFiltersGet(options?: any): Promise<axios.AxiosResponse<GroupBrowserFilterData>>;
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsBrowserSharedFiltersGet(options?: any): Promise<axios.AxiosResponse<GroupBrowserFilterData>>;
    /**
     * Fetch data to initialize filters for the group contents
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace: string, groupName: string, options?: any): Promise<axios.AxiosResponse<GroupContentsFilterData>>;
    /**
     * Returns one page of owned groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    listOwnedGroups(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, flat?: boolean, parent?: string, options?: any): Promise<axios.AxiosResponse<GroupBrowserData>>;
    /**
     * Returns one page of public groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    listPublicGroups(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, flat?: boolean, parent?: string, options?: any): Promise<axios.AxiosResponse<GroupBrowserData>>;
    /**
     * Returns one page of shared groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {Array<string>} [sharedTo] namespaces to filter results of where there groups were shared to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    listSharedGroups(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, flat?: boolean, parent?: string, sharedTo?: Array<string>, options?: any): Promise<axios.AxiosResponse<GroupBrowserData>>;
    /**
     * Registers an existing group in the namespace.
     * @param {string} namespace The namespace of the group
     * @param {string} array The unique name or id of the group
     * @param {GroupRegister} [groupRegister]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    registerGroup(namespace: string, array: string, groupRegister?: GroupRegister, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Share a group with a namespace
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupSharingRequest} groupSharingRequest Namespace and list of permissions to share with. Sharing is recursive, it is applied to all reachable subgroups and arrays of the group. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the group will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    shareGroup(groupNamespace: string, groupName: string, groupSharingRequest: GroupSharingRequest, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Changes attributes of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupUpdate} [groupUpdate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroup(groupNamespace: string, groupName: string, groupUpdate?: GroupUpdate, options?: any): Promise<axios.AxiosResponse<void>>;
}
/**
 * InvitationApi - axios parameter creator
 * @export
 */
declare const InvitationApiAxiosParamCreator: (configuration?: Configuration$1) => {
    /**
     * Accepts invitation
     * @param {string} invitation the ID of invitation about to be accepted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptInvitation: (invitation: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Cancels join organization invitation
     * @param {string} invitation the ID of invitation about to be cancelled
     * @param {string} organization name or UUID of organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelJoinOrganization: (invitation: string, organization: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Cancels array sharing invitation
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} invitation the ID of invitation about to be cancelled
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelShareArrayByInvite: (namespace: string, invitation: string, array: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch a list of invitations
     * @param {string} [organization] name or ID of organization to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
     * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
     * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInvitations: (organization?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, orderby?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Sends email to multiple recipients with joining information regarding an organization
     * @param {string} organization name or UUID of organization
     * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinOrganization: (organization: string, emailInvite: InvitationOrganizationJoinEmail, options?: any) => Promise<RequestArgs$1>;
    /**
     * Sends email to multiple recipients with sharing information regarding an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {InvitationArrayShareEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareArrayByInvite: (namespace: string, array: string, emailInvite: InvitationArrayShareEmail, options?: any) => Promise<RequestArgs$1>;
};
/**
 * InvitationApi - functional programming interface
 * @export
 */
declare const InvitationApiFp: (configuration?: Configuration$1) => {
    /**
     * Accepts invitation
     * @param {string} invitation the ID of invitation about to be accepted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptInvitation(invitation: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Cancels join organization invitation
     * @param {string} invitation the ID of invitation about to be cancelled
     * @param {string} organization name or UUID of organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelJoinOrganization(invitation: string, organization: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Cancels array sharing invitation
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} invitation the ID of invitation about to be cancelled
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelShareArrayByInvite(namespace: string, invitation: string, array: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Fetch a list of invitations
     * @param {string} [organization] name or ID of organization to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
     * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
     * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInvitations(organization?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, orderby?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvitationData>>;
    /**
     * Sends email to multiple recipients with joining information regarding an organization
     * @param {string} organization name or UUID of organization
     * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinOrganization(organization: string, emailInvite: InvitationOrganizationJoinEmail, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Sends email to multiple recipients with sharing information regarding an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {InvitationArrayShareEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareArrayByInvite(namespace: string, array: string, emailInvite: InvitationArrayShareEmail, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * InvitationApi - factory interface
 * @export
 */
declare const InvitationApiFactory: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Accepts invitation
     * @param {string} invitation the ID of invitation about to be accepted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptInvitation(invitation: string, options?: any): AxiosPromise<void>;
    /**
     * Cancels join organization invitation
     * @param {string} invitation the ID of invitation about to be cancelled
     * @param {string} organization name or UUID of organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelJoinOrganization(invitation: string, organization: string, options?: any): AxiosPromise<void>;
    /**
     * Cancels array sharing invitation
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} invitation the ID of invitation about to be cancelled
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelShareArrayByInvite(namespace: string, invitation: string, array: string, options?: any): AxiosPromise<void>;
    /**
     * Fetch a list of invitations
     * @param {string} [organization] name or ID of organization to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
     * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
     * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInvitations(organization?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, orderby?: string, options?: any): AxiosPromise<InvitationData>;
    /**
     * Sends email to multiple recipients with joining information regarding an organization
     * @param {string} organization name or UUID of organization
     * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinOrganization(organization: string, emailInvite: InvitationOrganizationJoinEmail, options?: any): AxiosPromise<void>;
    /**
     * Sends email to multiple recipients with sharing information regarding an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {InvitationArrayShareEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareArrayByInvite(namespace: string, array: string, emailInvite: InvitationArrayShareEmail, options?: any): AxiosPromise<void>;
};
/**
 * InvitationApi - object-oriented interface
 * @export
 * @class InvitationApi
 * @extends {BaseAPI}
 */
declare class InvitationApi extends BaseAPI$1 {
    /**
     * Accepts invitation
     * @param {string} invitation the ID of invitation about to be accepted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    acceptInvitation(invitation: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Cancels join organization invitation
     * @param {string} invitation the ID of invitation about to be cancelled
     * @param {string} organization name or UUID of organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    cancelJoinOrganization(invitation: string, organization: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Cancels array sharing invitation
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} invitation the ID of invitation about to be cancelled
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    cancelShareArrayByInvite(namespace: string, invitation: string, array: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Fetch a list of invitations
     * @param {string} [organization] name or ID of organization to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
     * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
     * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    fetchInvitations(organization?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, orderby?: string, options?: any): Promise<axios.AxiosResponse<InvitationData>>;
    /**
     * Sends email to multiple recipients with joining information regarding an organization
     * @param {string} organization name or UUID of organization
     * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    joinOrganization(organization: string, emailInvite: InvitationOrganizationJoinEmail, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Sends email to multiple recipients with sharing information regarding an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {InvitationArrayShareEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    shareArrayByInvite(namespace: string, array: string, emailInvite: InvitationArrayShareEmail, options?: any): Promise<axios.AxiosResponse<void>>;
}
/**
 * NotebookApi - axios parameter creator
 * @export
 */
declare const NotebookApiAxiosParamCreator: (configuration?: Configuration$1) => {
    /**
     * Get status of the notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotebookServerStatus: (namespace: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Copy a tiledb notebook at the specified location
     * @param {string} namespace The namespace of the notebook
     * @param {string} array The name of the notebook
     * @param {NotebookCopy} notebookCopy Input/Output information to create a new TileDB file
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {number} [endTimestamp] Milliseconds since Unix epoch, copy will use open_at functionality to copy notebook created at the specific timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleCopyNotebook: (namespace: string, array: string, notebookCopy: NotebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, endTimestamp?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     * Upload a notebook at the specified location
     * @param {string} namespace The namespace of the notebook
     * @param {any} inputFile the notebook to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [outputUri] output location of the TileDB File
     * @param {string} [name] name to set for registered file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleUploadNotebook: (namespace: string, inputFile: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, outputUri?: string, name?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Shutdown a notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shutdownNotebookServer: (namespace: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * update name on a notebok, moving related S3 object to new location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of notebook (array) that is url-encoded
     * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNotebookName: (namespace: string, array: string, notebookMetadata: ArrayInfoUpdate, options?: any) => Promise<RequestArgs$1>;
};
/**
 * NotebookApi - functional programming interface
 * @export
 */
declare const NotebookApiFp: (configuration?: Configuration$1) => {
    /**
     * Get status of the notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotebookServerStatus(namespace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotebookStatus>>;
    /**
     * Copy a tiledb notebook at the specified location
     * @param {string} namespace The namespace of the notebook
     * @param {string} array The name of the notebook
     * @param {NotebookCopy} notebookCopy Input/Output information to create a new TileDB file
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {number} [endTimestamp] Milliseconds since Unix epoch, copy will use open_at functionality to copy notebook created at the specific timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleCopyNotebook(namespace: string, array: string, notebookCopy: NotebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, endTimestamp?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotebookCopied>>;
    /**
     * Upload a notebook at the specified location
     * @param {string} namespace The namespace of the notebook
     * @param {any} inputFile the notebook to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [outputUri] output location of the TileDB File
     * @param {string} [name] name to set for registered file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleUploadNotebook(namespace: string, inputFile: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, outputUri?: string, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploaded>>;
    /**
     * Shutdown a notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shutdownNotebookServer(namespace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * update name on a notebok, moving related S3 object to new location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of notebook (array) that is url-encoded
     * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNotebookName(namespace: string, array: string, notebookMetadata: ArrayInfoUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * NotebookApi - factory interface
 * @export
 */
declare const NotebookApiFactory: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get status of the notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotebookServerStatus(namespace: string, options?: any): AxiosPromise<NotebookStatus>;
    /**
     * Copy a tiledb notebook at the specified location
     * @param {string} namespace The namespace of the notebook
     * @param {string} array The name of the notebook
     * @param {NotebookCopy} notebookCopy Input/Output information to create a new TileDB file
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {number} [endTimestamp] Milliseconds since Unix epoch, copy will use open_at functionality to copy notebook created at the specific timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleCopyNotebook(namespace: string, array: string, notebookCopy: NotebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, endTimestamp?: number, options?: any): AxiosPromise<NotebookCopied>;
    /**
     * Upload a notebook at the specified location
     * @param {string} namespace The namespace of the notebook
     * @param {any} inputFile the notebook to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [outputUri] output location of the TileDB File
     * @param {string} [name] name to set for registered file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleUploadNotebook(namespace: string, inputFile: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, outputUri?: string, name?: string, options?: any): AxiosPromise<FileUploaded>;
    /**
     * Shutdown a notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shutdownNotebookServer(namespace: string, options?: any): AxiosPromise<void>;
    /**
     * update name on a notebok, moving related S3 object to new location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of notebook (array) that is url-encoded
     * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNotebookName(namespace: string, array: string, notebookMetadata: ArrayInfoUpdate, options?: any): AxiosPromise<void>;
};
/**
 * NotebookApi - object-oriented interface
 * @export
 * @class NotebookApi
 * @extends {BaseAPI}
 */
declare class NotebookApi extends BaseAPI$1 {
    /**
     * Get status of the notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    getNotebookServerStatus(namespace: string, options?: any): Promise<axios.AxiosResponse<NotebookStatus>>;
    /**
     * Copy a tiledb notebook at the specified location
     * @param {string} namespace The namespace of the notebook
     * @param {string} array The name of the notebook
     * @param {NotebookCopy} notebookCopy Input/Output information to create a new TileDB file
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {number} [endTimestamp] Milliseconds since Unix epoch, copy will use open_at functionality to copy notebook created at the specific timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    handleCopyNotebook(namespace: string, array: string, notebookCopy: NotebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, endTimestamp?: number, options?: any): Promise<axios.AxiosResponse<NotebookCopied>>;
    /**
     * Upload a notebook at the specified location
     * @param {string} namespace The namespace of the notebook
     * @param {any} inputFile the notebook to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [outputUri] output location of the TileDB File
     * @param {string} [name] name to set for registered file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    handleUploadNotebook(namespace: string, inputFile: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, outputUri?: string, name?: string, options?: any): Promise<axios.AxiosResponse<FileUploaded>>;
    /**
     * Shutdown a notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    shutdownNotebookServer(namespace: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * update name on a notebok, moving related S3 object to new location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of notebook (array) that is url-encoded
     * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    updateNotebookName(namespace: string, array: string, notebookMetadata: ArrayInfoUpdate, options?: any): Promise<axios.AxiosResponse<void>>;
}
/**
 * NotebooksApi - axios parameter creator
 * @export
 */
declare const NotebooksApiAxiosParamCreator: (configuration?: Configuration$1) => {
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    notebooksNamespaceArrayEndTimestampsGet: (namespace: string, array: string, page?: number, perPage?: number, options?: any) => Promise<RequestArgs$1>;
};
/**
 * NotebooksApi - functional programming interface
 * @export
 */
declare const NotebooksApiFp: (configuration?: Configuration$1) => {
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    notebooksNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayEndTimestampData>>;
};
/**
 * NotebooksApi - factory interface
 * @export
 */
declare const NotebooksApiFactory: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    notebooksNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): AxiosPromise<ArrayEndTimestampData>;
};
/**
 * NotebooksApi - object-oriented interface
 * @export
 * @class NotebooksApi
 * @extends {BaseAPI}
 */
declare class NotebooksApi extends BaseAPI$1 {
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    notebooksNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): Promise<axios.AxiosResponse<ArrayEndTimestampData>>;
}
/**
 * OrganizationApi - axios parameter creator
 * @export
 */
declare const OrganizationApiAxiosParamCreator$1: (configuration?: Configuration$1) => {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAWSAccessCredentials: (namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any) => Promise<RequestArgs$1>;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToOrganization: (organization: string, user: OrganizationUser, options?: any) => Promise<RequestArgs$1>;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentials: (namespace: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentialsByName: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * create a organization, the user creating will be listed as owner
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganization: (organization: Organization, options?: any) => Promise<RequestArgs$1>;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAWSAccessCredentials: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * delete a organization
     * @param {string} organization organization name or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrganization: (organization: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserFromOrganization: (organization: string, username: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * get all organizations that the user is member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOrganizations: (options?: any) => Promise<RequestArgs$1>;
    /**
     * get a organization
     * @param {string} organization organization name or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization: (organization: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUser: (organization: string, username: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAWSAccessCredentials: (namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any) => Promise<RequestArgs$1>;
    /**
     * update a organization
     * @param {string} organization organization name or ID
     * @param {Organization} organizationDetails organization details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOrganization: (organization: string, organizationDetails: Organization, options?: any) => Promise<RequestArgs$1>;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInOrganization: (organization: string, username: string, user: OrganizationUser, options?: any) => Promise<RequestArgs$1>;
};
/**
 * OrganizationApi - functional programming interface
 * @export
 */
declare const OrganizationApiFp$1: (configuration?: Configuration$1) => {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToOrganization(organization: string, user: OrganizationUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentials(namespace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AWSAccessCredentials>>>;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSAccessCredentials>>;
    /**
     * create a organization, the user creating will be listed as owner
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganization(organization: Organization, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAWSAccessCredentials(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * delete a organization
     * @param {string} organization organization name or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrganization(organization: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserFromOrganization(organization: string, username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * get all organizations that the user is member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOrganizations(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>>;
    /**
     * get a organization
     * @param {string} organization organization name or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization(organization: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>>;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUser(organization: string, username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationUser>>;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * update a organization
     * @param {string} organization organization name or ID
     * @param {Organization} organizationDetails organization details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOrganization(organization: string, organizationDetails: Organization, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * OrganizationApi - factory interface
 * @export
 */
declare const OrganizationApiFactory$1: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void>;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToOrganization(organization: string, user: OrganizationUser, options?: any): AxiosPromise<void>;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentials(namespace: string, options?: any): AxiosPromise<Array<AWSAccessCredentials>>;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): AxiosPromise<AWSAccessCredentials>;
    /**
     * create a organization, the user creating will be listed as owner
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganization(organization: Organization, options?: any): AxiosPromise<void>;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAWSAccessCredentials(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * delete a organization
     * @param {string} organization organization name or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrganization(organization: string, options?: any): AxiosPromise<void>;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserFromOrganization(organization: string, username: string, options?: any): AxiosPromise<void>;
    /**
     * get all organizations that the user is member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOrganizations(options?: any): AxiosPromise<Array<Organization>>;
    /**
     * get a organization
     * @param {string} organization organization name or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization(organization: string, options?: any): AxiosPromise<Organization>;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUser(organization: string, username: string, options?: any): AxiosPromise<OrganizationUser>;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void>;
    /**
     * update a organization
     * @param {string} organization organization name or ID
     * @param {Organization} organizationDetails organization details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOrganization(organization: string, organizationDetails: Organization, options?: any): AxiosPromise<void>;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): AxiosPromise<void>;
};
/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
declare class OrganizationApi$1 extends BaseAPI$1 {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addUserToOrganization(organization: string, user: OrganizationUser, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    checkAWSAccessCredentials(namespace: string, options?: any): Promise<axios.AxiosResponse<AWSAccessCredentials[]>>;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<AWSAccessCredentials>>;
    /**
     * create a organization, the user creating will be listed as owner
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    createOrganization(organization: Organization, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteAWSAccessCredentials(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * delete a organization
     * @param {string} organization organization name or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteOrganization(organization: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteUserFromOrganization(organization: string, username: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * get all organizations that the user is member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getAllOrganizations(options?: any): Promise<axios.AxiosResponse<Organization[]>>;
    /**
     * get a organization
     * @param {string} organization organization name or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getOrganization(organization: string, options?: any): Promise<axios.AxiosResponse<Organization>>;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getOrganizationUser(organization: string, username: string, options?: any): Promise<axios.AxiosResponse<OrganizationUser>>;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * update a organization
     * @param {string} organization organization name or ID
     * @param {Organization} organizationDetails organization details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateOrganization(organization: string, organizationDetails: Organization, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): Promise<axios.AxiosResponse<void>>;
}
/**
 * QueryApi - axios parameter creator
 * @export
 */
declare const QueryApiAxiosParamCreator$1: (configuration?: Configuration$1) => {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    finalizeQuery: (namespace: string, array: string, type: string, contentType: string, query: Query$1, xPayer?: string, openAt?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEstResultSizes: (namespace: string, array: string, type: string, contentType: string, query: Query$1, xPayer?: string, openAt?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns file bytes
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile: (namespace: string, array: string, contentType: string, xPayer?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQuery: (namespace: string, array: string, type: string, contentType: string, query: Query$1, xPayer?: string, openAt?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns JSON results
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {QueryJson} queryJson query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQueryJson: (namespace: string, array: string, contentType: string, queryJson: QueryJson, xPayer?: string, options?: any) => Promise<RequestArgs$1>;
};
/**
 * QueryApi - functional programming interface
 * @export
 */
declare const QueryApiFp$1: (configuration?: Configuration$1) => {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    finalizeQuery(namespace: string, array: string, type: string, contentType: string, query: Query$1, xPayer?: string, openAt?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Query$1>>;
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEstResultSizes(namespace: string, array: string, type: string, contentType: string, query: Query$1, xPayer?: string, openAt?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Query$1>>;
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns file bytes
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>>;
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query$1, xPayer?: string, openAt?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Query$1>>;
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns JSON results
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {QueryJson} queryJson query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQueryJson(namespace: string, array: string, contentType: string, queryJson: QueryJson, xPayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>>;
};
/**
 * QueryApi - factory interface
 * @export
 */
declare const QueryApiFactory$1: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    finalizeQuery(namespace: string, array: string, type: string, contentType: string, query: Query$1, xPayer?: string, openAt?: number, options?: any): AxiosPromise<Query$1>;
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEstResultSizes(namespace: string, array: string, type: string, contentType: string, query: Query$1, xPayer?: string, openAt?: number, options?: any): AxiosPromise<Query$1>;
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns file bytes
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): AxiosPromise<any>;
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query$1, xPayer?: string, openAt?: number, options?: any): AxiosPromise<Query$1>;
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns JSON results
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {QueryJson} queryJson query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQueryJson(namespace: string, array: string, contentType: string, queryJson: QueryJson, xPayer?: string, options?: any): AxiosPromise<object>;
};
/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
declare class QueryApi$1 extends BaseAPI$1 {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    finalizeQuery(namespace: string, array: string, type: string, contentType: string, query: Query$1, xPayer?: string, openAt?: number, options?: any): Promise<axios.AxiosResponse<Query$1>>;
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    getEstResultSizes(namespace: string, array: string, type: string, contentType: string, query: Query$1, xPayer?: string, openAt?: number, options?: any): Promise<axios.AxiosResponse<Query$1>>;
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns file bytes
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    getFile(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): Promise<axios.AxiosResponse<any>>;
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query$1, xPayer?: string, openAt?: number, options?: any): Promise<axios.AxiosResponse<Query$1>>;
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns JSON results
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {QueryJson} queryJson query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQueryJson(namespace: string, array: string, contentType: string, queryJson: QueryJson, xPayer?: string, options?: any): Promise<axios.AxiosResponse<object>>;
}
/**
 * RegisteredTaskGraphsApi - axios parameter creator
 * @export
 */
declare const RegisteredTaskGraphsApiAxiosParamCreator: (configuration?: Configuration$1) => {
    /**
     * Delete the given registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRegisteredTaskGraph: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch the contents of this registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegisteredTaskGraph: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Get sharing policies for the task graph.
     * @param {string} namespace The namespace that owns the registered task graph.
     * @param {string} name The name of the task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegisteredTaskGraphSharingPolicies: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Register a task graph in the given namespace, with the given name.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {RegisteredTaskGraph} [graph] Task graph to register.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerRegisteredTaskGraph: (namespace: string, name: string, graph?: RegisteredTaskGraph, options?: any) => Promise<RequestArgs$1>;
    /**
     * Share a task graph.
     * @param {string} namespace The namespace that owns the registered task graph.
     * @param {string} name The name of the task graph.
     * @param {TaskGraphSharing} taskGraphSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareRegisteredTaskGraph: (namespace: string, name: string, taskGraphSharing: TaskGraphSharing, options?: any) => Promise<RequestArgs$1>;
    /**
     * Update the contents of an existing registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {RegisteredTaskGraph} [graph] The new contents of the task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRegisteredTaskGraph: (namespace: string, name: string, graph?: RegisteredTaskGraph, options?: any) => Promise<RequestArgs$1>;
};
/**
 * RegisteredTaskGraphsApi - functional programming interface
 * @export
 */
declare const RegisteredTaskGraphsApiFp: (configuration?: Configuration$1) => {
    /**
     * Delete the given registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRegisteredTaskGraph(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Fetch the contents of this registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegisteredTaskGraph(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisteredTaskGraph>>;
    /**
     * Get sharing policies for the task graph.
     * @param {string} namespace The namespace that owns the registered task graph.
     * @param {string} name The name of the task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegisteredTaskGraphSharingPolicies(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskGraphSharing>>>;
    /**
     * Register a task graph in the given namespace, with the given name.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {RegisteredTaskGraph} [graph] Task graph to register.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerRegisteredTaskGraph(namespace: string, name: string, graph?: RegisteredTaskGraph, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Share a task graph.
     * @param {string} namespace The namespace that owns the registered task graph.
     * @param {string} name The name of the task graph.
     * @param {TaskGraphSharing} taskGraphSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareRegisteredTaskGraph(namespace: string, name: string, taskGraphSharing: TaskGraphSharing, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Update the contents of an existing registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {RegisteredTaskGraph} [graph] The new contents of the task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRegisteredTaskGraph(namespace: string, name: string, graph?: RegisteredTaskGraph, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * RegisteredTaskGraphsApi - factory interface
 * @export
 */
declare const RegisteredTaskGraphsApiFactory: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Delete the given registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRegisteredTaskGraph(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * Fetch the contents of this registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegisteredTaskGraph(namespace: string, name: string, options?: any): AxiosPromise<RegisteredTaskGraph>;
    /**
     * Get sharing policies for the task graph.
     * @param {string} namespace The namespace that owns the registered task graph.
     * @param {string} name The name of the task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegisteredTaskGraphSharingPolicies(namespace: string, name: string, options?: any): AxiosPromise<Array<TaskGraphSharing>>;
    /**
     * Register a task graph in the given namespace, with the given name.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {RegisteredTaskGraph} [graph] Task graph to register.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerRegisteredTaskGraph(namespace: string, name: string, graph?: RegisteredTaskGraph, options?: any): AxiosPromise<void>;
    /**
     * Share a task graph.
     * @param {string} namespace The namespace that owns the registered task graph.
     * @param {string} name The name of the task graph.
     * @param {TaskGraphSharing} taskGraphSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareRegisteredTaskGraph(namespace: string, name: string, taskGraphSharing: TaskGraphSharing, options?: any): AxiosPromise<void>;
    /**
     * Update the contents of an existing registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {RegisteredTaskGraph} [graph] The new contents of the task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRegisteredTaskGraph(namespace: string, name: string, graph?: RegisteredTaskGraph, options?: any): AxiosPromise<void>;
};
/**
 * RegisteredTaskGraphsApi - object-oriented interface
 * @export
 * @class RegisteredTaskGraphsApi
 * @extends {BaseAPI}
 */
declare class RegisteredTaskGraphsApi extends BaseAPI$1 {
    /**
     * Delete the given registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    deleteRegisteredTaskGraph(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Fetch the contents of this registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    getRegisteredTaskGraph(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<RegisteredTaskGraph>>;
    /**
     * Get sharing policies for the task graph.
     * @param {string} namespace The namespace that owns the registered task graph.
     * @param {string} name The name of the task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    getRegisteredTaskGraphSharingPolicies(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<TaskGraphSharing[]>>;
    /**
     * Register a task graph in the given namespace, with the given name.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {RegisteredTaskGraph} [graph] Task graph to register.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    registerRegisteredTaskGraph(namespace: string, name: string, graph?: RegisteredTaskGraph, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Share a task graph.
     * @param {string} namespace The namespace that owns the registered task graph.
     * @param {string} name The name of the task graph.
     * @param {TaskGraphSharing} taskGraphSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    shareRegisteredTaskGraph(namespace: string, name: string, taskGraphSharing: TaskGraphSharing, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Update the contents of an existing registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {RegisteredTaskGraph} [graph] The new contents of the task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    updateRegisteredTaskGraph(namespace: string, name: string, graph?: RegisteredTaskGraph, options?: any): Promise<axios.AxiosResponse<void>>;
}
/**
 * SqlApi - axios parameter creator
 * @export
 */
declare const SqlApiAxiosParamCreator: (configuration?: Configuration$1) => {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSQL: (namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any) => Promise<RequestArgs$1>;
};
/**
 * SqlApi - functional programming interface
 * @export
 */
declare const SqlApiFp: (configuration?: Configuration$1) => {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>>;
};
/**
 * SqlApi - factory interface
 * @export
 */
declare const SqlApiFactory: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): AxiosPromise<Array<object>>;
};
/**
 * SqlApi - object-oriented interface
 * @export
 * @class SqlApi
 * @extends {BaseAPI}
 */
declare class SqlApi extends BaseAPI$1 {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SqlApi
     */
    runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): Promise<axios.AxiosResponse<object[]>>;
}
/**
 * StatsApi - axios parameter creator
 * @export
 */
declare const StatsApiAxiosParamCreator: (configuration?: Configuration$1) => {
    /**
     * Fetch libtiledb stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTiledbStats: (options?: any) => Promise<RequestArgs$1>;
};
/**
 * StatsApi - functional programming interface
 * @export
 */
declare const StatsApiFp: (configuration?: Configuration$1) => {
    /**
     * Fetch libtiledb stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTiledbStats(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>>;
};
/**
 * StatsApi - factory interface
 * @export
 */
declare const StatsApiFactory: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Fetch libtiledb stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTiledbStats(options?: any): AxiosPromise<InlineResponse200>;
};
/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
declare class StatsApi extends BaseAPI$1 {
    /**
     * Fetch libtiledb stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    getTiledbStats(options?: any): Promise<axios.AxiosResponse<InlineResponse200>>;
}
/**
 * TaskGraphLogsApi - axios parameter creator
 * @export
 */
declare const TaskGraphLogsApiAxiosParamCreator: (configuration?: Configuration$1) => {
    /**
     * Create a task graph log.
     * @param {string} namespace The namespace that will own this task graph log.
     * @param {TaskGraphLog} log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTaskGraphLog: (namespace: string, log: TaskGraphLog, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch information about a single task graph execution.
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskGraphLog: (namespace: string, id: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata.
     * @param {string} [namespace] Include logs for this namespace.
     * @param {string} [createdBy] Include logs from only this user.
     * @param {string} [search] search string that will look at name.
     * @param {string} [startTime] Include logs created after this time.
     * @param {string} [endTime] Include logs created before this time.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskGraphLogs: (namespace?: string, createdBy?: string, search?: string, startTime?: string, endTime?: string, page?: number, perPage?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     *
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {TaskGraphClientNodeStatus} report The node status to report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reportClientNode: (namespace: string, id: string, report: TaskGraphClientNodeStatus, options?: any) => Promise<RequestArgs$1>;
    /**
     * Update information about a single task graph execution.
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTaskGraphLog: (namespace: string, id: string, log: TaskGraphLog, options?: any) => Promise<RequestArgs$1>;
};
/**
 * TaskGraphLogsApi - functional programming interface
 * @export
 */
declare const TaskGraphLogsApiFp: (configuration?: Configuration$1) => {
    /**
     * Create a task graph log.
     * @param {string} namespace The namespace that will own this task graph log.
     * @param {TaskGraphLog} log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTaskGraphLog(namespace: string, log: TaskGraphLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskGraphLog>>;
    /**
     * Fetch information about a single task graph execution.
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskGraphLog(namespace: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskGraphLog>>;
    /**
     * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata.
     * @param {string} [namespace] Include logs for this namespace.
     * @param {string} [createdBy] Include logs from only this user.
     * @param {string} [search] search string that will look at name.
     * @param {string} [startTime] Include logs created after this time.
     * @param {string} [endTime] Include logs created before this time.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskGraphLogs(namespace?: string, createdBy?: string, search?: string, startTime?: string, endTime?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskGraphLogsData>>;
    /**
     *
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {TaskGraphClientNodeStatus} report The node status to report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reportClientNode(namespace: string, id: string, report: TaskGraphClientNodeStatus, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Update information about a single task graph execution.
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTaskGraphLog(namespace: string, id: string, log: TaskGraphLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * TaskGraphLogsApi - factory interface
 * @export
 */
declare const TaskGraphLogsApiFactory: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a task graph log.
     * @param {string} namespace The namespace that will own this task graph log.
     * @param {TaskGraphLog} log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTaskGraphLog(namespace: string, log: TaskGraphLog, options?: any): AxiosPromise<TaskGraphLog>;
    /**
     * Fetch information about a single task graph execution.
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskGraphLog(namespace: string, id: string, options?: any): AxiosPromise<TaskGraphLog>;
    /**
     * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata.
     * @param {string} [namespace] Include logs for this namespace.
     * @param {string} [createdBy] Include logs from only this user.
     * @param {string} [search] search string that will look at name.
     * @param {string} [startTime] Include logs created after this time.
     * @param {string} [endTime] Include logs created before this time.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTaskGraphLogs(namespace?: string, createdBy?: string, search?: string, startTime?: string, endTime?: string, page?: number, perPage?: number, options?: any): AxiosPromise<TaskGraphLogsData>;
    /**
     *
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {TaskGraphClientNodeStatus} report The node status to report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reportClientNode(namespace: string, id: string, report: TaskGraphClientNodeStatus, options?: any): AxiosPromise<void>;
    /**
     * Update information about a single task graph execution.
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTaskGraphLog(namespace: string, id: string, log: TaskGraphLog, options?: any): AxiosPromise<void>;
};
/**
 * TaskGraphLogsApi - object-oriented interface
 * @export
 * @class TaskGraphLogsApi
 * @extends {BaseAPI}
 */
declare class TaskGraphLogsApi extends BaseAPI$1 {
    /**
     * Create a task graph log.
     * @param {string} namespace The namespace that will own this task graph log.
     * @param {TaskGraphLog} log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    createTaskGraphLog(namespace: string, log: TaskGraphLog, options?: any): Promise<axios.AxiosResponse<TaskGraphLog>>;
    /**
     * Fetch information about a single task graph execution.
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    getTaskGraphLog(namespace: string, id: string, options?: any): Promise<axios.AxiosResponse<TaskGraphLog>>;
    /**
     * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata.
     * @param {string} [namespace] Include logs for this namespace.
     * @param {string} [createdBy] Include logs from only this user.
     * @param {string} [search] search string that will look at name.
     * @param {string} [startTime] Include logs created after this time.
     * @param {string} [endTime] Include logs created before this time.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    listTaskGraphLogs(namespace?: string, createdBy?: string, search?: string, startTime?: string, endTime?: string, page?: number, perPage?: number, options?: any): Promise<axios.AxiosResponse<TaskGraphLogsData>>;
    /**
     *
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {TaskGraphClientNodeStatus} report The node status to report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    reportClientNode(namespace: string, id: string, report: TaskGraphClientNodeStatus, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Update information about a single task graph execution.
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    updateTaskGraphLog(namespace: string, id: string, log: TaskGraphLog, options?: any): Promise<axios.AxiosResponse<void>>;
}
/**
 * TasksApi - axios parameter creator
 * @export
 */
declare const TasksApiAxiosParamCreator: (configuration?: Configuration$1) => {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSQL: (namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch an array task
     * @param {string} id task ID to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskIdGet: (id: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Retrieve results of an array task
     * @param {string} id task ID to retrieve stored results
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskIdResultGet: (id: string, acceptEncoding?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch a list of all array tasks a user has access to
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
     * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
     * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
     * @param {string} [status] Filter to only return these statuses
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include start_time, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksGet: (namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, excludeType?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, status?: string, search?: string, orderby?: string, options?: any) => Promise<RequestArgs$1>;
};
/**
 * TasksApi - functional programming interface
 * @export
 */
declare const TasksApiFp: (configuration?: Configuration$1) => {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>>;
    /**
     * Fetch an array task
     * @param {string} id task ID to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayTask>>;
    /**
     * Retrieve results of an array task
     * @param {string} id task ID to retrieve stored results
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskIdResultGet(id: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     * Fetch a list of all array tasks a user has access to
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
     * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
     * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
     * @param {string} [status] Filter to only return these statuses
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include start_time, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksGet(namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, excludeType?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, status?: string, search?: string, orderby?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayTaskData>>;
};
/**
 * TasksApi - factory interface
 * @export
 */
declare const TasksApiFactory: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): AxiosPromise<Array<object>>;
    /**
     * Fetch an array task
     * @param {string} id task ID to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskIdGet(id: string, options?: any): AxiosPromise<ArrayTask>;
    /**
     * Retrieve results of an array task
     * @param {string} id task ID to retrieve stored results
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taskIdResultGet(id: string, acceptEncoding?: string, options?: any): AxiosPromise<string>;
    /**
     * Fetch a list of all array tasks a user has access to
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
     * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
     * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
     * @param {string} [status] Filter to only return these statuses
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include start_time, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tasksGet(namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, excludeType?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, status?: string, search?: string, orderby?: string, options?: any): AxiosPromise<ArrayTaskData>;
};
/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
declare class TasksApi extends BaseAPI$1 {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): Promise<axios.AxiosResponse<object[]>>;
    /**
     * Fetch an array task
     * @param {string} id task ID to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    taskIdGet(id: string, options?: any): Promise<axios.AxiosResponse<ArrayTask>>;
    /**
     * Retrieve results of an array task
     * @param {string} id task ID to retrieve stored results
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    taskIdResultGet(id: string, acceptEncoding?: string, options?: any): Promise<axios.AxiosResponse<string>>;
    /**
     * Fetch a list of all array tasks a user has access to
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
     * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
     * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
     * @param {string} [status] Filter to only return these statuses
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include start_time, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    tasksGet(namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, excludeType?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, status?: string, search?: string, orderby?: string, options?: any): Promise<axios.AxiosResponse<ArrayTaskData>>;
}
/**
 * UdfApi - axios parameter creator
 * @export
 */
declare const UdfApiAxiosParamCreator: (configuration?: Configuration$1) => {
    /**
     * delete a registered UDF -- this will remove all sharing and can not be undone
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUDFInfo: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * get a specific UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFInfo: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Get all sharing details of the UDF
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFInfoSharingPolicies: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Copy a tiledb udf at the specified location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFCopy} uDFCopy Input/Output information to copy a UDF
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {number} [endTimestamp] Milliseconds since Unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleCopyUDF: (namespace: string, name: string, uDFCopy: UDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, endTimestamp?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     * register a UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {UDFInfoUpdate} udf UDF to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUDFInfo: (namespace: string, name: string, udf: UDFInfoUpdate, options?: any) => Promise<RequestArgs$1>;
    /**
     * Share a UDF with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareUDFInfo: (namespace: string, name: string, udfSharing: UDFSharing, options?: any) => Promise<RequestArgs$1>;
    /**
     * submit a generic UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {GenericUDF} udf UDF to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitGenericUDF: (namespace: string, udf: GenericUDF, acceptEncoding?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * submit a multi-array UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {MultiArrayUDF} udf UDF to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitMultiArrayUDF: (namespace: string, udf: MultiArrayUDF, acceptEncoding?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * send a UDF to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {MultiArrayUDF} udf UDF to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {string} [acceptEncoding] Encoding to use
     * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitUDF: (namespace: string, array: string, udf: MultiArrayUDF, xPayer?: string, acceptEncoding?: string, v2?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    udfNamespaceArrayEndTimestampsGet: (namespace: string, array: string, page?: number, perPage?: number, options?: any) => Promise<RequestArgs$1>;
    /**
     * update an existing registered UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {UDFInfoUpdate} udf UDF to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUDFInfo: (namespace: string, name: string, udf: UDFInfoUpdate, options?: any) => Promise<RequestArgs$1>;
};
/**
 * UdfApi - functional programming interface
 * @export
 */
declare const UdfApiFp: (configuration?: Configuration$1) => {
    /**
     * delete a registered UDF -- this will remove all sharing and can not be undone
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUDFInfo(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * get a specific UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFInfo(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UDFInfo>>;
    /**
     * Get all sharing details of the UDF
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFInfoSharingPolicies(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UDFSharing>>>;
    /**
     * Copy a tiledb udf at the specified location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFCopy} uDFCopy Input/Output information to copy a UDF
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {number} [endTimestamp] Milliseconds since Unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleCopyUDF(namespace: string, name: string, uDFCopy: UDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, endTimestamp?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UDFCopied>>;
    /**
     * register a UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {UDFInfoUpdate} udf UDF to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Share a UDF with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareUDFInfo(namespace: string, name: string, udfSharing: UDFSharing, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * submit a generic UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {GenericUDF} udf UDF to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitGenericUDF(namespace: string, udf: GenericUDF, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>>;
    /**
     * submit a multi-array UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {MultiArrayUDF} udf UDF to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitMultiArrayUDF(namespace: string, udf: MultiArrayUDF, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>>;
    /**
     * send a UDF to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {MultiArrayUDF} udf UDF to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {string} [acceptEncoding] Encoding to use
     * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitUDF(namespace: string, array: string, udf: MultiArrayUDF, xPayer?: string, acceptEncoding?: string, v2?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>>;
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    udfNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayEndTimestampData>>;
    /**
     * update an existing registered UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {UDFInfoUpdate} udf UDF to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * UdfApi - factory interface
 * @export
 */
declare const UdfApiFactory: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * delete a registered UDF -- this will remove all sharing and can not be undone
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUDFInfo(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * get a specific UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFInfo(namespace: string, name: string, options?: any): AxiosPromise<UDFInfo>;
    /**
     * Get all sharing details of the UDF
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUDFInfoSharingPolicies(namespace: string, name: string, options?: any): AxiosPromise<Array<UDFSharing>>;
    /**
     * Copy a tiledb udf at the specified location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFCopy} uDFCopy Input/Output information to copy a UDF
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {number} [endTimestamp] Milliseconds since Unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleCopyUDF(namespace: string, name: string, uDFCopy: UDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, endTimestamp?: number, options?: any): AxiosPromise<UDFCopied>;
    /**
     * register a UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {UDFInfoUpdate} udf UDF to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any): AxiosPromise<void>;
    /**
     * Share a UDF with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shareUDFInfo(namespace: string, name: string, udfSharing: UDFSharing, options?: any): AxiosPromise<void>;
    /**
     * submit a generic UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {GenericUDF} udf UDF to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitGenericUDF(namespace: string, udf: GenericUDF, acceptEncoding?: string, options?: any): AxiosPromise<any>;
    /**
     * submit a multi-array UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {MultiArrayUDF} udf UDF to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitMultiArrayUDF(namespace: string, udf: MultiArrayUDF, acceptEncoding?: string, options?: any): AxiosPromise<any>;
    /**
     * send a UDF to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {MultiArrayUDF} udf UDF to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {string} [acceptEncoding] Encoding to use
     * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitUDF(namespace: string, array: string, udf: MultiArrayUDF, xPayer?: string, acceptEncoding?: string, v2?: string, options?: any): AxiosPromise<any>;
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    udfNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): AxiosPromise<ArrayEndTimestampData>;
    /**
     * update an existing registered UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {UDFInfoUpdate} udf UDF to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any): AxiosPromise<void>;
};
/**
 * UdfApi - object-oriented interface
 * @export
 * @class UdfApi
 * @extends {BaseAPI}
 */
declare class UdfApi extends BaseAPI$1 {
    /**
     * delete a registered UDF -- this will remove all sharing and can not be undone
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    deleteUDFInfo(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * get a specific UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    getUDFInfo(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<UDFInfo>>;
    /**
     * Get all sharing details of the UDF
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    getUDFInfoSharingPolicies(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<UDFSharing[]>>;
    /**
     * Copy a tiledb udf at the specified location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFCopy} uDFCopy Input/Output information to copy a UDF
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {number} [endTimestamp] Milliseconds since Unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    handleCopyUDF(namespace: string, name: string, uDFCopy: UDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, endTimestamp?: number, options?: any): Promise<axios.AxiosResponse<UDFCopied>>;
    /**
     * register a UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {UDFInfoUpdate} udf UDF to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    registerUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Share a UDF with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    shareUDFInfo(namespace: string, name: string, udfSharing: UDFSharing, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * submit a generic UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {GenericUDF} udf UDF to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitGenericUDF(namespace: string, udf: GenericUDF, acceptEncoding?: string, options?: any): Promise<axios.AxiosResponse<any>>;
    /**
     * submit a multi-array UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {MultiArrayUDF} udf UDF to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitMultiArrayUDF(namespace: string, udf: MultiArrayUDF, acceptEncoding?: string, options?: any): Promise<axios.AxiosResponse<any>>;
    /**
     * send a UDF to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {MultiArrayUDF} udf UDF to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {string} [acceptEncoding] Encoding to use
     * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitUDF(namespace: string, array: string, udf: MultiArrayUDF, xPayer?: string, acceptEncoding?: string, v2?: string, options?: any): Promise<axios.AxiosResponse<any>>;
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    udfNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): Promise<axios.AxiosResponse<ArrayEndTimestampData>>;
    /**
     * update an existing registered UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {UDFInfoUpdate} udf UDF to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    updateUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any): Promise<axios.AxiosResponse<void>>;
}
/**
 * UserApi - axios parameter creator
 * @export
 */
declare const UserApiAxiosParamCreator$1: (configuration?: Configuration$1) => {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAWSAccessCredentials: (namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any) => Promise<RequestArgs$1>;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToOrganization: (organization: string, user: OrganizationUser, options?: any) => Promise<RequestArgs$1>;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentials: (namespace: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentialsByName: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * confirm user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmEmail: (options?: any) => Promise<RequestArgs$1>;
    /**
     * create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: (user: User, options?: any) => Promise<RequestArgs$1>;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAWSAccessCredentials: (namespace: string, name: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * delete a user
     * @param {string} username username or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: (username: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserFromOrganization: (organization: string, username: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUser: (organization: string, username: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Get session token for user
     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession: (rememberMe?: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * retrieves available token scopes for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenScopes: (options?: any) => Promise<RequestArgs$1>;
    /**
     * get a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: (options?: any) => Promise<RequestArgs$1>;
    /**
     * get a user
     * @param {string} username username or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserWithUsername: (username: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
     * @param {TokenRequest} [tokenRequest] token request object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestToken: (tokenRequest?: TokenRequest, options?: any) => Promise<RequestArgs$1>;
    /**
     * reset user password
     * @param {InlineObject} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUserPassword: (user: InlineObject, options?: any) => Promise<RequestArgs$1>;
    /**
     * revoke an authorization token
     * @param {string} token token name or token itself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken: (token: string, options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch a list of user tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensGet: (options?: any) => Promise<RequestArgs$1>;
    /**
     * Fetch a list of user session tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensSessionGet: (options?: any) => Promise<RequestArgs$1>;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAWSAccessCredentials: (namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any) => Promise<RequestArgs$1>;
    /**
     * update a user
     * @param {string} username username or ID
     * @param {User} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: (username: string, user: User, options?: any) => Promise<RequestArgs$1>;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInOrganization: (organization: string, username: string, user: OrganizationUser, options?: any) => Promise<RequestArgs$1>;
};
/**
 * UserApi - functional programming interface
 * @export
 */
declare const UserApiFp$1: (configuration?: Configuration$1) => {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToOrganization(organization: string, user: OrganizationUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentials(namespace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AWSAccessCredentials>>>;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSAccessCredentials>>;
    /**
     * confirm user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmEmail(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAWSAccessCredentials(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * delete a user
     * @param {string} username username or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserFromOrganization(organization: string, username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUser(organization: string, username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationUser>>;
    /**
     * Get session token for user
     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession(rememberMe?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>>;
    /**
     * retrieves available token scopes for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenScopes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenScope>>>;
    /**
     * get a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>>;
    /**
     * get a user
     * @param {string} username username or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserWithUsername(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>>;
    /**
     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
     * @param {TokenRequest} [tokenRequest] token request object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestToken(tokenRequest?: TokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>>;
    /**
     * reset user password
     * @param {InlineObject} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUserPassword(user: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * revoke an authorization token
     * @param {string} token token name or token itself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Fetch a list of user tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Token>>>;
    /**
     * Fetch a list of user session tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensSessionGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Token>>>;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * update a user
     * @param {string} username username or ID
     * @param {User} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(username: string, user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * UserApi - factory interface
 * @export
 */
declare const UserApiFactory$1: (configuration?: Configuration$1, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void>;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToOrganization(organization: string, user: OrganizationUser, options?: any): AxiosPromise<void>;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentials(namespace: string, options?: any): AxiosPromise<Array<AWSAccessCredentials>>;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): AxiosPromise<AWSAccessCredentials>;
    /**
     * confirm user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmEmail(options?: any): AxiosPromise<void>;
    /**
     * create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(user: User, options?: any): AxiosPromise<void>;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAWSAccessCredentials(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * delete a user
     * @param {string} username username or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(username: string, options?: any): AxiosPromise<void>;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserFromOrganization(organization: string, username: string, options?: any): AxiosPromise<void>;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUser(organization: string, username: string, options?: any): AxiosPromise<OrganizationUser>;
    /**
     * Get session token for user
     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSession(rememberMe?: string, options?: any): AxiosPromise<Token>;
    /**
     * retrieves available token scopes for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokenScopes(options?: any): AxiosPromise<Array<TokenScope>>;
    /**
     * get a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(options?: any): AxiosPromise<User>;
    /**
     * get a user
     * @param {string} username username or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserWithUsername(username: string, options?: any): AxiosPromise<User>;
    /**
     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
     * @param {TokenRequest} [tokenRequest] token request object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestToken(tokenRequest?: TokenRequest, options?: any): AxiosPromise<Token>;
    /**
     * reset user password
     * @param {InlineObject} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUserPassword(user: InlineObject, options?: any): AxiosPromise<void>;
    /**
     * revoke an authorization token
     * @param {string} token token name or token itself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken(token: string, options?: any): AxiosPromise<void>;
    /**
     * Fetch a list of user tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensGet(options?: any): AxiosPromise<Array<Token>>;
    /**
     * Fetch a list of user session tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tokensSessionGet(options?: any): AxiosPromise<Array<Token>>;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void>;
    /**
     * update a user
     * @param {string} username username or ID
     * @param {User} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(username: string, user: User, options?: any): AxiosPromise<void>;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): AxiosPromise<void>;
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
declare class UserApi$1 extends BaseAPI$1 {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addUserToOrganization(organization: string, user: OrganizationUser, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    checkAWSAccessCredentials(namespace: string, options?: any): Promise<axios.AxiosResponse<AWSAccessCredentials[]>>;
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<AWSAccessCredentials>>;
    /**
     * confirm user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    confirmEmail(options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createUser(user: User, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteAWSAccessCredentials(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * delete a user
     * @param {string} username username or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUser(username: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUserFromOrganization(organization: string, username: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getOrganizationUser(organization: string, username: string, options?: any): Promise<axios.AxiosResponse<OrganizationUser>>;
    /**
     * Get session token for user
     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getSession(rememberMe?: string, options?: any): Promise<axios.AxiosResponse<Token>>;
    /**
     * retrieves available token scopes for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getTokenScopes(options?: any): Promise<axios.AxiosResponse<TokenScope[]>>;
    /**
     * get a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(options?: any): Promise<axios.AxiosResponse<User>>;
    /**
     * get a user
     * @param {string} username username or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserWithUsername(username: string, options?: any): Promise<axios.AxiosResponse<User>>;
    /**
     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
     * @param {TokenRequest} [tokenRequest] token request object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    requestToken(tokenRequest?: TokenRequest, options?: any): Promise<axios.AxiosResponse<Token>>;
    /**
     * reset user password
     * @param {InlineObject} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    resetUserPassword(user: InlineObject, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * revoke an authorization token
     * @param {string} token token name or token itself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    revokeToken(token: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Fetch a list of user tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokensGet(options?: any): Promise<axios.AxiosResponse<Token[]>>;
    /**
     * Fetch a list of user session tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokensSessionGet(options?: any): Promise<axios.AxiosResponse<Token[]>>;
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * update a user
     * @param {string} username username or ID
     * @param {User} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUser(username: string, user: User, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): Promise<axios.AxiosResponse<void>>;
}

type api_AWSAccessCredentials = AWSAccessCredentials;
type api_ArrayActions = ArrayActions;
declare const api_ArrayActions: typeof ArrayActions;
type api_ArrayBrowserData = ArrayBrowserData;
type api_ArrayBrowserSidebar = ArrayBrowserSidebar;
type api_ArrayEndTimestampData = ArrayEndTimestampData;
type api_ArrayFavorite = ArrayFavorite;
type api_ArrayFavoritesData = ArrayFavoritesData;
type api_ArrayInfo = ArrayInfo;
type api_ArrayInfoUpdate = ArrayInfoUpdate;
type api_ArrayMetadata = ArrayMetadata;
type api_ArrayMetadataEntry = ArrayMetadataEntry;
type api_ArraySample = ArraySample;
type api_ArraySchema = ArraySchema;
type api_ArraySharing = ArraySharing;
type api_ArrayTask = ArrayTask;
type api_ArrayTaskBrowserSidebar = ArrayTaskBrowserSidebar;
type api_ArrayTaskData = ArrayTaskData;
type api_ArrayTaskLog = ArrayTaskLog;
type api_ArrayTaskStatus = ArrayTaskStatus;
declare const api_ArrayTaskStatus: typeof ArrayTaskStatus;
type api_ArrayTaskType = ArrayTaskType;
declare const api_ArrayTaskType: typeof ArrayTaskType;
type api_ArrayTasksApi = ArrayTasksApi;
declare const api_ArrayTasksApi: typeof ArrayTasksApi;
declare const api_ArrayTasksApiAxiosParamCreator: typeof ArrayTasksApiAxiosParamCreator;
declare const api_ArrayTasksApiFactory: typeof ArrayTasksApiFactory;
declare const api_ArrayTasksApiFp: typeof ArrayTasksApiFp;
type api_ArrayType = ArrayType;
declare const api_ArrayType: typeof ArrayType;
type api_AssetLocations = AssetLocations;
type api_Attribute = Attribute;
type api_Dimension = Dimension;
type api_DimensionCoordinate = DimensionCoordinate;
type api_DimensionTileExtent = DimensionTileExtent;
type api_Domain = Domain;
type api_FavoritesApi = FavoritesApi;
declare const api_FavoritesApi: typeof FavoritesApi;
declare const api_FavoritesApiAxiosParamCreator: typeof FavoritesApiAxiosParamCreator;
declare const api_FavoritesApiFactory: typeof FavoritesApiFactory;
declare const api_FavoritesApiFp: typeof FavoritesApiFp;
type api_FileCreate = FileCreate;
type api_FileCreated = FileCreated;
type api_FileExport = FileExport;
type api_FileExported = FileExported;
type api_FilePropertyName = FilePropertyName;
declare const api_FilePropertyName: typeof FilePropertyName;
type api_FileType = FileType;
declare const api_FileType: typeof FileType;
type api_FileUploaded = FileUploaded;
type api_FilesApi = FilesApi;
declare const api_FilesApi: typeof FilesApi;
declare const api_FilesApiAxiosParamCreator: typeof FilesApiAxiosParamCreator;
declare const api_FilesApiFactory: typeof FilesApiFactory;
declare const api_FilesApiFp: typeof FilesApiFp;
type api_Filter = Filter;
type api_FilterData = FilterData;
type api_FilterOption = FilterOption;
declare const api_FilterOption: typeof FilterOption;
type api_FilterPipeline = FilterPipeline;
type api_FilterType = FilterType;
declare const api_FilterType: typeof FilterType;
type api_GenericUDF = GenericUDF;
type api_GroupActions = GroupActions;
declare const api_GroupActions: typeof GroupActions;
type api_GroupBrowserData = GroupBrowserData;
type api_GroupBrowserFilterData = GroupBrowserFilterData;
type api_GroupChanges = GroupChanges;
type api_GroupContents = GroupContents;
type api_GroupContentsFilterData = GroupContentsFilterData;
type api_GroupCreate = GroupCreate;
type api_GroupEntry = GroupEntry;
type api_GroupInfo = GroupInfo;
type api_GroupRegister = GroupRegister;
type api_GroupSharing = GroupSharing;
type api_GroupSharingRequest = GroupSharingRequest;
type api_GroupUpdate = GroupUpdate;
type api_InlineObject = InlineObject;
type api_InlineResponse200 = InlineResponse200;
type api_Invitation = Invitation;
type api_InvitationApi = InvitationApi;
declare const api_InvitationApi: typeof InvitationApi;
declare const api_InvitationApiAxiosParamCreator: typeof InvitationApiAxiosParamCreator;
declare const api_InvitationApiFactory: typeof InvitationApiFactory;
declare const api_InvitationApiFp: typeof InvitationApiFp;
type api_InvitationArrayShareEmail = InvitationArrayShareEmail;
type api_InvitationData = InvitationData;
type api_InvitationOrganizationJoinEmail = InvitationOrganizationJoinEmail;
type api_InvitationStatus = InvitationStatus;
declare const api_InvitationStatus: typeof InvitationStatus;
type api_InvitationType = InvitationType;
declare const api_InvitationType: typeof InvitationType;
type api_LastAccessedArray = LastAccessedArray;
type api_MLModelFavorite = MLModelFavorite;
type api_MLModelFavoritesData = MLModelFavoritesData;
type api_MaxBufferSizes = MaxBufferSizes;
type api_MultiArrayUDF = MultiArrayUDF;
type api_NamespaceActions = NamespaceActions;
declare const api_NamespaceActions: typeof NamespaceActions;
type api_NonEmptyDomain = NonEmptyDomain;
type api_NotebookApi = NotebookApi;
declare const api_NotebookApi: typeof NotebookApi;
declare const api_NotebookApiAxiosParamCreator: typeof NotebookApiAxiosParamCreator;
declare const api_NotebookApiFactory: typeof NotebookApiFactory;
declare const api_NotebookApiFp: typeof NotebookApiFp;
type api_NotebookCopied = NotebookCopied;
type api_NotebookCopy = NotebookCopy;
type api_NotebookFavorite = NotebookFavorite;
type api_NotebookFavoritesData = NotebookFavoritesData;
type api_NotebookStatus = NotebookStatus;
type api_NotebooksApi = NotebooksApi;
declare const api_NotebooksApi: typeof NotebooksApi;
declare const api_NotebooksApiAxiosParamCreator: typeof NotebooksApiAxiosParamCreator;
declare const api_NotebooksApiFactory: typeof NotebooksApiFactory;
declare const api_NotebooksApiFp: typeof NotebooksApiFp;
type api_Organization = Organization;
type api_OrganizationRoles = OrganizationRoles;
declare const api_OrganizationRoles: typeof OrganizationRoles;
type api_OrganizationUser = OrganizationUser;
type api_Pricing = Pricing;
type api_PricingAggregateUsage = PricingAggregateUsage;
declare const api_PricingAggregateUsage: typeof PricingAggregateUsage;
type api_PricingCurrency = PricingCurrency;
declare const api_PricingCurrency: typeof PricingCurrency;
type api_PricingInterval = PricingInterval;
declare const api_PricingInterval: typeof PricingInterval;
type api_PricingType = PricingType;
declare const api_PricingType: typeof PricingType;
type api_PricingUnitLabel = PricingUnitLabel;
declare const api_PricingUnitLabel: typeof PricingUnitLabel;
type api_PublicShareFilter = PublicShareFilter;
declare const api_PublicShareFilter: typeof PublicShareFilter;
type api_QueryJson = QueryJson;
type api_QueryRanges = QueryRanges;
type api_RegisteredTaskGraph = RegisteredTaskGraph;
type api_RegisteredTaskGraphNode = RegisteredTaskGraphNode;
type api_RegisteredTaskGraphsApi = RegisteredTaskGraphsApi;
declare const api_RegisteredTaskGraphsApi: typeof RegisteredTaskGraphsApi;
declare const api_RegisteredTaskGraphsApiAxiosParamCreator: typeof RegisteredTaskGraphsApiAxiosParamCreator;
declare const api_RegisteredTaskGraphsApiFactory: typeof RegisteredTaskGraphsApiFactory;
declare const api_RegisteredTaskGraphsApiFp: typeof RegisteredTaskGraphsApiFp;
type api_ResultFormat = ResultFormat;
declare const api_ResultFormat: typeof ResultFormat;
type api_SQLParameters = SQLParameters;
type api_SSOProvider = SSOProvider;
declare const api_SSOProvider: typeof SSOProvider;
type api_SqlApi = SqlApi;
declare const api_SqlApi: typeof SqlApi;
declare const api_SqlApiAxiosParamCreator: typeof SqlApiAxiosParamCreator;
declare const api_SqlApiFactory: typeof SqlApiFactory;
declare const api_SqlApiFp: typeof SqlApiFp;
type api_StatsApi = StatsApi;
declare const api_StatsApi: typeof StatsApi;
declare const api_StatsApiAxiosParamCreator: typeof StatsApiAxiosParamCreator;
declare const api_StatsApiFactory: typeof StatsApiFactory;
declare const api_StatsApiFp: typeof StatsApiFp;
type api_StorageLocation = StorageLocation;
type api_Subscription = Subscription;
type api_TGInputNodeData = TGInputNodeData;
type api_TGSQLNodeData = TGSQLNodeData;
type api_TGUDFArgument = TGUDFArgument;
type api_TGUDFEnvironment = TGUDFEnvironment;
type api_TGUDFNodeData = TGUDFNodeData;
type api_TaskGraphActions = TaskGraphActions;
declare const api_TaskGraphActions: typeof TaskGraphActions;
type api_TaskGraphClientNodeStatus = TaskGraphClientNodeStatus;
type api_TaskGraphLog = TaskGraphLog;
type api_TaskGraphLogRunLocation = TaskGraphLogRunLocation;
declare const api_TaskGraphLogRunLocation: typeof TaskGraphLogRunLocation;
type api_TaskGraphLogStatus = TaskGraphLogStatus;
declare const api_TaskGraphLogStatus: typeof TaskGraphLogStatus;
type api_TaskGraphLogsApi = TaskGraphLogsApi;
declare const api_TaskGraphLogsApi: typeof TaskGraphLogsApi;
declare const api_TaskGraphLogsApiAxiosParamCreator: typeof TaskGraphLogsApiAxiosParamCreator;
declare const api_TaskGraphLogsApiFactory: typeof TaskGraphLogsApiFactory;
declare const api_TaskGraphLogsApiFp: typeof TaskGraphLogsApiFp;
type api_TaskGraphLogsData = TaskGraphLogsData;
type api_TaskGraphNodeMetadata = TaskGraphNodeMetadata;
type api_TaskGraphSharing = TaskGraphSharing;
type api_TasksApi = TasksApi;
declare const api_TasksApi: typeof TasksApi;
declare const api_TasksApiAxiosParamCreator: typeof TasksApiAxiosParamCreator;
declare const api_TasksApiFactory: typeof TasksApiFactory;
declare const api_TasksApiFp: typeof TasksApiFp;
type api_Token = Token;
type api_TokenRequest = TokenRequest;
type api_TokenScope = TokenScope;
declare const api_TokenScope: typeof TokenScope;
type api_UDFActions = UDFActions;
declare const api_UDFActions: typeof UDFActions;
type api_UDFArrayDetails = UDFArrayDetails;
type api_UDFCopied = UDFCopied;
type api_UDFCopy = UDFCopy;
type api_UDFFavorite = UDFFavorite;
type api_UDFFavoritesData = UDFFavoritesData;
type api_UDFImage = UDFImage;
type api_UDFImageVersion = UDFImageVersion;
type api_UDFInfo = UDFInfo;
type api_UDFInfoUpdate = UDFInfoUpdate;
type api_UDFLanguage = UDFLanguage;
declare const api_UDFLanguage: typeof UDFLanguage;
type api_UDFSharing = UDFSharing;
type api_UDFSubarray = UDFSubarray;
type api_UDFSubarrayRange = UDFSubarrayRange;
type api_UDFType = UDFType;
declare const api_UDFType: typeof UDFType;
type api_UdfApi = UdfApi;
declare const api_UdfApi: typeof UdfApi;
declare const api_UdfApiAxiosParamCreator: typeof UdfApiAxiosParamCreator;
declare const api_UdfApiFactory: typeof UdfApiFactory;
declare const api_UdfApiFp: typeof UdfApiFp;
type api_User = User;
declare namespace api {
  export {
    api_AWSAccessCredentials as AWSAccessCredentials,
    ActivityEventType$1 as ActivityEventType,
    api_ArrayActions as ArrayActions,
    ArrayActivityLog$1 as ArrayActivityLog,
    ArrayApi$1 as ArrayApi,
    ArrayApiAxiosParamCreator$1 as ArrayApiAxiosParamCreator,
    ArrayApiFactory$1 as ArrayApiFactory,
    ArrayApiFp$1 as ArrayApiFp,
    api_ArrayBrowserData as ArrayBrowserData,
    api_ArrayBrowserSidebar as ArrayBrowserSidebar,
    api_ArrayEndTimestampData as ArrayEndTimestampData,
    api_ArrayFavorite as ArrayFavorite,
    api_ArrayFavoritesData as ArrayFavoritesData,
    api_ArrayInfo as ArrayInfo,
    api_ArrayInfoUpdate as ArrayInfoUpdate,
    api_ArrayMetadata as ArrayMetadata,
    api_ArrayMetadataEntry as ArrayMetadataEntry,
    api_ArraySample as ArraySample,
    api_ArraySchema as ArraySchema,
    api_ArraySharing as ArraySharing,
    api_ArrayTask as ArrayTask,
    api_ArrayTaskBrowserSidebar as ArrayTaskBrowserSidebar,
    api_ArrayTaskData as ArrayTaskData,
    api_ArrayTaskLog as ArrayTaskLog,
    api_ArrayTaskStatus as ArrayTaskStatus,
    api_ArrayTaskType as ArrayTaskType,
    api_ArrayTasksApi as ArrayTasksApi,
    api_ArrayTasksApiAxiosParamCreator as ArrayTasksApiAxiosParamCreator,
    api_ArrayTasksApiFactory as ArrayTasksApiFactory,
    api_ArrayTasksApiFp as ArrayTasksApiFp,
    api_ArrayType as ArrayType,
    api_AssetLocations as AssetLocations,
    api_Attribute as Attribute,
    AttributeBufferHeader$1 as AttributeBufferHeader,
    AttributeBufferSize$1 as AttributeBufferSize,
    Datatype$1 as Datatype,
    api_Dimension as Dimension,
    api_DimensionCoordinate as DimensionCoordinate,
    api_DimensionTileExtent as DimensionTileExtent,
    api_Domain as Domain,
    DomainArray$1 as DomainArray,
    api_FavoritesApi as FavoritesApi,
    api_FavoritesApiAxiosParamCreator as FavoritesApiAxiosParamCreator,
    api_FavoritesApiFactory as FavoritesApiFactory,
    api_FavoritesApiFp as FavoritesApiFp,
    api_FileCreate as FileCreate,
    api_FileCreated as FileCreated,
    api_FileExport as FileExport,
    api_FileExported as FileExported,
    api_FilePropertyName as FilePropertyName,
    api_FileType as FileType,
    api_FileUploaded as FileUploaded,
    api_FilesApi as FilesApi,
    api_FilesApiAxiosParamCreator as FilesApiAxiosParamCreator,
    api_FilesApiFactory as FilesApiFactory,
    api_FilesApiFp as FilesApiFp,
    api_Filter as Filter,
    api_FilterData as FilterData,
    api_FilterOption as FilterOption,
    api_FilterPipeline as FilterPipeline,
    api_FilterType as FilterType,
    api_GenericUDF as GenericUDF,
    api_GroupActions as GroupActions,
    api_GroupBrowserData as GroupBrowserData,
    api_GroupBrowserFilterData as GroupBrowserFilterData,
    api_GroupChanges as GroupChanges,
    api_GroupContents as GroupContents,
    api_GroupContentsFilterData as GroupContentsFilterData,
    api_GroupCreate as GroupCreate,
    api_GroupEntry as GroupEntry,
    api_GroupInfo as GroupInfo,
    GroupMember$1 as GroupMember,
    GroupMemberAssetType$1 as GroupMemberAssetType,
    GroupMemberType$1 as GroupMemberType,
    api_GroupRegister as GroupRegister,
    api_GroupSharing as GroupSharing,
    api_GroupSharingRequest as GroupSharingRequest,
    api_GroupUpdate as GroupUpdate,
    GroupsApi$1 as GroupsApi,
    GroupsApiAxiosParamCreator$1 as GroupsApiAxiosParamCreator,
    GroupsApiFactory$1 as GroupsApiFactory,
    GroupsApiFp$1 as GroupsApiFp,
    api_InlineObject as InlineObject,
    api_InlineResponse200 as InlineResponse200,
    api_Invitation as Invitation,
    api_InvitationApi as InvitationApi,
    api_InvitationApiAxiosParamCreator as InvitationApiAxiosParamCreator,
    api_InvitationApiFactory as InvitationApiFactory,
    api_InvitationApiFp as InvitationApiFp,
    api_InvitationArrayShareEmail as InvitationArrayShareEmail,
    api_InvitationData as InvitationData,
    api_InvitationOrganizationJoinEmail as InvitationOrganizationJoinEmail,
    api_InvitationStatus as InvitationStatus,
    api_InvitationType as InvitationType,
    api_LastAccessedArray as LastAccessedArray,
    Layout$1 as Layout,
    api_MLModelFavorite as MLModelFavorite,
    api_MLModelFavoritesData as MLModelFavoritesData,
    api_MaxBufferSizes as MaxBufferSizes,
    ModelArray$1 as ModelArray,
    ModelError$1 as ModelError,
    api_MultiArrayUDF as MultiArrayUDF,
    api_NamespaceActions as NamespaceActions,
    api_NonEmptyDomain as NonEmptyDomain,
    api_NotebookApi as NotebookApi,
    api_NotebookApiAxiosParamCreator as NotebookApiAxiosParamCreator,
    api_NotebookApiFactory as NotebookApiFactory,
    api_NotebookApiFp as NotebookApiFp,
    api_NotebookCopied as NotebookCopied,
    api_NotebookCopy as NotebookCopy,
    api_NotebookFavorite as NotebookFavorite,
    api_NotebookFavoritesData as NotebookFavoritesData,
    api_NotebookStatus as NotebookStatus,
    api_NotebooksApi as NotebooksApi,
    api_NotebooksApiAxiosParamCreator as NotebooksApiAxiosParamCreator,
    api_NotebooksApiFactory as NotebooksApiFactory,
    api_NotebooksApiFp as NotebooksApiFp,
    api_Organization as Organization,
    OrganizationApi$1 as OrganizationApi,
    OrganizationApiAxiosParamCreator$1 as OrganizationApiAxiosParamCreator,
    OrganizationApiFactory$1 as OrganizationApiFactory,
    OrganizationApiFp$1 as OrganizationApiFp,
    api_OrganizationRoles as OrganizationRoles,
    api_OrganizationUser as OrganizationUser,
    PaginationMetadata$1 as PaginationMetadata,
    api_Pricing as Pricing,
    api_PricingAggregateUsage as PricingAggregateUsage,
    api_PricingCurrency as PricingCurrency,
    api_PricingInterval as PricingInterval,
    api_PricingType as PricingType,
    api_PricingUnitLabel as PricingUnitLabel,
    api_PublicShareFilter as PublicShareFilter,
    Query$1 as Query,
    QueryApi$1 as QueryApi,
    QueryApiAxiosParamCreator$1 as QueryApiAxiosParamCreator,
    QueryApiFactory$1 as QueryApiFactory,
    QueryApiFp$1 as QueryApiFp,
    api_QueryJson as QueryJson,
    api_QueryRanges as QueryRanges,
    QueryReader$1 as QueryReader,
    Querystatus$1 as Querystatus,
    Querytype$1 as Querytype,
    ReadState$1 as ReadState,
    api_RegisteredTaskGraph as RegisteredTaskGraph,
    api_RegisteredTaskGraphNode as RegisteredTaskGraphNode,
    api_RegisteredTaskGraphsApi as RegisteredTaskGraphsApi,
    api_RegisteredTaskGraphsApiAxiosParamCreator as RegisteredTaskGraphsApiAxiosParamCreator,
    api_RegisteredTaskGraphsApiFactory as RegisteredTaskGraphsApiFactory,
    api_RegisteredTaskGraphsApiFp as RegisteredTaskGraphsApiFp,
    api_ResultFormat as ResultFormat,
    api_SQLParameters as SQLParameters,
    api_SSOProvider as SSOProvider,
    api_SqlApi as SqlApi,
    api_SqlApiAxiosParamCreator as SqlApiAxiosParamCreator,
    api_SqlApiFactory as SqlApiFactory,
    api_SqlApiFp as SqlApiFp,
    api_StatsApi as StatsApi,
    api_StatsApiAxiosParamCreator as StatsApiAxiosParamCreator,
    api_StatsApiFactory as StatsApiFactory,
    api_StatsApiFp as StatsApiFp,
    api_StorageLocation as StorageLocation,
    Subarray$1 as Subarray,
    SubarrayPartitioner$1 as SubarrayPartitioner,
    SubarrayPartitionerCurrent$1 as SubarrayPartitionerCurrent,
    SubarrayPartitionerState$1 as SubarrayPartitionerState,
    SubarrayRanges$1 as SubarrayRanges,
    api_Subscription as Subscription,
    api_TGInputNodeData as TGInputNodeData,
    api_TGSQLNodeData as TGSQLNodeData,
    api_TGUDFArgument as TGUDFArgument,
    api_TGUDFEnvironment as TGUDFEnvironment,
    api_TGUDFNodeData as TGUDFNodeData,
    api_TaskGraphActions as TaskGraphActions,
    api_TaskGraphClientNodeStatus as TaskGraphClientNodeStatus,
    api_TaskGraphLog as TaskGraphLog,
    api_TaskGraphLogRunLocation as TaskGraphLogRunLocation,
    api_TaskGraphLogStatus as TaskGraphLogStatus,
    api_TaskGraphLogsApi as TaskGraphLogsApi,
    api_TaskGraphLogsApiAxiosParamCreator as TaskGraphLogsApiAxiosParamCreator,
    api_TaskGraphLogsApiFactory as TaskGraphLogsApiFactory,
    api_TaskGraphLogsApiFp as TaskGraphLogsApiFp,
    api_TaskGraphLogsData as TaskGraphLogsData,
    api_TaskGraphNodeMetadata as TaskGraphNodeMetadata,
    api_TaskGraphSharing as TaskGraphSharing,
    api_TasksApi as TasksApi,
    api_TasksApiAxiosParamCreator as TasksApiAxiosParamCreator,
    api_TasksApiFactory as TasksApiFactory,
    api_TasksApiFp as TasksApiFp,
    TileDBConfig$1 as TileDBConfig,
    api_Token as Token,
    api_TokenRequest as TokenRequest,
    api_TokenScope as TokenScope,
    api_UDFActions as UDFActions,
    api_UDFArrayDetails as UDFArrayDetails,
    api_UDFCopied as UDFCopied,
    api_UDFCopy as UDFCopy,
    api_UDFFavorite as UDFFavorite,
    api_UDFFavoritesData as UDFFavoritesData,
    api_UDFImage as UDFImage,
    api_UDFImageVersion as UDFImageVersion,
    api_UDFInfo as UDFInfo,
    api_UDFInfoUpdate as UDFInfoUpdate,
    api_UDFLanguage as UDFLanguage,
    api_UDFSharing as UDFSharing,
    api_UDFSubarray as UDFSubarray,
    api_UDFSubarrayRange as UDFSubarrayRange,
    api_UDFType as UDFType,
    api_UdfApi as UdfApi,
    api_UdfApiAxiosParamCreator as UdfApiAxiosParamCreator,
    api_UdfApiFactory as UdfApiFactory,
    api_UdfApiFp as UdfApiFp,
    api_User as User,
    UserApi$1 as UserApi,
    UserApiAxiosParamCreator$1 as UserApiAxiosParamCreator,
    UserApiFactory$1 as UserApiFactory,
    UserApiFp$1 as UserApiFp,
    Writer$1 as Writer,
  };
}

/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

declare namespace index$1 {
  export {
    Configuration$1 as Configuration,
    ConfigurationParameters$1 as ConfigurationParameters,
    api as V1API,
  };
}

/**
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    baseOptions?: any;
    formDataCtor?: new () => any;
}
declare class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;
    constructor(param?: ConfigurationParameters);
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime?(mime: string): boolean;
    /**
     * Check if the given MIME is a capnp MIME.
     * JSON MIME examples:
     *   application/capnp
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is capnp, false otherwise.
     */
    isCapnpMime?(mime: string): boolean;
}

/**
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface RequestArgs
 */
interface RequestArgs {
    url: string;
    options: AxiosRequestConfig;
}
/**
 *
 * @export
 * @class BaseAPI
 */
declare class BaseAPI {
    protected basePath: string;
    protected axios: AxiosInstance;
    protected configuration: Configuration | undefined;
    constructor(configuration?: Configuration, basePath?: string, axios?: AxiosInstance);
}

/**
 * Credential information to access Amazon Web Services
 * @export
 * @interface AWSCredential
 */
interface AWSCredential {
    /**
     * The ID of the access key
     * @type {string}
     * @memberof AWSCredential
     */
    access_key_id?: string;
    /**
     * The access key\'s secret. Never returned in responses.
     * @type {string}
     * @memberof AWSCredential
     */
    secret_access_key?: string;
}
/**
 * A union type which may contain a credential to access any one cloud provider.
 * @export
 * @interface AccessCredential
 */
interface AccessCredential {
    /**
     * A user-specified name for the key
     * @type {string}
     * @memberof AccessCredential
     */
    name?: string;
    /**
     *
     * @type {CloudProvider}
     * @memberof AccessCredential
     */
    provider?: CloudProvider;
    /**
     * True if this is the namespace\'s default credential to be used when connecting to the given cloud provider. There can be at most one default for each unique provider.
     * @type {boolean}
     * @memberof AccessCredential
     */
    provider_default?: boolean | null;
    /**
     * Time when the credential was created (rfc3339)
     * @type {string}
     * @memberof AccessCredential
     */
    created_at?: string;
    /**
     * Time when the credential was last updated (rfc3339)
     * @type {string}
     * @memberof AccessCredential
     */
    updated_at?: string;
    /**
     *
     * @type {AccessCredentialCredential}
     * @memberof AccessCredential
     */
    credential?: AccessCredentialCredential;
}
/**
 * The credential information itself. Exactly one sub-field may be set. The names match those in the CloudProvider enum.
 * @export
 * @interface AccessCredentialCredential
 */
interface AccessCredentialCredential {
    /**
     *
     * @type {AWSCredential}
     * @memberof AccessCredentialCredential
     */
    aws?: AWSCredential | null;
    /**
     *
     * @type {AzureCredential}
     * @memberof AccessCredentialCredential
     */
    azure?: AzureCredential | null;
}
/**
 * Object including credentials and pagination metadata
 * @export
 * @interface AccessCredentialsData
 */
interface AccessCredentialsData {
    /**
     * List of credentials
     * @type {Array<AccessCredential>}
     * @memberof AccessCredentialsData
     */
    credentials?: Array<AccessCredential>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof AccessCredentialsData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * Type of activity logged
 * @export
 * @enum {string}
 */
declare enum ActivityEventType {
    ReadSchema = "read_schema",
    MaxBufferSizes = "max_buffer_sizes",
    NonEmptyDomain = "non_empty_domain",
    QueryRead = "query_read",
    QueryWrite = "query_write",
    Create = "create",
    Delete = "delete",
    Register = "register",
    Deregister = "deregister",
    Udf = "udf",
    ArrayMetadataGet = "array_metadata_get",
    ArrayMetadataUpdate = "array_metadata_update",
    EstimatedResultSizes = "estimated_result_sizes",
    Update = "update",
    Info = "info",
    Run = "run"
}
/**
 * Actvity of an Array
 * @export
 * @interface ArrayActivityLog
 */
interface ArrayActivityLog {
    /**
     * time event took place (RFC3339)
     * @type {string}
     * @memberof ArrayActivityLog
     */
    event_at?: string;
    /**
     *
     * @type {ActivityEventType}
     * @memberof ArrayActivityLog
     */
    action?: ActivityEventType;
    /**
     * User who performed action
     * @type {string}
     * @memberof ArrayActivityLog
     */
    username?: string;
    /**
     * Bytes sent to client
     * @type {number}
     * @memberof ArrayActivityLog
     */
    bytes_sent?: number;
    /**
     * Bytes recieved from client
     * @type {number}
     * @memberof ArrayActivityLog
     */
    bytes_received?: number;
    /**
     * uuid of associated array task
     * @type {string}
     * @memberof ArrayActivityLog
     */
    array_task_id?: string;
    /**
     * id of the activity
     * @type {string}
     * @memberof ArrayActivityLog
     */
    id?: string;
    /**
     * ranges for query
     * @type {string}
     * @memberof ArrayActivityLog
     */
    query_ranges?: string;
    /**
     * stats for query
     * @type {string}
     * @memberof ArrayActivityLog
     */
    query_stats?: string;
}
/**
 * Object including array tasks and metadata
 * @export
 * @interface ArrayActivityLogData
 */
interface ArrayActivityLogData {
    /**
     * Array ArrayActivityLog
     * @type {Array<ArrayActivityLog>}
     * @memberof ArrayActivityLogData
     */
    activitylogs?: Array<ArrayActivityLog>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof ArrayActivityLogData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * Represents an attribute buffer header information
 * @export
 * @interface AttributeBufferHeader
 */
interface AttributeBufferHeader {
    /**
     * Attribute name
     * @type {string}
     * @memberof AttributeBufferHeader
     */
    name: string;
    /**
     * Number of bytes in the fixed-length attribute data buffer (offsets for var-len attributes)
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    fixedLenBufferSizeInBytes: number;
    /**
     * Number of bytes in the var-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    varLenBufferSizeInBytes: number;
    /**
     * Number of bytes for validity in case attribute is nullable
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    validityLenBufferSizeInBytes?: number;
    /**
     * Original user set number of bytes in the fixed-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    originalFixedLenBufferSizeInBytes?: number;
    /**
     * Original user set number of bytes in the var-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    originalVarLenBufferSizeInBytes?: number;
    /**
     * Original user set number of bytes in the validity data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    originalValidityLenBufferSizeInBytes?: number;
}
/**
 * object representing buffer size of an attribute
 * @export
 * @interface AttributeBufferSize
 */
interface AttributeBufferSize {
    /**
     * name of attribute
     * @type {string}
     * @memberof AttributeBufferSize
     */
    attribute: string;
    /**
     * buffer size (in bytes) of offset buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    offsetBytes: number;
    /**
     * buffer size (in bytes) of data buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    dataBytes: number;
}
/**
 * Credential information to access Microsoft Azure. Each supported property is the snake_case version of its name in an Azure Storage connection string.
 * @export
 * @interface AzureCredential
 */
interface AzureCredential {
    /**
     * The name of the Azure account to access
     * @type {string}
     * @memberof AzureCredential
     */
    account_name?: string;
    /**
     * The secret key. Never returned in responses.
     * @type {string}
     * @memberof AzureCredential
     */
    account_key?: string;
}
/**
 * A service where data is stored or computations take place.
 * @export
 * @enum {string}
 */
declare enum CloudProvider {
    Aws = "AWS",
    Azure = "AZURE"
}
/**
 * TileDB data type
 * @export
 * @enum {string}
 */
declare enum Datatype {
    Int32 = "INT32",
    Int64 = "INT64",
    Float32 = "FLOAT32",
    Float64 = "FLOAT64",
    Char = "CHAR",
    Int8 = "INT8",
    Uint8 = "UINT8",
    Int16 = "INT16",
    Uint16 = "UINT16",
    Uint32 = "UINT32",
    Uint64 = "UINT64",
    StringAscii = "STRING_ASCII",
    StringUtf8 = "STRING_UTF8",
    StringUtf16 = "STRING_UTF16",
    StringUtf32 = "STRING_UTF32",
    StringUcs2 = "STRING_UCS2",
    StringUcs4 = "STRING_UCS4",
    DatetimeYear = "DATETIME_YEAR",
    DatetimeMonth = "DATETIME_MONTH",
    DatetimeWeek = "DATETIME_WEEK",
    DatetimeDay = "DATETIME_DAY",
    DatetimeHr = "DATETIME_HR",
    DatetimeMin = "DATETIME_MIN",
    DatetimeSec = "DATETIME_SEC",
    DatetimeMs = "DATETIME_MS",
    DatetimeUs = "DATETIME_US",
    DatetimeNs = "DATETIME_NS",
    DatetimePs = "DATETIME_PS",
    DatetimeFs = "DATETIME_FS",
    DatetimeAs = "DATETIME_AS",
    Any = "ANY"
}
/**
 * Domain object for an array of each type
 * @export
 * @interface DomainArray
 */
interface DomainArray {
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int8?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint8?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int16?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint16?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int32?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint32?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int64?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint64?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float32?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float64?: Array<number>;
}
/**
 * Updates the contents group
 * @export
 * @interface GroupContentsChangesRequest
 */
interface GroupContentsChangesRequest {
    /**
     *
     * @type {TileDBConfig}
     * @memberof GroupContentsChangesRequest
     */
    config?: TileDBConfig;
    /**
     *
     * @type {GroupContentsChangesRequestGroupChanges}
     * @memberof GroupContentsChangesRequest
     */
    group_changes?: GroupContentsChangesRequestGroupChanges;
}
/**
 *
 * @export
 * @interface GroupContentsChangesRequestGroupChanges
 */
interface GroupContentsChangesRequestGroupChanges {
    /**
     * optional series of members to remove
     * @type {Array<string>}
     * @memberof GroupContentsChangesRequestGroupChanges
     */
    members_to_remove?: Array<string>;
    /**
     * optional series of members to add
     * @type {Array<GroupMember>}
     * @memberof GroupContentsChangesRequestGroupChanges
     */
    members_to_add?: Array<GroupMember>;
}
/**
 * Request the contents of a group
 * @export
 * @interface GroupContentsRetrievalRequest
 */
interface GroupContentsRetrievalRequest {
    /**
     *
     * @type {TileDBConfig}
     * @memberof GroupContentsRetrievalRequest
     */
    config?: TileDBConfig;
}
/**
 * Object including a page of members of a group and pagination metadata
 * @export
 * @interface GroupContentsRetrievalResponse
 */
interface GroupContentsRetrievalResponse {
    /**
     * Groups members
     * @type {Array<GroupMember>}
     * @memberof GroupContentsRetrievalResponse
     */
    members?: Array<GroupMember>;
    /**
     *
     * @type {Metadata}
     * @memberof GroupContentsRetrievalResponse
     */
    metadata?: Metadata;
}
/**
 * information for creating a new group with the passed configuration
 * @export
 * @interface GroupCreationRequest
 */
interface GroupCreationRequest {
    /**
     *
     * @type {TileDBConfig}
     * @memberof GroupCreationRequest
     */
    config?: TileDBConfig;
    /**
     *
     * @type {GroupCreationRequestGroupDetails}
     * @memberof GroupCreationRequest
     */
    group_details: GroupCreationRequestGroupDetails;
}
/**
 * Initial attributes for the creation of a group.
 * @export
 * @interface GroupCreationRequestGroupDetails
 */
interface GroupCreationRequestGroupDetails {
    /**
     * A human readable description of the contents of the group.
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    description?: string;
    /**
     * The name of the group. If must be unique within the group.
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    name?: string;
    /**
     * uri of group.
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    uri?: string;
    /**
     * logo (base64 encoded) for the group. Optional
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    logo?: string;
    /**
     * optional tags for groups.
     * @type {Array<string>}
     * @memberof GroupCreationRequestGroupDetails
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom.
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    license_text?: string;
}
/**
 * A groups member, array or another groups, to add or remove from an existing group.
 * @export
 * @interface GroupMember
 */
interface GroupMember {
    /**
     * The name of the member
     * @type {string}
     * @memberof GroupMember
     */
    name?: string;
    /**
     * The uri of the member
     * @type {string}
     * @memberof GroupMember
     */
    uri?: string;
    /**
     *
     * @type {GroupMemberType}
     * @memberof GroupMember
     */
    type?: GroupMemberType;
}
/**
 * Specific file types of group members
 * @export
 * @enum {string}
 */
declare enum GroupMemberAssetType {
    Group = "group",
    Array = "array",
    Notebook = "notebook",
    Dashboard = "dashboard",
    UserDefinedFunction = "user_defined_function",
    MlModel = "ml_model",
    File = "file"
}
/**
 * File types that can be included in groups
 * @export
 * @enum {string}
 */
declare enum GroupMemberType {
    Group = "GROUP",
    Array = "ARRAY"
}
/**
 * Retrieves the metadata of a group
 * @export
 * @interface GroupMetadataRetrievalRequest
 */
interface GroupMetadataRetrievalRequest {
    /**
     *
     * @type {TileDBConfig}
     * @memberof GroupMetadataRetrievalRequest
     */
    config?: TileDBConfig;
}
/**
 * Updates the metadata of a group
 * @export
 * @interface GroupMetadataUpdateRequest
 */
interface GroupMetadataUpdateRequest {
    /**
     *
     * @type {TileDBConfig}
     * @memberof GroupMetadataUpdateRequest
     */
    config?: TileDBConfig;
    /**
     *
     * @type {Metadata}
     * @memberof GroupMetadataUpdateRequest
     */
    metadata: Metadata;
}
/**
 * information for creating a new group with the passed configuration
 * @export
 * @interface GroupRegistrationRequest
 */
interface GroupRegistrationRequest {
    /**
     *
     * @type {TileDBConfig}
     * @memberof GroupRegistrationRequest
     */
    config?: TileDBConfig;
    /**
     *
     * @type {GroupRegistrationRequestGroupDetails}
     * @memberof GroupRegistrationRequest
     */
    group_details: GroupRegistrationRequestGroupDetails;
}
/**
 * Initial attributes for the creation of a group.
 * @export
 * @interface GroupRegistrationRequestGroupDetails
 */
interface GroupRegistrationRequestGroupDetails {
    /**
     * A human readable description of the contents of the group.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    description?: string;
    /**
     * The name of the group. If must be unique within the group.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    name?: string;
    /**
     * The unique name or id of the parent of the group. If empty, then the new group will be a top level group.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    parent?: string;
    /**
     * uri of group.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    uri?: string;
    /**
     * logo (base64 encoded) for the group. Optional
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    logo?: string;
    /**
     * optional tags for groups.
     * @type {Array<string>}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    license_text?: string;
    /**
     * region of the group
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    region?: string;
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    access_credentials_name?: string;
}
/**
 * Layout of array
 * @export
 * @enum {string}
 */
declare enum Layout {
    RowMajor = "row-major",
    ColMajor = "col-major",
    GlobalOrder = "global-order",
    Unordered = "unordered"
}
/**
 * user\'s TileDB metadata
 * @export
 * @interface Metadata
 */
interface Metadata {
    /**
     * List of metadata entries
     * @type {Array<MetadataEntry>}
     * @memberof Metadata
     */
    entries?: Array<MetadataEntry>;
}
/**
 * key/value pair representing a group metadata map entry
 * @export
 * @interface MetadataEntry
 */
interface MetadataEntry {
    /**
     *
     * @type {string}
     * @memberof MetadataEntry
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof MetadataEntry
     */
    type?: string;
    /**
     *
     * @type {number}
     * @memberof MetadataEntry
     */
    valueNum?: number;
    /**
     *
     * @type {object}
     * @memberof MetadataEntry
     */
    value?: object;
    /**
     *
     * @type {boolean}
     * @memberof MetadataEntry
     */
    del?: boolean;
}
/**
 * Represents an open array
 * @export
 * @interface ModelArray
 */
interface ModelArray {
    /**
     * timestamp (epoch milliseconds) array is opened at
     * @type {number}
     * @memberof ModelArray
     */
    timestamp: number;
    /**
     *
     * @type {Querytype}
     * @memberof ModelArray
     */
    queryType: Querytype;
    /**
     * Array uri
     * @type {string}
     * @memberof ModelArray
     */
    uri: string;
}
/**
 *
 * @export
 * @interface ModelError
 */
interface ModelError {
    /**
     *
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
}
/**
 *
 * @export
 * @interface PaginationMetadata
 */
interface PaginationMetadata {
    /**
     * pagination offset. Use it to skip the first ((page - 1) * per_page) items
     * @type {number}
     * @memberof PaginationMetadata
     */
    page?: number;
    /**
     * pagination limit (page size)
     * @type {number}
     * @memberof PaginationMetadata
     */
    per_page?: number;
    /**
     * number of total pages with current limit
     * @type {number}
     * @memberof PaginationMetadata
     */
    total_pages?: number;
    /**
     * number of total available items
     * @type {number}
     * @memberof PaginationMetadata
     */
    total_items?: number;
}
/**
 *
 * @export
 * @interface Query
 */
interface Query {
    /**
     *
     * @type {Querytype}
     * @memberof Query
     */
    type: Querytype;
    /**
     *
     * @type {Layout}
     * @memberof Query
     */
    layout: Layout;
    /**
     *
     * @type {Querystatus}
     * @memberof Query
     */
    status: Querystatus;
    /**
     * List of attribute buffer headers
     * @type {Array<AttributeBufferHeader>}
     * @memberof Query
     */
    attributeBufferHeaders: Array<AttributeBufferHeader>;
    /**
     *
     * @type {Writer}
     * @memberof Query
     */
    writer?: Writer;
    /**
     *
     * @type {QueryReader}
     * @memberof Query
     */
    reader?: QueryReader;
    /**
     *
     * @type {any}
     * @memberof Query
     */
    array: any;
    /**
     * Total number of bytes in fixed size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalFixedLengthBufferBytes: number;
    /**
     * Total number of bytes in variable size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalVarLenBufferBytes: number;
    /**
     * Total number of bytes in validity buffers
     * @type {number}
     * @memberof Query
     */
    totalValidityBufferBytes?: number;
}
/**
 * Read struct (can\'t be called reader due to class name conflict)
 * @export
 * @interface QueryReader
 */
interface QueryReader {
    /**
     *
     * @type {Layout}
     * @memberof QueryReader
     */
    layout?: Layout;
    /**
     *
     * @type {Subarray}
     * @memberof QueryReader
     */
    subarray?: Subarray;
    /**
     *
     * @type {ReadState}
     * @memberof QueryReader
     */
    readState?: ReadState;
}
/**
 * Status of query
 * @export
 * @enum {string}
 */
declare enum Querystatus {
    Failed = "FAILED",
    Completed = "COMPLETED",
    Inprogress = "INPROGRESS",
    Incomplete = "INCOMPLETE",
    Uninitialized = "UNINITIALIZED"
}
/**
 * Type of query
 * @export
 * @enum {string}
 */
declare enum Querytype {
    Read = "READ",
    Write = "WRITE"
}
/**
 * state for reads
 * @export
 * @interface ReadState
 */
interface ReadState {
    /**
     * True if the reader has been initialized.
     * @type {boolean}
     * @memberof ReadState
     */
    initialized?: boolean;
    /**
     * True if the query produced results that could not fit in some buffer.
     * @type {boolean}
     * @memberof ReadState
     */
    overflowed?: boolean;
    /**
     * True if the current subarray partition is unsplittable.
     * @type {boolean}
     * @memberof ReadState
     */
    unsplittable?: boolean;
    /**
     *
     * @type {SubarrayPartitioner}
     * @memberof ReadState
     */
    subarrayPartitioner?: SubarrayPartitioner;
}
/**
 * A Subarray
 * @export
 * @interface Subarray
 */
interface Subarray {
    /**
     *
     * @type {Layout}
     * @memberof Subarray
     */
    layout?: Layout;
    /**
     * List of 1D ranges, one per dimension
     * @type {Array<SubarrayRanges>}
     * @memberof Subarray
     */
    ranges?: Array<SubarrayRanges>;
}
/**
 * The subarray partitioner
 * @export
 * @interface SubarrayPartitioner
 */
interface SubarrayPartitioner {
    /**
     *
     * @type {Subarray}
     * @memberof SubarrayPartitioner
     */
    subarray?: Subarray;
    /**
     * Result size budget (in bytes) for all attributes.
     * @type {Array<AttributeBufferSize>}
     * @memberof SubarrayPartitioner
     */
    budget?: Array<AttributeBufferSize>;
    /**
     *
     * @type {SubarrayPartitionerCurrent}
     * @memberof SubarrayPartitioner
     */
    current?: SubarrayPartitionerCurrent;
    /**
     *
     * @type {SubarrayPartitionerState}
     * @memberof SubarrayPartitioner
     */
    state?: SubarrayPartitionerState;
    /**
     * The memory budget for the fixed-sized attributes and the offsets of the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudget?: number;
    /**
     * The memory budget for the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudgetVar?: number;
}
/**
 * The current partition info
 * @export
 * @interface SubarrayPartitionerCurrent
 */
interface SubarrayPartitionerCurrent {
    /**
     *
     * @type {Subarray}
     * @memberof SubarrayPartitionerCurrent
     */
    subarray?: Subarray;
    /**
     * PartitionInfo start
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    start?: number;
    /**
     * PartitionInfo end
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    end?: number;
    /**
     * PartitionInfo splitMultiRange
     * @type {boolean}
     * @memberof SubarrayPartitionerCurrent
     */
    splitMultiRange?: boolean;
}
/**
 * The state information for the remaining partitions to be produced
 * @export
 * @interface SubarrayPartitionerState
 */
interface SubarrayPartitionerState {
    /**
     * State start
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    start?: number;
    /**
     * State end
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    end?: number;
    /**
     * State singleRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    singleRange?: Array<Subarray>;
    /**
     * State multiRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    multiRange?: Array<Subarray>;
}
/**
 * A set of 1D ranges for a subarray
 * @export
 * @interface SubarrayRanges
 */
interface SubarrayRanges {
    /**
     *
     * @type {Datatype}
     * @memberof SubarrayRanges
     */
    type?: Datatype;
    /**
     * True if the range is the default range
     * @type {boolean}
     * @memberof SubarrayRanges
     */
    hasDefaultRange?: boolean;
    /**
     * The bytes of the ranges
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    buffer?: Array<number>;
    /**
     * The list of sizes per range
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    bufferSizes?: Array<number>;
    /**
     * The list of start sizes per range
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    bufferStartSizes?: Array<number>;
}
/**
 * TileDB config used for interaction with the embedded library
 * @export
 * @interface TileDBConfig
 */
interface TileDBConfig {
    /**
     *
     * @type {Array<TileDBConfigEntries>}
     * @memberof TileDBConfig
     */
    entries?: Array<TileDBConfigEntries>;
}
/**
 *
 * @export
 * @interface TileDBConfigEntries
 */
interface TileDBConfigEntries {
    /**
     *
     * @type {string}
     * @memberof TileDBConfigEntries
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof TileDBConfigEntries
     */
    value?: string;
}
/**
 *
 * @export
 * @interface Writer
 */
interface Writer {
    /**
     *
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordDups?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordOOB?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Writer
     */
    dedupCoords?: boolean;
    /**
     *
     * @type {Subarray}
     * @memberof Writer
     */
    subarrayRanges?: Subarray;
    /**
     *
     * @type {DomainArray}
     * @memberof Writer
     */
    subarray?: DomainArray;
}
/**
 * ArrayApi - axios parameter creator
 * @export
 */
declare const ArrayApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arrayActivityLog: (namespace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options?: any) => Promise<RequestArgs>;
};
/**
 * ArrayApi - functional programming interface
 * @export
 */
declare const ArrayApiFp: (configuration?: Configuration) => {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayActivityLogData>>;
};
/**
 * ArrayApi - factory interface
 * @export
 */
declare const ArrayApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options?: any): AxiosPromise<ArrayActivityLogData>;
};
/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
declare class ArrayApi extends BaseAPI {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options?: any): Promise<axios.AxiosResponse<ArrayActivityLogData>>;
}
/**
 * GroupsApi - axios parameter creator
 * @export
 */
declare const GroupsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Creates an empty group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupCreationRequest} [groupCreation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup: (groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Deregisters a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterGroup: (groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any) => Promise<RequestArgs>;
    /**
     * get metadata on a group using the requested config
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataRetrievalRequest} [metadataRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMetadata: (groupNamespace: string, groupName: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options?: any) => Promise<RequestArgs>;
    /**
     * can be used to check if the resource exists
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsGroupNamespaceGroupNameOptions: (groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Registers an already existing group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupRegistrationRequest} [groupRegistration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGroup: (groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Retrieves the contents of a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsRetrievalRequest} [groupRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveGroup: (groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Change the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsChangesRequest} [groupUpdateContents]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupContents: (groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options?: any) => Promise<RequestArgs>;
    /**
     * update metadata on a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataUpdateRequest} [metadataUpdating]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupMetadata: (groupNamespace: string, groupName: string, metadataUpdating?: GroupMetadataUpdateRequest, options?: any) => Promise<RequestArgs>;
};
/**
 * GroupsApi - functional programming interface
 * @export
 */
declare const GroupsApiFp: (configuration?: Configuration) => {
    /**
     * Creates an empty group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupCreationRequest} [groupCreation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deregisters a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * get metadata on a group using the requested config
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataRetrievalRequest} [metadataRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMetadata(groupNamespace: string, groupName: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metadata>>;
    /**
     * can be used to check if the resource exists
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsGroupNamespaceGroupNameOptions(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Registers an already existing group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupRegistrationRequest} [groupRegistration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Retrieves the contents of a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsRetrievalRequest} [groupRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupContentsRetrievalResponse>>;
    /**
     * Change the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsChangesRequest} [groupUpdateContents]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupContents(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * update metadata on a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataUpdateRequest} [metadataUpdating]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupMetadata(groupNamespace: string, groupName: string, metadataUpdating?: GroupMetadataUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * GroupsApi - factory interface
 * @export
 */
declare const GroupsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Creates an empty group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupCreationRequest} [groupCreation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options?: any): AxiosPromise<void>;
    /**
     * Deregisters a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): AxiosPromise<void>;
    /**
     * get metadata on a group using the requested config
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataRetrievalRequest} [metadataRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMetadata(groupNamespace: string, groupName: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options?: any): AxiosPromise<Metadata>;
    /**
     * can be used to check if the resource exists
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsGroupNamespaceGroupNameOptions(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): AxiosPromise<void>;
    /**
     * Registers an already existing group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupRegistrationRequest} [groupRegistration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options?: any): AxiosPromise<void>;
    /**
     * Retrieves the contents of a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsRetrievalRequest} [groupRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options?: any): AxiosPromise<GroupContentsRetrievalResponse>;
    /**
     * Change the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsChangesRequest} [groupUpdateContents]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupContents(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options?: any): AxiosPromise<void>;
    /**
     * update metadata on a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataUpdateRequest} [metadataUpdating]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupMetadata(groupNamespace: string, groupName: string, metadataUpdating?: GroupMetadataUpdateRequest, options?: any): AxiosPromise<void>;
};
/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
declare class GroupsApi extends BaseAPI {
    /**
     * Creates an empty group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupCreationRequest} [groupCreation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    createGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Deregisters a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deregisterGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * get metadata on a group using the requested config
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataRetrievalRequest} [metadataRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupMetadata(groupNamespace: string, groupName: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options?: any): Promise<axios.AxiosResponse<Metadata>>;
    /**
     * can be used to check if the resource exists
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsGroupNamespaceGroupNameOptions(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Registers an already existing group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupRegistrationRequest} [groupRegistration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    registerGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Retrieves the contents of a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsRetrievalRequest} [groupRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    retrieveGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options?: any): Promise<axios.AxiosResponse<GroupContentsRetrievalResponse>>;
    /**
     * Change the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsChangesRequest} [groupUpdateContents]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroupContents(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * update metadata on a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataUpdateRequest} [metadataUpdating]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroupMetadata(groupNamespace: string, groupName: string, metadataUpdating?: GroupMetadataUpdateRequest, options?: any): Promise<axios.AxiosResponse<void>>;
}
/**
 * OrganizationApi - axios parameter creator
 * @export
 */
declare const OrganizationApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCredential: (namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any) => Promise<RequestArgs>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential: (namespace: string, name: string, options?: any) => Promise<RequestArgs>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential: (namespace: string, name: string, options?: any) => Promise<RequestArgs>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials: (namespace: string, provider?: string, page?: number, perPage?: number, options?: any) => Promise<RequestArgs>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential: (namespace: string, name: string, accessCredential: AccessCredential, options?: any) => Promise<RequestArgs>;
};
/**
 * OrganizationApi - functional programming interface
 * @export
 */
declare const OrganizationApiFp: (configuration?: Configuration) => {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredential>>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredentialsData>>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * OrganizationApi - factory interface
 * @export
 */
declare const OrganizationApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): AxiosPromise<void>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential(namespace: string, name: string, options?: any): AxiosPromise<AccessCredential>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): AxiosPromise<AccessCredentialsData>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): AxiosPromise<void>;
};
/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
declare class OrganizationApi extends BaseAPI {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteCredential(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getCredential(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<AccessCredential>>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): Promise<axios.AxiosResponse<AccessCredentialsData>>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): Promise<axios.AxiosResponse<void>>;
}
/**
 * QueryApi - axios parameter creator
 * @export
 */
declare const QueryApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQuery: (namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any) => Promise<RequestArgs>;
};
/**
 * QueryApi - functional programming interface
 * @export
 */
declare const QueryApiFp: (configuration?: Configuration) => {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>>;
};
/**
 * QueryApi - factory interface
 * @export
 */
declare const QueryApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any): AxiosPromise<any>;
};
/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
declare class QueryApi extends BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any): Promise<axios.AxiosResponse<any>>;
}
/**
 * UserApi - axios parameter creator
 * @export
 */
declare const UserApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCredential: (namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any) => Promise<RequestArgs>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential: (namespace: string, name: string, options?: any) => Promise<RequestArgs>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential: (namespace: string, name: string, options?: any) => Promise<RequestArgs>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials: (namespace: string, provider?: string, page?: number, perPage?: number, options?: any) => Promise<RequestArgs>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential: (namespace: string, name: string, accessCredential: AccessCredential, options?: any) => Promise<RequestArgs>;
};
/**
 * UserApi - functional programming interface
 * @export
 */
declare const UserApiFp: (configuration?: Configuration) => {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredential>>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredentialsData>>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * UserApi - factory interface
 * @export
 */
declare const UserApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): AxiosPromise<void>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential(namespace: string, name: string, options?: any): AxiosPromise<AccessCredential>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): AxiosPromise<AccessCredentialsData>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): AxiosPromise<void>;
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
declare class UserApi extends BaseAPI {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteCredential(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getCredential(namespace: string, name: string, options?: any): Promise<axios.AxiosResponse<AccessCredential>>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): Promise<axios.AxiosResponse<AccessCredentialsData>>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): Promise<axios.AxiosResponse<void>>;
}

/**
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

type index_AWSCredential = AWSCredential;
type index_AccessCredential = AccessCredential;
type index_AccessCredentialCredential = AccessCredentialCredential;
type index_AccessCredentialsData = AccessCredentialsData;
type index_ActivityEventType = ActivityEventType;
declare const index_ActivityEventType: typeof ActivityEventType;
type index_ArrayActivityLog = ArrayActivityLog;
type index_ArrayActivityLogData = ArrayActivityLogData;
type index_ArrayApi = ArrayApi;
declare const index_ArrayApi: typeof ArrayApi;
declare const index_ArrayApiAxiosParamCreator: typeof ArrayApiAxiosParamCreator;
declare const index_ArrayApiFactory: typeof ArrayApiFactory;
declare const index_ArrayApiFp: typeof ArrayApiFp;
type index_AttributeBufferHeader = AttributeBufferHeader;
type index_AttributeBufferSize = AttributeBufferSize;
type index_AzureCredential = AzureCredential;
type index_CloudProvider = CloudProvider;
declare const index_CloudProvider: typeof CloudProvider;
type index_Configuration = Configuration;
declare const index_Configuration: typeof Configuration;
type index_ConfigurationParameters = ConfigurationParameters;
type index_Datatype = Datatype;
declare const index_Datatype: typeof Datatype;
type index_DomainArray = DomainArray;
type index_GroupContentsChangesRequest = GroupContentsChangesRequest;
type index_GroupContentsChangesRequestGroupChanges = GroupContentsChangesRequestGroupChanges;
type index_GroupContentsRetrievalRequest = GroupContentsRetrievalRequest;
type index_GroupContentsRetrievalResponse = GroupContentsRetrievalResponse;
type index_GroupCreationRequest = GroupCreationRequest;
type index_GroupCreationRequestGroupDetails = GroupCreationRequestGroupDetails;
type index_GroupMember = GroupMember;
type index_GroupMemberAssetType = GroupMemberAssetType;
declare const index_GroupMemberAssetType: typeof GroupMemberAssetType;
type index_GroupMemberType = GroupMemberType;
declare const index_GroupMemberType: typeof GroupMemberType;
type index_GroupMetadataRetrievalRequest = GroupMetadataRetrievalRequest;
type index_GroupMetadataUpdateRequest = GroupMetadataUpdateRequest;
type index_GroupRegistrationRequest = GroupRegistrationRequest;
type index_GroupRegistrationRequestGroupDetails = GroupRegistrationRequestGroupDetails;
type index_GroupsApi = GroupsApi;
declare const index_GroupsApi: typeof GroupsApi;
declare const index_GroupsApiAxiosParamCreator: typeof GroupsApiAxiosParamCreator;
declare const index_GroupsApiFactory: typeof GroupsApiFactory;
declare const index_GroupsApiFp: typeof GroupsApiFp;
type index_Layout = Layout;
declare const index_Layout: typeof Layout;
type index_Metadata = Metadata;
type index_MetadataEntry = MetadataEntry;
type index_ModelArray = ModelArray;
type index_ModelError = ModelError;
type index_OrganizationApi = OrganizationApi;
declare const index_OrganizationApi: typeof OrganizationApi;
declare const index_OrganizationApiAxiosParamCreator: typeof OrganizationApiAxiosParamCreator;
declare const index_OrganizationApiFactory: typeof OrganizationApiFactory;
declare const index_OrganizationApiFp: typeof OrganizationApiFp;
type index_PaginationMetadata = PaginationMetadata;
type index_Query = Query;
type index_QueryApi = QueryApi;
declare const index_QueryApi: typeof QueryApi;
declare const index_QueryApiAxiosParamCreator: typeof QueryApiAxiosParamCreator;
declare const index_QueryApiFactory: typeof QueryApiFactory;
declare const index_QueryApiFp: typeof QueryApiFp;
type index_QueryReader = QueryReader;
type index_Querystatus = Querystatus;
declare const index_Querystatus: typeof Querystatus;
type index_Querytype = Querytype;
declare const index_Querytype: typeof Querytype;
type index_ReadState = ReadState;
type index_Subarray = Subarray;
type index_SubarrayPartitioner = SubarrayPartitioner;
type index_SubarrayPartitionerCurrent = SubarrayPartitionerCurrent;
type index_SubarrayPartitionerState = SubarrayPartitionerState;
type index_SubarrayRanges = SubarrayRanges;
type index_TileDBConfig = TileDBConfig;
type index_TileDBConfigEntries = TileDBConfigEntries;
type index_UserApi = UserApi;
declare const index_UserApi: typeof UserApi;
declare const index_UserApiAxiosParamCreator: typeof UserApiAxiosParamCreator;
declare const index_UserApiFactory: typeof UserApiFactory;
declare const index_UserApiFp: typeof UserApiFp;
type index_Writer = Writer;
declare namespace index {
  export {
    index_AWSCredential as AWSCredential,
    index_AccessCredential as AccessCredential,
    index_AccessCredentialCredential as AccessCredentialCredential,
    index_AccessCredentialsData as AccessCredentialsData,
    index_ActivityEventType as ActivityEventType,
    index_ArrayActivityLog as ArrayActivityLog,
    index_ArrayActivityLogData as ArrayActivityLogData,
    index_ArrayApi as ArrayApi,
    index_ArrayApiAxiosParamCreator as ArrayApiAxiosParamCreator,
    index_ArrayApiFactory as ArrayApiFactory,
    index_ArrayApiFp as ArrayApiFp,
    index_AttributeBufferHeader as AttributeBufferHeader,
    index_AttributeBufferSize as AttributeBufferSize,
    index_AzureCredential as AzureCredential,
    index_CloudProvider as CloudProvider,
    index_Configuration as Configuration,
    index_ConfigurationParameters as ConfigurationParameters,
    index_Datatype as Datatype,
    index_DomainArray as DomainArray,
    index_GroupContentsChangesRequest as GroupContentsChangesRequest,
    index_GroupContentsChangesRequestGroupChanges as GroupContentsChangesRequestGroupChanges,
    index_GroupContentsRetrievalRequest as GroupContentsRetrievalRequest,
    index_GroupContentsRetrievalResponse as GroupContentsRetrievalResponse,
    index_GroupCreationRequest as GroupCreationRequest,
    index_GroupCreationRequestGroupDetails as GroupCreationRequestGroupDetails,
    index_GroupMember as GroupMember,
    index_GroupMemberAssetType as GroupMemberAssetType,
    index_GroupMemberType as GroupMemberType,
    index_GroupMetadataRetrievalRequest as GroupMetadataRetrievalRequest,
    index_GroupMetadataUpdateRequest as GroupMetadataUpdateRequest,
    index_GroupRegistrationRequest as GroupRegistrationRequest,
    index_GroupRegistrationRequestGroupDetails as GroupRegistrationRequestGroupDetails,
    index_GroupsApi as GroupsApi,
    index_GroupsApiAxiosParamCreator as GroupsApiAxiosParamCreator,
    index_GroupsApiFactory as GroupsApiFactory,
    index_GroupsApiFp as GroupsApiFp,
    index_Layout as Layout,
    index_Metadata as Metadata,
    index_MetadataEntry as MetadataEntry,
    index_ModelArray as ModelArray,
    index_ModelError as ModelError,
    index_OrganizationApi as OrganizationApi,
    index_OrganizationApiAxiosParamCreator as OrganizationApiAxiosParamCreator,
    index_OrganizationApiFactory as OrganizationApiFactory,
    index_OrganizationApiFp as OrganizationApiFp,
    index_PaginationMetadata as PaginationMetadata,
    index_Query as Query,
    index_QueryApi as QueryApi,
    index_QueryApiAxiosParamCreator as QueryApiAxiosParamCreator,
    index_QueryApiFactory as QueryApiFactory,
    index_QueryApiFp as QueryApiFp,
    index_QueryReader as QueryReader,
    index_Querystatus as Querystatus,
    index_Querytype as Querytype,
    index_ReadState as ReadState,
    index_Subarray as Subarray,
    index_SubarrayPartitioner as SubarrayPartitioner,
    index_SubarrayPartitionerCurrent as SubarrayPartitionerCurrent,
    index_SubarrayPartitionerState as SubarrayPartitionerState,
    index_SubarrayRanges as SubarrayRanges,
    index_TileDBConfig as TileDBConfig,
    index_TileDBConfigEntries as TileDBConfigEntries,
    index_UserApi as UserApi,
    index_UserApiAxiosParamCreator as UserApiAxiosParamCreator,
    index_UserApiFactory as UserApiFactory,
    index_UserApiFp as UserApiFp,
    index_Writer as Writer,
  };
}

declare enum DeserializableType {
    "arrayMetadata" = 0,
    "query" = 1
}
declare const deserializeCapnp: (data: any, type: DeserializableType) => {
    attributeBufferHeaders: {
        name: string;
        fixedLenBufferSizeInBytes: number;
        varLenBufferSizeInBytes: number;
        validityLenBufferSizeInBytes: number;
        originalFixedLenBufferSizeInBytes: number;
        originalVarLenBufferSizeInBytes: number;
        originalValidityLenBufferSizeInBytes: number;
    }[];
    layout: string;
    status: string;
    type: string;
    writer: {
        checkCoordDups: boolean;
        checkCoordOOB: boolean;
        dedupCoords: boolean;
        subarray: {
            int8: number[];
            uint8: number[];
            int16: number[];
            uint16: number[];
            int32: number[];
            uint32: number[];
            int64: capnp.Int64[];
            uint64: capnp.Uint64[];
            float32: number[];
            float64: number[];
        };
        subarrayRanges: {
            layout: string;
            stats: {
                timers: {
                    key: string;
                    value: number;
                }[];
                counters: {
                    key: string;
                    value: number;
                }[];
            };
            ranges: {
                type: string;
                hasDefaultRange: boolean;
                buffer: number[];
                bufferSizes: number[];
                bufferStartSizes: number[];
            }[];
        };
        stats: {
            timers: {
                key: string;
                value: number;
            }[];
            counters: {
                key: string;
                value: number;
            }[];
        };
    };
    reader: {
        layout: string;
        subarray: {
            layout: string;
            stats: {
                timers: {
                    key: string;
                    value: number;
                }[];
                counters: {
                    key: string;
                    value: number;
                }[];
            };
            ranges: {
                type: string;
                hasDefaultRange: boolean;
                buffer: number[];
                bufferSizes: number[];
                bufferStartSizes: number[];
            }[];
        };
        readState: {
            overflowed: boolean;
            unsplittable: boolean;
            initialized: boolean;
            subarrayPartitioner: {
                subarray: {
                    layout: string;
                    stats: {
                        timers: {
                            key: string;
                            value: number;
                        }[];
                        counters: {
                            key: string;
                            value: number;
                        }[];
                    };
                    ranges: {
                        type: string;
                        hasDefaultRange: boolean;
                        buffer: number[];
                        bufferSizes: number[];
                        bufferStartSizes: number[];
                    }[];
                };
                budget: {
                    attribute: string;
                }[];
                current: {
                    subarray: {
                        layout: string;
                        stats: {
                            timers: {
                                key: string;
                                value: number;
                            }[];
                            counters: {
                                key: string;
                                value: number;
                            }[];
                        };
                        ranges: {
                            type: string;
                            hasDefaultRange: boolean;
                            buffer: number[];
                            bufferSizes: number[];
                            bufferStartSizes: number[];
                        }[];
                    };
                    start: number;
                    end: number;
                    splitMultiRange: boolean;
                };
                state: {
                    start: number;
                    end: number;
                    singleRange: {
                        layout: string;
                        stats: {
                            timers: {
                                key: string;
                                value: number;
                            }[];
                            counters: {
                                key: string;
                                value: number;
                            }[];
                        };
                        ranges: {
                            type: string;
                            hasDefaultRange: boolean;
                            buffer: number[];
                            bufferSizes: number[];
                            bufferStartSizes: number[];
                        }[];
                    }[];
                    multiRange: {
                        layout: string;
                        stats: {
                            timers: {
                                key: string;
                                value: number;
                            }[];
                            counters: {
                                key: string;
                                value: number;
                            }[];
                        };
                        ranges: {
                            type: string;
                            hasDefaultRange: boolean;
                            buffer: number[];
                            bufferSizes: number[];
                            bufferStartSizes: number[];
                        }[];
                    }[];
                };
                memoryBudget: number;
                memoryBudgetVar: number;
                memoryBudgetValidity: number;
                stats: {
                    timers: {
                        key: string;
                        value: number;
                    }[];
                    counters: {
                        key: string;
                        value: number;
                    }[];
                };
            };
        };
        condition: {
            clauses: {
                fieldName: string;
                value: number[];
                op: string;
            }[];
            clauseCombinationOps: string[];
        };
        stats: {
            timers: {
                key: string;
                value: number;
            }[];
            counters: {
                key: string;
                value: number;
            }[];
        };
    };
    array: {
        endTimestamp: number;
        queryType: string;
        uri: string;
        startTimestamp: number;
    };
    totalFixedLengthBufferBytes: number;
    totalVarLenBufferBytes: number;
    totalValidityBufferBytes: number;
    varOffsetsMode: string;
    varOffsetsAddExtraElement: boolean;
    varOffsetsBitsize: number;
    config: {
        entries: {
            key: string;
            value: string;
        }[];
    };
    stats: {
        timers: {
            key: string;
            value: number;
        }[];
        counters: {
            key: string;
            value: number;
        }[];
    };
} | {
    entries: {
        value: number[];
        del: boolean;
        key: string;
        type: string;
        valueNum: number;
    }[];
};

interface Options {
    /**
     * Results will return without setting nullables, used on big data
     * to avoid expensive calculations
     */
    ignoreNullables?: boolean;
    /**
     * Results will return without setting offsets, used on big data
     * to avoid expensive calculations
     */
    ignoreOffsets?: boolean;
    /**
     * Return only given attributes/dimensions
     */
    attributes?: string[];
    /**
     * Return raw buffers instead of convert to javascript primitives
     */
    returnRawBuffers?: boolean;
}

declare type Range = number[] | string[];
interface QueryData extends Pick<Query, "layout">, Options {
    ranges: Array<Range | Array<Range>>;
    /**
     * Number of bytes allocated to the server for the query.
     */
    bufferSize: number;
}
interface AttributeValue {
    validity?: number[];
    offsets?: number[];
    values: any[];
}
declare type AttributeValues = Record<string, AttributeValue>;
interface QueryWrite extends Pick<Query, "layout"> {
    values: AttributeValues;
    subarray?: Array<number[] | string[]>;
}
declare class TileDBQuery {
    configurationParams: ConfigurationParameters;
    private axios;
    private queryAPI;
    private arrayAPI;
    constructor(params: ConfigurationParameters, axios?: AxiosInstance);
    WriteQuery(namespace: string, arrayName: string, data: QueryWrite): Promise<{
        attributeBufferHeaders: {
            name: string;
            fixedLenBufferSizeInBytes: number;
            varLenBufferSizeInBytes: number;
            validityLenBufferSizeInBytes: number;
            originalFixedLenBufferSizeInBytes: number;
            originalVarLenBufferSizeInBytes: number;
            originalValidityLenBufferSizeInBytes: number;
        }[];
        layout: string;
        status: string;
        type: string;
        writer: {
            checkCoordDups: boolean;
            checkCoordOOB: boolean;
            dedupCoords: boolean;
            subarray: {
                int8: number[];
                uint8: number[];
                int16: number[];
                uint16: number[];
                int32: number[];
                uint32: number[];
                int64: capnp.Int64[];
                uint64: capnp.Uint64[];
                float32: number[];
                float64: number[];
            };
            subarrayRanges: {
                layout: string;
                stats: {
                    timers: {
                        key: string;
                        value: number;
                    }[];
                    counters: {
                        key: string;
                        value: number;
                    }[];
                };
                ranges: {
                    type: string;
                    hasDefaultRange: boolean;
                    buffer: number[];
                    bufferSizes: number[];
                    bufferStartSizes: number[];
                }[];
            };
            stats: {
                timers: {
                    key: string;
                    value: number;
                }[];
                counters: {
                    key: string;
                    value: number;
                }[];
            };
        };
        reader: {
            layout: string;
            subarray: {
                layout: string;
                stats: {
                    timers: {
                        key: string;
                        value: number;
                    }[];
                    counters: {
                        key: string;
                        value: number;
                    }[];
                };
                ranges: {
                    type: string;
                    hasDefaultRange: boolean;
                    buffer: number[];
                    bufferSizes: number[];
                    bufferStartSizes: number[];
                }[];
            };
            readState: {
                overflowed: boolean;
                unsplittable: boolean;
                initialized: boolean;
                subarrayPartitioner: {
                    subarray: {
                        layout: string;
                        stats: {
                            timers: {
                                key: string;
                                value: number;
                            }[];
                            counters: {
                                key: string;
                                value: number;
                            }[];
                        };
                        ranges: {
                            type: string;
                            hasDefaultRange: boolean;
                            buffer: number[];
                            bufferSizes: number[];
                            bufferStartSizes: number[];
                        }[];
                    };
                    budget: {
                        attribute: string;
                    }[];
                    current: {
                        subarray: {
                            layout: string;
                            stats: {
                                timers: {
                                    key: string;
                                    value: number;
                                }[];
                                counters: {
                                    key: string;
                                    value: number;
                                }[];
                            };
                            ranges: {
                                type: string;
                                hasDefaultRange: boolean;
                                buffer: number[];
                                bufferSizes: number[];
                                bufferStartSizes: number[];
                            }[];
                        };
                        start: number;
                        end: number;
                        splitMultiRange: boolean;
                    };
                    state: {
                        start: number;
                        end: number;
                        singleRange: {
                            layout: string;
                            stats: {
                                timers: {
                                    key: string;
                                    value: number;
                                }[];
                                counters: {
                                    key: string;
                                    value: number;
                                }[];
                            };
                            ranges: {
                                type: string;
                                hasDefaultRange: boolean;
                                buffer: number[];
                                bufferSizes: number[];
                                bufferStartSizes: number[];
                            }[];
                        }[];
                        multiRange: {
                            layout: string;
                            stats: {
                                timers: {
                                    key: string;
                                    value: number;
                                }[];
                                counters: {
                                    key: string;
                                    value: number;
                                }[];
                            };
                            ranges: {
                                type: string;
                                hasDefaultRange: boolean;
                                buffer: number[];
                                bufferSizes: number[];
                                bufferStartSizes: number[];
                            }[];
                        }[];
                    };
                    memoryBudget: number;
                    memoryBudgetVar: number;
                    memoryBudgetValidity: number;
                    stats: {
                        timers: {
                            key: string;
                            value: number;
                        }[];
                        counters: {
                            key: string;
                            value: number;
                        }[];
                    };
                };
            };
            condition: {
                clauses: {
                    fieldName: string; /**
                     * Axios in nodeJS environments casts the response to a Buffer object
                     * we convert it back to an ArrayBuffer if needed
                     */
                    value: number[];
                    op: string;
                }[];
                clauseCombinationOps: string[];
            };
            stats: {
                timers: {
                    key: string;
                    value: number;
                }[];
                counters: {
                    key: string;
                    value: number;
                }[];
            };
        };
        array: {
            endTimestamp: number;
            queryType: string;
            uri: string;
            startTimestamp: number;
        };
        totalFixedLengthBufferBytes: number;
        totalVarLenBufferBytes: number;
        totalValidityBufferBytes: number;
        varOffsetsMode: string;
        varOffsetsAddExtraElement: boolean;
        varOffsetsBitsize: number;
        config: {
            entries: {
                key: string;
                value: string;
            }[];
        };
        stats: {
            timers: {
                key: string;
                value: number;
            }[];
            counters: {
                key: string;
                value: number;
            }[];
        };
    }>;
    ReadIncompleteQuery(arraySchema: ArraySchema, queryAsArrayBuffer: ArrayBuffer, namespace: string, arrayName: string, options: Options): Promise<{
        query: Query;
        results: Record<string, any>;
        queryAsArrayBuffer: ArrayBuffer;
    }>;
    ReadQuery(namespace: string, arrayName: string, body: QueryData, arraySchema?: ArraySchema): AsyncGenerator<{}, void, unknown>;
    private getResultsFromArrayBuffer;
    private throwError;
}

declare class UDF {
    config: Configuration$1;
    API: UdfApi;
    constructor(params: ConfigurationParameters$1, axios?: AxiosInstance);
    registerUdf(namespace: string, name: string, udf: UDFInfoUpdate): Promise<axios.AxiosResponse<void>>;
    registerGenericUdf(namespace: string, name: string, udf: Omit<UDFInfoUpdate, "type">): Promise<axios.AxiosResponse<void>>;
    registerSingleArrayUdf(namespace: string, name: string, udf: Omit<UDFInfoUpdate, "type">): Promise<axios.AxiosResponse<void>>;
    updateUdf(namespace: string, name: string, udf: UDFInfoUpdate): Promise<axios.AxiosResponse<void>>;
    updateGenericUdf(namespace: string, name: string, udf: Omit<UDFInfoUpdate, "type">): Promise<axios.AxiosResponse<void>>;
    updateSingleArrayUdf(namespace: string, name: string, udf: Omit<UDFInfoUpdate, "type">): Promise<axios.AxiosResponse<void>>;
    exec(namespaceAndUdf: string, args?: Array<any>, options?: Omit<GenericUDF, "argument" | "udf_info_name">): Promise<any>;
    info(namespace: string, udfName: string): Promise<axios.AxiosResponse<UDFInfo>>;
    share(namespace: string, udfName: string, udfSharing: UDFSharing): Promise<axios.AxiosResponse<void>>;
    unshare(namespace: string, udfName: string, namespaceToUnshare: string): Promise<axios.AxiosResponse<void>>;
    delete(namespace: string, udfName: string): Promise<axios.AxiosResponse<void>>;
}

declare class Sql {
    config: Configuration$1;
    API: SqlApi;
    constructor(params: ConfigurationParameters$1, axios?: AxiosInstance);
    exec(namespace: string, query: string, options?: Omit<SQLParameters, "query">): Promise<axios.AxiosResponse<object[]>>;
}

declare class Groups {
    API: GroupsApi$1;
    V2API: GroupsApi;
    constructor(params: Configuration$1, paramsV2: Configuration$1, axios?: AxiosInstance);
    getGroupContents(namespace: string, name: string): Promise<GroupContents>;
}

declare class TileDBClient {
    config: Configuration;
    configV2: Configuration;
    ArrayApi: ArrayApi$1;
    OrganizationApi: OrganizationApi$1;
    UserApi: UserApi$1;
    NotebookApi: NotebookApi;
    TasksApi: TasksApi;
    udf: UDF;
    groups: Groups;
    sql: Sql;
    query: TileDBQuery;
    private axios;
    constructor(params?: Omit<ConfigurationParameters, "username" | "password">);
    info(namespace: string, array: string, options?: any): Promise<axios.AxiosResponse<ArrayInfo>>;
    arrayActivity(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, hasTaskId?: boolean, options?: any): Promise<axios.AxiosResponse<ArrayActivityLog$1[]>>;
    deregisterArray(namespace: string, array: string, options?: any): Promise<axios.AxiosResponse<void>>;
    registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): Promise<axios.AxiosResponse<ArrayInfo>>;
    listSharedWith(namespace: string, array: string, options?: any): Promise<axios.AxiosResponse<ArraySharing[]>>;
    shareArray(namespace: string, array: string, arraySharing: ArraySharing, options?: any): Promise<axios.AxiosResponse<void>>;
    unshareArray(namespace: string, array: string, namespaceToUnshare: string, options?: any): Promise<axios.AxiosResponse<void>>;
    /**
     * List arrays in a user account
     */
    listArrays(params?: {
        page?: number;
        perPage?: number;
        search?: string;
        namespace?: string;
        orderby?: string;
        permissions?: string;
        tag?: string[];
        excludeTag?: string[];
        fileType?: string[];
        excludeFileType?: string[];
        fileProperty?: string[];
        options?: any;
    }): Promise<axios.AxiosResponse<ArrayBrowserData>>;
    /**
     * List public arrays
     */
    listPublicArrays(params?: {
        page?: number;
        perPage?: number;
        search?: string;
        namespace?: string;
        orderby?: string;
        permissions?: string;
        tag?: string[];
        excludeTag?: string[];
        fileType?: string[];
        excludeFileType?: string[];
        fileProperty?: string[];
        options?: any;
    }): Promise<axios.AxiosResponse<ArrayBrowserData>>;
    /**
     * List shared arrays
     */
    listSharedArrays(params?: {
        page?: number;
        perPage?: number;
        search?: string;
        namespace?: string;
        orderby?: string;
        permissions?: string;
        tag?: string[];
        excludeTag?: string[];
        fileType?: string[];
        excludeFileType?: string[];
        fileProperty?: string[];
        options?: any;
    }): Promise<axios.AxiosResponse<ArrayBrowserData>>;
    /**
     * Organization to fetch
     */
    organization(organization: string, options?: any): Promise<axios.AxiosResponse<Organization>>;
    /**
     * List of all organizations user is part of
     */
    organizations(options?: any): Promise<axios.AxiosResponse<Organization[]>>;
    /**
     * Your user profile
     */
    userProfile(options?: any): Promise<axios.AxiosResponse<User>>;
    /**
     * Rename a notebook's name
     */
    renameNotebook(namespace: string, array: string, notebookName: string, options?: any): Promise<axios.AxiosResponse<void>>;
    task(id: string, options?: any): Promise<axios.AxiosResponse<ArrayTask>>;
    downloadNotebookContents(namespace: string, notebook: string): Promise<string>;
    downloadNotebookToFile(namespace: string, notebook: string): Promise<void>;
    getFileContents(namespace: string, file: string): Promise<{
        buffer: ArrayBufferLike;
        originalFileName: string;
        mimeType: string;
    }>;
    downloadFile(namespace: string, file: string): Promise<void>;
    uploadNotebookContents(): void;
    uploadNotebookFromFile(): void;
    lastSqlTask(): void;
    lastUDFTask(): void;
}

/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

export { AttributeValues, DeserializableType, QueryData, QueryWrite, TileDBQuery, TileDBClient as default, deserializeCapnp, index$1 as v1, index as v2 };
