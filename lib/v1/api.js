"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilesApiFactory = exports.FilesApiFp = exports.FilesApiAxiosParamCreator = exports.FavoritesApi = exports.FavoritesApiFactory = exports.FavoritesApiFp = exports.FavoritesApiAxiosParamCreator = exports.ArrayTasksApi = exports.ArrayTasksApiFactory = exports.ArrayTasksApiFp = exports.ArrayTasksApiAxiosParamCreator = exports.ArrayApi = exports.ArrayApiFactory = exports.ArrayApiFp = exports.ArrayApiAxiosParamCreator = exports.UDFType = exports.UDFLanguage = exports.UDFActions = exports.TokenScope = exports.TaskGraphLogStatus = exports.TaskGraphLogRunLocation = exports.TaskGraphActions = exports.SSOProvider = exports.ResultFormat = exports.Querytype = exports.Querystatus = exports.PublicShareFilter = exports.PricingUnitLabel = exports.PricingType = exports.PricingInterval = exports.PricingCurrency = exports.PricingAggregateUsage = exports.OrganizationRoles = exports.NamespaceActions = exports.Layout = exports.InvitationType = exports.InvitationStatus = exports.GroupMemberType = exports.GroupMemberAssetType = exports.GroupActions = exports.FilterType = exports.FilterOption = exports.FileType = exports.FilePropertyName = exports.Datatype = exports.ArrayType = exports.ArrayTaskType = exports.ArrayTaskStatus = exports.ArrayActions = exports.ActivityEventType = void 0;
exports.UserApiAxiosParamCreator = exports.UdfApi = exports.UdfApiFactory = exports.UdfApiFp = exports.UdfApiAxiosParamCreator = exports.TasksApi = exports.TasksApiFactory = exports.TasksApiFp = exports.TasksApiAxiosParamCreator = exports.TaskGraphLogsApi = exports.TaskGraphLogsApiFactory = exports.TaskGraphLogsApiFp = exports.TaskGraphLogsApiAxiosParamCreator = exports.StatsApi = exports.StatsApiFactory = exports.StatsApiFp = exports.StatsApiAxiosParamCreator = exports.SqlApi = exports.SqlApiFactory = exports.SqlApiFp = exports.SqlApiAxiosParamCreator = exports.RegisteredTaskGraphsApi = exports.RegisteredTaskGraphsApiFactory = exports.RegisteredTaskGraphsApiFp = exports.RegisteredTaskGraphsApiAxiosParamCreator = exports.QueryApi = exports.QueryApiFactory = exports.QueryApiFp = exports.QueryApiAxiosParamCreator = exports.OrganizationApi = exports.OrganizationApiFactory = exports.OrganizationApiFp = exports.OrganizationApiAxiosParamCreator = exports.NotebooksApi = exports.NotebooksApiFactory = exports.NotebooksApiFp = exports.NotebooksApiAxiosParamCreator = exports.NotebookApi = exports.NotebookApiFactory = exports.NotebookApiFp = exports.NotebookApiAxiosParamCreator = exports.InvitationApi = exports.InvitationApiFactory = exports.InvitationApiFp = exports.InvitationApiAxiosParamCreator = exports.GroupsApi = exports.GroupsApiFactory = exports.GroupsApiFp = exports.GroupsApiAxiosParamCreator = exports.FilesApi = void 0;
exports.UserApi = exports.UserApiFactory = exports.UserApiFp = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 * Type of activity logged
 * @export
 * @enum {string}
 */
var ActivityEventType;
(function (ActivityEventType) {
    ActivityEventType["ReadSchema"] = "read_schema";
    ActivityEventType["MaxBufferSizes"] = "max_buffer_sizes";
    ActivityEventType["NonEmptyDomain"] = "non_empty_domain";
    ActivityEventType["QueryRead"] = "query_read";
    ActivityEventType["QueryWrite"] = "query_write";
    ActivityEventType["Create"] = "create";
    ActivityEventType["Delete"] = "delete";
    ActivityEventType["Register"] = "register";
    ActivityEventType["Deregister"] = "deregister";
    ActivityEventType["Udf"] = "udf";
    ActivityEventType["ArrayMetadataGet"] = "array_metadata_get";
    ActivityEventType["ArrayMetadataUpdate"] = "array_metadata_update";
    ActivityEventType["EstimatedResultSizes"] = "estimated_result_sizes";
})(ActivityEventType = exports.ActivityEventType || (exports.ActivityEventType = {}));
/**
 * actions a user can take on an array
 * @export
 * @enum {string}
 */
var ArrayActions;
(function (ArrayActions) {
    ArrayActions["Read"] = "read";
    ArrayActions["Write"] = "write";
    ArrayActions["Edit"] = "edit";
    ArrayActions["ReadArrayLogs"] = "read_array_logs";
    ArrayActions["ReadArrayInfo"] = "read_array_info";
    ArrayActions["ReadArraySchema"] = "read_array_schema";
})(ArrayActions = exports.ArrayActions || (exports.ArrayActions = {}));
/**
 * Status of array task
 * @export
 * @enum {string}
 */
var ArrayTaskStatus;
(function (ArrayTaskStatus) {
    ArrayTaskStatus["Queued"] = "QUEUED";
    ArrayTaskStatus["Failed"] = "FAILED";
    ArrayTaskStatus["Completed"] = "COMPLETED";
    ArrayTaskStatus["Running"] = "RUNNING";
    ArrayTaskStatus["ResourcesUnavailable"] = "RESOURCES_UNAVAILABLE";
    ArrayTaskStatus["Unknown"] = "UNKNOWN";
    ArrayTaskStatus["Cancelled"] = "CANCELLED";
    ArrayTaskStatus["Denied"] = "DENIED";
})(ArrayTaskStatus = exports.ArrayTaskStatus || (exports.ArrayTaskStatus = {}));
/**
 * Synchronous Task Type
 * @export
 * @enum {string}
 */
var ArrayTaskType;
(function (ArrayTaskType) {
    ArrayTaskType["Sql"] = "SQL";
    ArrayTaskType["Udf"] = "UDF";
    ArrayTaskType["Query"] = "QUERY";
    ArrayTaskType["GenericUdf"] = "GENERIC_UDF";
    ArrayTaskType["ClientComputation"] = "CLIENT_COMPUTATION";
})(ArrayTaskType = exports.ArrayTaskType || (exports.ArrayTaskType = {}));
/**
 * TileDB array type
 * @export
 * @enum {string}
 */
var ArrayType;
(function (ArrayType) {
    ArrayType["Dense"] = "dense";
    ArrayType["Sparse"] = "sparse";
})(ArrayType = exports.ArrayType || (exports.ArrayType = {}));
/**
 * TileDB data type
 * @export
 * @enum {string}
 */
var Datatype;
(function (Datatype) {
    Datatype["Int32"] = "INT32";
    Datatype["Int64"] = "INT64";
    Datatype["Float32"] = "FLOAT32";
    Datatype["Float64"] = "FLOAT64";
    Datatype["Char"] = "CHAR";
    Datatype["Int8"] = "INT8";
    Datatype["Uint8"] = "UINT8";
    Datatype["Int16"] = "INT16";
    Datatype["Uint16"] = "UINT16";
    Datatype["Uint32"] = "UINT32";
    Datatype["Uint64"] = "UINT64";
    Datatype["StringAscii"] = "STRING_ASCII";
    Datatype["StringUtf8"] = "STRING_UTF8";
    Datatype["StringUtf16"] = "STRING_UTF16";
    Datatype["StringUtf32"] = "STRING_UTF32";
    Datatype["StringUcs2"] = "STRING_UCS2";
    Datatype["StringUcs4"] = "STRING_UCS4";
    Datatype["Any"] = "ANY";
})(Datatype = exports.Datatype || (exports.Datatype = {}));
/**
 * File property assigned to a specific file (array)
 * @export
 * @enum {string}
 */
var FilePropertyName;
(function (FilePropertyName) {
    FilePropertyName["Image"] = "image";
    FilePropertyName["Size"] = "size";
    FilePropertyName["CodeBlock"] = "code_block";
    FilePropertyName["UdfLanguage"] = "udf_language";
    FilePropertyName["IsDashboard"] = "is_dashboard";
})(FilePropertyName = exports.FilePropertyName || (exports.FilePropertyName = {}));
/**
 * File types represented as TileDB arrays
 * @export
 * @enum {string}
 */
var FileType;
(function (FileType) {
    FileType["Notebook"] = "notebook";
    FileType["UserDefinedFunction"] = "user_defined_function";
    FileType["MlModel"] = "ml_model";
    FileType["File"] = "file";
    FileType["RegisteredTaskGraph"] = "registered_task_graph";
})(FileType = exports.FileType || (exports.FileType = {}));
/**
 * TileDB filter option
 * @export
 * @enum {string}
 */
var FilterOption;
(function (FilterOption) {
    FilterOption["CompressionLevel"] = "COMPRESSION_LEVEL";
    FilterOption["BitWidthMaxWindow"] = "BIT_WIDTH_MAX_WINDOW";
    FilterOption["PositiveDeltaMaxWindow"] = "POSITIVE_DELTA_MAX_WINDOW";
})(FilterOption = exports.FilterOption || (exports.FilterOption = {}));
/**
 * TileDB filter types
 * @export
 * @enum {string}
 */
var FilterType;
(function (FilterType) {
    FilterType["None"] = "FILTER_NONE";
    FilterType["Gzip"] = "FILTER_GZIP";
    FilterType["Zstd"] = "FILTER_ZSTD";
    FilterType["Lz4"] = "FILTER_LZ4";
    FilterType["Rle"] = "FILTER_RLE";
    FilterType["Bzip2"] = "FILTER_BZIP2";
    FilterType["DoubleDelta"] = "FILTER_DOUBLE_DELTA";
    FilterType["BitWidthReduction"] = "FILTER_BIT_WIDTH_REDUCTION";
    FilterType["Bitshuffle"] = "FILTER_BITSHUFFLE";
    FilterType["Byteshuffle"] = "FILTER_BYTESHUFFLE";
    FilterType["PositiveDelta"] = "FILTER_POSITIVE_DELTA";
})(FilterType = exports.FilterType || (exports.FilterType = {}));
/**
 * actions a user can take on a group
 * @export
 * @enum {string}
 */
var GroupActions;
(function (GroupActions) {
    GroupActions["Read"] = "read";
    GroupActions["Write"] = "write";
    GroupActions["Edit"] = "edit";
})(GroupActions = exports.GroupActions || (exports.GroupActions = {}));
/**
 * Specific file types of group members
 * @export
 * @enum {string}
 */
var GroupMemberAssetType;
(function (GroupMemberAssetType) {
    GroupMemberAssetType["Group"] = "group";
    GroupMemberAssetType["Array"] = "array";
    GroupMemberAssetType["Notebook"] = "notebook";
    GroupMemberAssetType["Dashboard"] = "dashboard";
    GroupMemberAssetType["UserDefinedFunction"] = "user_defined_function";
    GroupMemberAssetType["MlModel"] = "ml_model";
    GroupMemberAssetType["File"] = "file";
})(GroupMemberAssetType = exports.GroupMemberAssetType || (exports.GroupMemberAssetType = {}));
/**
 * File types that can be included in groups
 * @export
 * @enum {string}
 */
var GroupMemberType;
(function (GroupMemberType) {
    GroupMemberType["Group"] = "group";
    GroupMemberType["Array"] = "array";
})(GroupMemberType = exports.GroupMemberType || (exports.GroupMemberType = {}));
/**
 * List of values that InvitationStatus can take
 * @export
 * @enum {string}
 */
var InvitationStatus;
(function (InvitationStatus) {
    InvitationStatus["Pending"] = "PENDING";
    InvitationStatus["Accepted"] = "ACCEPTED";
})(InvitationStatus = exports.InvitationStatus || (exports.InvitationStatus = {}));
/**
 * List of values that InvitationType can take
 * @export
 * @enum {string}
 */
var InvitationType;
(function (InvitationType) {
    InvitationType["ArrayShare"] = "ARRAY_SHARE";
    InvitationType["JoinOrganization"] = "JOIN_ORGANIZATION";
})(InvitationType = exports.InvitationType || (exports.InvitationType = {}));
/**
 * Layout of array
 * @export
 * @enum {string}
 */
var Layout;
(function (Layout) {
    Layout["RowMajor"] = "row-major";
    Layout["ColMajor"] = "col-major";
    Layout["GlobalOrder"] = "global-order";
    Layout["Unordered"] = "unordered";
})(Layout = exports.Layout || (exports.Layout = {}));
/**
 * actions a user can take on an organization
 * @export
 * @enum {string}
 */
var NamespaceActions;
(function (NamespaceActions) {
    NamespaceActions["Read"] = "read";
    NamespaceActions["Write"] = "write";
    NamespaceActions["Create"] = "create";
    NamespaceActions["Delete"] = "delete";
    NamespaceActions["Edit"] = "edit";
    NamespaceActions["ReadArrayLogs"] = "read_array_logs";
    NamespaceActions["ReadJobLogs"] = "read_job_logs";
    NamespaceActions["ReadObjectLogs"] = "read_object_logs";
    NamespaceActions["RunJob"] = "run_job";
    NamespaceActions["DeleteOrganization"] = "delete_organization";
    NamespaceActions["EditOrganization"] = "edit_organization";
    NamespaceActions["EditBilling"] = "edit_billing";
})(NamespaceActions = exports.NamespaceActions || (exports.NamespaceActions = {}));
/**
 * role user has in organization
 * @export
 * @enum {string}
 */
var OrganizationRoles;
(function (OrganizationRoles) {
    OrganizationRoles["Owner"] = "owner";
    OrganizationRoles["Admin"] = "admin";
    OrganizationRoles["ReadWrite"] = "read_write";
    OrganizationRoles["ReadOnly"] = "read_only";
})(OrganizationRoles = exports.OrganizationRoles || (exports.OrganizationRoles = {}));
/**
 * Specifies a usage aggregation strategy for pricings of usage_type=metered
 * @export
 * @enum {string}
 */
var PricingAggregateUsage;
(function (PricingAggregateUsage) {
    PricingAggregateUsage["Sum"] = "sum";
})(PricingAggregateUsage = exports.PricingAggregateUsage || (exports.PricingAggregateUsage = {}));
/**
 * Currency of pricing
 * @export
 * @enum {string}
 */
var PricingCurrency;
(function (PricingCurrency) {
    PricingCurrency["Usd"] = "USD";
})(PricingCurrency = exports.PricingCurrency || (exports.PricingCurrency = {}));
/**
 * Interval for pricing
 * @export
 * @enum {string}
 */
var PricingInterval;
(function (PricingInterval) {
    PricingInterval["Month"] = "month";
})(PricingInterval = exports.PricingInterval || (exports.PricingInterval = {}));
/**
 * Pricing types
 * @export
 * @enum {string}
 */
var PricingType;
(function (PricingType) {
    PricingType["Egress"] = "egress";
    PricingType["Access"] = "access";
})(PricingType = exports.PricingType || (exports.PricingType = {}));
/**
 * Unit label
 * @export
 * @enum {string}
 */
var PricingUnitLabel;
(function (PricingUnitLabel) {
    PricingUnitLabel["Byte"] = "byte";
    PricingUnitLabel["Second"] = "second";
})(PricingUnitLabel = exports.PricingUnitLabel || (exports.PricingUnitLabel = {}));
/**
 * Query parameter to get array metadatas
 * @export
 * @enum {string}
 */
var PublicShareFilter;
(function (PublicShareFilter) {
    PublicShareFilter["Exclude"] = "exclude";
    PublicShareFilter["Only"] = "only";
})(PublicShareFilter = exports.PublicShareFilter || (exports.PublicShareFilter = {}));
/**
 * Status of query
 * @export
 * @enum {string}
 */
var Querystatus;
(function (Querystatus) {
    Querystatus["Failed"] = "FAILED";
    Querystatus["Completed"] = "COMPLETED";
    Querystatus["Inprogress"] = "INPROGRESS";
    Querystatus["Incomplete"] = "INCOMPLETE";
    Querystatus["Uninitialized"] = "UNINITIALIZED";
})(Querystatus = exports.Querystatus || (exports.Querystatus = {}));
/**
 * Type of query
 * @export
 * @enum {string}
 */
var Querytype;
(function (Querytype) {
    Querytype["Read"] = "READ";
    Querytype["Write"] = "WRITE";
})(Querytype = exports.Querytype || (exports.Querytype = {}));
/**
 * Data format of a result
 * @export
 * @enum {string}
 */
var ResultFormat;
(function (ResultFormat) {
    ResultFormat["PythonPickle"] = "python_pickle";
    ResultFormat["RSerialization"] = "r_serialization";
    ResultFormat["Json"] = "json";
    ResultFormat["Arrow"] = "arrow";
    ResultFormat["Bytes"] = "bytes";
    ResultFormat["TiledbJson"] = "tiledb_json";
    ResultFormat["Native"] = "native";
})(ResultFormat = exports.ResultFormat || (exports.ResultFormat = {}));
/**
 * Single sign on provider
 * @export
 * @enum {string}
 */
var SSOProvider;
(function (SSOProvider) {
    SSOProvider["Github"] = "github";
    SSOProvider["Google"] = "google";
    SSOProvider["Stripe"] = "stripe";
    SSOProvider["Okta"] = "okta";
})(SSOProvider = exports.SSOProvider || (exports.SSOProvider = {}));
/**
 * actions a user can take on a UDF
 * @export
 * @enum {string}
 */
var TaskGraphActions;
(function (TaskGraphActions) {
    TaskGraphActions["FetchTaskGraph"] = "fetch_task_graph";
    TaskGraphActions["ShareTaskGraph"] = "share_task_graph";
})(TaskGraphActions = exports.TaskGraphActions || (exports.TaskGraphActions = {}));
/**
 * The location where an individual node of a task graph is executed.
 * @export
 * @enum {string}
 */
var TaskGraphLogRunLocation;
(function (TaskGraphLogRunLocation) {
    TaskGraphLogRunLocation["Server"] = "server";
    TaskGraphLogRunLocation["Client"] = "client";
    TaskGraphLogRunLocation["Virtual"] = "virtual";
})(TaskGraphLogRunLocation = exports.TaskGraphLogRunLocation || (exports.TaskGraphLogRunLocation = {}));
/**
 * The status of a given task graph execution.
 * @export
 * @enum {string}
 */
var TaskGraphLogStatus;
(function (TaskGraphLogStatus) {
    TaskGraphLogStatus["Submitted"] = "submitted";
    TaskGraphLogStatus["Running"] = "running";
    TaskGraphLogStatus["Idle"] = "idle";
    TaskGraphLogStatus["Abandoned"] = "abandoned";
    TaskGraphLogStatus["Succeeded"] = "succeeded";
    TaskGraphLogStatus["Failed"] = "failed";
    TaskGraphLogStatus["Cancelled"] = "cancelled";
})(TaskGraphLogStatus = exports.TaskGraphLogStatus || (exports.TaskGraphLogStatus = {}));
/**
 * An api token scope available for creation
 * @export
 * @enum {string}
 */
var TokenScope;
(function (TokenScope) {
    TokenScope["PasswordReset"] = "password_reset";
    TokenScope["ConfirmEmail"] = "confirm_email";
    TokenScope["Star"] = "*";
    TokenScope["Userread"] = "user:read";
    TokenScope["UserreadWrite"] = "user:read-write";
    TokenScope["Useradmin"] = "user:admin";
    TokenScope["Arrayread"] = "array:read";
    TokenScope["ArrayreadWrite"] = "array:read-write";
    TokenScope["Arrayadmin"] = "array:admin";
    TokenScope["Organizationread"] = "organization:read";
    TokenScope["OrganizationreadWrite"] = "organization:read-write";
    TokenScope["Organizationadmin"] = "organization:admin";
    TokenScope["Groupread"] = "group:read";
    TokenScope["GroupreadWrite"] = "group:read-write";
    TokenScope["Groupadmin"] = "group:admin";
})(TokenScope = exports.TokenScope || (exports.TokenScope = {}));
/**
 * actions a user can take on a UDF
 * @export
 * @enum {string}
 */
var UDFActions;
(function (UDFActions) {
    UDFActions["FetchUdf"] = "fetch_udf";
    UDFActions["ShareUdf"] = "share_udf";
})(UDFActions = exports.UDFActions || (exports.UDFActions = {}));
/**
 * UDF Type
 * @export
 * @enum {string}
 */
var UDFLanguage;
(function (UDFLanguage) {
    UDFLanguage["Python"] = "python";
    UDFLanguage["R"] = "r";
})(UDFLanguage = exports.UDFLanguage || (exports.UDFLanguage = {}));
/**
 * UDF Type
 * @export
 * @enum {string}
 */
var UDFType;
(function (UDFType) {
    UDFType["MultiArray"] = "multi_array";
    UDFType["SingleArray"] = "single_array";
    UDFType["Generic"] = "generic";
})(UDFType = exports.UDFType || (exports.UDFType = {}));
/**
 * ArrayApi - axios parameter creator
 * @export
 */
const ArrayApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task ID To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog: (namespace, array, start, end, eventTypes, taskId, hasTaskId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('arrayActivityLog', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('arrayActivityLog', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/activity`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (eventTypes !== undefined) {
                localVarQueryParameter['event_types'] = eventTypes;
            }
            if (taskId !== undefined) {
                localVarQueryParameter['task_id'] = taskId;
            }
            if (hasTaskId !== undefined) {
                localVarQueryParameter['has_task_id'] = hasTaskId;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/owned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            if (fileProperty) {
                localVarQueryParameter['file_property'] = fileProperty;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/owned/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            if (fileProperty) {
                localVarQueryParameter['file_property'] = fileProperty;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/public/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {Array<string>} [sharedTo] namespaces to filter results of where there arrays were shared to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, sharedTo, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/shared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            if (fileProperty) {
                localVarQueryParameter['file_property'] = fileProperty;
            }
            if (sharedTo) {
                localVarQueryParameter['shared_to'] = sharedTo;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/shared/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysNamespaceArrayEndTimestampsGet: (namespace, array, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('arraysNamespaceArrayEndTimestampsGet', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('arraysNamespaceArrayEndTimestampsGet', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/end_timestamps`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consolidateArray: (namespace, array, tiledbConfig, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('consolidateArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('consolidateArray', 'array', array);
            // verify required parameter 'tiledbConfig' is not null or undefined
            common_1.assertParamExists('consolidateArray', 'tiledbConfig', tiledbConfig);
            const localVarPath = `/arrays/{namespace}/{array}/consolidate`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(tiledbConfig, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray: (namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('createArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('createArray', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('createArray', 'contentType', contentType);
            // verify required parameter 'arraySchema' is not null or undefined
            common_1.assertParamExists('createArray', 'arraySchema', arraySchema);
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arraySchema, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray: (namespace, array, contentType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('deleteArray', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('deleteArray', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deregisterArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('deregisterArray', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/deregister`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get activity log by ID
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} id ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityLogById: (namespace, array, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getActivityLogById', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getActivityLogById', 'array', array);
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getActivityLogById', 'id', id);
            const localVarPath = `/arrays/{namespace}/{array}/activity/{id}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata: (publicShare, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (publicShare !== undefined) {
                localVarQueryParameter['public_share'] = publicShare;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray: (namespace, array, contentType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArray', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getArray', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes: (namespace, array, subarray, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayMaxBufferSizes', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayMaxBufferSizes', 'array', array);
            // verify required parameter 'subarray' is not null or undefined
            common_1.assertParamExists('getArrayMaxBufferSizes', 'subarray', subarray);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getArrayMaxBufferSizes', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}/max_buffer_sizes`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (subarray !== undefined) {
                localVarQueryParameter['subarray'] = subarray;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata from the array in JSON format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson: (namespace, array, length, endTimestamp, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayMetaDataJson', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayMetaDataJson', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/metadata_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }
            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayMetadata', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayMetadata', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadataCapnp: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayMetadataCapnp', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayMetadataCapnp', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/array_metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain: (namespace, array, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomain', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomain', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomain', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}/non_empty_domain`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomainJson: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomainJson', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomainJson', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/non_empty_domain_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData: (namespace, array, samples, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArraySampleData', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArraySampleData', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/sample`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (samples !== undefined) {
                localVarQueryParameter['samples'] = samples;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArraySharingPolicies', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArraySharingPolicies', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArraysInNamespace', 'namespace', namespace);
            const localVarPath = `/arrays/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFragmentEndTimestamp: (namespace, array, endTimestamp, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getFragmentEndTimestamp', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getFragmentEndTimestamp', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/fragment_end_timestamp`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/last_accessed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray: (namespace, array, arrayMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('registerArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('registerArray', 'array', array);
            // verify required parameter 'arrayMetadata' is not null or undefined
            common_1.assertParamExists('registerArray', 'arrayMetadata', arrayMetadata);
            const localVarPath = `/arrays/{namespace}/{array}/register`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arrayMetadata, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray: (namespace, array, arraySharing, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('shareArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('shareArray', 'array', array);
            // verify required parameter 'arraySharing' is not null or undefined
            common_1.assertParamExists('shareArray', 'arraySharing', arraySharing);
            const localVarPath = `/arrays/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arraySharing, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata: (namespace, array, arrayMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateArrayMetadata', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('updateArrayMetadata', 'array', array);
            // verify required parameter 'arrayMetadata' is not null or undefined
            common_1.assertParamExists('updateArrayMetadata', 'arrayMetadata', arrayMetadata);
            const localVarPath = `/arrays/{namespace}/{array}/metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arrayMetadata, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadataCapnp: (namespace, array, arrayMetadataEntries, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateArrayMetadataCapnp', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('updateArrayMetadataCapnp', 'array', array);
            // verify required parameter 'arrayMetadataEntries' is not null or undefined
            common_1.assertParamExists('updateArrayMetadataCapnp', 'arrayMetadataEntries', arrayMetadataEntries);
            const localVarPath = `/arrays/{namespace}/{array}/array_metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arrayMetadataEntries, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vacuumArray: (namespace, array, tiledbConfig, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('vacuumArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('vacuumArray', 'array', array);
            // verify required parameter 'tiledbConfig' is not null or undefined
            common_1.assertParamExists('vacuumArray', 'tiledbConfig', tiledbConfig);
            const localVarPath = `/arrays/{namespace}/{array}/vacuum`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(tiledbConfig, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ArrayApiAxiosParamCreator = ArrayApiAxiosParamCreator;
/**
 * ArrayApi - functional programming interface
 * @export
 */
const ArrayApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ArrayApiAxiosParamCreator(configuration);
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task ID To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserOwnedSidebarGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserPublicSidebarGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {Array<string>} [sharedTo] namespaces to filter results of where there arrays were shared to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, sharedTo, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, sharedTo, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserSharedSidebarGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consolidateArray(namespace, array, tiledbConfig, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.consolidateArray(namespace, array, tiledbConfig, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray(namespace, array, contentType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteArray(namespace, array, contentType, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deregisterArray(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get activity log by ID
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} id ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityLogById(namespace, array, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getActivityLogById(namespace, array, id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata(publicShare, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllArrayMetadata(publicShare, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray(namespace, array, contentType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArray(namespace, array, contentType, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get metadata from the array in JSON format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson(namespace, array, length, endTimestamp, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetaDataJson(namespace, array, length, endTimestamp, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetadata(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadataCapnp(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetadataCapnp(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomainJson(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayNonEmptyDomainJson(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData(namespace, array, samples, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraySampleData(namespace, array, samples, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraySharingPolicies(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraysInNamespace(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFragmentEndTimestamp(namespace, array, endTimestamp, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFragmentEndTimestamp(namespace, array, endTimestamp, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLastAccessedArrays(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray(namespace, array, arrayMetadata, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerArray(namespace, array, arrayMetadata, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray(namespace, array, arraySharing, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareArray(namespace, array, arraySharing, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata(namespace, array, arrayMetadata, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateArrayMetadata(namespace, array, arrayMetadata, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vacuumArray(namespace, array, tiledbConfig, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.vacuumArray(namespace, array, tiledbConfig, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ArrayApiFp = ArrayApiFp;
/**
 * ArrayApi - factory interface
 * @export
 */
const ArrayApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ArrayApiFp(configuration);
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task ID To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {
            return localVarFp.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
            return localVarFp.arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet(options) {
            return localVarFp.arraysBrowserOwnedSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
            return localVarFp.arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet(options) {
            return localVarFp.arraysBrowserPublicSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {Array<string>} [sharedTo] namespaces to filter results of where there arrays were shared to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, sharedTo, options) {
            return localVarFp.arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, sharedTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet(options) {
            return localVarFp.arraysBrowserSharedSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
            return localVarFp.arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consolidateArray(namespace, array, tiledbConfig, options) {
            return localVarFp.consolidateArray(namespace, array, tiledbConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return localVarFp.createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray(namespace, array, contentType, options) {
            return localVarFp.deleteArray(namespace, array, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray(namespace, array, options) {
            return localVarFp.deregisterArray(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get activity log by ID
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} id ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityLogById(namespace, array, id, options) {
            return localVarFp.getActivityLogById(namespace, array, id, options).then((request) => request(axios, basePath));
        },
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata(publicShare, options) {
            return localVarFp.getAllArrayMetadata(publicShare, options).then((request) => request(axios, basePath));
        },
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray(namespace, array, contentType, options) {
            return localVarFp.getArray(namespace, array, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {
            return localVarFp.getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata from the array in JSON format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson(namespace, array, length, endTimestamp, options) {
            return localVarFp.getArrayMetaDataJson(namespace, array, length, endTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata(namespace, array, options) {
            return localVarFp.getArrayMetadata(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadataCapnp(namespace, array, options) {
            return localVarFp.getArrayMetadataCapnp(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {
            return localVarFp.getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomainJson(namespace, array, options) {
            return localVarFp.getArrayNonEmptyDomainJson(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData(namespace, array, samples, options) {
            return localVarFp.getArraySampleData(namespace, array, samples, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies(namespace, array, options) {
            return localVarFp.getArraySharingPolicies(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace(namespace, options) {
            return localVarFp.getArraysInNamespace(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFragmentEndTimestamp(namespace, array, endTimestamp, options) {
            return localVarFp.getFragmentEndTimestamp(namespace, array, endTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays(options) {
            return localVarFp.getLastAccessedArrays(options).then((request) => request(axios, basePath));
        },
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray(namespace, array, arrayMetadata, options) {
            return localVarFp.registerArray(namespace, array, arrayMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray(namespace, array, arraySharing, options) {
            return localVarFp.shareArray(namespace, array, arraySharing, options).then((request) => request(axios, basePath));
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata(namespace, array, arrayMetadata, options) {
            return localVarFp.updateArrayMetadata(namespace, array, arrayMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options) {
            return localVarFp.updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options).then((request) => request(axios, basePath));
        },
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vacuumArray(namespace, array, tiledbConfig, options) {
            return localVarFp.vacuumArray(namespace, array, tiledbConfig, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ArrayApiFactory = ArrayApiFactory;
/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
class ArrayApi extends base_1.BaseAPI {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task ID To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {
        return exports.ArrayApiFp(this.configuration).arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that are owned directly by user or user\'s organizations
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserOwnedSidebarGet(options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserOwnedSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that have been shared publically
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a sidebar of all arrays that have been shared publically
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserPublicSidebarGet(options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserPublicSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {Array<string>} [sharedTo] namespaces to filter results of where there arrays were shared to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, sharedTo, options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, sharedTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserSharedSidebarGet(options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserSharedSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
        return exports.ArrayApiFp(this.configuration).arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * consolidate an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    consolidateArray(namespace, array, tiledbConfig, options) {
        return exports.ArrayApiFp(this.configuration).consolidateArray(namespace, array, tiledbConfig, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * create a array schema at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArraySchema} arraySchema ArraySchema being created
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
        return exports.ArrayApiFp(this.configuration).createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    deleteArray(namespace, array, contentType, options) {
        return exports.ArrayApiFp(this.configuration).deleteArray(namespace, array, contentType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * deregister a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    deregisterArray(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).deregisterArray(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get activity log by ID
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} id ID of the activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getActivityLogById(namespace, array, id, options) {
        return exports.ArrayApiFp(this.configuration).getActivityLogById(namespace, array, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get all array metadata user has access to
     * @param {string} [publicShare] Public share values can be one of exclude, only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getAllArrayMetadata(publicShare, options) {
        return exports.ArrayApiFp(this.configuration).getAllArrayMetadata(publicShare, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get an ArraySchema using a url encoded uri
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArray(namespace, array, contentType, options) {
        return exports.ArrayApiFp(this.configuration).getArray(namespace, array, contentType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get the max buffer sizes of an array for a subarray
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} subarray CSV string of subarray to get max buffer sizes for
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {
        return exports.ArrayApiFp(this.configuration).getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata from the array in JSON format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [length] (optional) limit character length of returned values
     * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetaDataJson(namespace, array, length, endTimestamp, options) {
        return exports.ArrayApiFp(this.configuration).getArrayMetaDataJson(namespace, array, length, endTimestamp, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetadata(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).getArrayMetadata(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetadataCapnp(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).getArrayMetadataCapnp(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get the non empty domain of an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {
        return exports.ArrayApiFp(this.configuration).getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get non-empty domain from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayNonEmptyDomainJson(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).getArrayNonEmptyDomainJson(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get an sample set of data from the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [samples] Number of sample results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraySampleData(namespace, array, samples, options) {
        return exports.ArrayApiFp(this.configuration).getArraySampleData(namespace, array, samples, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all sharing details of the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraySharingPolicies(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).getArraySharingPolicies(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata on all arrays in a namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraysInNamespace(namespace, options) {
        return exports.ArrayApiFp(this.configuration).getArraysInNamespace(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [endTimestamp] Milliseconds since Unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getFragmentEndTimestamp(namespace, array, endTimestamp, options) {
        return exports.ArrayApiFp(this.configuration).getFragmentEndTimestamp(namespace, array, endTimestamp, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getLastAccessedArrays(options) {
        return exports.ArrayApiFp(this.configuration).getLastAccessedArrays(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * register an array at a specified URI registered to the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    registerArray(namespace, array, arrayMetadata, options) {
        return exports.ArrayApiFp(this.configuration).registerArray(namespace, array, arrayMetadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Share an array with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    shareArray(namespace, array, arraySharing, options) {
        return exports.ArrayApiFp(this.configuration).shareArray(namespace, array, arraySharing, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    updateArrayMetadata(namespace, array, arrayMetadata, options) {
        return exports.ArrayApiFp(this.configuration).updateArrayMetadata(namespace, array, arrayMetadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options) {
        return exports.ArrayApiFp(this.configuration).updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * vacuum an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    vacuumArray(namespace, array, tiledbConfig, options) {
        return exports.ArrayApiFp(this.configuration).vacuumArray(namespace, array, tiledbConfig, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ArrayApi = ArrayApi;
/**
 * ArrayTasksApi - axios parameter creator
 * @export
 */
const ArrayTasksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar: (start, end, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tasks/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ArrayTasksApiAxiosParamCreator = ArrayTasksApiAxiosParamCreator;
/**
 * ArrayTasksApi - functional programming interface
 * @export
 */
const ArrayTasksApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ArrayTasksApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar(start, end, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayTasksSidebar(start, end, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ArrayTasksApiFp = ArrayTasksApiFp;
/**
 * ArrayTasksApi - factory interface
 * @export
 */
const ArrayTasksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ArrayTasksApiFp(configuration);
    return {
        /**
         *
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar(start, end, options) {
            return localVarFp.getArrayTasksSidebar(start, end, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ArrayTasksApiFactory = ArrayTasksApiFactory;
/**
 * ArrayTasksApi - object-oriented interface
 * @export
 * @class ArrayTasksApi
 * @extends {BaseAPI}
 */
class ArrayTasksApi extends base_1.BaseAPI {
    /**
     *
     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayTasksApi
     */
    getArrayTasksSidebar(start, end, options) {
        return exports.ArrayTasksApiFp(this.configuration).getArrayTasksSidebar(start, end, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ArrayTasksApi = ArrayTasksApi;
/**
 * FavoritesApi - axios parameter creator
 * @export
 */
const FavoritesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add a new array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArrayFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('addArrayFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('addArrayFavorite', 'name', name);
            const localVarPath = `/arrays/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add a new ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMLModelFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('addMLModelFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('addMLModelFavorite', 'name', name);
            const localVarPath = `/ml_models/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add a new notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNotebookFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('addNotebookFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('addNotebookFavorite', 'name', name);
            const localVarPath = `/notebooks/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add a new UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUDFFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('addUDFFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('addUDFFavorite', 'name', name);
            const localVarPath = `/udfs/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete specific array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArrayFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteArrayFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteArrayFavorite', 'name', name);
            const localVarPath = `/arrays/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete specific ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMLModelFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteMLModelFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteMLModelFavorite', 'name', name);
            const localVarPath = `/ml_models/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete specific notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotebookFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteNotebookFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteNotebookFavorite', 'name', name);
            const localVarPath = `/notebooks/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete specific UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteUDFFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteUDFFavorite', 'name', name);
            const localVarPath = `/udfs/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch array favorite of a specific array
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('getArrayFavorite', 'name', name);
            const localVarPath = `/arrays/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch ML model favorite of a specific ML model
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMLModelFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getMLModelFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('getMLModelFavorite', 'name', name);
            const localVarPath = `/ml_models/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch notebook favorite of a specific notebook
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getNotebookFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('getNotebookFavorite', 'name', name);
            const localVarPath = `/notebooks/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch UDF favorite of a specific UDF
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getUDFFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('getUDFFavorite', 'name', name);
            const localVarPath = `/udfs/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a page of array favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavorites: (page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch all favorite array uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavoritesUUIDs: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/favorites/uuids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a page of ML models favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavorites: (page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ml_models/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch all favorite ML models uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavoritesUUIDs: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ml_models/favorites/uuids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a page of notebook favorites of connected user
         * @param {boolean} [isDashboard] return only dashboards
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavorites: (isDashboard, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/notebooks/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (isDashboard !== undefined) {
                localVarQueryParameter['is_dashboard'] = isDashboard;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch all favorite notebook uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavoritesUUIDs: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/notebooks/favorites/uuids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a page of UDF favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavorites: (page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/udfs/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch all favorite UDF uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavoritesUUIDs: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/udfs/favorites/uuids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FavoritesApiAxiosParamCreator = FavoritesApiAxiosParamCreator;
/**
 * FavoritesApi - functional programming interface
 * @export
 */
const FavoritesApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.FavoritesApiAxiosParamCreator(configuration);
    return {
        /**
         * Add a new array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArrayFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addArrayFavorite(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Add a new ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMLModelFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addMLModelFavorite(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Add a new notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNotebookFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addNotebookFavorite(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Add a new UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUDFFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addUDFFavorite(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Delete specific array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArrayFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteArrayFavorite(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Delete specific ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMLModelFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteMLModelFavorite(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Delete specific notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotebookFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteNotebookFavorite(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Delete specific UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUDFFavorite(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch array favorite of a specific array
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayFavorite(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch ML model favorite of a specific ML model
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMLModelFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMLModelFavorite(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch notebook favorite of a specific notebook
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getNotebookFavorite(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch UDF favorite of a specific UDF
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUDFFavorite(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a page of array favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavorites(page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listArrayFavorites(page, perPage, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch all favorite array uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavoritesUUIDs(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listArrayFavoritesUUIDs(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a page of ML models favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavorites(page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listMLModelFavorites(page, perPage, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch all favorite ML models uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavoritesUUIDs(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listMLModelFavoritesUUIDs(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a page of notebook favorites of connected user
         * @param {boolean} [isDashboard] return only dashboards
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavorites(isDashboard, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listNotebookFavorites(isDashboard, page, perPage, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch all favorite notebook uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavoritesUUIDs(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listNotebookFavoritesUUIDs(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a page of UDF favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavorites(page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listUDFFavorites(page, perPage, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch all favorite UDF uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavoritesUUIDs(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listUDFFavoritesUUIDs(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.FavoritesApiFp = FavoritesApiFp;
/**
 * FavoritesApi - factory interface
 * @export
 */
const FavoritesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.FavoritesApiFp(configuration);
    return {
        /**
         * Add a new array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArrayFavorite(namespace, name, options) {
            return localVarFp.addArrayFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMLModelFavorite(namespace, name, options) {
            return localVarFp.addMLModelFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNotebookFavorite(namespace, name, options) {
            return localVarFp.addNotebookFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUDFFavorite(namespace, name, options) {
            return localVarFp.addUDFFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArrayFavorite(namespace, name, options) {
            return localVarFp.deleteArrayFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMLModelFavorite(namespace, name, options) {
            return localVarFp.deleteMLModelFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotebookFavorite(namespace, name, options) {
            return localVarFp.deleteNotebookFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFFavorite(namespace, name, options) {
            return localVarFp.deleteUDFFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch array favorite of a specific array
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayFavorite(namespace, name, options) {
            return localVarFp.getArrayFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch ML model favorite of a specific ML model
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMLModelFavorite(namespace, name, options) {
            return localVarFp.getMLModelFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch notebook favorite of a specific notebook
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookFavorite(namespace, name, options) {
            return localVarFp.getNotebookFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch UDF favorite of a specific UDF
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFFavorite(namespace, name, options) {
            return localVarFp.getUDFFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a page of array favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavorites(page, perPage, options) {
            return localVarFp.listArrayFavorites(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all favorite array uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavoritesUUIDs(options) {
            return localVarFp.listArrayFavoritesUUIDs(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a page of ML models favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavorites(page, perPage, options) {
            return localVarFp.listMLModelFavorites(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all favorite ML models uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavoritesUUIDs(options) {
            return localVarFp.listMLModelFavoritesUUIDs(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a page of notebook favorites of connected user
         * @param {boolean} [isDashboard] return only dashboards
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavorites(isDashboard, page, perPage, options) {
            return localVarFp.listNotebookFavorites(isDashboard, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all favorite notebook uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavoritesUUIDs(options) {
            return localVarFp.listNotebookFavoritesUUIDs(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a page of UDF favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavorites(page, perPage, options) {
            return localVarFp.listUDFFavorites(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all favorite UDF uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavoritesUUIDs(options) {
            return localVarFp.listUDFFavoritesUUIDs(options).then((request) => request(axios, basePath));
        },
    };
};
exports.FavoritesApiFactory = FavoritesApiFactory;
/**
 * FavoritesApi - object-oriented interface
 * @export
 * @class FavoritesApi
 * @extends {BaseAPI}
 */
class FavoritesApi extends base_1.BaseAPI {
    /**
     * Add a new array favorite
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    addArrayFavorite(namespace, name, options) {
        return exports.FavoritesApiFp(this.configuration).addArrayFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add a new ML model favorite
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    addMLModelFavorite(namespace, name, options) {
        return exports.FavoritesApiFp(this.configuration).addMLModelFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add a new notebook favorite
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    addNotebookFavorite(namespace, name, options) {
        return exports.FavoritesApiFp(this.configuration).addNotebookFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add a new UDF favorite
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    addUDFFavorite(namespace, name, options) {
        return exports.FavoritesApiFp(this.configuration).addUDFFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete specific array favorite
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    deleteArrayFavorite(namespace, name, options) {
        return exports.FavoritesApiFp(this.configuration).deleteArrayFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete specific ML model favorite
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    deleteMLModelFavorite(namespace, name, options) {
        return exports.FavoritesApiFp(this.configuration).deleteMLModelFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete specific notebook favorite
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    deleteNotebookFavorite(namespace, name, options) {
        return exports.FavoritesApiFp(this.configuration).deleteNotebookFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete specific UDF favorite
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    deleteUDFFavorite(namespace, name, options) {
        return exports.FavoritesApiFp(this.configuration).deleteUDFFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch array favorite of a specific array
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getArrayFavorite(namespace, name, options) {
        return exports.FavoritesApiFp(this.configuration).getArrayFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch ML model favorite of a specific ML model
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getMLModelFavorite(namespace, name, options) {
        return exports.FavoritesApiFp(this.configuration).getMLModelFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch notebook favorite of a specific notebook
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getNotebookFavorite(namespace, name, options) {
        return exports.FavoritesApiFp(this.configuration).getNotebookFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch UDF favorite of a specific UDF
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getUDFFavorite(namespace, name, options) {
        return exports.FavoritesApiFp(this.configuration).getUDFFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a page of array favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listArrayFavorites(page, perPage, options) {
        return exports.FavoritesApiFp(this.configuration).listArrayFavorites(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch all favorite array uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listArrayFavoritesUUIDs(options) {
        return exports.FavoritesApiFp(this.configuration).listArrayFavoritesUUIDs(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a page of ML models favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listMLModelFavorites(page, perPage, options) {
        return exports.FavoritesApiFp(this.configuration).listMLModelFavorites(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch all favorite ML models uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listMLModelFavoritesUUIDs(options) {
        return exports.FavoritesApiFp(this.configuration).listMLModelFavoritesUUIDs(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a page of notebook favorites of connected user
     * @param {boolean} [isDashboard] return only dashboards
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listNotebookFavorites(isDashboard, page, perPage, options) {
        return exports.FavoritesApiFp(this.configuration).listNotebookFavorites(isDashboard, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch all favorite notebook uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listNotebookFavoritesUUIDs(options) {
        return exports.FavoritesApiFp(this.configuration).listNotebookFavoritesUUIDs(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a page of UDF favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listUDFFavorites(page, perPage, options) {
        return exports.FavoritesApiFp(this.configuration).listUDFFavorites(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch all favorite UDF uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listUDFFavoritesUUIDs(options) {
        return exports.FavoritesApiFp(this.configuration).listUDFFavoritesUUIDs(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FavoritesApi = FavoritesApi;
/**
 * FilesApi - axios parameter creator
 * @export
 */
const FilesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCreateFile: (namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('handleCreateFile', 'namespace', namespace);
            // verify required parameter 'fileCreate' is not null or undefined
            common_1.assertParamExists('handleCreateFile', 'fileCreate', fileCreate);
            const localVarPath = `/files/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(fileCreate, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Export a TileDB File back to its original file format
         * @param {string} namespace The namespace of the file
         * @param {string} file The file identifier
         * @param {FileExport} fileExport Export configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExportFile: (namespace, file, fileExport, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('handleExportFile', 'namespace', namespace);
            // verify required parameter 'file' is not null or undefined
            common_1.assertParamExists('handleExportFile', 'file', file);
            // verify required parameter 'fileExport' is not null or undefined
            common_1.assertParamExists('handleExportFile', 'fileExport', fileExport);
            const localVarPath = `/files/{namespace}/{file}/export`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"file"}}`, encodeURIComponent(String(file)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(fileExport, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Upload a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {any} inputFile the file to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [outputUri] output location of the TileDB File
         * @param {string} [name] name to set for registered file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadFile: (namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('handleUploadFile', 'namespace', namespace);
            // verify required parameter 'inputFile' is not null or undefined
            common_1.assertParamExists('handleUploadFile', 'inputFile', inputFile);
            const localVarPath = `/files/{namespace}/upload`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            if (inputFile !== undefined) {
                localVarFormParams.append('input_file', inputFile);
            }
            if (outputUri !== undefined) {
                localVarFormParams.append('output_uri', outputUri);
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FilesApiAxiosParamCreator = FilesApiAxiosParamCreator;
/**
 * FilesApi - functional programming interface
 * @export
 */
const FilesApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.FilesApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Export a TileDB File back to its original file format
         * @param {string} namespace The namespace of the file
         * @param {string} file The file identifier
         * @param {FileExport} fileExport Export configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExportFile(namespace, file, fileExport, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.handleExportFile(namespace, file, fileExport, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Upload a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {any} inputFile the file to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [outputUri] output location of the TileDB File
         * @param {string} [name] name to set for registered file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadFile(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.handleUploadFile(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.FilesApiFp = FilesApiFp;
/**
 * FilesApi - factory interface
 * @export
 */
const FilesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.FilesApiFp(configuration);
    return {
        /**
         * Create a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return localVarFp.handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(axios, basePath));
        },
        /**
         * Export a TileDB File back to its original file format
         * @param {string} namespace The namespace of the file
         * @param {string} file The file identifier
         * @param {FileExport} fileExport Export configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExportFile(namespace, file, fileExport, options) {
            return localVarFp.handleExportFile(namespace, file, fileExport, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {any} inputFile the file to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [outputUri] output location of the TileDB File
         * @param {string} [name] name to set for registered file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadFile(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options) {
            return localVarFp.handleUploadFile(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FilesApiFactory = FilesApiFactory;
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
class FilesApi extends base_1.BaseAPI {
    /**
     * Create a tiledb file at the specified location
     * @param {string} namespace The namespace of the file
     * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
        return exports.FilesApiFp(this.configuration).handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Export a TileDB File back to its original file format
     * @param {string} namespace The namespace of the file
     * @param {string} file The file identifier
     * @param {FileExport} fileExport Export configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    handleExportFile(namespace, file, fileExport, options) {
        return exports.FilesApiFp(this.configuration).handleExportFile(namespace, file, fileExport, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload a tiledb file at the specified location
     * @param {string} namespace The namespace of the file
     * @param {any} inputFile the file to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [outputUri] output location of the TileDB File
     * @param {string} [name] name to set for registered file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    handleUploadFile(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options) {
        return exports.FilesApiFp(this.configuration).handleUploadFile(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FilesApi = FilesApi;
/**
 * GroupsApi - axios parameter creator
 * @export
 */
const GroupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Changes the contents of the group by adding/removing members.
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupChanges} [groupChanges]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeGroupContents: (groupNamespace, groupName, groupChanges, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            common_1.assertParamExists('changeGroupContents', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            common_1.assertParamExists('changeGroupContents', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}/contents`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(groupChanges, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {GroupCreate} [groupCreate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: (namespace, groupCreate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('createGroup', 'namespace', namespace);
            const localVarPath = `/groups/{namespace}/create`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(groupCreate, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the group. The assets are not deleted nor are not relocated to any other group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: (groupNamespace, groupName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            common_1.assertParamExists('deleteGroup', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            common_1.assertParamExists('deleteGroup', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: (groupNamespace, groupName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            common_1.assertParamExists('getGroup', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            common_1.assertParamExists('getGroup', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the contents of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {number} [page] pagination offset for assets
         * @param {number} [perPage] pagination limit for assets
         * @param {string} [namespace] namespace to search for
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [memberType] member type to search for, more than one can be included
         * @param {Array<string>} [excludeMemberType] member type to exclude matching groups in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupContents: (groupNamespace, groupName, page, perPage, namespace, search, orderby, tag, excludeTag, memberType, excludeMemberType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            common_1.assertParamExists('getGroupContents', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            common_1.assertParamExists('getGroupContents', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}/contents`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (memberType) {
                localVarQueryParameter['member_type'] = memberType;
            }
            if (excludeMemberType) {
                localVarQueryParameter['exclude_member_type'] = excludeMemberType;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all sharing details of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupSharingPolicies: (groupNamespace, groupName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            common_1.assertParamExists('getGroupSharingPolicies', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            common_1.assertParamExists('getGroupSharingPolicies', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}/share`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserOwnedFiltersGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/groups/browser/owned/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserPublicFiltersGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/groups/browser/public/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserSharedFiltersGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/groups/browser/shared/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch data to initialize filters for the group contents
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupNamespaceGroupNameContentsFiltersGet: (groupNamespace, groupName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            common_1.assertParamExists('groupsGroupNamespaceGroupNameContentsFiltersGet', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            common_1.assertParamExists('groupsGroupNamespaceGroupNameContentsFiltersGet', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}/contents/filters`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns one page of owned groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedGroups: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/groups/browser/owned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }
            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns one page of public groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicGroups: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/groups/browser/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }
            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns one page of shared groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {Array<string>} [sharedTo] namespaces to filter results of where there groups were shared to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedGroups: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, sharedTo, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/groups/browser/shared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }
            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }
            if (sharedTo) {
                localVarQueryParameter['shared_to'] = sharedTo;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Registers an existing group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {string} array The unique name or id of the group
         * @param {GroupRegister} [groupRegister]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGroup: (namespace, array, groupRegister, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('registerGroup', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('registerGroup', 'array', array);
            const localVarPath = `/groups/{namespace}/{array}/register`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(groupRegister, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Share a group with a namespace
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupSharingRequest} groupSharingRequest Namespace and list of permissions to share with. Sharing is recursive, it is applied to all reachable subgroups and arrays of the group. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the group will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareGroup: (groupNamespace, groupName, groupSharingRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            common_1.assertParamExists('shareGroup', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            common_1.assertParamExists('shareGroup', 'groupName', groupName);
            // verify required parameter 'groupSharingRequest' is not null or undefined
            common_1.assertParamExists('shareGroup', 'groupSharingRequest', groupSharingRequest);
            const localVarPath = `/groups/{group_namespace}/{group_name}/share`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(groupSharingRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Changes attributes of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupUpdate} [groupUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: (groupNamespace, groupName, groupUpdate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            common_1.assertParamExists('updateGroup', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            common_1.assertParamExists('updateGroup', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(groupUpdate, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.GroupsApiAxiosParamCreator = GroupsApiAxiosParamCreator;
/**
 * GroupsApi - functional programming interface
 * @export
 */
const GroupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.GroupsApiAxiosParamCreator(configuration);
    return {
        /**
         * Changes the contents of the group by adding/removing members.
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupChanges} [groupChanges]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeGroupContents(groupNamespace, groupName, groupChanges, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.changeGroupContents(groupNamespace, groupName, groupChanges, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Creates a new group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {GroupCreate} [groupCreate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(namespace, groupCreate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createGroup(namespace, groupCreate, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Deletes the group. The assets are not deleted nor are not relocated to any other group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupNamespace, groupName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteGroup(groupNamespace, groupName, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns the the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupNamespace, groupName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGroup(groupNamespace, groupName, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns the contents of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {number} [page] pagination offset for assets
         * @param {number} [perPage] pagination limit for assets
         * @param {string} [namespace] namespace to search for
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [memberType] member type to search for, more than one can be included
         * @param {Array<string>} [excludeMemberType] member type to exclude matching groups in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupContents(groupNamespace, groupName, page, perPage, namespace, search, orderby, tag, excludeTag, memberType, excludeMemberType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGroupContents(groupNamespace, groupName, page, perPage, namespace, search, orderby, tag, excludeTag, memberType, excludeMemberType, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get all sharing details of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupSharingPolicies(groupNamespace, groupName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGroupSharingPolicies(groupNamespace, groupName, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserOwnedFiltersGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupsBrowserOwnedFiltersGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserPublicFiltersGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupsBrowserPublicFiltersGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserSharedFiltersGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupsBrowserSharedFiltersGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch data to initialize filters for the group contents
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace, groupName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace, groupName, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns one page of owned groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listOwnedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns one page of public groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPublicGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns one page of shared groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {Array<string>} [sharedTo] namespaces to filter results of where there groups were shared to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, sharedTo, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listSharedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, sharedTo, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Registers an existing group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {string} array The unique name or id of the group
         * @param {GroupRegister} [groupRegister]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGroup(namespace, array, groupRegister, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerGroup(namespace, array, groupRegister, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Share a group with a namespace
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupSharingRequest} groupSharingRequest Namespace and list of permissions to share with. Sharing is recursive, it is applied to all reachable subgroups and arrays of the group. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the group will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareGroup(groupNamespace, groupName, groupSharingRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareGroup(groupNamespace, groupName, groupSharingRequest, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Changes attributes of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupUpdate} [groupUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupNamespace, groupName, groupUpdate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateGroup(groupNamespace, groupName, groupUpdate, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.GroupsApiFp = GroupsApiFp;
/**
 * GroupsApi - factory interface
 * @export
 */
const GroupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.GroupsApiFp(configuration);
    return {
        /**
         * Changes the contents of the group by adding/removing members.
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupChanges} [groupChanges]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeGroupContents(groupNamespace, groupName, groupChanges, options) {
            return localVarFp.changeGroupContents(groupNamespace, groupName, groupChanges, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {GroupCreate} [groupCreate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(namespace, groupCreate, options) {
            return localVarFp.createGroup(namespace, groupCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the group. The assets are not deleted nor are not relocated to any other group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupNamespace, groupName, options) {
            return localVarFp.deleteGroup(groupNamespace, groupName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupNamespace, groupName, options) {
            return localVarFp.getGroup(groupNamespace, groupName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the contents of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {number} [page] pagination offset for assets
         * @param {number} [perPage] pagination limit for assets
         * @param {string} [namespace] namespace to search for
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [memberType] member type to search for, more than one can be included
         * @param {Array<string>} [excludeMemberType] member type to exclude matching groups in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupContents(groupNamespace, groupName, page, perPage, namespace, search, orderby, tag, excludeTag, memberType, excludeMemberType, options) {
            return localVarFp.getGroupContents(groupNamespace, groupName, page, perPage, namespace, search, orderby, tag, excludeTag, memberType, excludeMemberType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sharing details of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupSharingPolicies(groupNamespace, groupName, options) {
            return localVarFp.getGroupSharingPolicies(groupNamespace, groupName, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserOwnedFiltersGet(options) {
            return localVarFp.groupsBrowserOwnedFiltersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserPublicFiltersGet(options) {
            return localVarFp.groupsBrowserPublicFiltersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserSharedFiltersGet(options) {
            return localVarFp.groupsBrowserSharedFiltersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch data to initialize filters for the group contents
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace, groupName, options) {
            return localVarFp.groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace, groupName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns one page of owned groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options) {
            return localVarFp.listOwnedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns one page of public groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options) {
            return localVarFp.listPublicGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns one page of shared groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {Array<string>} [sharedTo] namespaces to filter results of where there groups were shared to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, sharedTo, options) {
            return localVarFp.listSharedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, sharedTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers an existing group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {string} array The unique name or id of the group
         * @param {GroupRegister} [groupRegister]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGroup(namespace, array, groupRegister, options) {
            return localVarFp.registerGroup(namespace, array, groupRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * Share a group with a namespace
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupSharingRequest} groupSharingRequest Namespace and list of permissions to share with. Sharing is recursive, it is applied to all reachable subgroups and arrays of the group. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the group will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareGroup(groupNamespace, groupName, groupSharingRequest, options) {
            return localVarFp.shareGroup(groupNamespace, groupName, groupSharingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes attributes of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupUpdate} [groupUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupNamespace, groupName, groupUpdate, options) {
            return localVarFp.updateGroup(groupNamespace, groupName, groupUpdate, options).then((request) => request(axios, basePath));
        },
    };
};
exports.GroupsApiFactory = GroupsApiFactory;
/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
class GroupsApi extends base_1.BaseAPI {
    /**
     * Changes the contents of the group by adding/removing members.
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupChanges} [groupChanges]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    changeGroupContents(groupNamespace, groupName, groupChanges, options) {
        return exports.GroupsApiFp(this.configuration).changeGroupContents(groupNamespace, groupName, groupChanges, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new group in the namespace.
     * @param {string} namespace The namespace of the group
     * @param {GroupCreate} [groupCreate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    createGroup(namespace, groupCreate, options) {
        return exports.GroupsApiFp(this.configuration).createGroup(namespace, groupCreate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the group. The assets are not deleted nor are not relocated to any other group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deleteGroup(groupNamespace, groupName, options) {
        return exports.GroupsApiFp(this.configuration).deleteGroup(groupNamespace, groupName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroup(groupNamespace, groupName, options) {
        return exports.GroupsApiFp(this.configuration).getGroup(groupNamespace, groupName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {number} [page] pagination offset for assets
     * @param {number} [perPage] pagination limit for assets
     * @param {string} [namespace] namespace to search for
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [memberType] member type to search for, more than one can be included
     * @param {Array<string>} [excludeMemberType] member type to exclude matching groups in results, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupContents(groupNamespace, groupName, page, perPage, namespace, search, orderby, tag, excludeTag, memberType, excludeMemberType, options) {
        return exports.GroupsApiFp(this.configuration).getGroupContents(groupNamespace, groupName, page, perPage, namespace, search, orderby, tag, excludeTag, memberType, excludeMemberType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all sharing details of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupSharingPolicies(groupNamespace, groupName, options) {
        return exports.GroupsApiFp(this.configuration).getGroupSharingPolicies(groupNamespace, groupName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsBrowserOwnedFiltersGet(options) {
        return exports.GroupsApiFp(this.configuration).groupsBrowserOwnedFiltersGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsBrowserPublicFiltersGet(options) {
        return exports.GroupsApiFp(this.configuration).groupsBrowserPublicFiltersGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsBrowserSharedFiltersGet(options) {
        return exports.GroupsApiFp(this.configuration).groupsBrowserSharedFiltersGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch data to initialize filters for the group contents
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace, groupName, options) {
        return exports.GroupsApiFp(this.configuration).groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace, groupName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns one page of owned groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    listOwnedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options) {
        return exports.GroupsApiFp(this.configuration).listOwnedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns one page of public groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    listPublicGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options) {
        return exports.GroupsApiFp(this.configuration).listPublicGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns one page of shared groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {Array<string>} [sharedTo] namespaces to filter results of where there groups were shared to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    listSharedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, sharedTo, options) {
        return exports.GroupsApiFp(this.configuration).listSharedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, sharedTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Registers an existing group in the namespace.
     * @param {string} namespace The namespace of the group
     * @param {string} array The unique name or id of the group
     * @param {GroupRegister} [groupRegister]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    registerGroup(namespace, array, groupRegister, options) {
        return exports.GroupsApiFp(this.configuration).registerGroup(namespace, array, groupRegister, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Share a group with a namespace
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupSharingRequest} groupSharingRequest Namespace and list of permissions to share with. Sharing is recursive, it is applied to all reachable subgroups and arrays of the group. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the group will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    shareGroup(groupNamespace, groupName, groupSharingRequest, options) {
        return exports.GroupsApiFp(this.configuration).shareGroup(groupNamespace, groupName, groupSharingRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes attributes of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupUpdate} [groupUpdate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroup(groupNamespace, groupName, groupUpdate, options) {
        return exports.GroupsApiFp(this.configuration).updateGroup(groupNamespace, groupName, groupUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.GroupsApi = GroupsApi;
/**
 * InvitationApi - axios parameter creator
 * @export
 */
const InvitationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the ID of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation: (invitation, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invitation' is not null or undefined
            common_1.assertParamExists('acceptInvitation', 'invitation', invitation);
            const localVarPath = `/invitations/{invitation}`
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Cancels join organization invitation
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} organization name or UUID of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization: (invitation, organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invitation' is not null or undefined
            common_1.assertParamExists('cancelJoinOrganization', 'invitation', invitation);
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('cancelJoinOrganization', 'organization', organization);
            const localVarPath = `/invitations/{invitation}/{organization}/join`
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)))
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite: (namespace, invitation, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('cancelShareArrayByInvite', 'namespace', namespace);
            // verify required parameter 'invitation' is not null or undefined
            common_1.assertParamExists('cancelShareArrayByInvite', 'invitation', invitation);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('cancelShareArrayByInvite', 'array', array);
            const localVarPath = `/invitations/{invitation}/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or ID of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations: (organization, array, start, end, page, perPage, type, status, orderby, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (organization !== undefined) {
                localVarQueryParameter['organization'] = organization;
            }
            if (array !== undefined) {
                localVarQueryParameter['array'] = array;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or UUID of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization: (organization, emailInvite, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('joinOrganization', 'organization', organization);
            // verify required parameter 'emailInvite' is not null or undefined
            common_1.assertParamExists('joinOrganization', 'emailInvite', emailInvite);
            const localVarPath = `/invitations/{organization}/join`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(emailInvite, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite: (namespace, array, emailInvite, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('shareArrayByInvite', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('shareArrayByInvite', 'array', array);
            // verify required parameter 'emailInvite' is not null or undefined
            common_1.assertParamExists('shareArrayByInvite', 'emailInvite', emailInvite);
            const localVarPath = `/invitations/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(emailInvite, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InvitationApiAxiosParamCreator = InvitationApiAxiosParamCreator;
/**
 * InvitationApi - functional programming interface
 * @export
 */
const InvitationApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.InvitationApiAxiosParamCreator(configuration);
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the ID of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(invitation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.acceptInvitation(invitation, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Cancels join organization invitation
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} organization name or UUID of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization(invitation, organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelJoinOrganization(invitation, organization, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite(namespace, invitation, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelShareArrayByInvite(namespace, invitation, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or ID of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or UUID of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization(organization, emailInvite, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.joinOrganization(organization, emailInvite, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite(namespace, array, emailInvite, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareArrayByInvite(namespace, array, emailInvite, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.InvitationApiFp = InvitationApiFp;
/**
 * InvitationApi - factory interface
 * @export
 */
const InvitationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.InvitationApiFp(configuration);
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the ID of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(invitation, options) {
            return localVarFp.acceptInvitation(invitation, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels join organization invitation
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} organization name or UUID of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization(invitation, organization, options) {
            return localVarFp.cancelJoinOrganization(invitation, organization, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite(namespace, invitation, array, options) {
            return localVarFp.cancelShareArrayByInvite(namespace, invitation, array, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or ID of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {
            return localVarFp.fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or UUID of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization(organization, emailInvite, options) {
            return localVarFp.joinOrganization(organization, emailInvite, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite(namespace, array, emailInvite, options) {
            return localVarFp.shareArrayByInvite(namespace, array, emailInvite, options).then((request) => request(axios, basePath));
        },
    };
};
exports.InvitationApiFactory = InvitationApiFactory;
/**
 * InvitationApi - object-oriented interface
 * @export
 * @class InvitationApi
 * @extends {BaseAPI}
 */
class InvitationApi extends base_1.BaseAPI {
    /**
     * Accepts invitation
     * @param {string} invitation the ID of invitation about to be accepted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    acceptInvitation(invitation, options) {
        return exports.InvitationApiFp(this.configuration).acceptInvitation(invitation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cancels join organization invitation
     * @param {string} invitation the ID of invitation about to be cancelled
     * @param {string} organization name or UUID of organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    cancelJoinOrganization(invitation, organization, options) {
        return exports.InvitationApiFp(this.configuration).cancelJoinOrganization(invitation, organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cancels array sharing invitation
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} invitation the ID of invitation about to be cancelled
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    cancelShareArrayByInvite(namespace, invitation, array, options) {
        return exports.InvitationApiFp(this.configuration).cancelShareArrayByInvite(namespace, invitation, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of invitations
     * @param {string} [organization] name or ID of organization to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
     * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
     * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {
        return exports.InvitationApiFp(this.configuration).fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends email to multiple recipients with joining information regarding an organization
     * @param {string} organization name or UUID of organization
     * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    joinOrganization(organization, emailInvite, options) {
        return exports.InvitationApiFp(this.configuration).joinOrganization(organization, emailInvite, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends email to multiple recipients with sharing information regarding an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {InvitationArrayShareEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    shareArrayByInvite(namespace, array, emailInvite, options) {
        return exports.InvitationApiFp(this.configuration).shareArrayByInvite(namespace, array, emailInvite, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InvitationApi = InvitationApi;
/**
 * NotebookApi - axios parameter creator
 * @export
 */
const NotebookApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getNotebookServerStatus', 'namespace', namespace);
            const localVarPath = `/notebooks/server/{namespace}/status`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Copy a tiledb notebook at the specified location
         * @param {string} namespace The namespace of the notebook
         * @param {string} array The name of the notebook
         * @param {NotebookCopy} notebookCopy Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, copy will use open_at functionality to copy notebook created at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCopyNotebook: (namespace, array, notebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('handleCopyNotebook', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('handleCopyNotebook', 'array', array);
            // verify required parameter 'notebookCopy' is not null or undefined
            common_1.assertParamExists('handleCopyNotebook', 'notebookCopy', notebookCopy);
            const localVarPath = `/notebooks/{namespace}/{array}/copy`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(notebookCopy, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Upload a notebook at the specified location
         * @param {string} namespace The namespace of the notebook
         * @param {any} inputFile the notebook to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [outputUri] output location of the TileDB File
         * @param {string} [name] name to set for registered file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadNotebook: (namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('handleUploadNotebook', 'namespace', namespace);
            // verify required parameter 'inputFile' is not null or undefined
            common_1.assertParamExists('handleUploadNotebook', 'inputFile', inputFile);
            const localVarPath = `/notebooks/{namespace}/upload`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            if (inputFile !== undefined) {
                localVarFormParams.append('input_file', inputFile);
            }
            if (outputUri !== undefined) {
                localVarFormParams.append('output_uri', outputUri);
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('shutdownNotebookServer', 'namespace', namespace);
            const localVarPath = `/notebooks/server/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update name on a notebok, moving related S3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotebookName: (namespace, array, notebookMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateNotebookName', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('updateNotebookName', 'array', array);
            // verify required parameter 'notebookMetadata' is not null or undefined
            common_1.assertParamExists('updateNotebookName', 'notebookMetadata', notebookMetadata);
            const localVarPath = `/notebooks/{namespace}/{array}/rename`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(notebookMetadata, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.NotebookApiAxiosParamCreator = NotebookApiAxiosParamCreator;
/**
 * NotebookApi - functional programming interface
 * @export
 */
const NotebookApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.NotebookApiAxiosParamCreator(configuration);
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getNotebookServerStatus(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Copy a tiledb notebook at the specified location
         * @param {string} namespace The namespace of the notebook
         * @param {string} array The name of the notebook
         * @param {NotebookCopy} notebookCopy Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, copy will use open_at functionality to copy notebook created at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCopyNotebook(namespace, array, notebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.handleCopyNotebook(namespace, array, notebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Upload a notebook at the specified location
         * @param {string} namespace The namespace of the notebook
         * @param {any} inputFile the notebook to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [outputUri] output location of the TileDB File
         * @param {string} [name] name to set for registered file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadNotebook(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.handleUploadNotebook(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shutdownNotebookServer(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update name on a notebok, moving related S3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotebookName(namespace, array, notebookMetadata, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateNotebookName(namespace, array, notebookMetadata, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.NotebookApiFp = NotebookApiFp;
/**
 * NotebookApi - factory interface
 * @export
 */
const NotebookApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.NotebookApiFp(configuration);
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus(namespace, options) {
            return localVarFp.getNotebookServerStatus(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Copy a tiledb notebook at the specified location
         * @param {string} namespace The namespace of the notebook
         * @param {string} array The name of the notebook
         * @param {NotebookCopy} notebookCopy Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, copy will use open_at functionality to copy notebook created at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCopyNotebook(namespace, array, notebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options) {
            return localVarFp.handleCopyNotebook(namespace, array, notebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a notebook at the specified location
         * @param {string} namespace The namespace of the notebook
         * @param {any} inputFile the notebook to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [outputUri] output location of the TileDB File
         * @param {string} [name] name to set for registered file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadNotebook(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options) {
            return localVarFp.handleUploadNotebook(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer(namespace, options) {
            return localVarFp.shutdownNotebookServer(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * update name on a notebok, moving related S3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotebookName(namespace, array, notebookMetadata, options) {
            return localVarFp.updateNotebookName(namespace, array, notebookMetadata, options).then((request) => request(axios, basePath));
        },
    };
};
exports.NotebookApiFactory = NotebookApiFactory;
/**
 * NotebookApi - object-oriented interface
 * @export
 * @class NotebookApi
 * @extends {BaseAPI}
 */
class NotebookApi extends base_1.BaseAPI {
    /**
     * Get status of the notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    getNotebookServerStatus(namespace, options) {
        return exports.NotebookApiFp(this.configuration).getNotebookServerStatus(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Copy a tiledb notebook at the specified location
     * @param {string} namespace The namespace of the notebook
     * @param {string} array The name of the notebook
     * @param {NotebookCopy} notebookCopy Input/Output information to create a new TileDB file
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {number} [endTimestamp] Milliseconds since Unix epoch, copy will use open_at functionality to copy notebook created at the specific timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    handleCopyNotebook(namespace, array, notebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options) {
        return exports.NotebookApiFp(this.configuration).handleCopyNotebook(namespace, array, notebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload a notebook at the specified location
     * @param {string} namespace The namespace of the notebook
     * @param {any} inputFile the notebook to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [outputUri] output location of the TileDB File
     * @param {string} [name] name to set for registered file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    handleUploadNotebook(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options) {
        return exports.NotebookApiFp(this.configuration).handleUploadNotebook(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Shutdown a notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    shutdownNotebookServer(namespace, options) {
        return exports.NotebookApiFp(this.configuration).shutdownNotebookServer(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update name on a notebok, moving related S3 object to new location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of notebook (array) that is url-encoded
     * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    updateNotebookName(namespace, array, notebookMetadata, options) {
        return exports.NotebookApiFp(this.configuration).updateNotebookName(namespace, array, notebookMetadata, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.NotebookApi = NotebookApi;
/**
 * NotebooksApi - axios parameter creator
 * @export
 */
const NotebooksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notebooksNamespaceArrayEndTimestampsGet: (namespace, array, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('notebooksNamespaceArrayEndTimestampsGet', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('notebooksNamespaceArrayEndTimestampsGet', 'array', array);
            const localVarPath = `/notebooks/{namespace}/{array}/end_timestamps`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.NotebooksApiAxiosParamCreator = NotebooksApiAxiosParamCreator;
/**
 * NotebooksApi - functional programming interface
 * @export
 */
const NotebooksApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.NotebooksApiAxiosParamCreator(configuration);
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.NotebooksApiFp = NotebooksApiFp;
/**
 * NotebooksApi - factory interface
 * @export
 */
const NotebooksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.NotebooksApiFp(configuration);
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
            return localVarFp.notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};
exports.NotebooksApiFactory = NotebooksApiFactory;
/**
 * NotebooksApi - object-oriented interface
 * @export
 * @class NotebooksApi
 * @extends {BaseAPI}
 */
class NotebooksApi extends base_1.BaseAPI {
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
        return exports.NotebooksApiFp(this.configuration).notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.NotebooksApi = NotebooksApi;
/**
 * OrganizationApi - axios parameter creator
 * @export
 */
const OrganizationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials: (namespace, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('addAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            common_1.assertParamExists('addAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization: (organization, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('addUserToOrganization', 'organization', organization);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('addUserToOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/user`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentials', 'namespace', namespace);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('createOrganization', 'organization', organization);
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(organization, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteAWSAccessCredentials', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('deleteOrganization', 'organization', organization);
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('deleteUserFromOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('deleteUserFromOrganization', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('getOrganization', 'organization', organization);
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('getOrganizationUser', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('getOrganizationUser', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials: (namespace, name, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'name', name);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a organization
         * @param {string} organization organization name or ID
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: (organization, organizationDetails, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('updateOrganization', 'organization', organization);
            // verify required parameter 'organizationDetails' is not null or undefined
            common_1.assertParamExists('updateOrganization', 'organizationDetails', organizationDetails);
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(organizationDetails, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization: (organization, username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'username', username);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.OrganizationApiAxiosParamCreator = OrganizationApiAxiosParamCreator;
/**
 * OrganizationApi - functional programming interface
 * @export
 */
const OrganizationApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.OrganizationApiAxiosParamCreator(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addAWSAccessCredentials(namespace, awsAccessCredentials, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addUserToOrganization(organization, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentials(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentialsByName(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createOrganization(organization, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAWSAccessCredentials(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteOrganization(organization, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserFromOrganization(organization, username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllOrganizations(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganization(organization, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizationUser(organization, username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update a organization
         * @param {string} organization organization name or ID
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organization, organizationDetails, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateOrganization(organization, organizationDetails, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserInOrganization(organization, username, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.OrganizationApiFp = OrganizationApiFp;
/**
 * OrganizationApi - factory interface
 * @export
 */
const OrganizationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.OrganizationApiFp(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return localVarFp.addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return localVarFp.addUserToOrganization(organization, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return localVarFp.checkAWSAccessCredentials(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return localVarFp.checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organization, options) {
            return localVarFp.createOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return localVarFp.deleteAWSAccessCredentials(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organization, options) {
            return localVarFp.deleteOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return localVarFp.deleteUserFromOrganization(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations(options) {
            return localVarFp.getAllOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * get a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organization, options) {
            return localVarFp.getOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return localVarFp.getOrganizationUser(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return localVarFp.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * update a organization
         * @param {string} organization organization name or ID
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organization, organizationDetails, options) {
            return localVarFp.updateOrganization(organization, organizationDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return localVarFp.updateUserInOrganization(organization, username, user, options).then((request) => request(axios, basePath));
        },
    };
};
exports.OrganizationApiFactory = OrganizationApiFactory;
/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
class OrganizationApi extends base_1.BaseAPI {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
        return exports.OrganizationApiFp(this.configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addUserToOrganization(organization, user, options) {
        return exports.OrganizationApiFp(this.configuration).addUserToOrganization(organization, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    checkAWSAccessCredentials(namespace, options) {
        return exports.OrganizationApiFp(this.configuration).checkAWSAccessCredentials(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    checkAWSAccessCredentialsByName(namespace, name, options) {
        return exports.OrganizationApiFp(this.configuration).checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * create a organization, the user creating will be listed as owner
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    createOrganization(organization, options) {
        return exports.OrganizationApiFp(this.configuration).createOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteAWSAccessCredentials(namespace, name, options) {
        return exports.OrganizationApiFp(this.configuration).deleteAWSAccessCredentials(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a organization
     * @param {string} organization organization name or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteOrganization(organization, options) {
        return exports.OrganizationApiFp(this.configuration).deleteOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteUserFromOrganization(organization, username, options) {
        return exports.OrganizationApiFp(this.configuration).deleteUserFromOrganization(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get all organizations that the user is member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getAllOrganizations(options) {
        return exports.OrganizationApiFp(this.configuration).getAllOrganizations(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a organization
     * @param {string} organization organization name or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getOrganization(organization, options) {
        return exports.OrganizationApiFp(this.configuration).getOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getOrganizationUser(organization, username, options) {
        return exports.OrganizationApiFp(this.configuration).getOrganizationUser(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
        return exports.OrganizationApiFp(this.configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a organization
     * @param {string} organization organization name or ID
     * @param {Organization} organizationDetails organization details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateOrganization(organization, organizationDetails, options) {
        return exports.OrganizationApiFp(this.configuration).updateOrganization(organization, organizationDetails, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateUserInOrganization(organization, username, user, options) {
        return exports.OrganizationApiFp(this.configuration).updateUserInOrganization(organization, username, user, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.OrganizationApi = OrganizationApi;
/**
 * QueryApi - axios parameter creator
 * @export
 */
const QueryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'array', array);
            // verify required parameter 'type' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/finalize`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'array', array);
            // verify required parameter 'type' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/est_result_sizes`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: (namespace, array, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getFile', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getFile', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getFile', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}/query/get_file`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitQuery', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('submitQuery', 'array', array);
            // verify required parameter 'type' is not null or undefined
            common_1.assertParamExists('submitQuery', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('submitQuery', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('submitQuery', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns JSON results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQueryJson: (namespace, array, contentType, queryJson, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitQueryJson', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('submitQueryJson', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('submitQueryJson', 'contentType', contentType);
            // verify required parameter 'queryJson' is not null or undefined
            common_1.assertParamExists('submitQueryJson', 'queryJson', queryJson);
            const localVarPath = `/arrays/{namespace}/{array}/query/submit_query_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(queryJson, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.QueryApiAxiosParamCreator = QueryApiAxiosParamCreator;
/**
 * QueryApi - functional programming interface
 * @export
 */
const QueryApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.QueryApiAxiosParamCreator(configuration);
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(namespace, array, contentType, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFile(namespace, array, contentType, xPayer, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns JSON results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitQueryJson(namespace, array, contentType, queryJson, xPayer, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.QueryApiFp = QueryApiFp;
/**
 * QueryApi - factory interface
 * @export
 */
const QueryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.QueryApiFp(configuration);
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return localVarFp.finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return localVarFp.getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(namespace, array, contentType, xPayer, options) {
            return localVarFp.getFile(namespace, array, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return localVarFp.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns JSON results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {
            return localVarFp.submitQueryJson(namespace, array, contentType, queryJson, xPayer, options).then((request) => request(axios, basePath));
        },
    };
};
exports.QueryApiFactory = QueryApiFactory;
/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
class QueryApi extends base_1.BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
        return exports.QueryApiFp(this.configuration).finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {
        return exports.QueryApiFp(this.configuration).getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns file bytes
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    getFile(namespace, array, contentType, xPayer, options) {
        return exports.QueryApiFp(this.configuration).getFile(namespace, array, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
        return exports.QueryApiFp(this.configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns JSON results
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {QueryJson} queryJson query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {
        return exports.QueryApiFp(this.configuration).submitQueryJson(namespace, array, contentType, queryJson, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.QueryApi = QueryApi;
/**
 * RegisteredTaskGraphsApi - axios parameter creator
 * @export
 */
const RegisteredTaskGraphsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete the given registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegisteredTaskGraph: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteRegisteredTaskGraph', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteRegisteredTaskGraph', 'name', name);
            const localVarPath = `/taskgraphs/{namespace}/registered/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch the contents of this registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisteredTaskGraph: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getRegisteredTaskGraph', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('getRegisteredTaskGraph', 'name', name);
            const localVarPath = `/taskgraphs/{namespace}/registered/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get sharing policies for the task graph.
         * @param {string} namespace The namespace that owns the registered task graph.
         * @param {string} name The name of the task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisteredTaskGraphSharingPolicies: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getRegisteredTaskGraphSharingPolicies', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('getRegisteredTaskGraphSharingPolicies', 'name', name);
            const localVarPath = `/taskgraphs/{namespace}/registered/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Register a task graph in the given namespace, with the given name.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {RegisteredTaskGraph} [graph] Task graph to register.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerRegisteredTaskGraph: (namespace, name, graph, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('registerRegisteredTaskGraph', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('registerRegisteredTaskGraph', 'name', name);
            const localVarPath = `/taskgraphs/{namespace}/registered/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(graph, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Share a task graph.
         * @param {string} namespace The namespace that owns the registered task graph.
         * @param {string} name The name of the task graph.
         * @param {TaskGraphSharing} taskGraphSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareRegisteredTaskGraph: (namespace, name, taskGraphSharing, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('shareRegisteredTaskGraph', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('shareRegisteredTaskGraph', 'name', name);
            // verify required parameter 'taskGraphSharing' is not null or undefined
            common_1.assertParamExists('shareRegisteredTaskGraph', 'taskGraphSharing', taskGraphSharing);
            const localVarPath = `/taskgraphs/{namespace}/registered/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(taskGraphSharing, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update the contents of an existing registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {RegisteredTaskGraph} [graph] The new contents of the task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegisteredTaskGraph: (namespace, name, graph, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateRegisteredTaskGraph', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('updateRegisteredTaskGraph', 'name', name);
            const localVarPath = `/taskgraphs/{namespace}/registered/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(graph, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.RegisteredTaskGraphsApiAxiosParamCreator = RegisteredTaskGraphsApiAxiosParamCreator;
/**
 * RegisteredTaskGraphsApi - functional programming interface
 * @export
 */
const RegisteredTaskGraphsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.RegisteredTaskGraphsApiAxiosParamCreator(configuration);
    return {
        /**
         * Delete the given registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegisteredTaskGraph(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteRegisteredTaskGraph(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch the contents of this registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisteredTaskGraph(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRegisteredTaskGraph(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get sharing policies for the task graph.
         * @param {string} namespace The namespace that owns the registered task graph.
         * @param {string} name The name of the task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisteredTaskGraphSharingPolicies(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRegisteredTaskGraphSharingPolicies(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Register a task graph in the given namespace, with the given name.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {RegisteredTaskGraph} [graph] Task graph to register.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerRegisteredTaskGraph(namespace, name, graph, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerRegisteredTaskGraph(namespace, name, graph, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Share a task graph.
         * @param {string} namespace The namespace that owns the registered task graph.
         * @param {string} name The name of the task graph.
         * @param {TaskGraphSharing} taskGraphSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareRegisteredTaskGraph(namespace, name, taskGraphSharing, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareRegisteredTaskGraph(namespace, name, taskGraphSharing, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update the contents of an existing registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {RegisteredTaskGraph} [graph] The new contents of the task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegisteredTaskGraph(namespace, name, graph, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateRegisteredTaskGraph(namespace, name, graph, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.RegisteredTaskGraphsApiFp = RegisteredTaskGraphsApiFp;
/**
 * RegisteredTaskGraphsApi - factory interface
 * @export
 */
const RegisteredTaskGraphsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.RegisteredTaskGraphsApiFp(configuration);
    return {
        /**
         * Delete the given registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegisteredTaskGraph(namespace, name, options) {
            return localVarFp.deleteRegisteredTaskGraph(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the contents of this registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisteredTaskGraph(namespace, name, options) {
            return localVarFp.getRegisteredTaskGraph(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sharing policies for the task graph.
         * @param {string} namespace The namespace that owns the registered task graph.
         * @param {string} name The name of the task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisteredTaskGraphSharingPolicies(namespace, name, options) {
            return localVarFp.getRegisteredTaskGraphSharingPolicies(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a task graph in the given namespace, with the given name.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {RegisteredTaskGraph} [graph] Task graph to register.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerRegisteredTaskGraph(namespace, name, graph, options) {
            return localVarFp.registerRegisteredTaskGraph(namespace, name, graph, options).then((request) => request(axios, basePath));
        },
        /**
         * Share a task graph.
         * @param {string} namespace The namespace that owns the registered task graph.
         * @param {string} name The name of the task graph.
         * @param {TaskGraphSharing} taskGraphSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareRegisteredTaskGraph(namespace, name, taskGraphSharing, options) {
            return localVarFp.shareRegisteredTaskGraph(namespace, name, taskGraphSharing, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the contents of an existing registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {RegisteredTaskGraph} [graph] The new contents of the task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegisteredTaskGraph(namespace, name, graph, options) {
            return localVarFp.updateRegisteredTaskGraph(namespace, name, graph, options).then((request) => request(axios, basePath));
        },
    };
};
exports.RegisteredTaskGraphsApiFactory = RegisteredTaskGraphsApiFactory;
/**
 * RegisteredTaskGraphsApi - object-oriented interface
 * @export
 * @class RegisteredTaskGraphsApi
 * @extends {BaseAPI}
 */
class RegisteredTaskGraphsApi extends base_1.BaseAPI {
    /**
     * Delete the given registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    deleteRegisteredTaskGraph(namespace, name, options) {
        return exports.RegisteredTaskGraphsApiFp(this.configuration).deleteRegisteredTaskGraph(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the contents of this registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    getRegisteredTaskGraph(namespace, name, options) {
        return exports.RegisteredTaskGraphsApiFp(this.configuration).getRegisteredTaskGraph(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get sharing policies for the task graph.
     * @param {string} namespace The namespace that owns the registered task graph.
     * @param {string} name The name of the task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    getRegisteredTaskGraphSharingPolicies(namespace, name, options) {
        return exports.RegisteredTaskGraphsApiFp(this.configuration).getRegisteredTaskGraphSharingPolicies(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Register a task graph in the given namespace, with the given name.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {RegisteredTaskGraph} [graph] Task graph to register.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    registerRegisteredTaskGraph(namespace, name, graph, options) {
        return exports.RegisteredTaskGraphsApiFp(this.configuration).registerRegisteredTaskGraph(namespace, name, graph, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Share a task graph.
     * @param {string} namespace The namespace that owns the registered task graph.
     * @param {string} name The name of the task graph.
     * @param {TaskGraphSharing} taskGraphSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    shareRegisteredTaskGraph(namespace, name, taskGraphSharing, options) {
        return exports.RegisteredTaskGraphsApiFp(this.configuration).shareRegisteredTaskGraph(namespace, name, taskGraphSharing, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the contents of an existing registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {RegisteredTaskGraph} [graph] The new contents of the task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    updateRegisteredTaskGraph(namespace, name, graph, options) {
        return exports.RegisteredTaskGraphsApiFp(this.configuration).updateRegisteredTaskGraph(namespace, name, graph, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RegisteredTaskGraphsApi = RegisteredTaskGraphsApi;
/**
 * SqlApi - axios parameter creator
 * @export
 */
const SqlApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL: (namespace, sql, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('runSQL', 'namespace', namespace);
            // verify required parameter 'sql' is not null or undefined
            common_1.assertParamExists('runSQL', 'sql', sql);
            const localVarPath = `/sql/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(sql, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SqlApiAxiosParamCreator = SqlApiAxiosParamCreator;
/**
 * SqlApi - functional programming interface
 * @export
 */
const SqlApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.SqlApiAxiosParamCreator(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.runSQL(namespace, sql, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.SqlApiFp = SqlApiFp;
/**
 * SqlApi - factory interface
 * @export
 */
const SqlApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.SqlApiFp(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return localVarFp.runSQL(namespace, sql, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SqlApiFactory = SqlApiFactory;
/**
 * SqlApi - object-oriented interface
 * @export
 * @class SqlApi
 * @extends {BaseAPI}
 */
class SqlApi extends base_1.BaseAPI {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SqlApi
     */
    runSQL(namespace, sql, acceptEncoding, options) {
        return exports.SqlApiFp(this.configuration).runSQL(namespace, sql, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SqlApi = SqlApi;
/**
 * StatsApi - axios parameter creator
 * @export
 */
const StatsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/.stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.StatsApiAxiosParamCreator = StatsApiAxiosParamCreator;
/**
 * StatsApi - functional programming interface
 * @export
 */
const StatsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.StatsApiAxiosParamCreator(configuration);
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTiledbStats(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.StatsApiFp = StatsApiFp;
/**
 * StatsApi - factory interface
 * @export
 */
const StatsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.StatsApiFp(configuration);
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats(options) {
            return localVarFp.getTiledbStats(options).then((request) => request(axios, basePath));
        },
    };
};
exports.StatsApiFactory = StatsApiFactory;
/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
class StatsApi extends base_1.BaseAPI {
    /**
     * Fetch libtiledb stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    getTiledbStats(options) {
        return exports.StatsApiFp(this.configuration).getTiledbStats(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.StatsApi = StatsApi;
/**
 * TaskGraphLogsApi - axios parameter creator
 * @export
 */
const TaskGraphLogsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a task graph log.
         * @param {string} namespace The namespace that will own this task graph log.
         * @param {TaskGraphLog} log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskGraphLog: (namespace, log, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('createTaskGraphLog', 'namespace', namespace);
            // verify required parameter 'log' is not null or undefined
            common_1.assertParamExists('createTaskGraphLog', 'log', log);
            const localVarPath = `/taskgraphs/{namespace}/log`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(log, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch information about a single task graph execution.
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskGraphLog: (namespace, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getTaskGraphLog', 'namespace', namespace);
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getTaskGraphLog', 'id', id);
            const localVarPath = `/taskgraphs/{namespace}/logs/{id}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata.
         * @param {string} [namespace] Include logs for this namespace.
         * @param {string} [createdBy] Include logs from only this user.
         * @param {string} [search] search string that will look at name.
         * @param {string} [startTime] Include logs created after this time.
         * @param {string} [endTime] Include logs created before this time.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaskGraphLogs: (namespace, createdBy, search, startTime, endTime, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/taskgraphs/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime instanceof Date) ?
                    startTime.toISOString() :
                    startTime;
            }
            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime instanceof Date) ?
                    endTime.toISOString() :
                    endTime;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphClientNodeStatus} report The node status to report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportClientNode: (namespace, id, report, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('reportClientNode', 'namespace', namespace);
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('reportClientNode', 'id', id);
            // verify required parameter 'report' is not null or undefined
            common_1.assertParamExists('reportClientNode', 'report', report);
            const localVarPath = `/taskgraphs/{namespace}/logs/{id}/report_client_node`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(report, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update information about a single task graph execution.
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskGraphLog: (namespace, id, log, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateTaskGraphLog', 'namespace', namespace);
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('updateTaskGraphLog', 'id', id);
            // verify required parameter 'log' is not null or undefined
            common_1.assertParamExists('updateTaskGraphLog', 'log', log);
            const localVarPath = `/taskgraphs/{namespace}/logs/{id}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(log, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TaskGraphLogsApiAxiosParamCreator = TaskGraphLogsApiAxiosParamCreator;
/**
 * TaskGraphLogsApi - functional programming interface
 * @export
 */
const TaskGraphLogsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.TaskGraphLogsApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a task graph log.
         * @param {string} namespace The namespace that will own this task graph log.
         * @param {TaskGraphLog} log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskGraphLog(namespace, log, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTaskGraphLog(namespace, log, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch information about a single task graph execution.
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskGraphLog(namespace, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTaskGraphLog(namespace, id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata.
         * @param {string} [namespace] Include logs for this namespace.
         * @param {string} [createdBy] Include logs from only this user.
         * @param {string} [search] search string that will look at name.
         * @param {string} [startTime] Include logs created after this time.
         * @param {string} [endTime] Include logs created before this time.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphClientNodeStatus} report The node status to report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportClientNode(namespace, id, report, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.reportClientNode(namespace, id, report, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update information about a single task graph execution.
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskGraphLog(namespace, id, log, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateTaskGraphLog(namespace, id, log, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TaskGraphLogsApiFp = TaskGraphLogsApiFp;
/**
 * TaskGraphLogsApi - factory interface
 * @export
 */
const TaskGraphLogsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.TaskGraphLogsApiFp(configuration);
    return {
        /**
         * Create a task graph log.
         * @param {string} namespace The namespace that will own this task graph log.
         * @param {TaskGraphLog} log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskGraphLog(namespace, log, options) {
            return localVarFp.createTaskGraphLog(namespace, log, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch information about a single task graph execution.
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskGraphLog(namespace, id, options) {
            return localVarFp.getTaskGraphLog(namespace, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata.
         * @param {string} [namespace] Include logs for this namespace.
         * @param {string} [createdBy] Include logs from only this user.
         * @param {string} [search] search string that will look at name.
         * @param {string} [startTime] Include logs created after this time.
         * @param {string} [endTime] Include logs created before this time.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options) {
            return localVarFp.listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphClientNodeStatus} report The node status to report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportClientNode(namespace, id, report, options) {
            return localVarFp.reportClientNode(namespace, id, report, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information about a single task graph execution.
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskGraphLog(namespace, id, log, options) {
            return localVarFp.updateTaskGraphLog(namespace, id, log, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TaskGraphLogsApiFactory = TaskGraphLogsApiFactory;
/**
 * TaskGraphLogsApi - object-oriented interface
 * @export
 * @class TaskGraphLogsApi
 * @extends {BaseAPI}
 */
class TaskGraphLogsApi extends base_1.BaseAPI {
    /**
     * Create a task graph log.
     * @param {string} namespace The namespace that will own this task graph log.
     * @param {TaskGraphLog} log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    createTaskGraphLog(namespace, log, options) {
        return exports.TaskGraphLogsApiFp(this.configuration).createTaskGraphLog(namespace, log, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch information about a single task graph execution.
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    getTaskGraphLog(namespace, id, options) {
        return exports.TaskGraphLogsApiFp(this.configuration).getTaskGraphLog(namespace, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata.
     * @param {string} [namespace] Include logs for this namespace.
     * @param {string} [createdBy] Include logs from only this user.
     * @param {string} [search] search string that will look at name.
     * @param {string} [startTime] Include logs created after this time.
     * @param {string} [endTime] Include logs created before this time.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options) {
        return exports.TaskGraphLogsApiFp(this.configuration).listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {TaskGraphClientNodeStatus} report The node status to report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    reportClientNode(namespace, id, report, options) {
        return exports.TaskGraphLogsApiFp(this.configuration).reportClientNode(namespace, id, report, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update information about a single task graph execution.
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    updateTaskGraphLog(namespace, id, log, options) {
        return exports.TaskGraphLogsApiFp(this.configuration).updateTaskGraphLog(namespace, id, log, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TaskGraphLogsApi = TaskGraphLogsApi;
/**
 * TasksApi - axios parameter creator
 * @export
 */
const TasksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL: (namespace, sql, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('runSQL', 'namespace', namespace);
            // verify required parameter 'sql' is not null or undefined
            common_1.assertParamExists('runSQL', 'sql', sql);
            const localVarPath = `/sql/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(sql, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch an array task
         * @param {string} id task ID to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('taskIdGet', 'id', id);
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve results of an array task
         * @param {string} id task ID to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdResultGet: (id, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('taskIdResultGet', 'id', id);
            const localVarPath = `/task/{id}/result`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet: (namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }
            if (array !== undefined) {
                localVarQueryParameter['array'] = array;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (excludeType) {
                localVarQueryParameter['exclude_type'] = excludeType.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TasksApiAxiosParamCreator = TasksApiAxiosParamCreator;
/**
 * TasksApi - functional programming interface
 * @export
 */
const TasksApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.TasksApiAxiosParamCreator(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.runSQL(namespace, sql, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch an array task
         * @param {string} id task ID to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.taskIdGet(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve results of an array task
         * @param {string} id task ID to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdResultGet(id, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.taskIdResultGet(id, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TasksApiFp = TasksApiFp;
/**
 * TasksApi - factory interface
 * @export
 */
const TasksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.TasksApiFp(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return localVarFp.runSQL(namespace, sql, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch an array task
         * @param {string} id task ID to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet(id, options) {
            return localVarFp.taskIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve results of an array task
         * @param {string} id task ID to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdResultGet(id, acceptEncoding, options) {
            return localVarFp.taskIdResultGet(id, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {
            return localVarFp.tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TasksApiFactory = TasksApiFactory;
/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
class TasksApi extends base_1.BaseAPI {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    runSQL(namespace, sql, acceptEncoding, options) {
        return exports.TasksApiFp(this.configuration).runSQL(namespace, sql, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch an array task
     * @param {string} id task ID to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    taskIdGet(id, options) {
        return exports.TasksApiFp(this.configuration).taskIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve results of an array task
     * @param {string} id task ID to retrieve stored results
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    taskIdResultGet(id, acceptEncoding, options) {
        return exports.TasksApiFp(this.configuration).taskIdResultGet(id, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all array tasks a user has access to
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
     * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
     * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
     * @param {string} [status] Filter to only return these statuses
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include start_time, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {
        return exports.TasksApiFp(this.configuration).tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TasksApi = TasksApi;
/**
 * UdfApi - axios parameter creator
 * @export
 */
const UdfApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * delete a registered UDF -- this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFInfo: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteUDFInfo', 'name', name);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('getUDFInfo', 'name', name);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all sharing details of the UDF
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getUDFInfoSharingPolicies', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('getUDFInfoSharingPolicies', 'name', name);
            const localVarPath = `/udf/{namespace}/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Copy a tiledb udf at the specified location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFCopy} uDFCopy Input/Output information to copy a UDF
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCopyUDF: (namespace, name, uDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('handleCopyUDF', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('handleCopyUDF', 'name', name);
            // verify required parameter 'uDFCopy' is not null or undefined
            common_1.assertParamExists('handleCopyUDF', 'uDFCopy', uDFCopy);
            const localVarPath = `/udf/{namespace}/{name}/copy`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(uDFCopy, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo: (namespace, name, udf, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('registerUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('registerUDFInfo', 'name', name);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('registerUDFInfo', 'udf', udf);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo: (namespace, name, udfSharing, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('shareUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('shareUDFInfo', 'name', name);
            // verify required parameter 'udfSharing' is not null or undefined
            common_1.assertParamExists('shareUDFInfo', 'udfSharing', udfSharing);
            const localVarPath = `/udf/{namespace}/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udfSharing, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF: (namespace, udf, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitGenericUDF', 'namespace', namespace);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('submitGenericUDF', 'udf', udf);
            const localVarPath = `/udfs/generic/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiArrayUDF: (namespace, udf, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitMultiArrayUDF', 'namespace', namespace);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('submitMultiArrayUDF', 'udf', udf);
            const localVarPath = `/udfs/arrays/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF: (namespace, array, udf, xPayer, acceptEncoding, v2, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitUDF', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('submitUDF', 'array', array);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('submitUDF', 'udf', udf);
            const localVarPath = `/arrays/{namespace}/{array}/udf/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (v2 !== undefined) {
                localVarQueryParameter['v2'] = v2;
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        udfNamespaceArrayEndTimestampsGet: (namespace, array, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('udfNamespaceArrayEndTimestampsGet', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('udfNamespaceArrayEndTimestampsGet', 'array', array);
            const localVarPath = `/udf/{namespace}/{array}/end_timestamps`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update an existing registered UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo: (namespace, name, udf, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('updateUDFInfo', 'name', name);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('updateUDFInfo', 'udf', udf);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UdfApiAxiosParamCreator = UdfApiAxiosParamCreator;
/**
 * UdfApi - functional programming interface
 * @export
 */
const UdfApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.UdfApiAxiosParamCreator(configuration);
    return {
        /**
         * delete a registered UDF -- this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFInfo(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUDFInfo(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUDFInfo(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get all sharing details of the UDF
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUDFInfoSharingPolicies(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Copy a tiledb udf at the specified location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFCopy} uDFCopy Input/Output information to copy a UDF
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCopyUDF(namespace, name, uDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.handleCopyUDF(namespace, name, uDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo(namespace, name, udf, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerUDFInfo(namespace, name, udf, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo(namespace, name, udfSharing, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareUDFInfo(namespace, name, udfSharing, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF(namespace, udf, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitGenericUDF(namespace, udf, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitMultiArrayUDF(namespace, udf, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update an existing registered UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo(namespace, name, udf, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUDFInfo(namespace, name, udf, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.UdfApiFp = UdfApiFp;
/**
 * UdfApi - factory interface
 * @export
 */
const UdfApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.UdfApiFp(configuration);
    return {
        /**
         * delete a registered UDF -- this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFInfo(namespace, name, options) {
            return localVarFp.deleteUDFInfo(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo(namespace, name, options) {
            return localVarFp.getUDFInfo(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sharing details of the UDF
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies(namespace, name, options) {
            return localVarFp.getUDFInfoSharingPolicies(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Copy a tiledb udf at the specified location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFCopy} uDFCopy Input/Output information to copy a UDF
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCopyUDF(namespace, name, uDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options) {
            return localVarFp.handleCopyUDF(namespace, name, uDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo(namespace, name, udf, options) {
            return localVarFp.registerUDFInfo(namespace, name, udf, options).then((request) => request(axios, basePath));
        },
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo(namespace, name, udfSharing, options) {
            return localVarFp.shareUDFInfo(namespace, name, udfSharing, options).then((request) => request(axios, basePath));
        },
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF(namespace, udf, acceptEncoding, options) {
            return localVarFp.submitGenericUDF(namespace, udf, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {
            return localVarFp.submitMultiArrayUDF(namespace, udf, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {
            return localVarFp.submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options).then((request) => request(axios, basePath));
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
            return localVarFp.udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * update an existing registered UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo(namespace, name, udf, options) {
            return localVarFp.updateUDFInfo(namespace, name, udf, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UdfApiFactory = UdfApiFactory;
/**
 * UdfApi - object-oriented interface
 * @export
 * @class UdfApi
 * @extends {BaseAPI}
 */
class UdfApi extends base_1.BaseAPI {
    /**
     * delete a registered UDF -- this will remove all sharing and can not be undone
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    deleteUDFInfo(namespace, name, options) {
        return exports.UdfApiFp(this.configuration).deleteUDFInfo(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a specific UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    getUDFInfo(namespace, name, options) {
        return exports.UdfApiFp(this.configuration).getUDFInfo(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all sharing details of the UDF
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    getUDFInfoSharingPolicies(namespace, name, options) {
        return exports.UdfApiFp(this.configuration).getUDFInfoSharingPolicies(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Copy a tiledb udf at the specified location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFCopy} uDFCopy Input/Output information to copy a UDF
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {number} [endTimestamp] Milliseconds since Unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    handleCopyUDF(namespace, name, uDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options) {
        return exports.UdfApiFp(this.configuration).handleCopyUDF(namespace, name, uDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * register a UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {UDFInfoUpdate} udf UDF to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    registerUDFInfo(namespace, name, udf, options) {
        return exports.UdfApiFp(this.configuration).registerUDFInfo(namespace, name, udf, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Share a UDF with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    shareUDFInfo(namespace, name, udfSharing, options) {
        return exports.UdfApiFp(this.configuration).shareUDFInfo(namespace, name, udfSharing, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * submit a generic UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {GenericUDF} udf UDF to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitGenericUDF(namespace, udf, acceptEncoding, options) {
        return exports.UdfApiFp(this.configuration).submitGenericUDF(namespace, udf, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * submit a multi-array UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {MultiArrayUDF} udf UDF to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {
        return exports.UdfApiFp(this.configuration).submitMultiArrayUDF(namespace, udf, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a UDF to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {MultiArrayUDF} udf UDF to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {string} [acceptEncoding] Encoding to use
     * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {
        return exports.UdfApiFp(this.configuration).submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
        return exports.UdfApiFp(this.configuration).udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update an existing registered UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {UDFInfoUpdate} udf UDF to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    updateUDFInfo(namespace, name, udf, options) {
        return exports.UdfApiFp(this.configuration).updateUDFInfo(namespace, name, udf, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UdfApi = UdfApi;
/**
 * UserApi - axios parameter creator
 * @export
 */
const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials: (namespace, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('addAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            common_1.assertParamExists('addAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization: (organization, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('addUserToOrganization', 'organization', organization);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('addUserToOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/user`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentials', 'namespace', namespace);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/user/confirm_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: (user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('createUser', 'user', user);
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteAWSAccessCredentials', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: (username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('deleteUser', 'username', username);
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('deleteUserFromOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('deleteUserFromOrganization', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('getOrganizationUser', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('getOrganizationUser', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: (rememberMe, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (rememberMe !== undefined) {
                localVarQueryParameter['remember_me'] = rememberMe;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * retrieves available token scopes for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenScopes: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tokens/scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername: (username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('getUserWithUsername', 'username', username);
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken: (tokenRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * reset user password
         * @param {InlineObject} user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword: (user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('resetUserPassword', 'user', user);
            const localVarPath = `/user/password_reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken: (token, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'token' is not null or undefined
            common_1.assertParamExists('revokeToken', 'token', token);
            const localVarPath = `/tokens/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensSessionGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tokens/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials: (namespace, name, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'name', name);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a user
         * @param {string} username username or ID
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: (username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('updateUser', 'username', username);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('updateUser', 'user', user);
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization: (organization, username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'username', username);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UserApiAxiosParamCreator = UserApiAxiosParamCreator;
/**
 * UserApi - functional programming interface
 * @export
 */
const UserApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.UserApiAxiosParamCreator(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addAWSAccessCredentials(namespace, awsAccessCredentials, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addUserToOrganization(organization, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentials(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentialsByName(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.confirmEmail(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createUser(user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAWSAccessCredentials(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUser(username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserFromOrganization(organization, username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizationUser(organization, username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(rememberMe, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSession(rememberMe, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * retrieves available token scopes for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenScopes(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTokenScopes(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUser(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername(username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserWithUsername(username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken(tokenRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.requestToken(tokenRequest, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * reset user password
         * @param {InlineObject} user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resetUserPassword(user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(token, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.revokeToken(token, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokensGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensSessionGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokensSessionGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update a user
         * @param {string} username username or ID
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUser(username, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserInOrganization(organization, username, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.UserApiFp = UserApiFp;
/**
 * UserApi - factory interface
 * @export
 */
const UserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.UserApiFp(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return localVarFp.addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return localVarFp.addUserToOrganization(organization, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return localVarFp.checkAWSAccessCredentials(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return localVarFp.checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail(options) {
            return localVarFp.confirmEmail(options).then((request) => request(axios, basePath));
        },
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user, options) {
            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return localVarFp.deleteAWSAccessCredentials(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username, options) {
            return localVarFp.deleteUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return localVarFp.deleteUserFromOrganization(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return localVarFp.getOrganizationUser(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(rememberMe, options) {
            return localVarFp.getSession(rememberMe, options).then((request) => request(axios, basePath));
        },
        /**
         * retrieves available token scopes for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenScopes(options) {
            return localVarFp.getTokenScopes(options).then((request) => request(axios, basePath));
        },
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options) {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * get a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername(username, options) {
            return localVarFp.getUserWithUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken(tokenRequest, options) {
            return localVarFp.requestToken(tokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * reset user password
         * @param {InlineObject} user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(user, options) {
            return localVarFp.resetUserPassword(user, options).then((request) => request(axios, basePath));
        },
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(token, options) {
            return localVarFp.revokeToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options) {
            return localVarFp.tokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensSessionGet(options) {
            return localVarFp.tokensSessionGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return localVarFp.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user
         * @param {string} username username or ID
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username, user, options) {
            return localVarFp.updateUser(username, user, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return localVarFp.updateUserInOrganization(organization, username, user, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserApiFactory = UserApiFactory;
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends base_1.BaseAPI {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
        return exports.UserApiFp(this.configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addUserToOrganization(organization, user, options) {
        return exports.UserApiFp(this.configuration).addUserToOrganization(organization, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    checkAWSAccessCredentials(namespace, options) {
        return exports.UserApiFp(this.configuration).checkAWSAccessCredentials(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    checkAWSAccessCredentialsByName(namespace, name, options) {
        return exports.UserApiFp(this.configuration).checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * confirm user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    confirmEmail(options) {
        return exports.UserApiFp(this.configuration).confirmEmail(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createUser(user, options) {
        return exports.UserApiFp(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteAWSAccessCredentials(namespace, name, options) {
        return exports.UserApiFp(this.configuration).deleteAWSAccessCredentials(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a user
     * @param {string} username username or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUser(username, options) {
        return exports.UserApiFp(this.configuration).deleteUser(username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUserFromOrganization(organization, username, options) {
        return exports.UserApiFp(this.configuration).deleteUserFromOrganization(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getOrganizationUser(organization, username, options) {
        return exports.UserApiFp(this.configuration).getOrganizationUser(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get session token for user
     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getSession(rememberMe, options) {
        return exports.UserApiFp(this.configuration).getSession(rememberMe, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * retrieves available token scopes for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getTokenScopes(options) {
        return exports.UserApiFp(this.configuration).getTokenScopes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(options) {
        return exports.UserApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user
     * @param {string} username username or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserWithUsername(username, options) {
        return exports.UserApiFp(this.configuration).getUserWithUsername(username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
     * @param {TokenRequest} [tokenRequest] token request object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    requestToken(tokenRequest, options) {
        return exports.UserApiFp(this.configuration).requestToken(tokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * reset user password
     * @param {InlineObject} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    resetUserPassword(user, options) {
        return exports.UserApiFp(this.configuration).resetUserPassword(user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * revoke an authorization token
     * @param {string} token token name or token itself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    revokeToken(token, options) {
        return exports.UserApiFp(this.configuration).revokeToken(token, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of user tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokensGet(options) {
        return exports.UserApiFp(this.configuration).tokensGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of user session tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokensSessionGet(options) {
        return exports.UserApiFp(this.configuration).tokensSessionGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
        return exports.UserApiFp(this.configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a user
     * @param {string} username username or ID
     * @param {User} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUser(username, user, options) {
        return exports.UserApiFp(this.configuration).updateUser(username, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUserInOrganization(organization, username, user, options) {
        return exports.UserApiFp(this.configuration).updateUserInOrganization(organization, username, user, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserApi = UserApi;
//# sourceMappingURL=api.js.map