import globalAxios from 'axios';
import * as capnp from 'capnp-ts';
import { ObjectSize, Struct } from 'capnp-ts';
import Parallel from 'paralleljs';
import save from 'save-file';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

const updateBasePathAfterRedirect = (axios, BASE_PATH, baseAPI) => {
    axios.interceptors.response.use((response) => {
        var _a;
        /**
         * Get responseURL from the response object
         * For browsers it's located in response.request.responseURL
         * For NodeJS it's located in response.request.res.responseUrl
         */
        const responseURL = (response === null || response === void 0 ? void 0 : response.request.responseURL) ||
            ((_a = response === null || response === void 0 ? void 0 : response.request.res) === null || _a === void 0 ? void 0 : _a.responseUrl);
        if (responseURL) {
            const url = new URL(responseURL);
            const version = new URL(BASE_PATH).pathname;
            const REDIRECTED_BASE_PATH = url.origin + version;
            baseAPI.basePath = REDIRECTED_BASE_PATH;
            if (baseAPI.configuration) {
                baseAPI.configuration.basePath = REDIRECTED_BASE_PATH;
            }
            else {
                baseAPI.configuration = { basePath: REDIRECTED_BASE_PATH };
            }
        }
        return response;
    }, function (error) {
        // Any status codes that falls outside the range of 2xx cause this function to trigger
        // Do something with response error
        return Promise.reject(error);
    });
};

/* tslint:disable */
const BASE_PATH$1 = "https://api.tiledb.com/v1".replace(/\/+$/, "");
/**
 *
 * @export
 */
const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
let BaseAPI$1 = class BaseAPI {
    constructor(configuration, basePath = BASE_PATH$1, axios = globalAxios) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
        updateBasePathAfterRedirect(axios, BASE_PATH$1, this);
    }
};
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
let RequiredError$1 = class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
};

/* tslint:disable */
class ArrayMetadata_MetadataEntry extends Struct {
    getKey() { return Struct.getText(0, this); }
    setKey(value) { Struct.setText(0, value, this); }
    getType() { return Struct.getText(1, this); }
    setType(value) { Struct.setText(1, value, this); }
    getValueNum() { return Struct.getUint32(0, this); }
    setValueNum(value) { Struct.setUint32(0, value, this); }
    adoptValue(value) { Struct.adopt(value, Struct.getPointer(2, this)); }
    disownValue() { return Struct.disown(this.getValue()); }
    getValue() { return Struct.getData(2, this); }
    hasValue() { return !Struct.isNull(Struct.getPointer(2, this)); }
    initValue(length) { return Struct.initData(2, length, this); }
    setValue(value) { Struct.copyFrom(value, Struct.getPointer(2, this)); }
    getDel() { return Struct.getBit(32, this); }
    setDel(value) { Struct.setBit(32, value, this); }
    toString() { return "ArrayMetadata_MetadataEntry_" + super.toString(); }
}
ArrayMetadata_MetadataEntry._capnp = { displayName: "MetadataEntry", id: "926fe1c3b12ed651", size: new ObjectSize(8, 3) };
class ArrayMetadata extends Struct {
    adoptEntries(value) { Struct.adopt(value, Struct.getPointer(0, this)); }
    disownEntries() { return Struct.disown(this.getEntries()); }
    getEntries() { return Struct.getList(0, ArrayMetadata._Entries, this); }
    hasEntries() { return !Struct.isNull(Struct.getPointer(0, this)); }
    initEntries(length) { return Struct.initList(0, ArrayMetadata._Entries, length, this); }
    setEntries(value) { Struct.copyFrom(value, Struct.getPointer(0, this)); }
    toString() { return "ArrayMetadata_" + super.toString(); }
}
ArrayMetadata.MetadataEntry = ArrayMetadata_MetadataEntry;
ArrayMetadata._capnp = { displayName: "ArrayMetadata", id: "9737dcafdfce31bb", size: new ObjectSize(0, 1) };
ArrayMetadata._Entries = capnp.CompositeList(ArrayMetadata_MetadataEntry);

/* tslint:disable */
class Query extends Struct {
    adoptAttributeBufferHeaders(value) { Struct.adopt(value, Struct.getPointer(0, this)); }
    disownAttributeBufferHeaders() { return Struct.disown(this.getAttributeBufferHeaders()); }
    getAttributeBufferHeaders() { return Struct.getList(0, Query._AttributeBufferHeaders, this); }
    hasAttributeBufferHeaders() { return !Struct.isNull(Struct.getPointer(0, this)); }
    initAttributeBufferHeaders(length) { return Struct.initList(0, Query._AttributeBufferHeaders, length, this); }
    setAttributeBufferHeaders(value) { Struct.copyFrom(value, Struct.getPointer(0, this)); }
    getLayout() { return Struct.getText(1, this); }
    setLayout(value) { Struct.setText(1, value, this); }
    getStatus() { return Struct.getText(2, this); }
    setStatus(value) { Struct.setText(2, value, this); }
    getType() { return Struct.getText(3, this); }
    setType(value) { Struct.setText(3, value, this); }
    adoptWriter(value) { Struct.adopt(value, Struct.getPointer(4, this)); }
    disownWriter() { return Struct.disown(this.getWriter()); }
    getWriter() { return Struct.getStruct(4, Writer, this); }
    hasWriter() { return !Struct.isNull(Struct.getPointer(4, this)); }
    initWriter() { return Struct.initStructAt(4, Writer, this); }
    setWriter(value) { Struct.copyFrom(value, Struct.getPointer(4, this)); }
    adoptReader(value) { Struct.adopt(value, Struct.getPointer(5, this)); }
    disownReader() { return Struct.disown(this.getReader()); }
    getReader() { return Struct.getStruct(5, QueryReader, this); }
    hasReader() { return !Struct.isNull(Struct.getPointer(5, this)); }
    initReader() { return Struct.initStructAt(5, QueryReader, this); }
    setReader(value) { Struct.copyFrom(value, Struct.getPointer(5, this)); }
    adoptArray(value) { Struct.adopt(value, Struct.getPointer(6, this)); }
    disownArray() { return Struct.disown(this.getArray()); }
    getArray() { return Struct.getStruct(6, Array$1, this); }
    hasArray() { return !Struct.isNull(Struct.getPointer(6, this)); }
    initArray() { return Struct.initStructAt(6, Array$1, this); }
    setArray(value) { Struct.copyFrom(value, Struct.getPointer(6, this)); }
    getTotalFixedLengthBufferBytes() { return Struct.getUint64(0, this); }
    setTotalFixedLengthBufferBytes(value) { Struct.setUint64(0, value, this); }
    getTotalVarLenBufferBytes() { return Struct.getUint64(8, this); }
    setTotalVarLenBufferBytes(value) { Struct.setUint64(8, value, this); }
    getTotalValidityBufferBytes() { return Struct.getUint64(16, this); }
    setTotalValidityBufferBytes(value) { Struct.setUint64(16, value, this); }
    getVarOffsetsMode() { return Struct.getText(7, this); }
    setVarOffsetsMode(value) { Struct.setText(7, value, this); }
    getVarOffsetsAddExtraElement() { return Struct.getBit(192, this); }
    setVarOffsetsAddExtraElement(value) { Struct.setBit(192, value, this); }
    getVarOffsetsBitsize() { return Struct.getInt32(28, this); }
    setVarOffsetsBitsize(value) { Struct.setInt32(28, value, this); }
    adoptConfig(value) { Struct.adopt(value, Struct.getPointer(8, this)); }
    disownConfig() { return Struct.disown(this.getConfig()); }
    getConfig() { return Struct.getStruct(8, Config, this); }
    hasConfig() { return !Struct.isNull(Struct.getPointer(8, this)); }
    initConfig() { return Struct.initStructAt(8, Config, this); }
    setConfig(value) { Struct.copyFrom(value, Struct.getPointer(8, this)); }
    adoptStats(value) { Struct.adopt(value, Struct.getPointer(9, this)); }
    disownStats() { return Struct.disown(this.getStats()); }
    getStats() { return Struct.getStruct(9, Stats, this); }
    hasStats() { return !Struct.isNull(Struct.getPointer(9, this)); }
    initStats() { return Struct.initStructAt(9, Stats, this); }
    setStats(value) { Struct.copyFrom(value, Struct.getPointer(9, this)); }
    toString() { return "Query_" + super.toString(); }
}
Query._capnp = { displayName: "Query", id: "ea34268ae031ac7a", size: new ObjectSize(32, 10) };
class AttributeBufferHeader extends Struct {
    getName() { return Struct.getText(0, this); }
    setName(value) { Struct.setText(0, value, this); }
    getFixedLenBufferSizeInBytes() { return Struct.getUint64(0, this); }
    setFixedLenBufferSizeInBytes(value) { Struct.setUint64(0, value, this); }
    getVarLenBufferSizeInBytes() { return Struct.getUint64(8, this); }
    setVarLenBufferSizeInBytes(value) { Struct.setUint64(8, value, this); }
    getValidityLenBufferSizeInBytes() { return Struct.getUint64(16, this); }
    setValidityLenBufferSizeInBytes(value) { Struct.setUint64(16, value, this); }
    getOriginalFixedLenBufferSizeInBytes() { return Struct.getUint64(24, this); }
    setOriginalFixedLenBufferSizeInBytes(value) { Struct.setUint64(24, value, this); }
    getOriginalVarLenBufferSizeInBytes() { return Struct.getUint64(32, this); }
    setOriginalVarLenBufferSizeInBytes(value) { Struct.setUint64(32, value, this); }
    getOriginalValidityLenBufferSizeInBytes() { return Struct.getUint64(40, this); }
    setOriginalValidityLenBufferSizeInBytes(value) { Struct.setUint64(40, value, this); }
    toString() { return "AttributeBufferHeader_" + super.toString(); }
}
AttributeBufferHeader._capnp = { displayName: "AttributeBufferHeader", id: "9884df9a1b40f364", size: new ObjectSize(48, 1) };
let Array$1 = class Array extends Struct {
    getEndTimestamp() { return Struct.getUint64(0, this); }
    setEndTimestamp(value) { Struct.setUint64(0, value, this); }
    getQueryType() { return Struct.getText(0, this); }
    setQueryType(value) { Struct.setText(0, value, this); }
    getUri() { return Struct.getText(1, this); }
    setUri(value) { Struct.setText(1, value, this); }
    getStartTimestamp() { return Struct.getUint64(8, this); }
    setStartTimestamp(value) { Struct.setUint64(8, value, this); }
    toString() { return "Array_" + super.toString(); }
};
Array$1._capnp = { displayName: "Array", id: "e8b44da5a3b284a4", size: new ObjectSize(16, 2) };
class FilterPipeline extends Struct {
    adoptFilters(value) { Struct.adopt(value, Struct.getPointer(0, this)); }
    disownFilters() { return Struct.disown(this.getFilters()); }
    getFilters() { return Struct.getList(0, FilterPipeline._Filters, this); }
    hasFilters() { return !Struct.isNull(Struct.getPointer(0, this)); }
    initFilters(length) { return Struct.initList(0, FilterPipeline._Filters, length, this); }
    setFilters(value) { Struct.copyFrom(value, Struct.getPointer(0, this)); }
    toString() { return "FilterPipeline_" + super.toString(); }
}
FilterPipeline._capnp = { displayName: "FilterPipeline", id: "a6d903a3c84d4809", size: new ObjectSize(0, 1) };
var Filter_Data_Which;
(function (Filter_Data_Which) {
    Filter_Data_Which[Filter_Data_Which["TEXT"] = 0] = "TEXT";
    Filter_Data_Which[Filter_Data_Which["BYTES"] = 1] = "BYTES";
    Filter_Data_Which[Filter_Data_Which["INT8"] = 2] = "INT8";
    Filter_Data_Which[Filter_Data_Which["UINT8"] = 3] = "UINT8";
    Filter_Data_Which[Filter_Data_Which["INT16"] = 4] = "INT16";
    Filter_Data_Which[Filter_Data_Which["UINT16"] = 5] = "UINT16";
    Filter_Data_Which[Filter_Data_Which["INT32"] = 6] = "INT32";
    Filter_Data_Which[Filter_Data_Which["UINT32"] = 7] = "UINT32";
    Filter_Data_Which[Filter_Data_Which["INT64"] = 8] = "INT64";
    Filter_Data_Which[Filter_Data_Which["UINT64"] = 9] = "UINT64";
    Filter_Data_Which[Filter_Data_Which["FLOAT32"] = 10] = "FLOAT32";
    Filter_Data_Which[Filter_Data_Which["FLOAT64"] = 11] = "FLOAT64";
})(Filter_Data_Which || (Filter_Data_Which = {}));
class Filter_Data extends Struct {
    getText() {
        Struct.testWhich("text", Struct.getUint16(0, this), 0, this);
        return Struct.getText(1, this);
    }
    isText() { return Struct.getUint16(0, this) === 0; }
    setText(value) {
        Struct.setUint16(0, 0, this);
        Struct.setText(1, value, this);
    }
    adoptBytes(value) {
        Struct.setUint16(0, 1, this);
        Struct.adopt(value, Struct.getPointer(1, this));
    }
    disownBytes() { return Struct.disown(this.getBytes()); }
    getBytes() {
        Struct.testWhich("bytes", Struct.getUint16(0, this), 1, this);
        return Struct.getData(1, this);
    }
    hasBytes() { return !Struct.isNull(Struct.getPointer(1, this)); }
    initBytes(length) {
        Struct.setUint16(0, 1, this);
        return Struct.initData(1, length, this);
    }
    isBytes() { return Struct.getUint16(0, this) === 1; }
    setBytes(value) {
        Struct.setUint16(0, 1, this);
        Struct.copyFrom(value, Struct.getPointer(1, this));
    }
    getInt8() {
        Struct.testWhich("int8", Struct.getUint16(0, this), 2, this);
        return Struct.getInt8(2, this);
    }
    isInt8() { return Struct.getUint16(0, this) === 2; }
    setInt8(value) {
        Struct.setUint16(0, 2, this);
        Struct.setInt8(2, value, this);
    }
    getUint8() {
        Struct.testWhich("uint8", Struct.getUint16(0, this), 3, this);
        return Struct.getUint8(2, this);
    }
    isUint8() { return Struct.getUint16(0, this) === 3; }
    setUint8(value) {
        Struct.setUint16(0, 3, this);
        Struct.setUint8(2, value, this);
    }
    getInt16() {
        Struct.testWhich("int16", Struct.getUint16(0, this), 4, this);
        return Struct.getInt16(2, this);
    }
    isInt16() { return Struct.getUint16(0, this) === 4; }
    setInt16(value) {
        Struct.setUint16(0, 4, this);
        Struct.setInt16(2, value, this);
    }
    getUint16() {
        Struct.testWhich("uint16", Struct.getUint16(0, this), 5, this);
        return Struct.getUint16(2, this);
    }
    isUint16() { return Struct.getUint16(0, this) === 5; }
    setUint16(value) {
        Struct.setUint16(0, 5, this);
        Struct.setUint16(2, value, this);
    }
    getInt32() {
        Struct.testWhich("int32", Struct.getUint16(0, this), 6, this);
        return Struct.getInt32(4, this);
    }
    isInt32() { return Struct.getUint16(0, this) === 6; }
    setInt32(value) {
        Struct.setUint16(0, 6, this);
        Struct.setInt32(4, value, this);
    }
    getUint32() {
        Struct.testWhich("uint32", Struct.getUint16(0, this), 7, this);
        return Struct.getUint32(4, this);
    }
    isUint32() { return Struct.getUint16(0, this) === 7; }
    setUint32(value) {
        Struct.setUint16(0, 7, this);
        Struct.setUint32(4, value, this);
    }
    getInt64() {
        Struct.testWhich("int64", Struct.getUint16(0, this), 8, this);
        return Struct.getInt64(8, this);
    }
    isInt64() { return Struct.getUint16(0, this) === 8; }
    setInt64(value) {
        Struct.setUint16(0, 8, this);
        Struct.setInt64(8, value, this);
    }
    getUint64() {
        Struct.testWhich("uint64", Struct.getUint16(0, this), 9, this);
        return Struct.getUint64(8, this);
    }
    isUint64() { return Struct.getUint16(0, this) === 9; }
    setUint64(value) {
        Struct.setUint16(0, 9, this);
        Struct.setUint64(8, value, this);
    }
    getFloat32() {
        Struct.testWhich("float32", Struct.getUint16(0, this), 10, this);
        return Struct.getFloat32(4, this);
    }
    isFloat32() { return Struct.getUint16(0, this) === 10; }
    setFloat32(value) {
        Struct.setUint16(0, 10, this);
        Struct.setFloat32(4, value, this);
    }
    getFloat64() {
        Struct.testWhich("float64", Struct.getUint16(0, this), 11, this);
        return Struct.getFloat64(8, this);
    }
    isFloat64() { return Struct.getUint16(0, this) === 11; }
    setFloat64(value) {
        Struct.setUint16(0, 11, this);
        Struct.setFloat64(8, value, this);
    }
    toString() { return "Filter_Data_" + super.toString(); }
    which() { return Struct.getUint16(0, this); }
}
Filter_Data.TEXT = Filter_Data_Which.TEXT;
Filter_Data.BYTES = Filter_Data_Which.BYTES;
Filter_Data.INT8 = Filter_Data_Which.INT8;
Filter_Data.UINT8 = Filter_Data_Which.UINT8;
Filter_Data.INT16 = Filter_Data_Which.INT16;
Filter_Data.UINT16 = Filter_Data_Which.UINT16;
Filter_Data.INT32 = Filter_Data_Which.INT32;
Filter_Data.UINT32 = Filter_Data_Which.UINT32;
Filter_Data.INT64 = Filter_Data_Which.INT64;
Filter_Data.UINT64 = Filter_Data_Which.UINT64;
Filter_Data.FLOAT32 = Filter_Data_Which.FLOAT32;
Filter_Data.FLOAT64 = Filter_Data_Which.FLOAT64;
Filter_Data._capnp = { displayName: "data", id: "f7e88fec77255f9a", size: new ObjectSize(16, 2) };
class Filter extends Struct {
    getType() { return Struct.getText(0, this); }
    setType(value) { Struct.setText(0, value, this); }
    getData() { return Struct.getAs(Filter_Data, this); }
    initData() { return Struct.getAs(Filter_Data, this); }
    toString() { return "Filter_" + super.toString(); }
}
Filter._capnp = { displayName: "Filter", id: "dac88a0a3b53a50a", size: new ObjectSize(16, 2) };
class KV extends Struct {
    getKey() { return Struct.getText(0, this); }
    setKey(value) { Struct.setText(0, value, this); }
    getValue() { return Struct.getText(1, this); }
    setValue(value) { Struct.setText(1, value, this); }
    toString() { return "KV_" + super.toString(); }
}
KV._capnp = { displayName: "KV", id: "f81811af0443b7bd", size: new ObjectSize(0, 2) };
class Config extends Struct {
    adoptEntries(value) { Struct.adopt(value, Struct.getPointer(0, this)); }
    disownEntries() { return Struct.disown(this.getEntries()); }
    getEntries() { return Struct.getList(0, Config._Entries, this); }
    hasEntries() { return !Struct.isNull(Struct.getPointer(0, this)); }
    initEntries(length) { return Struct.initList(0, Config._Entries, length, this); }
    setEntries(value) { Struct.copyFrom(value, Struct.getPointer(0, this)); }
    toString() { return "Config_" + super.toString(); }
}
Config._capnp = { displayName: "Config", id: "84e9e25074e7b66d", size: new ObjectSize(0, 1) };
class Stats extends Struct {
    adoptTimers(value) { Struct.adopt(value, Struct.getPointer(0, this)); }
    disownTimers() { return Struct.disown(this.getTimers()); }
    getTimers() { return Struct.getStruct(0, MapFloat64, this); }
    hasTimers() { return !Struct.isNull(Struct.getPointer(0, this)); }
    initTimers() { return Struct.initStructAt(0, MapFloat64, this); }
    setTimers(value) { Struct.copyFrom(value, Struct.getPointer(0, this)); }
    adoptCounters(value) { Struct.adopt(value, Struct.getPointer(1, this)); }
    disownCounters() { return Struct.disown(this.getCounters()); }
    getCounters() { return Struct.getStruct(1, MapUInt64, this); }
    hasCounters() { return !Struct.isNull(Struct.getPointer(1, this)); }
    initCounters() { return Struct.initStructAt(1, MapUInt64, this); }
    setCounters(value) { Struct.copyFrom(value, Struct.getPointer(1, this)); }
    toString() { return "Stats_" + super.toString(); }
}
Stats._capnp = { displayName: "Stats", id: "ef6314d713d0ab34", size: new ObjectSize(0, 2) };
class Writer extends Struct {
    getCheckCoordDups() { return Struct.getBit(0, this); }
    setCheckCoordDups(value) { Struct.setBit(0, value, this); }
    getCheckCoordOOB() { return Struct.getBit(1, this); }
    setCheckCoordOOB(value) { Struct.setBit(1, value, this); }
    getDedupCoords() { return Struct.getBit(2, this); }
    setDedupCoords(value) { Struct.setBit(2, value, this); }
    adoptSubarray(value) { Struct.adopt(value, Struct.getPointer(0, this)); }
    disownSubarray() { return Struct.disown(this.getSubarray()); }
    getSubarray() { return Struct.getStruct(0, DomainArray, this); }
    hasSubarray() { return !Struct.isNull(Struct.getPointer(0, this)); }
    initSubarray() { return Struct.initStructAt(0, DomainArray, this); }
    setSubarray(value) { Struct.copyFrom(value, Struct.getPointer(0, this)); }
    adoptSubarrayRanges(value) { Struct.adopt(value, Struct.getPointer(1, this)); }
    disownSubarrayRanges() { return Struct.disown(this.getSubarrayRanges()); }
    getSubarrayRanges() { return Struct.getStruct(1, Subarray, this); }
    hasSubarrayRanges() { return !Struct.isNull(Struct.getPointer(1, this)); }
    initSubarrayRanges() { return Struct.initStructAt(1, Subarray, this); }
    setSubarrayRanges(value) { Struct.copyFrom(value, Struct.getPointer(1, this)); }
    adoptStats(value) { Struct.adopt(value, Struct.getPointer(2, this)); }
    disownStats() { return Struct.disown(this.getStats()); }
    getStats() { return Struct.getStruct(2, Stats, this); }
    hasStats() { return !Struct.isNull(Struct.getPointer(2, this)); }
    initStats() { return Struct.initStructAt(2, Stats, this); }
    setStats(value) { Struct.copyFrom(value, Struct.getPointer(2, this)); }
    toString() { return "Writer_" + super.toString(); }
}
Writer._capnp = { displayName: "Writer", id: "fe68eabb8ab4dcfa", size: new ObjectSize(8, 3) };
class QueryReader extends Struct {
    getLayout() { return Struct.getText(0, this); }
    setLayout(value) { Struct.setText(0, value, this); }
    adoptSubarray(value) { Struct.adopt(value, Struct.getPointer(1, this)); }
    disownSubarray() { return Struct.disown(this.getSubarray()); }
    getSubarray() { return Struct.getStruct(1, Subarray, this); }
    hasSubarray() { return !Struct.isNull(Struct.getPointer(1, this)); }
    initSubarray() { return Struct.initStructAt(1, Subarray, this); }
    setSubarray(value) { Struct.copyFrom(value, Struct.getPointer(1, this)); }
    adoptReadState(value) { Struct.adopt(value, Struct.getPointer(2, this)); }
    disownReadState() { return Struct.disown(this.getReadState()); }
    getReadState() { return Struct.getStruct(2, ReadState, this); }
    hasReadState() { return !Struct.isNull(Struct.getPointer(2, this)); }
    initReadState() { return Struct.initStructAt(2, ReadState, this); }
    setReadState(value) { Struct.copyFrom(value, Struct.getPointer(2, this)); }
    adoptCondition(value) { Struct.adopt(value, Struct.getPointer(3, this)); }
    disownCondition() { return Struct.disown(this.getCondition()); }
    getCondition() { return Struct.getStruct(3, Condition, this); }
    hasCondition() { return !Struct.isNull(Struct.getPointer(3, this)); }
    initCondition() { return Struct.initStructAt(3, Condition, this); }
    setCondition(value) { Struct.copyFrom(value, Struct.getPointer(3, this)); }
    adoptStats(value) { Struct.adopt(value, Struct.getPointer(4, this)); }
    disownStats() { return Struct.disown(this.getStats()); }
    getStats() { return Struct.getStruct(4, Stats, this); }
    hasStats() { return !Struct.isNull(Struct.getPointer(4, this)); }
    initStats() { return Struct.initStructAt(4, Stats, this); }
    setStats(value) { Struct.copyFrom(value, Struct.getPointer(4, this)); }
    toString() { return "QueryReader_" + super.toString(); }
}
QueryReader._capnp = { displayName: "QueryReader", id: "97a817df79d1095d", size: new ObjectSize(0, 5) };
class SubarrayRanges extends Struct {
    getType() { return Struct.getText(0, this); }
    setType(value) { Struct.setText(0, value, this); }
    getHasDefaultRange() { return Struct.getBit(0, this); }
    setHasDefaultRange(value) { Struct.setBit(0, value, this); }
    adoptBuffer(value) { Struct.adopt(value, Struct.getPointer(1, this)); }
    disownBuffer() { return Struct.disown(this.getBuffer()); }
    getBuffer() { return Struct.getData(1, this); }
    hasBuffer() { return !Struct.isNull(Struct.getPointer(1, this)); }
    initBuffer(length) { return Struct.initData(1, length, this); }
    setBuffer(value) { Struct.copyFrom(value, Struct.getPointer(1, this)); }
    adoptBufferSizes(value) { Struct.adopt(value, Struct.getPointer(2, this)); }
    disownBufferSizes() { return Struct.disown(this.getBufferSizes()); }
    getBufferSizes() { return Struct.getList(2, capnp.Uint64List, this); }
    hasBufferSizes() { return !Struct.isNull(Struct.getPointer(2, this)); }
    initBufferSizes(length) { return Struct.initList(2, capnp.Uint64List, length, this); }
    setBufferSizes(value) { Struct.copyFrom(value, Struct.getPointer(2, this)); }
    adoptBufferStartSizes(value) { Struct.adopt(value, Struct.getPointer(3, this)); }
    disownBufferStartSizes() { return Struct.disown(this.getBufferStartSizes()); }
    getBufferStartSizes() { return Struct.getList(3, capnp.Uint64List, this); }
    hasBufferStartSizes() { return !Struct.isNull(Struct.getPointer(3, this)); }
    initBufferStartSizes(length) { return Struct.initList(3, capnp.Uint64List, length, this); }
    setBufferStartSizes(value) { Struct.copyFrom(value, Struct.getPointer(3, this)); }
    toString() { return "SubarrayRanges_" + super.toString(); }
}
SubarrayRanges._capnp = { displayName: "SubarrayRanges", id: "8587733f29e10a41", size: new ObjectSize(8, 4) };
class Subarray extends Struct {
    getLayout() { return Struct.getText(0, this); }
    setLayout(value) { Struct.setText(0, value, this); }
    adoptRanges(value) { Struct.adopt(value, Struct.getPointer(1, this)); }
    disownRanges() { return Struct.disown(this.getRanges()); }
    getRanges() { return Struct.getList(1, Subarray._Ranges, this); }
    hasRanges() { return !Struct.isNull(Struct.getPointer(1, this)); }
    initRanges(length) { return Struct.initList(1, Subarray._Ranges, length, this); }
    setRanges(value) { Struct.copyFrom(value, Struct.getPointer(1, this)); }
    adoptStats(value) { Struct.adopt(value, Struct.getPointer(2, this)); }
    disownStats() { return Struct.disown(this.getStats()); }
    getStats() { return Struct.getStruct(2, Stats, this); }
    hasStats() { return !Struct.isNull(Struct.getPointer(2, this)); }
    initStats() { return Struct.initStructAt(2, Stats, this); }
    setStats(value) { Struct.copyFrom(value, Struct.getPointer(2, this)); }
    toString() { return "Subarray_" + super.toString(); }
}
Subarray._capnp = { displayName: "Subarray", id: "da36de34a7124afb", size: new ObjectSize(0, 3) };
class SubarrayPartitioner_PartitionInfo extends Struct {
    adoptSubarray(value) { Struct.adopt(value, Struct.getPointer(0, this)); }
    disownSubarray() { return Struct.disown(this.getSubarray()); }
    getSubarray() { return Struct.getStruct(0, Subarray, this); }
    hasSubarray() { return !Struct.isNull(Struct.getPointer(0, this)); }
    initSubarray() { return Struct.initStructAt(0, Subarray, this); }
    setSubarray(value) { Struct.copyFrom(value, Struct.getPointer(0, this)); }
    getStart() { return Struct.getUint64(0, this); }
    setStart(value) { Struct.setUint64(0, value, this); }
    getEnd() { return Struct.getUint64(8, this); }
    setEnd(value) { Struct.setUint64(8, value, this); }
    getSplitMultiRange() { return Struct.getBit(128, this); }
    setSplitMultiRange(value) { Struct.setBit(128, value, this); }
    toString() { return "SubarrayPartitioner_PartitionInfo_" + super.toString(); }
}
SubarrayPartitioner_PartitionInfo._capnp = { displayName: "PartitionInfo", id: "c195bcd1baa34c68", size: new ObjectSize(24, 1) };
class SubarrayPartitioner_State extends Struct {
    getStart() { return Struct.getUint64(0, this); }
    setStart(value) { Struct.setUint64(0, value, this); }
    getEnd() { return Struct.getUint64(8, this); }
    setEnd(value) { Struct.setUint64(8, value, this); }
    adoptSingleRange(value) { Struct.adopt(value, Struct.getPointer(0, this)); }
    disownSingleRange() { return Struct.disown(this.getSingleRange()); }
    getSingleRange() { return Struct.getList(0, SubarrayPartitioner_State._SingleRange, this); }
    hasSingleRange() { return !Struct.isNull(Struct.getPointer(0, this)); }
    initSingleRange(length) { return Struct.initList(0, SubarrayPartitioner_State._SingleRange, length, this); }
    setSingleRange(value) { Struct.copyFrom(value, Struct.getPointer(0, this)); }
    adoptMultiRange(value) { Struct.adopt(value, Struct.getPointer(1, this)); }
    disownMultiRange() { return Struct.disown(this.getMultiRange()); }
    getMultiRange() { return Struct.getList(1, SubarrayPartitioner_State._MultiRange, this); }
    hasMultiRange() { return !Struct.isNull(Struct.getPointer(1, this)); }
    initMultiRange(length) { return Struct.initList(1, SubarrayPartitioner_State._MultiRange, length, this); }
    setMultiRange(value) { Struct.copyFrom(value, Struct.getPointer(1, this)); }
    toString() { return "SubarrayPartitioner_State_" + super.toString(); }
}
SubarrayPartitioner_State._capnp = { displayName: "State", id: "cbd6edafbf7bb215", size: new ObjectSize(16, 2) };
class SubarrayPartitioner extends Struct {
    adoptSubarray(value) { Struct.adopt(value, Struct.getPointer(0, this)); }
    disownSubarray() { return Struct.disown(this.getSubarray()); }
    getSubarray() { return Struct.getStruct(0, Subarray, this); }
    hasSubarray() { return !Struct.isNull(Struct.getPointer(0, this)); }
    initSubarray() { return Struct.initStructAt(0, Subarray, this); }
    setSubarray(value) { Struct.copyFrom(value, Struct.getPointer(0, this)); }
    adoptBudget(value) { Struct.adopt(value, Struct.getPointer(1, this)); }
    disownBudget() { return Struct.disown(this.getBudget()); }
    getBudget() { return Struct.getList(1, SubarrayPartitioner._Budget, this); }
    hasBudget() { return !Struct.isNull(Struct.getPointer(1, this)); }
    initBudget(length) { return Struct.initList(1, SubarrayPartitioner._Budget, length, this); }
    setBudget(value) { Struct.copyFrom(value, Struct.getPointer(1, this)); }
    adoptCurrent(value) { Struct.adopt(value, Struct.getPointer(2, this)); }
    disownCurrent() { return Struct.disown(this.getCurrent()); }
    getCurrent() { return Struct.getStruct(2, SubarrayPartitioner_PartitionInfo, this); }
    hasCurrent() { return !Struct.isNull(Struct.getPointer(2, this)); }
    initCurrent() { return Struct.initStructAt(2, SubarrayPartitioner_PartitionInfo, this); }
    setCurrent(value) { Struct.copyFrom(value, Struct.getPointer(2, this)); }
    adoptState(value) { Struct.adopt(value, Struct.getPointer(3, this)); }
    disownState() { return Struct.disown(this.getState()); }
    getState() { return Struct.getStruct(3, SubarrayPartitioner_State, this); }
    hasState() { return !Struct.isNull(Struct.getPointer(3, this)); }
    initState() { return Struct.initStructAt(3, SubarrayPartitioner_State, this); }
    setState(value) { Struct.copyFrom(value, Struct.getPointer(3, this)); }
    getMemoryBudget() { return Struct.getUint64(0, this); }
    setMemoryBudget(value) { Struct.setUint64(0, value, this); }
    getMemoryBudgetVar() { return Struct.getUint64(8, this); }
    setMemoryBudgetVar(value) { Struct.setUint64(8, value, this); }
    getMemoryBudgetValidity() { return Struct.getUint64(16, this); }
    setMemoryBudgetValidity(value) { Struct.setUint64(16, value, this); }
    adoptStats(value) { Struct.adopt(value, Struct.getPointer(4, this)); }
    disownStats() { return Struct.disown(this.getStats()); }
    getStats() { return Struct.getStruct(4, Stats, this); }
    hasStats() { return !Struct.isNull(Struct.getPointer(4, this)); }
    initStats() { return Struct.initStructAt(4, Stats, this); }
    setStats(value) { Struct.copyFrom(value, Struct.getPointer(4, this)); }
    toString() { return "SubarrayPartitioner_" + super.toString(); }
}
SubarrayPartitioner.PartitionInfo = SubarrayPartitioner_PartitionInfo;
SubarrayPartitioner.State = SubarrayPartitioner_State;
SubarrayPartitioner._capnp = { displayName: "SubarrayPartitioner", id: "98222aaeac2b06c0", size: new ObjectSize(24, 5) };
class ReadState extends Struct {
    getOverflowed() { return Struct.getBit(0, this); }
    setOverflowed(value) { Struct.setBit(0, value, this); }
    getUnsplittable() { return Struct.getBit(1, this); }
    setUnsplittable(value) { Struct.setBit(1, value, this); }
    getInitialized() { return Struct.getBit(2, this); }
    setInitialized(value) { Struct.setBit(2, value, this); }
    adoptSubarrayPartitioner(value) { Struct.adopt(value, Struct.getPointer(0, this)); }
    disownSubarrayPartitioner() { return Struct.disown(this.getSubarrayPartitioner()); }
    getSubarrayPartitioner() { return Struct.getStruct(0, SubarrayPartitioner, this); }
    hasSubarrayPartitioner() { return !Struct.isNull(Struct.getPointer(0, this)); }
    initSubarrayPartitioner() { return Struct.initStructAt(0, SubarrayPartitioner, this); }
    setSubarrayPartitioner(value) { Struct.copyFrom(value, Struct.getPointer(0, this)); }
    toString() { return "ReadState_" + super.toString(); }
}
ReadState._capnp = { displayName: "ReadState", id: "910b5afbbc6a0745", size: new ObjectSize(8, 1) };
class ConditionClause extends Struct {
    getFieldName() { return Struct.getText(0, this); }
    setFieldName(value) { Struct.setText(0, value, this); }
    adoptValue(value) { Struct.adopt(value, Struct.getPointer(1, this)); }
    disownValue() { return Struct.disown(this.getValue()); }
    getValue() { return Struct.getData(1, this); }
    hasValue() { return !Struct.isNull(Struct.getPointer(1, this)); }
    initValue(length) { return Struct.initData(1, length, this); }
    setValue(value) { Struct.copyFrom(value, Struct.getPointer(1, this)); }
    getOp() { return Struct.getText(2, this); }
    setOp(value) { Struct.setText(2, value, this); }
    toString() { return "ConditionClause_" + super.toString(); }
}
ConditionClause._capnp = { displayName: "ConditionClause", id: "fa99a0f16eaa03a5", size: new ObjectSize(0, 3) };
class Condition extends Struct {
    adoptClauses(value) { Struct.adopt(value, Struct.getPointer(0, this)); }
    disownClauses() { return Struct.disown(this.getClauses()); }
    getClauses() { return Struct.getList(0, Condition._Clauses, this); }
    hasClauses() { return !Struct.isNull(Struct.getPointer(0, this)); }
    initClauses(length) { return Struct.initList(0, Condition._Clauses, length, this); }
    setClauses(value) { Struct.copyFrom(value, Struct.getPointer(0, this)); }
    adoptClauseCombinationOps(value) { Struct.adopt(value, Struct.getPointer(1, this)); }
    disownClauseCombinationOps() { return Struct.disown(this.getClauseCombinationOps()); }
    getClauseCombinationOps() { return Struct.getList(1, capnp.TextList, this); }
    hasClauseCombinationOps() { return !Struct.isNull(Struct.getPointer(1, this)); }
    initClauseCombinationOps(length) { return Struct.initList(1, capnp.TextList, length, this); }
    setClauseCombinationOps(value) { Struct.copyFrom(value, Struct.getPointer(1, this)); }
    toString() { return "Condition_" + super.toString(); }
}
Condition._capnp = { displayName: "Condition", id: "fb156e2d8b8f4cf3", size: new ObjectSize(0, 2) };
class DomainArray extends Struct {
    adoptInt8(value) { Struct.adopt(value, Struct.getPointer(0, this)); }
    disownInt8() { return Struct.disown(this.getInt8()); }
    getInt8() { return Struct.getList(0, capnp.Int8List, this); }
    hasInt8() { return !Struct.isNull(Struct.getPointer(0, this)); }
    initInt8(length) { return Struct.initList(0, capnp.Int8List, length, this); }
    setInt8(value) { Struct.copyFrom(value, Struct.getPointer(0, this)); }
    adoptUint8(value) { Struct.adopt(value, Struct.getPointer(1, this)); }
    disownUint8() { return Struct.disown(this.getUint8()); }
    getUint8() { return Struct.getList(1, capnp.Uint8List, this); }
    hasUint8() { return !Struct.isNull(Struct.getPointer(1, this)); }
    initUint8(length) { return Struct.initList(1, capnp.Uint8List, length, this); }
    setUint8(value) { Struct.copyFrom(value, Struct.getPointer(1, this)); }
    adoptInt16(value) { Struct.adopt(value, Struct.getPointer(2, this)); }
    disownInt16() { return Struct.disown(this.getInt16()); }
    getInt16() { return Struct.getList(2, capnp.Int16List, this); }
    hasInt16() { return !Struct.isNull(Struct.getPointer(2, this)); }
    initInt16(length) { return Struct.initList(2, capnp.Int16List, length, this); }
    setInt16(value) { Struct.copyFrom(value, Struct.getPointer(2, this)); }
    adoptUint16(value) { Struct.adopt(value, Struct.getPointer(3, this)); }
    disownUint16() { return Struct.disown(this.getUint16()); }
    getUint16() { return Struct.getList(3, capnp.Uint16List, this); }
    hasUint16() { return !Struct.isNull(Struct.getPointer(3, this)); }
    initUint16(length) { return Struct.initList(3, capnp.Uint16List, length, this); }
    setUint16(value) { Struct.copyFrom(value, Struct.getPointer(3, this)); }
    adoptInt32(value) { Struct.adopt(value, Struct.getPointer(4, this)); }
    disownInt32() { return Struct.disown(this.getInt32()); }
    getInt32() { return Struct.getList(4, capnp.Int32List, this); }
    hasInt32() { return !Struct.isNull(Struct.getPointer(4, this)); }
    initInt32(length) { return Struct.initList(4, capnp.Int32List, length, this); }
    setInt32(value) { Struct.copyFrom(value, Struct.getPointer(4, this)); }
    adoptUint32(value) { Struct.adopt(value, Struct.getPointer(5, this)); }
    disownUint32() { return Struct.disown(this.getUint32()); }
    getUint32() { return Struct.getList(5, capnp.Uint32List, this); }
    hasUint32() { return !Struct.isNull(Struct.getPointer(5, this)); }
    initUint32(length) { return Struct.initList(5, capnp.Uint32List, length, this); }
    setUint32(value) { Struct.copyFrom(value, Struct.getPointer(5, this)); }
    adoptInt64(value) { Struct.adopt(value, Struct.getPointer(6, this)); }
    disownInt64() { return Struct.disown(this.getInt64()); }
    getInt64() { return Struct.getList(6, capnp.Int64List, this); }
    hasInt64() { return !Struct.isNull(Struct.getPointer(6, this)); }
    initInt64(length) { return Struct.initList(6, capnp.Int64List, length, this); }
    setInt64(value) { Struct.copyFrom(value, Struct.getPointer(6, this)); }
    adoptUint64(value) { Struct.adopt(value, Struct.getPointer(7, this)); }
    disownUint64() { return Struct.disown(this.getUint64()); }
    getUint64() { return Struct.getList(7, capnp.Uint64List, this); }
    hasUint64() { return !Struct.isNull(Struct.getPointer(7, this)); }
    initUint64(length) { return Struct.initList(7, capnp.Uint64List, length, this); }
    setUint64(value) { Struct.copyFrom(value, Struct.getPointer(7, this)); }
    adoptFloat32(value) { Struct.adopt(value, Struct.getPointer(8, this)); }
    disownFloat32() { return Struct.disown(this.getFloat32()); }
    getFloat32() { return Struct.getList(8, capnp.Float32List, this); }
    hasFloat32() { return !Struct.isNull(Struct.getPointer(8, this)); }
    initFloat32(length) { return Struct.initList(8, capnp.Float32List, length, this); }
    setFloat32(value) { Struct.copyFrom(value, Struct.getPointer(8, this)); }
    adoptFloat64(value) { Struct.adopt(value, Struct.getPointer(9, this)); }
    disownFloat64() { return Struct.disown(this.getFloat64()); }
    getFloat64() { return Struct.getList(9, capnp.Float64List, this); }
    hasFloat64() { return !Struct.isNull(Struct.getPointer(9, this)); }
    initFloat64(length) { return Struct.initList(9, capnp.Float64List, length, this); }
    setFloat64(value) { Struct.copyFrom(value, Struct.getPointer(9, this)); }
    toString() { return "DomainArray_" + super.toString(); }
}
DomainArray._capnp = { displayName: "DomainArray", id: "bc387f87af7fdffb", size: new ObjectSize(0, 10) };
class MapFloat64_Entry extends Struct {
    getKey() { return Struct.getText(0, this); }
    setKey(value) { Struct.setText(0, value, this); }
    getValue() { return Struct.getFloat64(0, this); }
    setValue(value) { Struct.setFloat64(0, value, this); }
    toString() { return "MapFloat64_Entry_" + super.toString(); }
}
MapFloat64_Entry._capnp = { displayName: "Entry", id: "bc6fa37d7f8e67b0", size: new ObjectSize(8, 1) };
class MapFloat64 extends Struct {
    adoptEntries(value) { Struct.adopt(value, Struct.getPointer(0, this)); }
    disownEntries() { return Struct.disown(this.getEntries()); }
    getEntries() { return Struct.getList(0, MapFloat64._Entries, this); }
    hasEntries() { return !Struct.isNull(Struct.getPointer(0, this)); }
    initEntries(length) { return Struct.initList(0, MapFloat64._Entries, length, this); }
    setEntries(value) { Struct.copyFrom(value, Struct.getPointer(0, this)); }
    toString() { return "MapFloat64_" + super.toString(); }
}
MapFloat64.Entry = MapFloat64_Entry;
MapFloat64._capnp = { displayName: "MapFloat64", id: "a240366668f18d8e", size: new ObjectSize(0, 1) };
class MapUInt64_Entry extends Struct {
    getKey() { return Struct.getText(0, this); }
    setKey(value) { Struct.setText(0, value, this); }
    getValue() { return Struct.getUint64(0, this); }
    setValue(value) { Struct.setUint64(0, value, this); }
    toString() { return "MapUInt64_Entry_" + super.toString(); }
}
MapUInt64_Entry._capnp = { displayName: "Entry", id: "977674438c18071e", size: new ObjectSize(8, 1) };
class MapUInt64 extends Struct {
    adoptEntries(value) { Struct.adopt(value, Struct.getPointer(0, this)); }
    disownEntries() { return Struct.disown(this.getEntries()); }
    getEntries() { return Struct.getList(0, MapUInt64._Entries, this); }
    hasEntries() { return !Struct.isNull(Struct.getPointer(0, this)); }
    initEntries(length) { return Struct.initList(0, MapUInt64._Entries, length, this); }
    setEntries(value) { Struct.copyFrom(value, Struct.getPointer(0, this)); }
    toString() { return "MapUInt64_" + super.toString(); }
}
MapUInt64.Entry = MapUInt64_Entry;
MapUInt64._capnp = { displayName: "MapUInt64", id: "de734faff53aa239", size: new ObjectSize(0, 1) };
class AttributeBufferSize extends Struct {
    getAttribute() { return Struct.getText(0, this); }
    setAttribute(value) { Struct.setText(0, value, this); }
    getOffsetBytes() { return Struct.getUint64(0, this); }
    setOffsetBytes(value) { Struct.setUint64(0, value, this); }
    getDataBytes() { return Struct.getUint64(8, this); }
    setDataBytes(value) { Struct.setUint64(8, value, this); }
    getValidityBytes() { return Struct.getUint64(16, this); }
    setValidityBytes(value) { Struct.setUint64(16, value, this); }
    toString() { return "AttributeBufferSize_" + super.toString(); }
}
AttributeBufferSize._capnp = { displayName: "AttributeBufferSize", id: "e8c3366db226bb6a", size: new ObjectSize(24, 1) };
Query._AttributeBufferHeaders = capnp.CompositeList(AttributeBufferHeader);
FilterPipeline._Filters = capnp.CompositeList(Filter);
Config._Entries = capnp.CompositeList(KV);
Subarray._Ranges = capnp.CompositeList(SubarrayRanges);
SubarrayPartitioner_State._SingleRange = capnp.CompositeList(Subarray);
SubarrayPartitioner_State._MultiRange = capnp.CompositeList(Subarray);
SubarrayPartitioner._Budget = capnp.CompositeList(AttributeBufferSize);
Condition._Clauses = capnp.CompositeList(ConditionClause);
MapFloat64._Entries = capnp.CompositeList(MapFloat64_Entry);
MapUInt64._Entries = capnp.CompositeList(MapUInt64_Entry);

/**
 * Serialize the Query object to capnp
 * @param data Query javascript object
 * @returns ArrayBuffer of the capnp Query object
 */
const capnpQuerySerializer = (data) => {
    const message = new capnp.Message();
    const queryData = message.initRoot(Query);
    const { reader = {}, writer = {}, array = {}, attributeBufferHeaders = [], layout = "", status = "", type = "", } = data;
    queryData.setLayout(layout);
    queryData.setStatus(status);
    queryData.setType(type);
    queryData.setTotalFixedLengthBufferBytes(capnp.Uint64.fromNumber(data.totalFixedLengthBufferBytes));
    queryData.setTotalVarLenBufferBytes(capnp.Uint64.fromNumber(data.totalVarLenBufferBytes));
    queryData.setTotalValidityBufferBytes(capnp.Uint64.fromNumber(data.totalValidityBufferBytes));
    queryData.setVarOffsetsMode("bytes");
    queryData.setVarOffsetsAddExtraElement(false);
    queryData.setVarOffsetsBitsize(64);
    const attrBuffers = queryData.initAttributeBufferHeaders(attributeBufferHeaders.length);
    attributeBufferHeaders.forEach((attrHeader, i) => {
        const attrBufferHeader = attrBuffers.get(i);
        attrBufferHeader.setName(attrHeader.name);
        attrBufferHeader.setFixedLenBufferSizeInBytes(capnp.Uint64.fromNumber(attrHeader.fixedLenBufferSizeInBytes));
        attrBufferHeader.setValidityLenBufferSizeInBytes(capnp.Uint64.fromNumber(attrHeader.validityLenBufferSizeInBytes));
        attrBufferHeader.setVarLenBufferSizeInBytes(capnp.Uint64.fromNumber(attrHeader.varLenBufferSizeInBytes));
        const { originalFixedLenBufferSizeInBytes = 0, originalVarLenBufferSizeInBytes = 0, originalValidityLenBufferSizeInBytes = 0, } = attrHeader;
        attrBufferHeader.setOriginalFixedLenBufferSizeInBytes(capnp.Uint64.fromNumber(originalFixedLenBufferSizeInBytes));
        attrBufferHeader.setOriginalVarLenBufferSizeInBytes(capnp.Uint64.fromNumber(originalVarLenBufferSizeInBytes));
        attrBufferHeader.setOriginalValidityLenBufferSizeInBytes(capnp.Uint64.fromNumber(originalValidityLenBufferSizeInBytes));
    });
    if (writer) {
        const { subarrayRanges = {}, subarray = {} } = writer;
        const queryWriter = queryData.initWriter();
        queryWriter.setCheckCoordDups(writer.checkCoordDups);
        queryWriter.setCheckCoordOOB(writer.checkCoordOOB);
        queryWriter.setDedupCoords(writer.dedupCoords);
        const writerSubArray = queryWriter.initSubarrayRanges();
        serializeSubArray(writerSubArray, subarrayRanges);
        const writerDomain = queryWriter.initSubarray();
        serializeDomainArray(writerDomain, subarray);
    }
    if (reader) {
        const queryReader = queryData.initReader();
        const subArrayCap = queryReader.initSubarray();
        const { subarray: subarrayData = {}, readState = {}, layout = "" } = reader;
        serializeSubArray(subArrayCap, subarrayData);
        queryReader.setLayout(layout);
        const readStateData = queryReader.initReadState();
        readStateData.setOverflowed(readState.overflowed);
        readStateData.setUnsplittable(readState.unsplittable);
        readStateData.setInitialized(readState.initialized);
        // subarrayPartitioner
        const { subarrayPartitioner = {} } = readState;
        const { budget = [], subarray = {}, current = {}, state = {}, memoryBudget = 0, memoryBudgetVar = 0, } = subarrayPartitioner;
        const subPartitioner = readStateData.initSubarrayPartitioner();
        subPartitioner.setMemoryBudget(capnp.Uint64.fromNumber(memoryBudget));
        subPartitioner.setMemoryBudgetVar(capnp.Uint64.fromNumber(memoryBudgetVar));
        // TODO: fix type
        // subPartitioner.setMemoryBudgetValidity(capnp.Uint64.fromNumber(0));
        const budgetData = subPartitioner.initBudget(budget.length);
        // subarrayPartitioner.Buget
        budget.forEach((b, i) => {
            const singleBudget = budgetData.get(i);
            singleBudget.setAttribute(b.attribute);
        });
        // subarrayPartitioner.Subarray
        const subArrayData = subPartitioner.initSubarray();
        serializeSubArray(subArrayData, subarray);
        // subarrayPartitioner.Current
        const currentData = subPartitioner.initCurrent();
        currentData.setSplitMultiRange(current.splitMultiRange);
        currentData.setStart(capnp.Uint64.fromNumber(current.start || 0));
        currentData.setEnd(capnp.Uint64.fromNumber(current.end || 0));
        const currentSubarray = currentData.initSubarray();
        serializeSubArray(currentSubarray, current.subarray || {});
        // subarrayPartitioner.State
        const capSubPartitionerState = subPartitioner.initState();
        capSubPartitionerState.setStart(capnp.Uint64.fromNumber(state.start || 0));
        capSubPartitionerState.setEnd(capnp.Uint64.fromNumber(state.end || 0));
        const multiRange = state.multiRange || [];
        const singleRange = state.singleRange || [];
        const capSubPartitionerStateMultiRange = capSubPartitionerState.initMultiRange(multiRange.length);
        const capSubPartitionerStateSingleRange = capSubPartitionerState.initSingleRange(singleRange.length);
        multiRange.forEach((mRange, i) => {
            const capMultiRange = capSubPartitionerStateMultiRange.get(i);
            serializeSubArray(capMultiRange, mRange);
        });
        singleRange.forEach((sRange, i) => {
            const capSingleRange = capSubPartitionerStateSingleRange.get(i);
            serializeSubArray(capSingleRange, sRange);
        });
    }
    if (array) {
        const queryArray = queryData.initArray();
        const startTimeStamp = clamp(array.startTimestamp || 0, 0, Date.now());
        queryArray.setStartTimestamp(capnp.Uint64.fromNumber(startTimeStamp));
        const endTimeStamp = clamp(array.endTimestamp || Date.now(), 0, Date.now());
        queryArray.setEndTimestamp(capnp.Uint64.fromNumber(endTimeStamp));
        queryArray.setQueryType(array.queryType || "");
        queryArray.setUri(array.uri || "");
    }
    return message.toArrayBuffer();
};
const add = (a, b) => a + b;
const serializeDomainArray = (domainArray, data) => {
    const { float32 = [], float64 = [], int8 = [], int16 = [], int32 = [], int64 = [], uint8 = [], uint16 = [], uint32 = [], uint64 = [] } = data;
    const dFloat32 = domainArray.initFloat32(float32.length);
    float32.forEach((num, i) => {
        dFloat32.set(i, num);
    });
    const dFloat64 = domainArray.initFloat64(float64.length);
    float64.forEach((num, i) => {
        dFloat64.set(i, num);
    });
    const dInt8 = domainArray.initInt8(int8.length);
    int8.forEach((num, i) => {
        dInt8.set(i, num);
    });
    const dInt16 = domainArray.initInt16(int16.length);
    int16.forEach((num, i) => {
        dInt16.set(i, num);
    });
    const dInt32 = domainArray.initInt32(int32.length);
    int32.forEach((num, i) => {
        dInt32.set(i, num);
    });
    const dInt64 = domainArray.initInt64(int64.length);
    int64.forEach((num, i) => {
        dInt64.set(i, capnp.Int64.fromNumber(num));
    });
    const dUint8 = domainArray.initUint8(uint8.length);
    uint8.forEach((num, i) => {
        dUint8.set(i, num);
    });
    const dUint16 = domainArray.initUint16(uint16.length);
    uint16.forEach((num, i) => {
        dUint16.set(i, num);
    });
    const dUint32 = domainArray.initUint32(uint32.length);
    uint32.forEach((num, i) => {
        dUint32.set(i, num);
    });
    const dUint64 = domainArray.initUint64(uint64.length);
    uint64.forEach((num, i) => {
        dUint64.set(i, capnp.Uint64.fromNumber(num));
    });
};
const serializeSubArray = (capSubArray, subArray) => {
    const { ranges = [], layout = "" } = subArray;
    capSubArray.setLayout(layout);
    const capRanges = capSubArray.initRanges(ranges.length);
    ranges.forEach((range, i) => {
        const r = capRanges.get(i);
        const bufferSizesArray = range.bufferSizes || [];
        r.setType(range.type);
        r.setHasDefaultRange(range.hasDefaultRange);
        const totalBufferSize = bufferSizesArray.reduce(add);
        const bufferData = r.initBuffer(totalBufferSize);
        const view = Uint8Array.from(range.buffer);
        bufferData.copyBuffer(view);
        r.setBuffer(bufferData);
        const bufferSizes = r.initBufferSizes(bufferSizesArray.length);
        bufferSizesArray.forEach((bsize, i) => {
            bufferSizes.set(i, capnp.Uint64.fromNumber(bsize));
        });
        r.setBufferSizes(bufferSizes);
        const bufferStartSizesArray = range.bufferStartSizes || [];
        const bufferStartSizes = r.initBufferStartSizes(bufferStartSizesArray.length);
        bufferStartSizesArray.forEach((bsize, i) => {
            bufferStartSizes.set(i, capnp.Uint64.fromNumber(bsize));
        });
        r.setBufferStartSizes(bufferStartSizes);
    });
};
const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

const capnpSerializer = (data) => {
    if (isArrayMetadata(data)) {
        return serializeArrayMetadata(data);
    }
    else if (isQuerydata(data)) {
        return capnpQuerySerializer(data);
    }
    return data;
};
const serializeArrayMetadata = (data) => {
    const entriesLength = data.entries.length;
    const message = new capnp.Message();
    const metadata = message.initRoot(ArrayMetadata);
    const entries = metadata.initEntries(entriesLength);
    data.entries.forEach((entryData, i) => {
        const entry = entries.get(i);
        entry.setKey(entryData.key);
        entry.setType(entryData.type);
        entry.setValueNum(entryData.valueNum);
        const valueLength = entryData.value.length;
        const data = entry.initValue(valueLength);
        const arrBuffer = new ArrayBuffer(valueLength);
        const view = new Uint8Array(arrBuffer);
        entryData.value.forEach((num, i) => {
            view[i] = num;
        });
        data.copyBuffer(view);
        entry.setValue(data);
        entry.setDel(entryData.del);
    });
    return message.toArrayBuffer();
};
const isArrayMetadata = (data) => {
    if (data && Array.isArray(data.entries)) {
        return true;
    }
    return false;
};
const isQuerydata = (data) => {
    if (data && (data.reader || data.writer)) {
        return true;
    }
    return false;
};

/* tslint:disable */
/**
 *
 * @export
 */
const DUMMY_BASE_URL$1 = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists$1 = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError$1(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
/**
 *
 * @export
 */
const setApiKeyToObject$1 = function (object, keyParamName, configuration) {
    return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.apiKey) {
            const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                ? yield configuration.apiKey(keyParamName)
                : yield configuration.apiKey;
            object[keyParamName] = localVarApiKeyValue;
        }
    });
};
/**
 *
 * @export
 */
const setBasicAuthToObject$1 = function (object, configuration) {
    if (configuration && (configuration.username || configuration.password)) {
        object["auth"] = { username: configuration.username, password: configuration.password };
    }
};
/**
 *
 * @export
 */
const setSearchParams$1 = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    for (const object of objects) {
        for (const key in object) {
            if (Array.isArray(object[key])) {
                searchParams.delete(key);
                for (const item of object[key]) {
                    searchParams.append(key, item);
                }
            }
            else {
                searchParams.set(key, object[key]);
            }
        }
    }
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const serializeDataIfNeeded$1 = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsJSONSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    if (needsJSONSerialization) {
        return JSON.stringify(value !== undefined ? value : {});
    }
    const needsCapnpSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isCapnpMime(requestOptions.headers['Content-Type'])
        : nonString;
    if (needsCapnpSerialization) {
        return value !== undefined ? capnpSerializer(value) : '';
    }
    return value || "";
};
/**
 *
 * @export
 */
const toPathString$1 = function (url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction$1 = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + axiosArgs.url });
        return axios.request(axiosRequestArgs);
    };
};

/* tslint:disable */
/**
 * Type of activity logged
 * @export
 * @enum {string}
 */
var ActivityEventType$1;
(function (ActivityEventType) {
    ActivityEventType["ReadSchema"] = "read_schema";
    ActivityEventType["MaxBufferSizes"] = "max_buffer_sizes";
    ActivityEventType["NonEmptyDomain"] = "non_empty_domain";
    ActivityEventType["QueryRead"] = "query_read";
    ActivityEventType["QueryWrite"] = "query_write";
    ActivityEventType["Create"] = "create";
    ActivityEventType["Delete"] = "delete";
    ActivityEventType["Register"] = "register";
    ActivityEventType["Deregister"] = "deregister";
    ActivityEventType["Udf"] = "udf";
    ActivityEventType["ArrayMetadataGet"] = "array_metadata_get";
    ActivityEventType["ArrayMetadataUpdate"] = "array_metadata_update";
    ActivityEventType["EstimatedResultSizes"] = "estimated_result_sizes";
})(ActivityEventType$1 || (ActivityEventType$1 = {}));
/**
 * actions a user can take on an array
 * @export
 * @enum {string}
 */
var ArrayActions;
(function (ArrayActions) {
    ArrayActions["Read"] = "read";
    ArrayActions["Write"] = "write";
    ArrayActions["Edit"] = "edit";
    ArrayActions["ReadArrayLogs"] = "read_array_logs";
    ArrayActions["ReadArrayInfo"] = "read_array_info";
    ArrayActions["ReadArraySchema"] = "read_array_schema";
})(ArrayActions || (ArrayActions = {}));
/**
 * Status of array task
 * @export
 * @enum {string}
 */
var ArrayTaskStatus;
(function (ArrayTaskStatus) {
    ArrayTaskStatus["Queued"] = "QUEUED";
    ArrayTaskStatus["Failed"] = "FAILED";
    ArrayTaskStatus["Completed"] = "COMPLETED";
    ArrayTaskStatus["Running"] = "RUNNING";
    ArrayTaskStatus["ResourcesUnavailable"] = "RESOURCES_UNAVAILABLE";
    ArrayTaskStatus["Unknown"] = "UNKNOWN";
    ArrayTaskStatus["Cancelled"] = "CANCELLED";
    ArrayTaskStatus["Denied"] = "DENIED";
})(ArrayTaskStatus || (ArrayTaskStatus = {}));
/**
 * Synchronous Task Type
 * @export
 * @enum {string}
 */
var ArrayTaskType;
(function (ArrayTaskType) {
    ArrayTaskType["Sql"] = "SQL";
    ArrayTaskType["Udf"] = "UDF";
    ArrayTaskType["Query"] = "QUERY";
    ArrayTaskType["GenericUdf"] = "GENERIC_UDF";
    ArrayTaskType["ClientComputation"] = "CLIENT_COMPUTATION";
})(ArrayTaskType || (ArrayTaskType = {}));
/**
 * TileDB array type
 * @export
 * @enum {string}
 */
var ArrayType;
(function (ArrayType) {
    ArrayType["Dense"] = "dense";
    ArrayType["Sparse"] = "sparse";
})(ArrayType || (ArrayType = {}));
/**
 * TileDB data type
 * @export
 * @enum {string}
 */
var Datatype$1;
(function (Datatype) {
    Datatype["Int32"] = "INT32";
    Datatype["Int64"] = "INT64";
    Datatype["Float32"] = "FLOAT32";
    Datatype["Float64"] = "FLOAT64";
    Datatype["Char"] = "CHAR";
    Datatype["Int8"] = "INT8";
    Datatype["Uint8"] = "UINT8";
    Datatype["Int16"] = "INT16";
    Datatype["Uint16"] = "UINT16";
    Datatype["Uint32"] = "UINT32";
    Datatype["Uint64"] = "UINT64";
    Datatype["StringAscii"] = "STRING_ASCII";
    Datatype["StringUtf8"] = "STRING_UTF8";
    Datatype["StringUtf16"] = "STRING_UTF16";
    Datatype["StringUtf32"] = "STRING_UTF32";
    Datatype["StringUcs2"] = "STRING_UCS2";
    Datatype["StringUcs4"] = "STRING_UCS4";
    Datatype["Any"] = "ANY";
})(Datatype$1 || (Datatype$1 = {}));
/**
 * File property assigned to a specific file (array)
 * @export
 * @enum {string}
 */
var FilePropertyName;
(function (FilePropertyName) {
    FilePropertyName["Image"] = "image";
    FilePropertyName["Size"] = "size";
    FilePropertyName["CodeBlock"] = "code_block";
    FilePropertyName["UdfLanguage"] = "udf_language";
    FilePropertyName["IsDashboard"] = "is_dashboard";
})(FilePropertyName || (FilePropertyName = {}));
/**
 * File types represented as TileDB arrays
 * @export
 * @enum {string}
 */
var FileType;
(function (FileType) {
    FileType["Notebook"] = "notebook";
    FileType["UserDefinedFunction"] = "user_defined_function";
    FileType["MlModel"] = "ml_model";
    FileType["File"] = "file";
    FileType["RegisteredTaskGraph"] = "registered_task_graph";
})(FileType || (FileType = {}));
/**
 * TileDB filter option
 * @export
 * @enum {string}
 */
var FilterOption;
(function (FilterOption) {
    FilterOption["CompressionLevel"] = "COMPRESSION_LEVEL";
    FilterOption["BitWidthMaxWindow"] = "BIT_WIDTH_MAX_WINDOW";
    FilterOption["PositiveDeltaMaxWindow"] = "POSITIVE_DELTA_MAX_WINDOW";
})(FilterOption || (FilterOption = {}));
/**
 * TileDB filter types
 * @export
 * @enum {string}
 */
var FilterType;
(function (FilterType) {
    FilterType["None"] = "FILTER_NONE";
    FilterType["Gzip"] = "FILTER_GZIP";
    FilterType["Zstd"] = "FILTER_ZSTD";
    FilterType["Lz4"] = "FILTER_LZ4";
    FilterType["Rle"] = "FILTER_RLE";
    FilterType["Bzip2"] = "FILTER_BZIP2";
    FilterType["DoubleDelta"] = "FILTER_DOUBLE_DELTA";
    FilterType["BitWidthReduction"] = "FILTER_BIT_WIDTH_REDUCTION";
    FilterType["Bitshuffle"] = "FILTER_BITSHUFFLE";
    FilterType["Byteshuffle"] = "FILTER_BYTESHUFFLE";
    FilterType["PositiveDelta"] = "FILTER_POSITIVE_DELTA";
})(FilterType || (FilterType = {}));
/**
 * actions a user can take on a group
 * @export
 * @enum {string}
 */
var GroupActions;
(function (GroupActions) {
    GroupActions["Read"] = "read";
    GroupActions["Write"] = "write";
    GroupActions["Edit"] = "edit";
})(GroupActions || (GroupActions = {}));
/**
 * Specific file types of group members
 * @export
 * @enum {string}
 */
var GroupMemberAssetType$1;
(function (GroupMemberAssetType) {
    GroupMemberAssetType["Group"] = "group";
    GroupMemberAssetType["Array"] = "array";
    GroupMemberAssetType["Notebook"] = "notebook";
    GroupMemberAssetType["Dashboard"] = "dashboard";
    GroupMemberAssetType["UserDefinedFunction"] = "user_defined_function";
    GroupMemberAssetType["MlModel"] = "ml_model";
    GroupMemberAssetType["File"] = "file";
})(GroupMemberAssetType$1 || (GroupMemberAssetType$1 = {}));
/**
 * File types that can be included in groups
 * @export
 * @enum {string}
 */
var GroupMemberType$1;
(function (GroupMemberType) {
    GroupMemberType["Group"] = "group";
    GroupMemberType["Array"] = "array";
})(GroupMemberType$1 || (GroupMemberType$1 = {}));
/**
 * List of values that InvitationStatus can take
 * @export
 * @enum {string}
 */
var InvitationStatus;
(function (InvitationStatus) {
    InvitationStatus["Pending"] = "PENDING";
    InvitationStatus["Accepted"] = "ACCEPTED";
})(InvitationStatus || (InvitationStatus = {}));
/**
 * List of values that InvitationType can take
 * @export
 * @enum {string}
 */
var InvitationType;
(function (InvitationType) {
    InvitationType["ArrayShare"] = "ARRAY_SHARE";
    InvitationType["JoinOrganization"] = "JOIN_ORGANIZATION";
})(InvitationType || (InvitationType = {}));
/**
 * Layout of array
 * @export
 * @enum {string}
 */
var Layout$1;
(function (Layout) {
    Layout["RowMajor"] = "row-major";
    Layout["ColMajor"] = "col-major";
    Layout["GlobalOrder"] = "global-order";
    Layout["Unordered"] = "unordered";
})(Layout$1 || (Layout$1 = {}));
/**
 * actions a user can take on an organization
 * @export
 * @enum {string}
 */
var NamespaceActions;
(function (NamespaceActions) {
    NamespaceActions["Read"] = "read";
    NamespaceActions["Write"] = "write";
    NamespaceActions["Create"] = "create";
    NamespaceActions["Delete"] = "delete";
    NamespaceActions["Edit"] = "edit";
    NamespaceActions["ReadArrayLogs"] = "read_array_logs";
    NamespaceActions["ReadJobLogs"] = "read_job_logs";
    NamespaceActions["ReadObjectLogs"] = "read_object_logs";
    NamespaceActions["RunJob"] = "run_job";
    NamespaceActions["DeleteOrganization"] = "delete_organization";
    NamespaceActions["EditOrganization"] = "edit_organization";
    NamespaceActions["EditBilling"] = "edit_billing";
})(NamespaceActions || (NamespaceActions = {}));
/**
 * role user has in organization
 * @export
 * @enum {string}
 */
var OrganizationRoles;
(function (OrganizationRoles) {
    OrganizationRoles["Owner"] = "owner";
    OrganizationRoles["Admin"] = "admin";
    OrganizationRoles["ReadWrite"] = "read_write";
    OrganizationRoles["ReadOnly"] = "read_only";
})(OrganizationRoles || (OrganizationRoles = {}));
/**
 * Specifies a usage aggregation strategy for pricings of usage_type=metered
 * @export
 * @enum {string}
 */
var PricingAggregateUsage;
(function (PricingAggregateUsage) {
    PricingAggregateUsage["Sum"] = "sum";
})(PricingAggregateUsage || (PricingAggregateUsage = {}));
/**
 * Currency of pricing
 * @export
 * @enum {string}
 */
var PricingCurrency;
(function (PricingCurrency) {
    PricingCurrency["Usd"] = "USD";
})(PricingCurrency || (PricingCurrency = {}));
/**
 * Interval for pricing
 * @export
 * @enum {string}
 */
var PricingInterval;
(function (PricingInterval) {
    PricingInterval["Month"] = "month";
})(PricingInterval || (PricingInterval = {}));
/**
 * Pricing types
 * @export
 * @enum {string}
 */
var PricingType;
(function (PricingType) {
    PricingType["Egress"] = "egress";
    PricingType["Access"] = "access";
})(PricingType || (PricingType = {}));
/**
 * Unit label
 * @export
 * @enum {string}
 */
var PricingUnitLabel;
(function (PricingUnitLabel) {
    PricingUnitLabel["Byte"] = "byte";
    PricingUnitLabel["Second"] = "second";
})(PricingUnitLabel || (PricingUnitLabel = {}));
/**
 * Query parameter to get array metadatas
 * @export
 * @enum {string}
 */
var PublicShareFilter;
(function (PublicShareFilter) {
    PublicShareFilter["Exclude"] = "exclude";
    PublicShareFilter["Only"] = "only";
})(PublicShareFilter || (PublicShareFilter = {}));
/**
 * Status of query
 * @export
 * @enum {string}
 */
var Querystatus$1;
(function (Querystatus) {
    Querystatus["Failed"] = "FAILED";
    Querystatus["Completed"] = "COMPLETED";
    Querystatus["Inprogress"] = "INPROGRESS";
    Querystatus["Incomplete"] = "INCOMPLETE";
    Querystatus["Uninitialized"] = "UNINITIALIZED";
})(Querystatus$1 || (Querystatus$1 = {}));
/**
 * Type of query
 * @export
 * @enum {string}
 */
var Querytype$1;
(function (Querytype) {
    Querytype["Read"] = "READ";
    Querytype["Write"] = "WRITE";
})(Querytype$1 || (Querytype$1 = {}));
/**
 * Data format of a result
 * @export
 * @enum {string}
 */
var ResultFormat;
(function (ResultFormat) {
    ResultFormat["PythonPickle"] = "python_pickle";
    ResultFormat["RSerialization"] = "r_serialization";
    ResultFormat["Json"] = "json";
    ResultFormat["Arrow"] = "arrow";
    ResultFormat["Bytes"] = "bytes";
    ResultFormat["TiledbJson"] = "tiledb_json";
    ResultFormat["Native"] = "native";
})(ResultFormat || (ResultFormat = {}));
/**
 * Single sign on provider
 * @export
 * @enum {string}
 */
var SSOProvider;
(function (SSOProvider) {
    SSOProvider["Github"] = "github";
    SSOProvider["Google"] = "google";
    SSOProvider["Stripe"] = "stripe";
    SSOProvider["Okta"] = "okta";
})(SSOProvider || (SSOProvider = {}));
/**
 * actions a user can take on a UDF
 * @export
 * @enum {string}
 */
var TaskGraphActions;
(function (TaskGraphActions) {
    TaskGraphActions["FetchTaskGraph"] = "fetch_task_graph";
    TaskGraphActions["ShareTaskGraph"] = "share_task_graph";
})(TaskGraphActions || (TaskGraphActions = {}));
/**
 * The location where an individual node of a task graph is executed.
 * @export
 * @enum {string}
 */
var TaskGraphLogRunLocation;
(function (TaskGraphLogRunLocation) {
    TaskGraphLogRunLocation["Server"] = "server";
    TaskGraphLogRunLocation["Client"] = "client";
    TaskGraphLogRunLocation["Virtual"] = "virtual";
})(TaskGraphLogRunLocation || (TaskGraphLogRunLocation = {}));
/**
 * The status of a given task graph execution.
 * @export
 * @enum {string}
 */
var TaskGraphLogStatus;
(function (TaskGraphLogStatus) {
    TaskGraphLogStatus["Submitted"] = "submitted";
    TaskGraphLogStatus["Running"] = "running";
    TaskGraphLogStatus["Idle"] = "idle";
    TaskGraphLogStatus["Abandoned"] = "abandoned";
    TaskGraphLogStatus["Succeeded"] = "succeeded";
    TaskGraphLogStatus["Failed"] = "failed";
    TaskGraphLogStatus["Cancelled"] = "cancelled";
})(TaskGraphLogStatus || (TaskGraphLogStatus = {}));
/**
 * An api token scope available for creation
 * @export
 * @enum {string}
 */
var TokenScope;
(function (TokenScope) {
    TokenScope["PasswordReset"] = "password_reset";
    TokenScope["ConfirmEmail"] = "confirm_email";
    TokenScope["Star"] = "*";
    TokenScope["Userread"] = "user:read";
    TokenScope["UserreadWrite"] = "user:read-write";
    TokenScope["Useradmin"] = "user:admin";
    TokenScope["Arrayread"] = "array:read";
    TokenScope["ArrayreadWrite"] = "array:read-write";
    TokenScope["Arrayadmin"] = "array:admin";
    TokenScope["Organizationread"] = "organization:read";
    TokenScope["OrganizationreadWrite"] = "organization:read-write";
    TokenScope["Organizationadmin"] = "organization:admin";
    TokenScope["Groupread"] = "group:read";
    TokenScope["GroupreadWrite"] = "group:read-write";
    TokenScope["Groupadmin"] = "group:admin";
})(TokenScope || (TokenScope = {}));
/**
 * actions a user can take on a UDF
 * @export
 * @enum {string}
 */
var UDFActions;
(function (UDFActions) {
    UDFActions["FetchUdf"] = "fetch_udf";
    UDFActions["ShareUdf"] = "share_udf";
})(UDFActions || (UDFActions = {}));
/**
 * UDF Type
 * @export
 * @enum {string}
 */
var UDFLanguage;
(function (UDFLanguage) {
    UDFLanguage["Python"] = "python";
    UDFLanguage["R"] = "r";
})(UDFLanguage || (UDFLanguage = {}));
/**
 * UDF Type
 * @export
 * @enum {string}
 */
var UDFType;
(function (UDFType) {
    UDFType["MultiArray"] = "multi_array";
    UDFType["SingleArray"] = "single_array";
    UDFType["Generic"] = "generic";
})(UDFType || (UDFType = {}));
/**
 * ArrayApi - axios parameter creator
 * @export
 */
const ArrayApiAxiosParamCreator$1 = function (configuration) {
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task ID To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog: (namespace, array, start, end, eventTypes, taskId, hasTaskId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('arrayActivityLog', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('arrayActivityLog', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/activity`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (eventTypes !== undefined) {
                localVarQueryParameter['event_types'] = eventTypes;
            }
            if (taskId !== undefined) {
                localVarQueryParameter['task_id'] = taskId;
            }
            if (hasTaskId !== undefined) {
                localVarQueryParameter['has_task_id'] = hasTaskId;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/owned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            if (fileProperty) {
                localVarQueryParameter['file_property'] = fileProperty;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/owned/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            if (fileProperty) {
                localVarQueryParameter['file_property'] = fileProperty;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/public/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {Array<string>} [sharedTo] namespaces to filter results of where there arrays were shared to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, sharedTo, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/shared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            if (fileProperty) {
                localVarQueryParameter['file_property'] = fileProperty;
            }
            if (sharedTo) {
                localVarQueryParameter['shared_to'] = sharedTo;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/shared/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysNamespaceArrayEndTimestampsGet: (namespace, array, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('arraysNamespaceArrayEndTimestampsGet', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('arraysNamespaceArrayEndTimestampsGet', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/end_timestamps`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consolidateArray: (namespace, array, tiledbConfig, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('consolidateArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('consolidateArray', 'array', array);
            // verify required parameter 'tiledbConfig' is not null or undefined
            assertParamExists$1('consolidateArray', 'tiledbConfig', tiledbConfig);
            const localVarPath = `/arrays/{namespace}/{array}/consolidate`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(tiledbConfig, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray: (namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('createArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('createArray', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists$1('createArray', 'contentType', contentType);
            // verify required parameter 'arraySchema' is not null or undefined
            assertParamExists$1('createArray', 'arraySchema', arraySchema);
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(arraySchema, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray: (namespace, array, contentType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('deleteArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('deleteArray', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists$1('deleteArray', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('deregisterArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('deregisterArray', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/deregister`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get activity log by ID
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} id ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityLogById: (namespace, array, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getActivityLogById', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('getActivityLogById', 'array', array);
            // verify required parameter 'id' is not null or undefined
            assertParamExists$1('getActivityLogById', 'id', id);
            const localVarPath = `/arrays/{namespace}/{array}/activity/{id}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata: (publicShare, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (publicShare !== undefined) {
                localVarQueryParameter['public_share'] = publicShare;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray: (namespace, array, contentType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('getArray', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists$1('getArray', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes: (namespace, array, subarray, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getArrayMaxBufferSizes', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('getArrayMaxBufferSizes', 'array', array);
            // verify required parameter 'subarray' is not null or undefined
            assertParamExists$1('getArrayMaxBufferSizes', 'subarray', subarray);
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists$1('getArrayMaxBufferSizes', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}/max_buffer_sizes`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (subarray !== undefined) {
                localVarQueryParameter['subarray'] = subarray;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata from the array in JSON format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson: (namespace, array, length, endTimestamp, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getArrayMetaDataJson', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('getArrayMetaDataJson', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/metadata_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }
            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getArrayMetadata', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('getArrayMetadata', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadataCapnp: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getArrayMetadataCapnp', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('getArrayMetadataCapnp', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/array_metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain: (namespace, array, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getArrayNonEmptyDomain', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('getArrayNonEmptyDomain', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists$1('getArrayNonEmptyDomain', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}/non_empty_domain`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomainJson: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getArrayNonEmptyDomainJson', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('getArrayNonEmptyDomainJson', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/non_empty_domain_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData: (namespace, array, samples, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getArraySampleData', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('getArraySampleData', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/sample`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (samples !== undefined) {
                localVarQueryParameter['samples'] = samples;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getArraySharingPolicies', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('getArraySharingPolicies', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getArraysInNamespace', 'namespace', namespace);
            const localVarPath = `/arrays/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFragmentEndTimestamp: (namespace, array, endTimestamp, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getFragmentEndTimestamp', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('getFragmentEndTimestamp', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/fragment_end_timestamp`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/last_accessed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray: (namespace, array, arrayMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('registerArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('registerArray', 'array', array);
            // verify required parameter 'arrayMetadata' is not null or undefined
            assertParamExists$1('registerArray', 'arrayMetadata', arrayMetadata);
            const localVarPath = `/arrays/{namespace}/{array}/register`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(arrayMetadata, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray: (namespace, array, arraySharing, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('shareArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('shareArray', 'array', array);
            // verify required parameter 'arraySharing' is not null or undefined
            assertParamExists$1('shareArray', 'arraySharing', arraySharing);
            const localVarPath = `/arrays/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(arraySharing, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata: (namespace, array, arrayMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('updateArrayMetadata', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('updateArrayMetadata', 'array', array);
            // verify required parameter 'arrayMetadata' is not null or undefined
            assertParamExists$1('updateArrayMetadata', 'arrayMetadata', arrayMetadata);
            const localVarPath = `/arrays/{namespace}/{array}/metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(arrayMetadata, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadataCapnp: (namespace, array, arrayMetadataEntries, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('updateArrayMetadataCapnp', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('updateArrayMetadataCapnp', 'array', array);
            // verify required parameter 'arrayMetadataEntries' is not null or undefined
            assertParamExists$1('updateArrayMetadataCapnp', 'arrayMetadataEntries', arrayMetadataEntries);
            const localVarPath = `/arrays/{namespace}/{array}/array_metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(arrayMetadataEntries, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vacuumArray: (namespace, array, tiledbConfig, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('vacuumArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('vacuumArray', 'array', array);
            // verify required parameter 'tiledbConfig' is not null or undefined
            assertParamExists$1('vacuumArray', 'tiledbConfig', tiledbConfig);
            const localVarPath = `/arrays/{namespace}/{array}/vacuum`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(tiledbConfig, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ArrayApi - functional programming interface
 * @export
 */
const ArrayApiFp$1 = function (configuration) {
    const localVarAxiosParamCreator = ArrayApiAxiosParamCreator$1(configuration);
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task ID To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserOwnedSidebarGet(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserPublicSidebarGet(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {Array<string>} [sharedTo] namespaces to filter results of where there arrays were shared to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, sharedTo, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, sharedTo, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserSharedSidebarGet(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consolidateArray(namespace, array, tiledbConfig, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.consolidateArray(namespace, array, tiledbConfig, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray(namespace, array, contentType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteArray(namespace, array, contentType, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deregisterArray(namespace, array, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get activity log by ID
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} id ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityLogById(namespace, array, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getActivityLogById(namespace, array, id, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata(publicShare, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllArrayMetadata(publicShare, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray(namespace, array, contentType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArray(namespace, array, contentType, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get metadata from the array in JSON format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson(namespace, array, length, endTimestamp, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetaDataJson(namespace, array, length, endTimestamp, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetadata(namespace, array, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadataCapnp(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetadataCapnp(namespace, array, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomainJson(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayNonEmptyDomainJson(namespace, array, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData(namespace, array, samples, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraySampleData(namespace, array, samples, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraySharingPolicies(namespace, array, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraysInNamespace(namespace, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFragmentEndTimestamp(namespace, array, endTimestamp, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFragmentEndTimestamp(namespace, array, endTimestamp, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLastAccessedArrays(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray(namespace, array, arrayMetadata, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerArray(namespace, array, arrayMetadata, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray(namespace, array, arraySharing, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareArray(namespace, array, arraySharing, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata(namespace, array, arrayMetadata, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateArrayMetadata(namespace, array, arrayMetadata, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vacuumArray(namespace, array, tiledbConfig, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.vacuumArray(namespace, array, tiledbConfig, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * ArrayApi - factory interface
 * @export
 */
const ArrayApiFactory$1 = function (configuration, basePath, axios) {
    const localVarFp = ArrayApiFp$1(configuration);
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task ID To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {
            return localVarFp.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
            return localVarFp.arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet(options) {
            return localVarFp.arraysBrowserOwnedSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
            return localVarFp.arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet(options) {
            return localVarFp.arraysBrowserPublicSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {Array<string>} [sharedTo] namespaces to filter results of where there arrays were shared to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, sharedTo, options) {
            return localVarFp.arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, sharedTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet(options) {
            return localVarFp.arraysBrowserSharedSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
            return localVarFp.arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consolidateArray(namespace, array, tiledbConfig, options) {
            return localVarFp.consolidateArray(namespace, array, tiledbConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return localVarFp.createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray(namespace, array, contentType, options) {
            return localVarFp.deleteArray(namespace, array, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray(namespace, array, options) {
            return localVarFp.deregisterArray(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get activity log by ID
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} id ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityLogById(namespace, array, id, options) {
            return localVarFp.getActivityLogById(namespace, array, id, options).then((request) => request(axios, basePath));
        },
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata(publicShare, options) {
            return localVarFp.getAllArrayMetadata(publicShare, options).then((request) => request(axios, basePath));
        },
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray(namespace, array, contentType, options) {
            return localVarFp.getArray(namespace, array, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {
            return localVarFp.getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata from the array in JSON format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson(namespace, array, length, endTimestamp, options) {
            return localVarFp.getArrayMetaDataJson(namespace, array, length, endTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata(namespace, array, options) {
            return localVarFp.getArrayMetadata(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadataCapnp(namespace, array, options) {
            return localVarFp.getArrayMetadataCapnp(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {
            return localVarFp.getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomainJson(namespace, array, options) {
            return localVarFp.getArrayNonEmptyDomainJson(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData(namespace, array, samples, options) {
            return localVarFp.getArraySampleData(namespace, array, samples, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies(namespace, array, options) {
            return localVarFp.getArraySharingPolicies(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace(namespace, options) {
            return localVarFp.getArraysInNamespace(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFragmentEndTimestamp(namespace, array, endTimestamp, options) {
            return localVarFp.getFragmentEndTimestamp(namespace, array, endTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays(options) {
            return localVarFp.getLastAccessedArrays(options).then((request) => request(axios, basePath));
        },
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray(namespace, array, arrayMetadata, options) {
            return localVarFp.registerArray(namespace, array, arrayMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray(namespace, array, arraySharing, options) {
            return localVarFp.shareArray(namespace, array, arraySharing, options).then((request) => request(axios, basePath));
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata(namespace, array, arrayMetadata, options) {
            return localVarFp.updateArrayMetadata(namespace, array, arrayMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options) {
            return localVarFp.updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options).then((request) => request(axios, basePath));
        },
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vacuumArray(namespace, array, tiledbConfig, options) {
            return localVarFp.vacuumArray(namespace, array, tiledbConfig, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
let ArrayApi$1 = class ArrayApi extends BaseAPI$1 {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task ID To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {
        return ArrayApiFp$1(this.configuration).arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that are owned directly by user or user\'s organizations
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
        return ArrayApiFp$1(this.configuration).arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserOwnedSidebarGet(options) {
        return ArrayApiFp$1(this.configuration).arraysBrowserOwnedSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that have been shared publically
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
        return ArrayApiFp$1(this.configuration).arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a sidebar of all arrays that have been shared publically
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserPublicSidebarGet(options) {
        return ArrayApiFp$1(this.configuration).arraysBrowserPublicSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {Array<string>} [sharedTo] namespaces to filter results of where there arrays were shared to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, sharedTo, options) {
        return ArrayApiFp$1(this.configuration).arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, sharedTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserSharedSidebarGet(options) {
        return ArrayApiFp$1(this.configuration).arraysBrowserSharedSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
        return ArrayApiFp$1(this.configuration).arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * consolidate an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    consolidateArray(namespace, array, tiledbConfig, options) {
        return ArrayApiFp$1(this.configuration).consolidateArray(namespace, array, tiledbConfig, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * create a array schema at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArraySchema} arraySchema ArraySchema being created
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
        return ArrayApiFp$1(this.configuration).createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    deleteArray(namespace, array, contentType, options) {
        return ArrayApiFp$1(this.configuration).deleteArray(namespace, array, contentType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * deregister a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    deregisterArray(namespace, array, options) {
        return ArrayApiFp$1(this.configuration).deregisterArray(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get activity log by ID
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} id ID of the activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getActivityLogById(namespace, array, id, options) {
        return ArrayApiFp$1(this.configuration).getActivityLogById(namespace, array, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get all array metadata user has access to
     * @param {string} [publicShare] Public share values can be one of exclude, only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getAllArrayMetadata(publicShare, options) {
        return ArrayApiFp$1(this.configuration).getAllArrayMetadata(publicShare, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get an ArraySchema using a url encoded uri
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArray(namespace, array, contentType, options) {
        return ArrayApiFp$1(this.configuration).getArray(namespace, array, contentType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get the max buffer sizes of an array for a subarray
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} subarray CSV string of subarray to get max buffer sizes for
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {
        return ArrayApiFp$1(this.configuration).getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata from the array in JSON format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [length] (optional) limit character length of returned values
     * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetaDataJson(namespace, array, length, endTimestamp, options) {
        return ArrayApiFp$1(this.configuration).getArrayMetaDataJson(namespace, array, length, endTimestamp, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetadata(namespace, array, options) {
        return ArrayApiFp$1(this.configuration).getArrayMetadata(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetadataCapnp(namespace, array, options) {
        return ArrayApiFp$1(this.configuration).getArrayMetadataCapnp(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get the non empty domain of an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {
        return ArrayApiFp$1(this.configuration).getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get non-empty domain from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayNonEmptyDomainJson(namespace, array, options) {
        return ArrayApiFp$1(this.configuration).getArrayNonEmptyDomainJson(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get an sample set of data from the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [samples] Number of sample results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraySampleData(namespace, array, samples, options) {
        return ArrayApiFp$1(this.configuration).getArraySampleData(namespace, array, samples, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all sharing details of the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraySharingPolicies(namespace, array, options) {
        return ArrayApiFp$1(this.configuration).getArraySharingPolicies(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata on all arrays in a namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraysInNamespace(namespace, options) {
        return ArrayApiFp$1(this.configuration).getArraysInNamespace(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [endTimestamp] Milliseconds since Unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getFragmentEndTimestamp(namespace, array, endTimestamp, options) {
        return ArrayApiFp$1(this.configuration).getFragmentEndTimestamp(namespace, array, endTimestamp, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getLastAccessedArrays(options) {
        return ArrayApiFp$1(this.configuration).getLastAccessedArrays(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * register an array at a specified URI registered to the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    registerArray(namespace, array, arrayMetadata, options) {
        return ArrayApiFp$1(this.configuration).registerArray(namespace, array, arrayMetadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Share an array with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    shareArray(namespace, array, arraySharing, options) {
        return ArrayApiFp$1(this.configuration).shareArray(namespace, array, arraySharing, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    updateArrayMetadata(namespace, array, arrayMetadata, options) {
        return ArrayApiFp$1(this.configuration).updateArrayMetadata(namespace, array, arrayMetadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options) {
        return ArrayApiFp$1(this.configuration).updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * vacuum an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    vacuumArray(namespace, array, tiledbConfig, options) {
        return ArrayApiFp$1(this.configuration).vacuumArray(namespace, array, tiledbConfig, options).then((request) => request(this.axios, this.basePath));
    }
};
/**
 * ArrayTasksApi - axios parameter creator
 * @export
 */
const ArrayTasksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar: (start, end, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tasks/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ArrayTasksApi - functional programming interface
 * @export
 */
const ArrayTasksApiFp = function (configuration) {
    const localVarAxiosParamCreator = ArrayTasksApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar(start, end, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayTasksSidebar(start, end, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * ArrayTasksApi - factory interface
 * @export
 */
const ArrayTasksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ArrayTasksApiFp(configuration);
    return {
        /**
         *
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar(start, end, options) {
            return localVarFp.getArrayTasksSidebar(start, end, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ArrayTasksApi - object-oriented interface
 * @export
 * @class ArrayTasksApi
 * @extends {BaseAPI}
 */
class ArrayTasksApi extends BaseAPI$1 {
    /**
     *
     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayTasksApi
     */
    getArrayTasksSidebar(start, end, options) {
        return ArrayTasksApiFp(this.configuration).getArrayTasksSidebar(start, end, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * FavoritesApi - axios parameter creator
 * @export
 */
const FavoritesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add a new array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArrayFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('addArrayFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('addArrayFavorite', 'name', name);
            const localVarPath = `/arrays/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add a new ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMLModelFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('addMLModelFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('addMLModelFavorite', 'name', name);
            const localVarPath = `/ml_models/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add a new notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNotebookFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('addNotebookFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('addNotebookFavorite', 'name', name);
            const localVarPath = `/notebooks/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add a new UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUDFFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('addUDFFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('addUDFFavorite', 'name', name);
            const localVarPath = `/udfs/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete specific array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArrayFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('deleteArrayFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('deleteArrayFavorite', 'name', name);
            const localVarPath = `/arrays/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete specific ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMLModelFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('deleteMLModelFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('deleteMLModelFavorite', 'name', name);
            const localVarPath = `/ml_models/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete specific notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotebookFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('deleteNotebookFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('deleteNotebookFavorite', 'name', name);
            const localVarPath = `/notebooks/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete specific UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('deleteUDFFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('deleteUDFFavorite', 'name', name);
            const localVarPath = `/udfs/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch array favorite of a specific array
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getArrayFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('getArrayFavorite', 'name', name);
            const localVarPath = `/arrays/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch ML model favorite of a specific ML model
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMLModelFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getMLModelFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('getMLModelFavorite', 'name', name);
            const localVarPath = `/ml_models/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch notebook favorite of a specific notebook
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getNotebookFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('getNotebookFavorite', 'name', name);
            const localVarPath = `/notebooks/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch UDF favorite of a specific UDF
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFFavorite: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getUDFFavorite', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('getUDFFavorite', 'name', name);
            const localVarPath = `/udfs/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a page of array favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavorites: (page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch all favorite array uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavoritesUUIDs: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/favorites/uuids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a page of ML models favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavorites: (page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ml_models/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch all favorite ML models uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavoritesUUIDs: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ml_models/favorites/uuids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a page of notebook favorites of connected user
         * @param {boolean} [isDashboard] return only dashboards
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavorites: (isDashboard, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/notebooks/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (isDashboard !== undefined) {
                localVarQueryParameter['is_dashboard'] = isDashboard;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch all favorite notebook uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavoritesUUIDs: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/notebooks/favorites/uuids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a page of UDF favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavorites: (page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/udfs/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch all favorite UDF uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavoritesUUIDs: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/udfs/favorites/uuids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * FavoritesApi - functional programming interface
 * @export
 */
const FavoritesApiFp = function (configuration) {
    const localVarAxiosParamCreator = FavoritesApiAxiosParamCreator(configuration);
    return {
        /**
         * Add a new array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArrayFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addArrayFavorite(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Add a new ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMLModelFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addMLModelFavorite(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Add a new notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNotebookFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addNotebookFavorite(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Add a new UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUDFFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addUDFFavorite(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Delete specific array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArrayFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteArrayFavorite(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Delete specific ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMLModelFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteMLModelFavorite(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Delete specific notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotebookFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteNotebookFavorite(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Delete specific UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUDFFavorite(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch array favorite of a specific array
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayFavorite(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch ML model favorite of a specific ML model
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMLModelFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMLModelFavorite(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch notebook favorite of a specific notebook
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getNotebookFavorite(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch UDF favorite of a specific UDF
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFFavorite(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUDFFavorite(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch a page of array favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavorites(page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listArrayFavorites(page, perPage, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch all favorite array uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavoritesUUIDs(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listArrayFavoritesUUIDs(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch a page of ML models favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavorites(page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listMLModelFavorites(page, perPage, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch all favorite ML models uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavoritesUUIDs(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listMLModelFavoritesUUIDs(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch a page of notebook favorites of connected user
         * @param {boolean} [isDashboard] return only dashboards
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavorites(isDashboard, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listNotebookFavorites(isDashboard, page, perPage, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch all favorite notebook uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavoritesUUIDs(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listNotebookFavoritesUUIDs(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch a page of UDF favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavorites(page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listUDFFavorites(page, perPage, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch all favorite UDF uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavoritesUUIDs(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listUDFFavoritesUUIDs(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * FavoritesApi - factory interface
 * @export
 */
const FavoritesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = FavoritesApiFp(configuration);
    return {
        /**
         * Add a new array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArrayFavorite(namespace, name, options) {
            return localVarFp.addArrayFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMLModelFavorite(namespace, name, options) {
            return localVarFp.addMLModelFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNotebookFavorite(namespace, name, options) {
            return localVarFp.addNotebookFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUDFFavorite(namespace, name, options) {
            return localVarFp.addUDFFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArrayFavorite(namespace, name, options) {
            return localVarFp.deleteArrayFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMLModelFavorite(namespace, name, options) {
            return localVarFp.deleteMLModelFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotebookFavorite(namespace, name, options) {
            return localVarFp.deleteNotebookFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFFavorite(namespace, name, options) {
            return localVarFp.deleteUDFFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch array favorite of a specific array
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayFavorite(namespace, name, options) {
            return localVarFp.getArrayFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch ML model favorite of a specific ML model
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMLModelFavorite(namespace, name, options) {
            return localVarFp.getMLModelFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch notebook favorite of a specific notebook
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookFavorite(namespace, name, options) {
            return localVarFp.getNotebookFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch UDF favorite of a specific UDF
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFFavorite(namespace, name, options) {
            return localVarFp.getUDFFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a page of array favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavorites(page, perPage, options) {
            return localVarFp.listArrayFavorites(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all favorite array uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavoritesUUIDs(options) {
            return localVarFp.listArrayFavoritesUUIDs(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a page of ML models favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavorites(page, perPage, options) {
            return localVarFp.listMLModelFavorites(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all favorite ML models uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavoritesUUIDs(options) {
            return localVarFp.listMLModelFavoritesUUIDs(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a page of notebook favorites of connected user
         * @param {boolean} [isDashboard] return only dashboards
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavorites(isDashboard, page, perPage, options) {
            return localVarFp.listNotebookFavorites(isDashboard, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all favorite notebook uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavoritesUUIDs(options) {
            return localVarFp.listNotebookFavoritesUUIDs(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a page of UDF favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavorites(page, perPage, options) {
            return localVarFp.listUDFFavorites(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all favorite UDF uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavoritesUUIDs(options) {
            return localVarFp.listUDFFavoritesUUIDs(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * FavoritesApi - object-oriented interface
 * @export
 * @class FavoritesApi
 * @extends {BaseAPI}
 */
class FavoritesApi extends BaseAPI$1 {
    /**
     * Add a new array favorite
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    addArrayFavorite(namespace, name, options) {
        return FavoritesApiFp(this.configuration).addArrayFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add a new ML model favorite
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    addMLModelFavorite(namespace, name, options) {
        return FavoritesApiFp(this.configuration).addMLModelFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add a new notebook favorite
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    addNotebookFavorite(namespace, name, options) {
        return FavoritesApiFp(this.configuration).addNotebookFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add a new UDF favorite
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    addUDFFavorite(namespace, name, options) {
        return FavoritesApiFp(this.configuration).addUDFFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete specific array favorite
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    deleteArrayFavorite(namespace, name, options) {
        return FavoritesApiFp(this.configuration).deleteArrayFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete specific ML model favorite
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    deleteMLModelFavorite(namespace, name, options) {
        return FavoritesApiFp(this.configuration).deleteMLModelFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete specific notebook favorite
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    deleteNotebookFavorite(namespace, name, options) {
        return FavoritesApiFp(this.configuration).deleteNotebookFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete specific UDF favorite
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    deleteUDFFavorite(namespace, name, options) {
        return FavoritesApiFp(this.configuration).deleteUDFFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch array favorite of a specific array
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getArrayFavorite(namespace, name, options) {
        return FavoritesApiFp(this.configuration).getArrayFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch ML model favorite of a specific ML model
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getMLModelFavorite(namespace, name, options) {
        return FavoritesApiFp(this.configuration).getMLModelFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch notebook favorite of a specific notebook
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getNotebookFavorite(namespace, name, options) {
        return FavoritesApiFp(this.configuration).getNotebookFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch UDF favorite of a specific UDF
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getUDFFavorite(namespace, name, options) {
        return FavoritesApiFp(this.configuration).getUDFFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a page of array favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listArrayFavorites(page, perPage, options) {
        return FavoritesApiFp(this.configuration).listArrayFavorites(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch all favorite array uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listArrayFavoritesUUIDs(options) {
        return FavoritesApiFp(this.configuration).listArrayFavoritesUUIDs(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a page of ML models favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listMLModelFavorites(page, perPage, options) {
        return FavoritesApiFp(this.configuration).listMLModelFavorites(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch all favorite ML models uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listMLModelFavoritesUUIDs(options) {
        return FavoritesApiFp(this.configuration).listMLModelFavoritesUUIDs(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a page of notebook favorites of connected user
     * @param {boolean} [isDashboard] return only dashboards
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listNotebookFavorites(isDashboard, page, perPage, options) {
        return FavoritesApiFp(this.configuration).listNotebookFavorites(isDashboard, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch all favorite notebook uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listNotebookFavoritesUUIDs(options) {
        return FavoritesApiFp(this.configuration).listNotebookFavoritesUUIDs(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a page of UDF favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listUDFFavorites(page, perPage, options) {
        return FavoritesApiFp(this.configuration).listUDFFavorites(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch all favorite UDF uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listUDFFavoritesUUIDs(options) {
        return FavoritesApiFp(this.configuration).listUDFFavoritesUUIDs(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * FilesApi - axios parameter creator
 * @export
 */
const FilesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCreateFile: (namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('handleCreateFile', 'namespace', namespace);
            // verify required parameter 'fileCreate' is not null or undefined
            assertParamExists$1('handleCreateFile', 'fileCreate', fileCreate);
            const localVarPath = `/files/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(fileCreate, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Export a TileDB File back to its original file format
         * @param {string} namespace The namespace of the file
         * @param {string} file The file identifier
         * @param {FileExport} fileExport Export configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExportFile: (namespace, file, fileExport, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('handleExportFile', 'namespace', namespace);
            // verify required parameter 'file' is not null or undefined
            assertParamExists$1('handleExportFile', 'file', file);
            // verify required parameter 'fileExport' is not null or undefined
            assertParamExists$1('handleExportFile', 'fileExport', fileExport);
            const localVarPath = `/files/{namespace}/{file}/export`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"file"}}`, encodeURIComponent(String(file)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(fileExport, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Upload a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {any} inputFile the file to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [outputUri] output location of the TileDB File
         * @param {string} [name] name to set for registered file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadFile: (namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('handleUploadFile', 'namespace', namespace);
            // verify required parameter 'inputFile' is not null or undefined
            assertParamExists$1('handleUploadFile', 'inputFile', inputFile);
            const localVarPath = `/files/{namespace}/upload`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            if (inputFile !== undefined) {
                localVarFormParams.append('input_file', inputFile);
            }
            if (outputUri !== undefined) {
                localVarFormParams.append('output_uri', outputUri);
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * FilesApi - functional programming interface
 * @export
 */
const FilesApiFp = function (configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Export a TileDB File back to its original file format
         * @param {string} namespace The namespace of the file
         * @param {string} file The file identifier
         * @param {FileExport} fileExport Export configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExportFile(namespace, file, fileExport, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.handleExportFile(namespace, file, fileExport, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Upload a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {any} inputFile the file to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [outputUri] output location of the TileDB File
         * @param {string} [name] name to set for registered file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadFile(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.handleUploadFile(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * FilesApi - factory interface
 * @export
 */
const FilesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = FilesApiFp(configuration);
    return {
        /**
         * Create a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return localVarFp.handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(axios, basePath));
        },
        /**
         * Export a TileDB File back to its original file format
         * @param {string} namespace The namespace of the file
         * @param {string} file The file identifier
         * @param {FileExport} fileExport Export configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExportFile(namespace, file, fileExport, options) {
            return localVarFp.handleExportFile(namespace, file, fileExport, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {any} inputFile the file to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [outputUri] output location of the TileDB File
         * @param {string} [name] name to set for registered file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadFile(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options) {
            return localVarFp.handleUploadFile(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
class FilesApi extends BaseAPI$1 {
    /**
     * Create a tiledb file at the specified location
     * @param {string} namespace The namespace of the file
     * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
        return FilesApiFp(this.configuration).handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Export a TileDB File back to its original file format
     * @param {string} namespace The namespace of the file
     * @param {string} file The file identifier
     * @param {FileExport} fileExport Export configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    handleExportFile(namespace, file, fileExport, options) {
        return FilesApiFp(this.configuration).handleExportFile(namespace, file, fileExport, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload a tiledb file at the specified location
     * @param {string} namespace The namespace of the file
     * @param {any} inputFile the file to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [outputUri] output location of the TileDB File
     * @param {string} [name] name to set for registered file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    handleUploadFile(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options) {
        return FilesApiFp(this.configuration).handleUploadFile(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * GroupsApi - axios parameter creator
 * @export
 */
const GroupsApiAxiosParamCreator$1 = function (configuration) {
    return {
        /**
         * Changes the contents of the group by adding/removing members.
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupChanges} [groupChanges]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeGroupContents: (groupNamespace, groupName, groupChanges, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists$1('changeGroupContents', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists$1('changeGroupContents', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}/contents`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(groupChanges, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {GroupCreate} [groupCreate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: (namespace, groupCreate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('createGroup', 'namespace', namespace);
            const localVarPath = `/groups/{namespace}/create`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(groupCreate, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes the group. The assets are not deleted nor are not relocated to any other group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: (groupNamespace, groupName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists$1('deleteGroup', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists$1('deleteGroup', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: (groupNamespace, groupName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists$1('getGroup', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists$1('getGroup', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the contents of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {number} [page] pagination offset for assets
         * @param {number} [perPage] pagination limit for assets
         * @param {string} [namespace] namespace to search for
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [memberType] member type to search for, more than one can be included
         * @param {Array<string>} [excludeMemberType] member type to exclude matching groups in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupContents: (groupNamespace, groupName, page, perPage, namespace, search, orderby, tag, excludeTag, memberType, excludeMemberType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists$1('getGroupContents', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists$1('getGroupContents', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}/contents`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (memberType) {
                localVarQueryParameter['member_type'] = memberType;
            }
            if (excludeMemberType) {
                localVarQueryParameter['exclude_member_type'] = excludeMemberType;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all sharing details of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupSharingPolicies: (groupNamespace, groupName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists$1('getGroupSharingPolicies', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists$1('getGroupSharingPolicies', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}/share`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserOwnedFiltersGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/groups/browser/owned/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserPublicFiltersGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/groups/browser/public/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserSharedFiltersGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/groups/browser/shared/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch data to initialize filters for the group contents
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupNamespaceGroupNameContentsFiltersGet: (groupNamespace, groupName, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists$1('groupsGroupNamespaceGroupNameContentsFiltersGet', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists$1('groupsGroupNamespaceGroupNameContentsFiltersGet', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}/contents/filters`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns one page of owned groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedGroups: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/groups/browser/owned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }
            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns one page of public groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicGroups: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/groups/browser/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }
            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns one page of shared groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {Array<string>} [sharedTo] namespaces to filter results of where there groups were shared to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedGroups: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, sharedTo, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/groups/browser/shared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }
            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }
            if (sharedTo) {
                localVarQueryParameter['shared_to'] = sharedTo;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Registers an existing group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {string} array The unique name or id of the group
         * @param {GroupRegister} [groupRegister]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGroup: (namespace, array, groupRegister, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('registerGroup', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('registerGroup', 'array', array);
            const localVarPath = `/groups/{namespace}/{array}/register`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(groupRegister, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Share a group with a namespace
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupSharingRequest} groupSharingRequest Namespace and list of permissions to share with. Sharing is recursive, it is applied to all reachable subgroups and arrays of the group. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the group will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareGroup: (groupNamespace, groupName, groupSharingRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists$1('shareGroup', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists$1('shareGroup', 'groupName', groupName);
            // verify required parameter 'groupSharingRequest' is not null or undefined
            assertParamExists$1('shareGroup', 'groupSharingRequest', groupSharingRequest);
            const localVarPath = `/groups/{group_namespace}/{group_name}/share`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(groupSharingRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Changes attributes of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupUpdate} [groupUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: (groupNamespace, groupName, groupUpdate, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists$1('updateGroup', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists$1('updateGroup', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(groupUpdate, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * GroupsApi - functional programming interface
 * @export
 */
const GroupsApiFp$1 = function (configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator$1(configuration);
    return {
        /**
         * Changes the contents of the group by adding/removing members.
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupChanges} [groupChanges]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeGroupContents(groupNamespace, groupName, groupChanges, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.changeGroupContents(groupNamespace, groupName, groupChanges, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Creates a new group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {GroupCreate} [groupCreate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(namespace, groupCreate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createGroup(namespace, groupCreate, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Deletes the group. The assets are not deleted nor are not relocated to any other group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupNamespace, groupName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteGroup(groupNamespace, groupName, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Returns the the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupNamespace, groupName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGroup(groupNamespace, groupName, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Returns the contents of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {number} [page] pagination offset for assets
         * @param {number} [perPage] pagination limit for assets
         * @param {string} [namespace] namespace to search for
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [memberType] member type to search for, more than one can be included
         * @param {Array<string>} [excludeMemberType] member type to exclude matching groups in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupContents(groupNamespace, groupName, page, perPage, namespace, search, orderby, tag, excludeTag, memberType, excludeMemberType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGroupContents(groupNamespace, groupName, page, perPage, namespace, search, orderby, tag, excludeTag, memberType, excludeMemberType, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Get all sharing details of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupSharingPolicies(groupNamespace, groupName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGroupSharingPolicies(groupNamespace, groupName, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserOwnedFiltersGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupsBrowserOwnedFiltersGet(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserPublicFiltersGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupsBrowserPublicFiltersGet(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserSharedFiltersGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupsBrowserSharedFiltersGet(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch data to initialize filters for the group contents
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace, groupName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace, groupName, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Returns one page of owned groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listOwnedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Returns one page of public groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPublicGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Returns one page of shared groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {Array<string>} [sharedTo] namespaces to filter results of where there groups were shared to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, sharedTo, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listSharedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, sharedTo, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Registers an existing group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {string} array The unique name or id of the group
         * @param {GroupRegister} [groupRegister]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGroup(namespace, array, groupRegister, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerGroup(namespace, array, groupRegister, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Share a group with a namespace
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupSharingRequest} groupSharingRequest Namespace and list of permissions to share with. Sharing is recursive, it is applied to all reachable subgroups and arrays of the group. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the group will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareGroup(groupNamespace, groupName, groupSharingRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareGroup(groupNamespace, groupName, groupSharingRequest, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Changes attributes of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupUpdate} [groupUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupNamespace, groupName, groupUpdate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateGroup(groupNamespace, groupName, groupUpdate, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * GroupsApi - factory interface
 * @export
 */
const GroupsApiFactory$1 = function (configuration, basePath, axios) {
    const localVarFp = GroupsApiFp$1(configuration);
    return {
        /**
         * Changes the contents of the group by adding/removing members.
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupChanges} [groupChanges]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeGroupContents(groupNamespace, groupName, groupChanges, options) {
            return localVarFp.changeGroupContents(groupNamespace, groupName, groupChanges, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {GroupCreate} [groupCreate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(namespace, groupCreate, options) {
            return localVarFp.createGroup(namespace, groupCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the group. The assets are not deleted nor are not relocated to any other group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupNamespace, groupName, options) {
            return localVarFp.deleteGroup(groupNamespace, groupName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupNamespace, groupName, options) {
            return localVarFp.getGroup(groupNamespace, groupName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the contents of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {number} [page] pagination offset for assets
         * @param {number} [perPage] pagination limit for assets
         * @param {string} [namespace] namespace to search for
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [memberType] member type to search for, more than one can be included
         * @param {Array<string>} [excludeMemberType] member type to exclude matching groups in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupContents(groupNamespace, groupName, page, perPage, namespace, search, orderby, tag, excludeTag, memberType, excludeMemberType, options) {
            return localVarFp.getGroupContents(groupNamespace, groupName, page, perPage, namespace, search, orderby, tag, excludeTag, memberType, excludeMemberType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sharing details of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupSharingPolicies(groupNamespace, groupName, options) {
            return localVarFp.getGroupSharingPolicies(groupNamespace, groupName, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserOwnedFiltersGet(options) {
            return localVarFp.groupsBrowserOwnedFiltersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserPublicFiltersGet(options) {
            return localVarFp.groupsBrowserPublicFiltersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch data to initialize filters for the groups browser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsBrowserSharedFiltersGet(options) {
            return localVarFp.groupsBrowserSharedFiltersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch data to initialize filters for the group contents
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace, groupName, options) {
            return localVarFp.groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace, groupName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns one page of owned groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options) {
            return localVarFp.listOwnedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns one page of public groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options) {
            return localVarFp.listPublicGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns one page of shared groups.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
         * @param {string} [parent] search only the children of the groups with this uuid
         * @param {Array<string>} [sharedTo] namespaces to filter results of where there groups were shared to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSharedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, sharedTo, options) {
            return localVarFp.listSharedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, sharedTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers an existing group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {string} array The unique name or id of the group
         * @param {GroupRegister} [groupRegister]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGroup(namespace, array, groupRegister, options) {
            return localVarFp.registerGroup(namespace, array, groupRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * Share a group with a namespace
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupSharingRequest} groupSharingRequest Namespace and list of permissions to share with. Sharing is recursive, it is applied to all reachable subgroups and arrays of the group. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the group will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareGroup(groupNamespace, groupName, groupSharingRequest, options) {
            return localVarFp.shareGroup(groupNamespace, groupName, groupSharingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes attributes of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupUpdate} [groupUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupNamespace, groupName, groupUpdate, options) {
            return localVarFp.updateGroup(groupNamespace, groupName, groupUpdate, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
let GroupsApi$1 = class GroupsApi extends BaseAPI$1 {
    /**
     * Changes the contents of the group by adding/removing members.
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupChanges} [groupChanges]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    changeGroupContents(groupNamespace, groupName, groupChanges, options) {
        return GroupsApiFp$1(this.configuration).changeGroupContents(groupNamespace, groupName, groupChanges, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new group in the namespace.
     * @param {string} namespace The namespace of the group
     * @param {GroupCreate} [groupCreate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    createGroup(namespace, groupCreate, options) {
        return GroupsApiFp$1(this.configuration).createGroup(namespace, groupCreate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the group. The assets are not deleted nor are not relocated to any other group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deleteGroup(groupNamespace, groupName, options) {
        return GroupsApiFp$1(this.configuration).deleteGroup(groupNamespace, groupName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroup(groupNamespace, groupName, options) {
        return GroupsApiFp$1(this.configuration).getGroup(groupNamespace, groupName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {number} [page] pagination offset for assets
     * @param {number} [perPage] pagination limit for assets
     * @param {string} [namespace] namespace to search for
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [memberType] member type to search for, more than one can be included
     * @param {Array<string>} [excludeMemberType] member type to exclude matching groups in results, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupContents(groupNamespace, groupName, page, perPage, namespace, search, orderby, tag, excludeTag, memberType, excludeMemberType, options) {
        return GroupsApiFp$1(this.configuration).getGroupContents(groupNamespace, groupName, page, perPage, namespace, search, orderby, tag, excludeTag, memberType, excludeMemberType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all sharing details of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupSharingPolicies(groupNamespace, groupName, options) {
        return GroupsApiFp$1(this.configuration).getGroupSharingPolicies(groupNamespace, groupName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsBrowserOwnedFiltersGet(options) {
        return GroupsApiFp$1(this.configuration).groupsBrowserOwnedFiltersGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsBrowserPublicFiltersGet(options) {
        return GroupsApiFp$1(this.configuration).groupsBrowserPublicFiltersGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch data to initialize filters for the groups browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsBrowserSharedFiltersGet(options) {
        return GroupsApiFp$1(this.configuration).groupsBrowserSharedFiltersGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch data to initialize filters for the group contents
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace, groupName, options) {
        return GroupsApiFp$1(this.configuration).groupsGroupNamespaceGroupNameContentsFiltersGet(groupNamespace, groupName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns one page of owned groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    listOwnedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options) {
        return GroupsApiFp$1(this.configuration).listOwnedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns one page of public groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    listPublicGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options) {
        return GroupsApiFp$1(this.configuration).listPublicGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns one page of shared groups.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {boolean} [flat] if true, ignores the nesting of groups and searches all of them
     * @param {string} [parent] search only the children of the groups with this uuid
     * @param {Array<string>} [sharedTo] namespaces to filter results of where there groups were shared to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    listSharedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, sharedTo, options) {
        return GroupsApiFp$1(this.configuration).listSharedGroups(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, flat, parent, sharedTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Registers an existing group in the namespace.
     * @param {string} namespace The namespace of the group
     * @param {string} array The unique name or id of the group
     * @param {GroupRegister} [groupRegister]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    registerGroup(namespace, array, groupRegister, options) {
        return GroupsApiFp$1(this.configuration).registerGroup(namespace, array, groupRegister, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Share a group with a namespace
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupSharingRequest} groupSharingRequest Namespace and list of permissions to share with. Sharing is recursive, it is applied to all reachable subgroups and arrays of the group. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the group will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    shareGroup(groupNamespace, groupName, groupSharingRequest, options) {
        return GroupsApiFp$1(this.configuration).shareGroup(groupNamespace, groupName, groupSharingRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes attributes of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupUpdate} [groupUpdate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroup(groupNamespace, groupName, groupUpdate, options) {
        return GroupsApiFp$1(this.configuration).updateGroup(groupNamespace, groupName, groupUpdate, options).then((request) => request(this.axios, this.basePath));
    }
};
/**
 * InvitationApi - axios parameter creator
 * @export
 */
const InvitationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the ID of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation: (invitation, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invitation' is not null or undefined
            assertParamExists$1('acceptInvitation', 'invitation', invitation);
            const localVarPath = `/invitations/{invitation}`
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Cancels join organization invitation
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} organization name or UUID of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization: (invitation, organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invitation' is not null or undefined
            assertParamExists$1('cancelJoinOrganization', 'invitation', invitation);
            // verify required parameter 'organization' is not null or undefined
            assertParamExists$1('cancelJoinOrganization', 'organization', organization);
            const localVarPath = `/invitations/{invitation}/{organization}/join`
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)))
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite: (namespace, invitation, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('cancelShareArrayByInvite', 'namespace', namespace);
            // verify required parameter 'invitation' is not null or undefined
            assertParamExists$1('cancelShareArrayByInvite', 'invitation', invitation);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('cancelShareArrayByInvite', 'array', array);
            const localVarPath = `/invitations/{invitation}/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or ID of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations: (organization, array, start, end, page, perPage, type, status, orderby, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (organization !== undefined) {
                localVarQueryParameter['organization'] = organization;
            }
            if (array !== undefined) {
                localVarQueryParameter['array'] = array;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or UUID of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization: (organization, emailInvite, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists$1('joinOrganization', 'organization', organization);
            // verify required parameter 'emailInvite' is not null or undefined
            assertParamExists$1('joinOrganization', 'emailInvite', emailInvite);
            const localVarPath = `/invitations/{organization}/join`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(emailInvite, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite: (namespace, array, emailInvite, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('shareArrayByInvite', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('shareArrayByInvite', 'array', array);
            // verify required parameter 'emailInvite' is not null or undefined
            assertParamExists$1('shareArrayByInvite', 'emailInvite', emailInvite);
            const localVarPath = `/invitations/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(emailInvite, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * InvitationApi - functional programming interface
 * @export
 */
const InvitationApiFp = function (configuration) {
    const localVarAxiosParamCreator = InvitationApiAxiosParamCreator(configuration);
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the ID of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(invitation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.acceptInvitation(invitation, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Cancels join organization invitation
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} organization name or UUID of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization(invitation, organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelJoinOrganization(invitation, organization, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite(namespace, invitation, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelShareArrayByInvite(namespace, invitation, array, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or ID of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or UUID of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization(organization, emailInvite, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.joinOrganization(organization, emailInvite, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite(namespace, array, emailInvite, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareArrayByInvite(namespace, array, emailInvite, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * InvitationApi - factory interface
 * @export
 */
const InvitationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = InvitationApiFp(configuration);
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the ID of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(invitation, options) {
            return localVarFp.acceptInvitation(invitation, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels join organization invitation
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} organization name or UUID of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization(invitation, organization, options) {
            return localVarFp.cancelJoinOrganization(invitation, organization, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite(namespace, invitation, array, options) {
            return localVarFp.cancelShareArrayByInvite(namespace, invitation, array, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or ID of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {
            return localVarFp.fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or UUID of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization(organization, emailInvite, options) {
            return localVarFp.joinOrganization(organization, emailInvite, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite(namespace, array, emailInvite, options) {
            return localVarFp.shareArrayByInvite(namespace, array, emailInvite, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * InvitationApi - object-oriented interface
 * @export
 * @class InvitationApi
 * @extends {BaseAPI}
 */
class InvitationApi extends BaseAPI$1 {
    /**
     * Accepts invitation
     * @param {string} invitation the ID of invitation about to be accepted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    acceptInvitation(invitation, options) {
        return InvitationApiFp(this.configuration).acceptInvitation(invitation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cancels join organization invitation
     * @param {string} invitation the ID of invitation about to be cancelled
     * @param {string} organization name or UUID of organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    cancelJoinOrganization(invitation, organization, options) {
        return InvitationApiFp(this.configuration).cancelJoinOrganization(invitation, organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cancels array sharing invitation
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} invitation the ID of invitation about to be cancelled
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    cancelShareArrayByInvite(namespace, invitation, array, options) {
        return InvitationApiFp(this.configuration).cancelShareArrayByInvite(namespace, invitation, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of invitations
     * @param {string} [organization] name or ID of organization to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
     * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
     * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {
        return InvitationApiFp(this.configuration).fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends email to multiple recipients with joining information regarding an organization
     * @param {string} organization name or UUID of organization
     * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    joinOrganization(organization, emailInvite, options) {
        return InvitationApiFp(this.configuration).joinOrganization(organization, emailInvite, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends email to multiple recipients with sharing information regarding an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {InvitationArrayShareEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    shareArrayByInvite(namespace, array, emailInvite, options) {
        return InvitationApiFp(this.configuration).shareArrayByInvite(namespace, array, emailInvite, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * NotebookApi - axios parameter creator
 * @export
 */
const NotebookApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getNotebookServerStatus', 'namespace', namespace);
            const localVarPath = `/notebooks/server/{namespace}/status`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Copy a tiledb notebook at the specified location
         * @param {string} namespace The namespace of the notebook
         * @param {string} array The name of the notebook
         * @param {NotebookCopy} notebookCopy Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, copy will use open_at functionality to copy notebook created at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCopyNotebook: (namespace, array, notebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('handleCopyNotebook', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('handleCopyNotebook', 'array', array);
            // verify required parameter 'notebookCopy' is not null or undefined
            assertParamExists$1('handleCopyNotebook', 'notebookCopy', notebookCopy);
            const localVarPath = `/notebooks/{namespace}/{array}/copy`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(notebookCopy, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Upload a notebook at the specified location
         * @param {string} namespace The namespace of the notebook
         * @param {any} inputFile the notebook to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [outputUri] output location of the TileDB File
         * @param {string} [name] name to set for registered file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadNotebook: (namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('handleUploadNotebook', 'namespace', namespace);
            // verify required parameter 'inputFile' is not null or undefined
            assertParamExists$1('handleUploadNotebook', 'inputFile', inputFile);
            const localVarPath = `/notebooks/{namespace}/upload`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            if (inputFile !== undefined) {
                localVarFormParams.append('input_file', inputFile);
            }
            if (outputUri !== undefined) {
                localVarFormParams.append('output_uri', outputUri);
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('shutdownNotebookServer', 'namespace', namespace);
            const localVarPath = `/notebooks/server/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update name on a notebok, moving related S3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotebookName: (namespace, array, notebookMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('updateNotebookName', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('updateNotebookName', 'array', array);
            // verify required parameter 'notebookMetadata' is not null or undefined
            assertParamExists$1('updateNotebookName', 'notebookMetadata', notebookMetadata);
            const localVarPath = `/notebooks/{namespace}/{array}/rename`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(notebookMetadata, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * NotebookApi - functional programming interface
 * @export
 */
const NotebookApiFp = function (configuration) {
    const localVarAxiosParamCreator = NotebookApiAxiosParamCreator(configuration);
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getNotebookServerStatus(namespace, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Copy a tiledb notebook at the specified location
         * @param {string} namespace The namespace of the notebook
         * @param {string} array The name of the notebook
         * @param {NotebookCopy} notebookCopy Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, copy will use open_at functionality to copy notebook created at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCopyNotebook(namespace, array, notebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.handleCopyNotebook(namespace, array, notebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Upload a notebook at the specified location
         * @param {string} namespace The namespace of the notebook
         * @param {any} inputFile the notebook to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [outputUri] output location of the TileDB File
         * @param {string} [name] name to set for registered file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadNotebook(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.handleUploadNotebook(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shutdownNotebookServer(namespace, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * update name on a notebok, moving related S3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotebookName(namespace, array, notebookMetadata, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateNotebookName(namespace, array, notebookMetadata, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * NotebookApi - factory interface
 * @export
 */
const NotebookApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NotebookApiFp(configuration);
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus(namespace, options) {
            return localVarFp.getNotebookServerStatus(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Copy a tiledb notebook at the specified location
         * @param {string} namespace The namespace of the notebook
         * @param {string} array The name of the notebook
         * @param {NotebookCopy} notebookCopy Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, copy will use open_at functionality to copy notebook created at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCopyNotebook(namespace, array, notebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options) {
            return localVarFp.handleCopyNotebook(namespace, array, notebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a notebook at the specified location
         * @param {string} namespace The namespace of the notebook
         * @param {any} inputFile the notebook to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [outputUri] output location of the TileDB File
         * @param {string} [name] name to set for registered file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadNotebook(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options) {
            return localVarFp.handleUploadNotebook(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer(namespace, options) {
            return localVarFp.shutdownNotebookServer(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * update name on a notebok, moving related S3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotebookName(namespace, array, notebookMetadata, options) {
            return localVarFp.updateNotebookName(namespace, array, notebookMetadata, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NotebookApi - object-oriented interface
 * @export
 * @class NotebookApi
 * @extends {BaseAPI}
 */
class NotebookApi extends BaseAPI$1 {
    /**
     * Get status of the notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    getNotebookServerStatus(namespace, options) {
        return NotebookApiFp(this.configuration).getNotebookServerStatus(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Copy a tiledb notebook at the specified location
     * @param {string} namespace The namespace of the notebook
     * @param {string} array The name of the notebook
     * @param {NotebookCopy} notebookCopy Input/Output information to create a new TileDB file
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {number} [endTimestamp] Milliseconds since Unix epoch, copy will use open_at functionality to copy notebook created at the specific timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    handleCopyNotebook(namespace, array, notebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options) {
        return NotebookApiFp(this.configuration).handleCopyNotebook(namespace, array, notebookCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload a notebook at the specified location
     * @param {string} namespace The namespace of the notebook
     * @param {any} inputFile the notebook to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [outputUri] output location of the TileDB File
     * @param {string} [name] name to set for registered file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    handleUploadNotebook(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options) {
        return NotebookApiFp(this.configuration).handleUploadNotebook(namespace, inputFile, xTILEDBCLOUDACCESSCREDENTIALSNAME, outputUri, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Shutdown a notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    shutdownNotebookServer(namespace, options) {
        return NotebookApiFp(this.configuration).shutdownNotebookServer(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update name on a notebok, moving related S3 object to new location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of notebook (array) that is url-encoded
     * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    updateNotebookName(namespace, array, notebookMetadata, options) {
        return NotebookApiFp(this.configuration).updateNotebookName(namespace, array, notebookMetadata, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * NotebooksApi - axios parameter creator
 * @export
 */
const NotebooksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notebooksNamespaceArrayEndTimestampsGet: (namespace, array, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('notebooksNamespaceArrayEndTimestampsGet', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('notebooksNamespaceArrayEndTimestampsGet', 'array', array);
            const localVarPath = `/notebooks/{namespace}/{array}/end_timestamps`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * NotebooksApi - functional programming interface
 * @export
 */
const NotebooksApiFp = function (configuration) {
    const localVarAxiosParamCreator = NotebooksApiAxiosParamCreator(configuration);
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * NotebooksApi - factory interface
 * @export
 */
const NotebooksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NotebooksApiFp(configuration);
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
            return localVarFp.notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NotebooksApi - object-oriented interface
 * @export
 * @class NotebooksApi
 * @extends {BaseAPI}
 */
class NotebooksApi extends BaseAPI$1 {
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
        return NotebooksApiFp(this.configuration).notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * OrganizationApi - axios parameter creator
 * @export
 */
const OrganizationApiAxiosParamCreator$1 = function (configuration) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials: (namespace, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('addAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            assertParamExists$1('addAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization: (organization, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists$1('addUserToOrganization', 'organization', organization);
            // verify required parameter 'user' is not null or undefined
            assertParamExists$1('addUserToOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/user`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(user, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('checkAWSAccessCredentials', 'namespace', namespace);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('checkAWSAccessCredentialsByName', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('checkAWSAccessCredentialsByName', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists$1('createOrganization', 'organization', organization);
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(organization, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('deleteAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('deleteAWSAccessCredentials', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists$1('deleteOrganization', 'organization', organization);
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists$1('deleteUserFromOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            assertParamExists$1('deleteUserFromOrganization', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists$1('getOrganization', 'organization', organization);
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists$1('getOrganizationUser', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            assertParamExists$1('getOrganizationUser', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials: (namespace, name, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('updateAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('updateAWSAccessCredentials', 'name', name);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            assertParamExists$1('updateAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a organization
         * @param {string} organization organization name or ID
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: (organization, organizationDetails, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists$1('updateOrganization', 'organization', organization);
            // verify required parameter 'organizationDetails' is not null or undefined
            assertParamExists$1('updateOrganization', 'organizationDetails', organizationDetails);
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(organizationDetails, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization: (organization, username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists$1('updateUserInOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            assertParamExists$1('updateUserInOrganization', 'username', username);
            // verify required parameter 'user' is not null or undefined
            assertParamExists$1('updateUserInOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(user, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * OrganizationApi - functional programming interface
 * @export
 */
const OrganizationApiFp$1 = function (configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator$1(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addAWSAccessCredentials(namespace, awsAccessCredentials, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addUserToOrganization(organization, user, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentials(namespace, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentialsByName(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createOrganization(organization, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAWSAccessCredentials(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * delete a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteOrganization(organization, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserFromOrganization(organization, username, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllOrganizations(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganization(organization, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizationUser(organization, username, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * update a organization
         * @param {string} organization organization name or ID
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organization, organizationDetails, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateOrganization(organization, organizationDetails, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserInOrganization(organization, username, user, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * OrganizationApi - factory interface
 * @export
 */
const OrganizationApiFactory$1 = function (configuration, basePath, axios) {
    const localVarFp = OrganizationApiFp$1(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return localVarFp.addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return localVarFp.addUserToOrganization(organization, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return localVarFp.checkAWSAccessCredentials(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return localVarFp.checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organization, options) {
            return localVarFp.createOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return localVarFp.deleteAWSAccessCredentials(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organization, options) {
            return localVarFp.deleteOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return localVarFp.deleteUserFromOrganization(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations(options) {
            return localVarFp.getAllOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * get a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organization, options) {
            return localVarFp.getOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return localVarFp.getOrganizationUser(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return localVarFp.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * update a organization
         * @param {string} organization organization name or ID
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organization, organizationDetails, options) {
            return localVarFp.updateOrganization(organization, organizationDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return localVarFp.updateUserInOrganization(organization, username, user, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
let OrganizationApi$1 = class OrganizationApi extends BaseAPI$1 {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
        return OrganizationApiFp$1(this.configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addUserToOrganization(organization, user, options) {
        return OrganizationApiFp$1(this.configuration).addUserToOrganization(organization, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    checkAWSAccessCredentials(namespace, options) {
        return OrganizationApiFp$1(this.configuration).checkAWSAccessCredentials(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    checkAWSAccessCredentialsByName(namespace, name, options) {
        return OrganizationApiFp$1(this.configuration).checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * create a organization, the user creating will be listed as owner
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    createOrganization(organization, options) {
        return OrganizationApiFp$1(this.configuration).createOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteAWSAccessCredentials(namespace, name, options) {
        return OrganizationApiFp$1(this.configuration).deleteAWSAccessCredentials(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a organization
     * @param {string} organization organization name or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteOrganization(organization, options) {
        return OrganizationApiFp$1(this.configuration).deleteOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteUserFromOrganization(organization, username, options) {
        return OrganizationApiFp$1(this.configuration).deleteUserFromOrganization(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get all organizations that the user is member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getAllOrganizations(options) {
        return OrganizationApiFp$1(this.configuration).getAllOrganizations(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a organization
     * @param {string} organization organization name or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getOrganization(organization, options) {
        return OrganizationApiFp$1(this.configuration).getOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getOrganizationUser(organization, username, options) {
        return OrganizationApiFp$1(this.configuration).getOrganizationUser(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
        return OrganizationApiFp$1(this.configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a organization
     * @param {string} organization organization name or ID
     * @param {Organization} organizationDetails organization details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateOrganization(organization, organizationDetails, options) {
        return OrganizationApiFp$1(this.configuration).updateOrganization(organization, organizationDetails, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateUserInOrganization(organization, username, user, options) {
        return OrganizationApiFp$1(this.configuration).updateUserInOrganization(organization, username, user, options).then((request) => request(this.axios, this.basePath));
    }
};
/**
 * QueryApi - axios parameter creator
 * @export
 */
const QueryApiAxiosParamCreator$1 = function (configuration) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('finalizeQuery', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('finalizeQuery', 'array', array);
            // verify required parameter 'type' is not null or undefined
            assertParamExists$1('finalizeQuery', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists$1('finalizeQuery', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            assertParamExists$1('finalizeQuery', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/finalize`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(query, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getEstResultSizes', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('getEstResultSizes', 'array', array);
            // verify required parameter 'type' is not null or undefined
            assertParamExists$1('getEstResultSizes', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists$1('getEstResultSizes', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            assertParamExists$1('getEstResultSizes', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/est_result_sizes`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(query, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: (namespace, array, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getFile', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('getFile', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists$1('getFile', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}/query/get_file`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('submitQuery', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('submitQuery', 'array', array);
            // verify required parameter 'type' is not null or undefined
            assertParamExists$1('submitQuery', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists$1('submitQuery', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            assertParamExists$1('submitQuery', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(query, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns JSON results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQueryJson: (namespace, array, contentType, queryJson, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('submitQueryJson', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('submitQueryJson', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists$1('submitQueryJson', 'contentType', contentType);
            // verify required parameter 'queryJson' is not null or undefined
            assertParamExists$1('submitQueryJson', 'queryJson', queryJson);
            const localVarPath = `/arrays/{namespace}/{array}/query/submit_query_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(queryJson, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * QueryApi - functional programming interface
 * @export
 */
const QueryApiFp$1 = function (configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator$1(configuration);
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(namespace, array, contentType, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFile(namespace, array, contentType, xPayer, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns JSON results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitQueryJson(namespace, array, contentType, queryJson, xPayer, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * QueryApi - factory interface
 * @export
 */
const QueryApiFactory$1 = function (configuration, basePath, axios) {
    const localVarFp = QueryApiFp$1(configuration);
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return localVarFp.finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return localVarFp.getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(namespace, array, contentType, xPayer, options) {
            return localVarFp.getFile(namespace, array, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return localVarFp.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns JSON results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {
            return localVarFp.submitQueryJson(namespace, array, contentType, queryJson, xPayer, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
let QueryApi$1 = class QueryApi extends BaseAPI$1 {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
        return QueryApiFp$1(this.configuration).finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {
        return QueryApiFp$1(this.configuration).getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns file bytes
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    getFile(namespace, array, contentType, xPayer, options) {
        return QueryApiFp$1(this.configuration).getFile(namespace, array, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
        return QueryApiFp$1(this.configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns JSON results
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {QueryJson} queryJson query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {
        return QueryApiFp$1(this.configuration).submitQueryJson(namespace, array, contentType, queryJson, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
};
/**
 * RegisteredTaskGraphsApi - axios parameter creator
 * @export
 */
const RegisteredTaskGraphsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete the given registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegisteredTaskGraph: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('deleteRegisteredTaskGraph', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('deleteRegisteredTaskGraph', 'name', name);
            const localVarPath = `/taskgraphs/{namespace}/registered/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch the contents of this registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisteredTaskGraph: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getRegisteredTaskGraph', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('getRegisteredTaskGraph', 'name', name);
            const localVarPath = `/taskgraphs/{namespace}/registered/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get sharing policies for the task graph.
         * @param {string} namespace The namespace that owns the registered task graph.
         * @param {string} name The name of the task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisteredTaskGraphSharingPolicies: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getRegisteredTaskGraphSharingPolicies', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('getRegisteredTaskGraphSharingPolicies', 'name', name);
            const localVarPath = `/taskgraphs/{namespace}/registered/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Register a task graph in the given namespace, with the given name.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {RegisteredTaskGraph} [graph] Task graph to register.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerRegisteredTaskGraph: (namespace, name, graph, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('registerRegisteredTaskGraph', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('registerRegisteredTaskGraph', 'name', name);
            const localVarPath = `/taskgraphs/{namespace}/registered/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(graph, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Share a task graph.
         * @param {string} namespace The namespace that owns the registered task graph.
         * @param {string} name The name of the task graph.
         * @param {TaskGraphSharing} taskGraphSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareRegisteredTaskGraph: (namespace, name, taskGraphSharing, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('shareRegisteredTaskGraph', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('shareRegisteredTaskGraph', 'name', name);
            // verify required parameter 'taskGraphSharing' is not null or undefined
            assertParamExists$1('shareRegisteredTaskGraph', 'taskGraphSharing', taskGraphSharing);
            const localVarPath = `/taskgraphs/{namespace}/registered/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(taskGraphSharing, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update the contents of an existing registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {RegisteredTaskGraph} [graph] The new contents of the task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegisteredTaskGraph: (namespace, name, graph, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('updateRegisteredTaskGraph', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('updateRegisteredTaskGraph', 'name', name);
            const localVarPath = `/taskgraphs/{namespace}/registered/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(graph, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * RegisteredTaskGraphsApi - functional programming interface
 * @export
 */
const RegisteredTaskGraphsApiFp = function (configuration) {
    const localVarAxiosParamCreator = RegisteredTaskGraphsApiAxiosParamCreator(configuration);
    return {
        /**
         * Delete the given registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegisteredTaskGraph(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteRegisteredTaskGraph(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch the contents of this registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisteredTaskGraph(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRegisteredTaskGraph(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Get sharing policies for the task graph.
         * @param {string} namespace The namespace that owns the registered task graph.
         * @param {string} name The name of the task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisteredTaskGraphSharingPolicies(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRegisteredTaskGraphSharingPolicies(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Register a task graph in the given namespace, with the given name.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {RegisteredTaskGraph} [graph] Task graph to register.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerRegisteredTaskGraph(namespace, name, graph, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerRegisteredTaskGraph(namespace, name, graph, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Share a task graph.
         * @param {string} namespace The namespace that owns the registered task graph.
         * @param {string} name The name of the task graph.
         * @param {TaskGraphSharing} taskGraphSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareRegisteredTaskGraph(namespace, name, taskGraphSharing, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareRegisteredTaskGraph(namespace, name, taskGraphSharing, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Update the contents of an existing registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {RegisteredTaskGraph} [graph] The new contents of the task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegisteredTaskGraph(namespace, name, graph, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateRegisteredTaskGraph(namespace, name, graph, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * RegisteredTaskGraphsApi - factory interface
 * @export
 */
const RegisteredTaskGraphsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = RegisteredTaskGraphsApiFp(configuration);
    return {
        /**
         * Delete the given registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRegisteredTaskGraph(namespace, name, options) {
            return localVarFp.deleteRegisteredTaskGraph(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the contents of this registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisteredTaskGraph(namespace, name, options) {
            return localVarFp.getRegisteredTaskGraph(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sharing policies for the task graph.
         * @param {string} namespace The namespace that owns the registered task graph.
         * @param {string} name The name of the task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisteredTaskGraphSharingPolicies(namespace, name, options) {
            return localVarFp.getRegisteredTaskGraphSharingPolicies(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a task graph in the given namespace, with the given name.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {RegisteredTaskGraph} [graph] Task graph to register.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerRegisteredTaskGraph(namespace, name, graph, options) {
            return localVarFp.registerRegisteredTaskGraph(namespace, name, graph, options).then((request) => request(axios, basePath));
        },
        /**
         * Share a task graph.
         * @param {string} namespace The namespace that owns the registered task graph.
         * @param {string} name The name of the task graph.
         * @param {TaskGraphSharing} taskGraphSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareRegisteredTaskGraph(namespace, name, taskGraphSharing, options) {
            return localVarFp.shareRegisteredTaskGraph(namespace, name, taskGraphSharing, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the contents of an existing registered task graph.
         * @param {string} namespace The namespace that owns this registered UDF.
         * @param {string} name The name of the registered task graph.
         * @param {RegisteredTaskGraph} [graph] The new contents of the task graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRegisteredTaskGraph(namespace, name, graph, options) {
            return localVarFp.updateRegisteredTaskGraph(namespace, name, graph, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * RegisteredTaskGraphsApi - object-oriented interface
 * @export
 * @class RegisteredTaskGraphsApi
 * @extends {BaseAPI}
 */
class RegisteredTaskGraphsApi extends BaseAPI$1 {
    /**
     * Delete the given registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    deleteRegisteredTaskGraph(namespace, name, options) {
        return RegisteredTaskGraphsApiFp(this.configuration).deleteRegisteredTaskGraph(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the contents of this registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    getRegisteredTaskGraph(namespace, name, options) {
        return RegisteredTaskGraphsApiFp(this.configuration).getRegisteredTaskGraph(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get sharing policies for the task graph.
     * @param {string} namespace The namespace that owns the registered task graph.
     * @param {string} name The name of the task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    getRegisteredTaskGraphSharingPolicies(namespace, name, options) {
        return RegisteredTaskGraphsApiFp(this.configuration).getRegisteredTaskGraphSharingPolicies(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Register a task graph in the given namespace, with the given name.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {RegisteredTaskGraph} [graph] Task graph to register.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    registerRegisteredTaskGraph(namespace, name, graph, options) {
        return RegisteredTaskGraphsApiFp(this.configuration).registerRegisteredTaskGraph(namespace, name, graph, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Share a task graph.
     * @param {string} namespace The namespace that owns the registered task graph.
     * @param {string} name The name of the task graph.
     * @param {TaskGraphSharing} taskGraphSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    shareRegisteredTaskGraph(namespace, name, taskGraphSharing, options) {
        return RegisteredTaskGraphsApiFp(this.configuration).shareRegisteredTaskGraph(namespace, name, taskGraphSharing, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the contents of an existing registered task graph.
     * @param {string} namespace The namespace that owns this registered UDF.
     * @param {string} name The name of the registered task graph.
     * @param {RegisteredTaskGraph} [graph] The new contents of the task graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredTaskGraphsApi
     */
    updateRegisteredTaskGraph(namespace, name, graph, options) {
        return RegisteredTaskGraphsApiFp(this.configuration).updateRegisteredTaskGraph(namespace, name, graph, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * SqlApi - axios parameter creator
 * @export
 */
const SqlApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL: (namespace, sql, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('runSQL', 'namespace', namespace);
            // verify required parameter 'sql' is not null or undefined
            assertParamExists$1('runSQL', 'sql', sql);
            const localVarPath = `/sql/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(sql, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SqlApi - functional programming interface
 * @export
 */
const SqlApiFp = function (configuration) {
    const localVarAxiosParamCreator = SqlApiAxiosParamCreator(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.runSQL(namespace, sql, acceptEncoding, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * SqlApi - factory interface
 * @export
 */
const SqlApiFactory = function (configuration, basePath, axios) {
    const localVarFp = SqlApiFp(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return localVarFp.runSQL(namespace, sql, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SqlApi - object-oriented interface
 * @export
 * @class SqlApi
 * @extends {BaseAPI}
 */
class SqlApi extends BaseAPI$1 {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SqlApi
     */
    runSQL(namespace, sql, acceptEncoding, options) {
        return SqlApiFp(this.configuration).runSQL(namespace, sql, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * StatsApi - axios parameter creator
 * @export
 */
const StatsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/.stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * StatsApi - functional programming interface
 * @export
 */
const StatsApiFp = function (configuration) {
    const localVarAxiosParamCreator = StatsApiAxiosParamCreator(configuration);
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTiledbStats(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * StatsApi - factory interface
 * @export
 */
const StatsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = StatsApiFp(configuration);
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats(options) {
            return localVarFp.getTiledbStats(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
class StatsApi extends BaseAPI$1 {
    /**
     * Fetch libtiledb stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    getTiledbStats(options) {
        return StatsApiFp(this.configuration).getTiledbStats(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TaskGraphLogsApi - axios parameter creator
 * @export
 */
const TaskGraphLogsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a task graph log.
         * @param {string} namespace The namespace that will own this task graph log.
         * @param {TaskGraphLog} log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskGraphLog: (namespace, log, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('createTaskGraphLog', 'namespace', namespace);
            // verify required parameter 'log' is not null or undefined
            assertParamExists$1('createTaskGraphLog', 'log', log);
            const localVarPath = `/taskgraphs/{namespace}/log`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(log, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch information about a single task graph execution.
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskGraphLog: (namespace, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getTaskGraphLog', 'namespace', namespace);
            // verify required parameter 'id' is not null or undefined
            assertParamExists$1('getTaskGraphLog', 'id', id);
            const localVarPath = `/taskgraphs/{namespace}/logs/{id}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata.
         * @param {string} [namespace] Include logs for this namespace.
         * @param {string} [createdBy] Include logs from only this user.
         * @param {string} [search] search string that will look at name.
         * @param {string} [startTime] Include logs created after this time.
         * @param {string} [endTime] Include logs created before this time.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaskGraphLogs: (namespace, createdBy, search, startTime, endTime, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/taskgraphs/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime instanceof Date) ?
                    startTime.toISOString() :
                    startTime;
            }
            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime instanceof Date) ?
                    endTime.toISOString() :
                    endTime;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphClientNodeStatus} report The node status to report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportClientNode: (namespace, id, report, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('reportClientNode', 'namespace', namespace);
            // verify required parameter 'id' is not null or undefined
            assertParamExists$1('reportClientNode', 'id', id);
            // verify required parameter 'report' is not null or undefined
            assertParamExists$1('reportClientNode', 'report', report);
            const localVarPath = `/taskgraphs/{namespace}/logs/{id}/report_client_node`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(report, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update information about a single task graph execution.
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskGraphLog: (namespace, id, log, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('updateTaskGraphLog', 'namespace', namespace);
            // verify required parameter 'id' is not null or undefined
            assertParamExists$1('updateTaskGraphLog', 'id', id);
            // verify required parameter 'log' is not null or undefined
            assertParamExists$1('updateTaskGraphLog', 'log', log);
            const localVarPath = `/taskgraphs/{namespace}/logs/{id}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(log, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TaskGraphLogsApi - functional programming interface
 * @export
 */
const TaskGraphLogsApiFp = function (configuration) {
    const localVarAxiosParamCreator = TaskGraphLogsApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a task graph log.
         * @param {string} namespace The namespace that will own this task graph log.
         * @param {TaskGraphLog} log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskGraphLog(namespace, log, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTaskGraphLog(namespace, log, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch information about a single task graph execution.
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskGraphLog(namespace, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTaskGraphLog(namespace, id, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata.
         * @param {string} [namespace] Include logs for this namespace.
         * @param {string} [createdBy] Include logs from only this user.
         * @param {string} [search] search string that will look at name.
         * @param {string} [startTime] Include logs created after this time.
         * @param {string} [endTime] Include logs created before this time.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         *
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphClientNodeStatus} report The node status to report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportClientNode(namespace, id, report, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.reportClientNode(namespace, id, report, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Update information about a single task graph execution.
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskGraphLog(namespace, id, log, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateTaskGraphLog(namespace, id, log, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * TaskGraphLogsApi - factory interface
 * @export
 */
const TaskGraphLogsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TaskGraphLogsApiFp(configuration);
    return {
        /**
         * Create a task graph log.
         * @param {string} namespace The namespace that will own this task graph log.
         * @param {TaskGraphLog} log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskGraphLog(namespace, log, options) {
            return localVarFp.createTaskGraphLog(namespace, log, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch information about a single task graph execution.
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskGraphLog(namespace, id, options) {
            return localVarFp.getTaskGraphLog(namespace, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata.
         * @param {string} [namespace] Include logs for this namespace.
         * @param {string} [createdBy] Include logs from only this user.
         * @param {string} [search] search string that will look at name.
         * @param {string} [startTime] Include logs created after this time.
         * @param {string} [endTime] Include logs created before this time.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options) {
            return localVarFp.listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphClientNodeStatus} report The node status to report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportClientNode(namespace, id, report, options) {
            return localVarFp.reportClientNode(namespace, id, report, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information about a single task graph execution.
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskGraphLog(namespace, id, log, options) {
            return localVarFp.updateTaskGraphLog(namespace, id, log, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TaskGraphLogsApi - object-oriented interface
 * @export
 * @class TaskGraphLogsApi
 * @extends {BaseAPI}
 */
class TaskGraphLogsApi extends BaseAPI$1 {
    /**
     * Create a task graph log.
     * @param {string} namespace The namespace that will own this task graph log.
     * @param {TaskGraphLog} log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    createTaskGraphLog(namespace, log, options) {
        return TaskGraphLogsApiFp(this.configuration).createTaskGraphLog(namespace, log, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch information about a single task graph execution.
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    getTaskGraphLog(namespace, id, options) {
        return TaskGraphLogsApiFp(this.configuration).getTaskGraphLog(namespace, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata.
     * @param {string} [namespace] Include logs for this namespace.
     * @param {string} [createdBy] Include logs from only this user.
     * @param {string} [search] search string that will look at name.
     * @param {string} [startTime] Include logs created after this time.
     * @param {string} [endTime] Include logs created before this time.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options) {
        return TaskGraphLogsApiFp(this.configuration).listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {TaskGraphClientNodeStatus} report The node status to report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    reportClientNode(namespace, id, report, options) {
        return TaskGraphLogsApiFp(this.configuration).reportClientNode(namespace, id, report, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update information about a single task graph execution.
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    updateTaskGraphLog(namespace, id, log, options) {
        return TaskGraphLogsApiFp(this.configuration).updateTaskGraphLog(namespace, id, log, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TasksApi - axios parameter creator
 * @export
 */
const TasksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL: (namespace, sql, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('runSQL', 'namespace', namespace);
            // verify required parameter 'sql' is not null or undefined
            assertParamExists$1('runSQL', 'sql', sql);
            const localVarPath = `/sql/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(sql, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch an array task
         * @param {string} id task ID to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists$1('taskIdGet', 'id', id);
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve results of an array task
         * @param {string} id task ID to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdResultGet: (id, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists$1('taskIdResultGet', 'id', id);
            const localVarPath = `/task/{id}/result`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet: (namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }
            if (array !== undefined) {
                localVarQueryParameter['array'] = array;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (excludeType) {
                localVarQueryParameter['exclude_type'] = excludeType.join(COLLECTION_FORMATS.csv);
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TasksApi - functional programming interface
 * @export
 */
const TasksApiFp = function (configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.runSQL(namespace, sql, acceptEncoding, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch an array task
         * @param {string} id task ID to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.taskIdGet(id, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Retrieve results of an array task
         * @param {string} id task ID to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdResultGet(id, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.taskIdResultGet(id, acceptEncoding, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * TasksApi - factory interface
 * @export
 */
const TasksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TasksApiFp(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return localVarFp.runSQL(namespace, sql, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch an array task
         * @param {string} id task ID to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet(id, options) {
            return localVarFp.taskIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve results of an array task
         * @param {string} id task ID to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdResultGet(id, acceptEncoding, options) {
            return localVarFp.taskIdResultGet(id, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {
            return localVarFp.tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
class TasksApi extends BaseAPI$1 {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    runSQL(namespace, sql, acceptEncoding, options) {
        return TasksApiFp(this.configuration).runSQL(namespace, sql, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch an array task
     * @param {string} id task ID to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    taskIdGet(id, options) {
        return TasksApiFp(this.configuration).taskIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve results of an array task
     * @param {string} id task ID to retrieve stored results
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    taskIdResultGet(id, acceptEncoding, options) {
        return TasksApiFp(this.configuration).taskIdResultGet(id, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all array tasks a user has access to
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
     * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
     * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
     * @param {string} [status] Filter to only return these statuses
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include start_time, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {
        return TasksApiFp(this.configuration).tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UdfApi - axios parameter creator
 * @export
 */
const UdfApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * delete a registered UDF -- this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFInfo: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('deleteUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('deleteUDFInfo', 'name', name);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('getUDFInfo', 'name', name);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all sharing details of the UDF
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('getUDFInfoSharingPolicies', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('getUDFInfoSharingPolicies', 'name', name);
            const localVarPath = `/udf/{namespace}/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Copy a tiledb udf at the specified location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFCopy} uDFCopy Input/Output information to copy a UDF
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCopyUDF: (namespace, name, uDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('handleCopyUDF', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('handleCopyUDF', 'name', name);
            // verify required parameter 'uDFCopy' is not null or undefined
            assertParamExists$1('handleCopyUDF', 'uDFCopy', uDFCopy);
            const localVarPath = `/udf/{namespace}/{name}/copy`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(uDFCopy, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo: (namespace, name, udf, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('registerUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('registerUDFInfo', 'name', name);
            // verify required parameter 'udf' is not null or undefined
            assertParamExists$1('registerUDFInfo', 'udf', udf);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(udf, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo: (namespace, name, udfSharing, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('shareUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('shareUDFInfo', 'name', name);
            // verify required parameter 'udfSharing' is not null or undefined
            assertParamExists$1('shareUDFInfo', 'udfSharing', udfSharing);
            const localVarPath = `/udf/{namespace}/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(udfSharing, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF: (namespace, udf, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('submitGenericUDF', 'namespace', namespace);
            // verify required parameter 'udf' is not null or undefined
            assertParamExists$1('submitGenericUDF', 'udf', udf);
            const localVarPath = `/udfs/generic/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(udf, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiArrayUDF: (namespace, udf, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('submitMultiArrayUDF', 'namespace', namespace);
            // verify required parameter 'udf' is not null or undefined
            assertParamExists$1('submitMultiArrayUDF', 'udf', udf);
            const localVarPath = `/udfs/arrays/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(udf, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF: (namespace, array, udf, xPayer, acceptEncoding, v2, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('submitUDF', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('submitUDF', 'array', array);
            // verify required parameter 'udf' is not null or undefined
            assertParamExists$1('submitUDF', 'udf', udf);
            const localVarPath = `/arrays/{namespace}/{array}/udf/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (v2 !== undefined) {
                localVarQueryParameter['v2'] = v2;
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(udf, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        udfNamespaceArrayEndTimestampsGet: (namespace, array, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('udfNamespaceArrayEndTimestampsGet', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists$1('udfNamespaceArrayEndTimestampsGet', 'array', array);
            const localVarPath = `/udf/{namespace}/{array}/end_timestamps`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update an existing registered UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo: (namespace, name, udf, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('updateUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('updateUDFInfo', 'name', name);
            // verify required parameter 'udf' is not null or undefined
            assertParamExists$1('updateUDFInfo', 'udf', udf);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(udf, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UdfApi - functional programming interface
 * @export
 */
const UdfApiFp = function (configuration) {
    const localVarAxiosParamCreator = UdfApiAxiosParamCreator(configuration);
    return {
        /**
         * delete a registered UDF -- this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFInfo(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUDFInfo(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUDFInfo(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Get all sharing details of the UDF
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUDFInfoSharingPolicies(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Copy a tiledb udf at the specified location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFCopy} uDFCopy Input/Output information to copy a UDF
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCopyUDF(namespace, name, uDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.handleCopyUDF(namespace, name, uDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo(namespace, name, udf, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerUDFInfo(namespace, name, udf, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo(namespace, name, udfSharing, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareUDFInfo(namespace, name, udfSharing, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF(namespace, udf, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitGenericUDF(namespace, udf, acceptEncoding, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitMultiArrayUDF(namespace, udf, acceptEncoding, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * update an existing registered UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo(namespace, name, udf, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUDFInfo(namespace, name, udf, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * UdfApi - factory interface
 * @export
 */
const UdfApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UdfApiFp(configuration);
    return {
        /**
         * delete a registered UDF -- this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFInfo(namespace, name, options) {
            return localVarFp.deleteUDFInfo(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo(namespace, name, options) {
            return localVarFp.getUDFInfo(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sharing details of the UDF
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies(namespace, name, options) {
            return localVarFp.getUDFInfoSharingPolicies(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Copy a tiledb udf at the specified location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFCopy} uDFCopy Input/Output information to copy a UDF
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCopyUDF(namespace, name, uDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options) {
            return localVarFp.handleCopyUDF(namespace, name, uDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo(namespace, name, udf, options) {
            return localVarFp.registerUDFInfo(namespace, name, udf, options).then((request) => request(axios, basePath));
        },
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo(namespace, name, udfSharing, options) {
            return localVarFp.shareUDFInfo(namespace, name, udfSharing, options).then((request) => request(axios, basePath));
        },
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF(namespace, udf, acceptEncoding, options) {
            return localVarFp.submitGenericUDF(namespace, udf, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {
            return localVarFp.submitMultiArrayUDF(namespace, udf, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {
            return localVarFp.submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options).then((request) => request(axios, basePath));
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
            return localVarFp.udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * update an existing registered UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo(namespace, name, udf, options) {
            return localVarFp.updateUDFInfo(namespace, name, udf, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UdfApi - object-oriented interface
 * @export
 * @class UdfApi
 * @extends {BaseAPI}
 */
class UdfApi extends BaseAPI$1 {
    /**
     * delete a registered UDF -- this will remove all sharing and can not be undone
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    deleteUDFInfo(namespace, name, options) {
        return UdfApiFp(this.configuration).deleteUDFInfo(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a specific UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    getUDFInfo(namespace, name, options) {
        return UdfApiFp(this.configuration).getUDFInfo(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all sharing details of the UDF
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    getUDFInfoSharingPolicies(namespace, name, options) {
        return UdfApiFp(this.configuration).getUDFInfoSharingPolicies(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Copy a tiledb udf at the specified location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFCopy} uDFCopy Input/Output information to copy a UDF
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {number} [endTimestamp] Milliseconds since Unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    handleCopyUDF(namespace, name, uDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options) {
        return UdfApiFp(this.configuration).handleCopyUDF(namespace, name, uDFCopy, xTILEDBCLOUDACCESSCREDENTIALSNAME, endTimestamp, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * register a UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {UDFInfoUpdate} udf UDF to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    registerUDFInfo(namespace, name, udf, options) {
        return UdfApiFp(this.configuration).registerUDFInfo(namespace, name, udf, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Share a UDF with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    shareUDFInfo(namespace, name, udfSharing, options) {
        return UdfApiFp(this.configuration).shareUDFInfo(namespace, name, udfSharing, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * submit a generic UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {GenericUDF} udf UDF to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitGenericUDF(namespace, udf, acceptEncoding, options) {
        return UdfApiFp(this.configuration).submitGenericUDF(namespace, udf, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * submit a multi-array UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {MultiArrayUDF} udf UDF to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {
        return UdfApiFp(this.configuration).submitMultiArrayUDF(namespace, udf, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a UDF to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {MultiArrayUDF} udf UDF to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {string} [acceptEncoding] Encoding to use
     * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {
        return UdfApiFp(this.configuration).submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options) {
        return UdfApiFp(this.configuration).udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update an existing registered UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {UDFInfoUpdate} udf UDF to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    updateUDFInfo(namespace, name, udf, options) {
        return UdfApiFp(this.configuration).updateUDFInfo(namespace, name, udf, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserApi - axios parameter creator
 * @export
 */
const UserApiAxiosParamCreator$1 = function (configuration) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials: (namespace, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('addAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            assertParamExists$1('addAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization: (organization, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists$1('addUserToOrganization', 'organization', organization);
            // verify required parameter 'user' is not null or undefined
            assertParamExists$1('addUserToOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/user`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(user, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('checkAWSAccessCredentials', 'namespace', namespace);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('checkAWSAccessCredentialsByName', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('checkAWSAccessCredentialsByName', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/user/confirm_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: (user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'user' is not null or undefined
            assertParamExists$1('createUser', 'user', user);
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(user, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('deleteAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('deleteAWSAccessCredentials', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: (username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'username' is not null or undefined
            assertParamExists$1('deleteUser', 'username', username);
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists$1('deleteUserFromOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            assertParamExists$1('deleteUserFromOrganization', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists$1('getOrganizationUser', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            assertParamExists$1('getOrganizationUser', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: (rememberMe, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            if (rememberMe !== undefined) {
                localVarQueryParameter['remember_me'] = rememberMe;
            }
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * retrieves available token scopes for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenScopes: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tokens/scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername: (username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'username' is not null or undefined
            assertParamExists$1('getUserWithUsername', 'username', username);
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken: (tokenRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(tokenRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * reset user password
         * @param {InlineObject} user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword: (user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'user' is not null or undefined
            assertParamExists$1('resetUserPassword', 'user', user);
            const localVarPath = `/user/password_reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(user, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken: (token, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'token' is not null or undefined
            assertParamExists$1('revokeToken', 'token', token);
            const localVarPath = `/tokens/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensSessionGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tokens/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials: (namespace, name, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists$1('updateAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists$1('updateAWSAccessCredentials', 'name', name);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            assertParamExists$1('updateAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a user
         * @param {string} username username or ID
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: (username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'username' is not null or undefined
            assertParamExists$1('updateUser', 'username', username);
            // verify required parameter 'user' is not null or undefined
            assertParamExists$1('updateUser', 'user', user);
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(user, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization: (organization, username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists$1('updateUserInOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            assertParamExists$1('updateUserInOrganization', 'username', username);
            // verify required parameter 'user' is not null or undefined
            assertParamExists$1('updateUserInOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL$1);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject$1(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject$1(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams$1(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded$1(user, localVarRequestOptions, configuration);
            return {
                url: toPathString$1(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
const UserApiFp$1 = function (configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator$1(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addAWSAccessCredentials(namespace, awsAccessCredentials, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addUserToOrganization(organization, user, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentials(namespace, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentialsByName(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.confirmEmail(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createUser(user, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAWSAccessCredentials(namespace, name, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * delete a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUser(username, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserFromOrganization(organization, username, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizationUser(organization, username, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(rememberMe, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSession(rememberMe, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * retrieves available token scopes for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenScopes(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTokenScopes(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUser(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * get a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername(username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserWithUsername(username, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken(tokenRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.requestToken(tokenRequest, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * reset user password
         * @param {InlineObject} user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resetUserPassword(user, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(token, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.revokeToken(token, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokensGet(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensSessionGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokensSessionGet(options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * update a user
         * @param {string} username username or ID
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUser(username, user, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserInOrganization(organization, username, user, options);
                return createRequestFunction$1(localVarAxiosArgs, globalAxios, BASE_PATH$1, configuration);
            });
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
const UserApiFactory$1 = function (configuration, basePath, axios) {
    const localVarFp = UserApiFp$1(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return localVarFp.addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return localVarFp.addUserToOrganization(organization, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return localVarFp.checkAWSAccessCredentials(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return localVarFp.checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail(options) {
            return localVarFp.confirmEmail(options).then((request) => request(axios, basePath));
        },
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user, options) {
            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return localVarFp.deleteAWSAccessCredentials(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username, options) {
            return localVarFp.deleteUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return localVarFp.deleteUserFromOrganization(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return localVarFp.getOrganizationUser(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(rememberMe, options) {
            return localVarFp.getSession(rememberMe, options).then((request) => request(axios, basePath));
        },
        /**
         * retrieves available token scopes for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenScopes(options) {
            return localVarFp.getTokenScopes(options).then((request) => request(axios, basePath));
        },
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options) {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * get a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername(username, options) {
            return localVarFp.getUserWithUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken(tokenRequest, options) {
            return localVarFp.requestToken(tokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * reset user password
         * @param {InlineObject} user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(user, options) {
            return localVarFp.resetUserPassword(user, options).then((request) => request(axios, basePath));
        },
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(token, options) {
            return localVarFp.revokeToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options) {
            return localVarFp.tokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensSessionGet(options) {
            return localVarFp.tokensSessionGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return localVarFp.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user
         * @param {string} username username or ID
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username, user, options) {
            return localVarFp.updateUser(username, user, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return localVarFp.updateUserInOrganization(organization, username, user, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
let UserApi$1 = class UserApi extends BaseAPI$1 {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
        return UserApiFp$1(this.configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addUserToOrganization(organization, user, options) {
        return UserApiFp$1(this.configuration).addUserToOrganization(organization, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    checkAWSAccessCredentials(namespace, options) {
        return UserApiFp$1(this.configuration).checkAWSAccessCredentials(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    checkAWSAccessCredentialsByName(namespace, name, options) {
        return UserApiFp$1(this.configuration).checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * confirm user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    confirmEmail(options) {
        return UserApiFp$1(this.configuration).confirmEmail(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createUser(user, options) {
        return UserApiFp$1(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteAWSAccessCredentials(namespace, name, options) {
        return UserApiFp$1(this.configuration).deleteAWSAccessCredentials(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a user
     * @param {string} username username or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUser(username, options) {
        return UserApiFp$1(this.configuration).deleteUser(username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUserFromOrganization(organization, username, options) {
        return UserApiFp$1(this.configuration).deleteUserFromOrganization(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getOrganizationUser(organization, username, options) {
        return UserApiFp$1(this.configuration).getOrganizationUser(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get session token for user
     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getSession(rememberMe, options) {
        return UserApiFp$1(this.configuration).getSession(rememberMe, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * retrieves available token scopes for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getTokenScopes(options) {
        return UserApiFp$1(this.configuration).getTokenScopes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(options) {
        return UserApiFp$1(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user
     * @param {string} username username or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserWithUsername(username, options) {
        return UserApiFp$1(this.configuration).getUserWithUsername(username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
     * @param {TokenRequest} [tokenRequest] token request object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    requestToken(tokenRequest, options) {
        return UserApiFp$1(this.configuration).requestToken(tokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * reset user password
     * @param {InlineObject} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    resetUserPassword(user, options) {
        return UserApiFp$1(this.configuration).resetUserPassword(user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * revoke an authorization token
     * @param {string} token token name or token itself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    revokeToken(token, options) {
        return UserApiFp$1(this.configuration).revokeToken(token, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of user tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokensGet(options) {
        return UserApiFp$1(this.configuration).tokensGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of user session tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokensSessionGet(options) {
        return UserApiFp$1(this.configuration).tokensSessionGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
        return UserApiFp$1(this.configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a user
     * @param {string} username username or ID
     * @param {User} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUser(username, user, options) {
        return UserApiFp$1(this.configuration).updateUser(username, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUserInOrganization(organization, username, user, options) {
        return UserApiFp$1(this.configuration).updateUserInOrganization(organization, username, user, options).then((request) => request(this.axios, this.basePath));
    }
};

/* tslint:disable */
/* eslint-disable */
/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
let Configuration$1 = class Configuration {
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
    /**
     * Check if the given MIME is a capnp MIME.
     * JSON MIME examples:
     *   application/capnp
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is capnp, false otherwise.
     */
    isCapnpMime(mime) {
        return mime === 'application/capnp';
    }
};

/* tslint:disable */

var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get ActivityEventType () { return ActivityEventType$1; },
    get ArrayActions () { return ArrayActions; },
    ArrayApi: ArrayApi$1,
    ArrayApiAxiosParamCreator: ArrayApiAxiosParamCreator$1,
    ArrayApiFactory: ArrayApiFactory$1,
    ArrayApiFp: ArrayApiFp$1,
    get ArrayTaskStatus () { return ArrayTaskStatus; },
    get ArrayTaskType () { return ArrayTaskType; },
    ArrayTasksApi: ArrayTasksApi,
    ArrayTasksApiAxiosParamCreator: ArrayTasksApiAxiosParamCreator,
    ArrayTasksApiFactory: ArrayTasksApiFactory,
    ArrayTasksApiFp: ArrayTasksApiFp,
    get ArrayType () { return ArrayType; },
    Configuration: Configuration$1,
    get Datatype () { return Datatype$1; },
    FavoritesApi: FavoritesApi,
    FavoritesApiAxiosParamCreator: FavoritesApiAxiosParamCreator,
    FavoritesApiFactory: FavoritesApiFactory,
    FavoritesApiFp: FavoritesApiFp,
    get FilePropertyName () { return FilePropertyName; },
    get FileType () { return FileType; },
    FilesApi: FilesApi,
    FilesApiAxiosParamCreator: FilesApiAxiosParamCreator,
    FilesApiFactory: FilesApiFactory,
    FilesApiFp: FilesApiFp,
    get FilterOption () { return FilterOption; },
    get FilterType () { return FilterType; },
    get GroupActions () { return GroupActions; },
    get GroupMemberAssetType () { return GroupMemberAssetType$1; },
    get GroupMemberType () { return GroupMemberType$1; },
    GroupsApi: GroupsApi$1,
    GroupsApiAxiosParamCreator: GroupsApiAxiosParamCreator$1,
    GroupsApiFactory: GroupsApiFactory$1,
    GroupsApiFp: GroupsApiFp$1,
    InvitationApi: InvitationApi,
    InvitationApiAxiosParamCreator: InvitationApiAxiosParamCreator,
    InvitationApiFactory: InvitationApiFactory,
    InvitationApiFp: InvitationApiFp,
    get InvitationStatus () { return InvitationStatus; },
    get InvitationType () { return InvitationType; },
    get Layout () { return Layout$1; },
    get NamespaceActions () { return NamespaceActions; },
    NotebookApi: NotebookApi,
    NotebookApiAxiosParamCreator: NotebookApiAxiosParamCreator,
    NotebookApiFactory: NotebookApiFactory,
    NotebookApiFp: NotebookApiFp,
    NotebooksApi: NotebooksApi,
    NotebooksApiAxiosParamCreator: NotebooksApiAxiosParamCreator,
    NotebooksApiFactory: NotebooksApiFactory,
    NotebooksApiFp: NotebooksApiFp,
    OrganizationApi: OrganizationApi$1,
    OrganizationApiAxiosParamCreator: OrganizationApiAxiosParamCreator$1,
    OrganizationApiFactory: OrganizationApiFactory$1,
    OrganizationApiFp: OrganizationApiFp$1,
    get OrganizationRoles () { return OrganizationRoles; },
    get PricingAggregateUsage () { return PricingAggregateUsage; },
    get PricingCurrency () { return PricingCurrency; },
    get PricingInterval () { return PricingInterval; },
    get PricingType () { return PricingType; },
    get PricingUnitLabel () { return PricingUnitLabel; },
    get PublicShareFilter () { return PublicShareFilter; },
    QueryApi: QueryApi$1,
    QueryApiAxiosParamCreator: QueryApiAxiosParamCreator$1,
    QueryApiFactory: QueryApiFactory$1,
    QueryApiFp: QueryApiFp$1,
    get Querystatus () { return Querystatus$1; },
    get Querytype () { return Querytype$1; },
    RegisteredTaskGraphsApi: RegisteredTaskGraphsApi,
    RegisteredTaskGraphsApiAxiosParamCreator: RegisteredTaskGraphsApiAxiosParamCreator,
    RegisteredTaskGraphsApiFactory: RegisteredTaskGraphsApiFactory,
    RegisteredTaskGraphsApiFp: RegisteredTaskGraphsApiFp,
    get ResultFormat () { return ResultFormat; },
    get SSOProvider () { return SSOProvider; },
    SqlApi: SqlApi,
    SqlApiAxiosParamCreator: SqlApiAxiosParamCreator,
    SqlApiFactory: SqlApiFactory,
    SqlApiFp: SqlApiFp,
    StatsApi: StatsApi,
    StatsApiAxiosParamCreator: StatsApiAxiosParamCreator,
    StatsApiFactory: StatsApiFactory,
    StatsApiFp: StatsApiFp,
    get TaskGraphActions () { return TaskGraphActions; },
    get TaskGraphLogRunLocation () { return TaskGraphLogRunLocation; },
    get TaskGraphLogStatus () { return TaskGraphLogStatus; },
    TaskGraphLogsApi: TaskGraphLogsApi,
    TaskGraphLogsApiAxiosParamCreator: TaskGraphLogsApiAxiosParamCreator,
    TaskGraphLogsApiFactory: TaskGraphLogsApiFactory,
    TaskGraphLogsApiFp: TaskGraphLogsApiFp,
    TasksApi: TasksApi,
    TasksApiAxiosParamCreator: TasksApiAxiosParamCreator,
    TasksApiFactory: TasksApiFactory,
    TasksApiFp: TasksApiFp,
    get TokenScope () { return TokenScope; },
    get UDFActions () { return UDFActions; },
    get UDFLanguage () { return UDFLanguage; },
    get UDFType () { return UDFType; },
    UdfApi: UdfApi,
    UdfApiAxiosParamCreator: UdfApiAxiosParamCreator,
    UdfApiFactory: UdfApiFactory,
    UdfApiFp: UdfApiFp,
    UserApi: UserApi$1,
    UserApiAxiosParamCreator: UserApiAxiosParamCreator$1,
    UserApiFactory: UserApiFactory$1,
    UserApiFp: UserApiFp$1
});

/* tslint:disable */
const BASE_PATH = "https://api.tiledb.com/v2".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, axios = globalAxios) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
        updateBasePathAfterRedirect(axios, BASE_PATH, this);
    }
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}

/* tslint:disable */
/**
 *
 * @export
 */
const DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
/**
 *
 * @export
 */
const setApiKeyToObject = function (object, keyParamName, configuration) {
    return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.apiKey) {
            const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                ? yield configuration.apiKey(keyParamName)
                : yield configuration.apiKey;
            object[keyParamName] = localVarApiKeyValue;
        }
    });
};
/**
 *
 * @export
 */
const setBasicAuthToObject = function (object, configuration) {
    if (configuration && (configuration.username || configuration.password)) {
        object["auth"] = { username: configuration.username, password: configuration.password };
    }
};
/**
 *
 * @export
 */
const setSearchParams = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    for (const object of objects) {
        for (const key in object) {
            if (Array.isArray(object[key])) {
                searchParams.delete(key);
                for (const item of object[key]) {
                    searchParams.append(key, item);
                }
            }
            else {
                searchParams.set(key, object[key]);
            }
        }
    }
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const serializeDataIfNeeded = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsJSONSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    if (needsJSONSerialization) {
        return JSON.stringify(value !== undefined ? value : {});
    }
    const needsCapnpSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isCapnpMime(requestOptions.headers['Content-Type'])
        : nonString;
    if (needsCapnpSerialization) {
        return value !== undefined ? capnpSerializer(value) : '';
    }
    return value || "";
};
/**
 *
 * @export
 */
const toPathString = function (url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + axiosArgs.url });
        return axios.request(axiosRequestArgs);
    };
};

/* tslint:disable */
/**
 * Type of activity logged
 * @export
 * @enum {string}
 */
var ActivityEventType;
(function (ActivityEventType) {
    ActivityEventType["ReadSchema"] = "read_schema";
    ActivityEventType["MaxBufferSizes"] = "max_buffer_sizes";
    ActivityEventType["NonEmptyDomain"] = "non_empty_domain";
    ActivityEventType["QueryRead"] = "query_read";
    ActivityEventType["QueryWrite"] = "query_write";
    ActivityEventType["Create"] = "create";
    ActivityEventType["Delete"] = "delete";
    ActivityEventType["Register"] = "register";
    ActivityEventType["Deregister"] = "deregister";
    ActivityEventType["Udf"] = "udf";
    ActivityEventType["ArrayMetadataGet"] = "array_metadata_get";
    ActivityEventType["ArrayMetadataUpdate"] = "array_metadata_update";
    ActivityEventType["EstimatedResultSizes"] = "estimated_result_sizes";
    ActivityEventType["Update"] = "update";
    ActivityEventType["Info"] = "info";
    ActivityEventType["Run"] = "run";
})(ActivityEventType || (ActivityEventType = {}));
/**
 * A service where data is stored or computations take place.
 * @export
 * @enum {string}
 */
var CloudProvider;
(function (CloudProvider) {
    CloudProvider["Aws"] = "AWS";
    CloudProvider["Azure"] = "AZURE";
})(CloudProvider || (CloudProvider = {}));
/**
 * TileDB data type
 * @export
 * @enum {string}
 */
var Datatype;
(function (Datatype) {
    Datatype["Int32"] = "INT32";
    Datatype["Int64"] = "INT64";
    Datatype["Float32"] = "FLOAT32";
    Datatype["Float64"] = "FLOAT64";
    Datatype["Char"] = "CHAR";
    Datatype["Int8"] = "INT8";
    Datatype["Uint8"] = "UINT8";
    Datatype["Int16"] = "INT16";
    Datatype["Uint16"] = "UINT16";
    Datatype["Uint32"] = "UINT32";
    Datatype["Uint64"] = "UINT64";
    Datatype["StringAscii"] = "STRING_ASCII";
    Datatype["StringUtf8"] = "STRING_UTF8";
    Datatype["StringUtf16"] = "STRING_UTF16";
    Datatype["StringUtf32"] = "STRING_UTF32";
    Datatype["StringUcs2"] = "STRING_UCS2";
    Datatype["StringUcs4"] = "STRING_UCS4";
    Datatype["DatetimeYear"] = "DATETIME_YEAR";
    Datatype["DatetimeMonth"] = "DATETIME_MONTH";
    Datatype["DatetimeWeek"] = "DATETIME_WEEK";
    Datatype["DatetimeDay"] = "DATETIME_DAY";
    Datatype["DatetimeHr"] = "DATETIME_HR";
    Datatype["DatetimeMin"] = "DATETIME_MIN";
    Datatype["DatetimeSec"] = "DATETIME_SEC";
    Datatype["DatetimeMs"] = "DATETIME_MS";
    Datatype["DatetimeUs"] = "DATETIME_US";
    Datatype["DatetimeNs"] = "DATETIME_NS";
    Datatype["DatetimePs"] = "DATETIME_PS";
    Datatype["DatetimeFs"] = "DATETIME_FS";
    Datatype["DatetimeAs"] = "DATETIME_AS";
    Datatype["Any"] = "ANY";
})(Datatype || (Datatype = {}));
/**
 * Specific file types of group members
 * @export
 * @enum {string}
 */
var GroupMemberAssetType;
(function (GroupMemberAssetType) {
    GroupMemberAssetType["Group"] = "group";
    GroupMemberAssetType["Array"] = "array";
    GroupMemberAssetType["Notebook"] = "notebook";
    GroupMemberAssetType["Dashboard"] = "dashboard";
    GroupMemberAssetType["UserDefinedFunction"] = "user_defined_function";
    GroupMemberAssetType["MlModel"] = "ml_model";
    GroupMemberAssetType["File"] = "file";
})(GroupMemberAssetType || (GroupMemberAssetType = {}));
/**
 * File types that can be included in groups
 * @export
 * @enum {string}
 */
var GroupMemberType;
(function (GroupMemberType) {
    GroupMemberType["Group"] = "GROUP";
    GroupMemberType["Array"] = "ARRAY";
})(GroupMemberType || (GroupMemberType = {}));
/**
 * Layout of array
 * @export
 * @enum {string}
 */
var Layout;
(function (Layout) {
    Layout["RowMajor"] = "row-major";
    Layout["ColMajor"] = "col-major";
    Layout["GlobalOrder"] = "global-order";
    Layout["Unordered"] = "unordered";
})(Layout || (Layout = {}));
/**
 * Status of query
 * @export
 * @enum {string}
 */
var Querystatus;
(function (Querystatus) {
    Querystatus["Failed"] = "FAILED";
    Querystatus["Completed"] = "COMPLETED";
    Querystatus["Inprogress"] = "INPROGRESS";
    Querystatus["Incomplete"] = "INCOMPLETE";
    Querystatus["Uninitialized"] = "UNINITIALIZED";
})(Querystatus || (Querystatus = {}));
/**
 * Type of query
 * @export
 * @enum {string}
 */
var Querytype;
(function (Querytype) {
    Querytype["Read"] = "READ";
    Querytype["Write"] = "WRITE";
})(Querytype || (Querytype = {}));
/**
 * ArrayApi - axios parameter creator
 * @export
 */
const ArrayApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog: (namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('arrayActivityLog', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists('arrayActivityLog', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/activity`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (eventTypes) {
                localVarQueryParameter['event_types'] = eventTypes;
            }
            if (taskId !== undefined) {
                localVarQueryParameter['task_id'] = taskId;
            }
            if (hasTaskId !== undefined) {
                localVarQueryParameter['has_task_id'] = hasTaskId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ArrayApi - functional programming interface
 * @export
 */
const ArrayApiFp = function (configuration) {
    const localVarAxiosParamCreator = ArrayApiAxiosParamCreator(configuration);
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
    };
};
/**
 * ArrayApi - factory interface
 * @export
 */
const ArrayApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ArrayApiFp(configuration);
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options) {
            return localVarFp.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
class ArrayApi extends BaseAPI {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options) {
        return ArrayApiFp(this.configuration).arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * GroupsApi - axios parameter creator
 * @export
 */
const GroupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates an empty group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupCreationRequest} [groupCreation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: (groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupCreation, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('createGroup', 'groupNamespace', groupNamespace);
            const localVarPath = `/groups/{group_namespace}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(groupCreation, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deregisters a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterGroup: (groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('deregisterGroup', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('deregisterGroup', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata on a group using the requested config
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupMetadataRetrievalRequest} [metadataRetrieval]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMetadata: (groupNamespace, groupName, metadataRetrieval, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('getGroupMetadata', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('getGroupMetadata', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}/metadata`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(metadataRetrieval, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * can be used to check if the resource exists
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupNamespaceGroupNameOptions: (groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('groupsGroupNamespaceGroupNameOptions', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('groupsGroupNamespaceGroupNameOptions', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'OPTIONS' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Registers an already existing group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupRegistrationRequest} [groupRegistration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGroup: (groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRegistration, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('registerGroup', 'groupNamespace', groupNamespace);
            const localVarPath = `/groups/{group_namespace}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(groupRegistration, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the contents of a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsRetrievalRequest} [groupRetrieval]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroup: (groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRetrieval, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('retrieveGroup', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('retrieveGroup', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(groupRetrieval, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Change the contents of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsChangesRequest} [groupUpdateContents]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupContents: (groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupUpdateContents, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('updateGroupContents', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('updateGroupContents', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(groupUpdateContents, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update metadata on a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupMetadataUpdateRequest} [metadataUpdating]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMetadata: (groupNamespace, groupName, metadataUpdating, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('updateGroupMetadata', 'groupNamespace', groupNamespace);
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('updateGroupMetadata', 'groupName', groupName);
            const localVarPath = `/groups/{group_namespace}/{group_name}/metadata`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(metadataUpdating, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * GroupsApi - functional programming interface
 * @export
 */
const GroupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates an empty group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupCreationRequest} [groupCreation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupCreation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupCreation, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Deregisters a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deregisterGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * get metadata on a group using the requested config
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupMetadataRetrievalRequest} [metadataRetrieval]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMetadata(groupNamespace, groupName, metadataRetrieval, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getGroupMetadata(groupNamespace, groupName, metadataRetrieval, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * can be used to check if the resource exists
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupNamespaceGroupNameOptions(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.groupsGroupNamespaceGroupNameOptions(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Registers an already existing group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupRegistrationRequest} [groupRegistration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRegistration, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRegistration, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Retrieves the contents of a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsRetrievalRequest} [groupRetrieval]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRetrieval, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.retrieveGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRetrieval, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Change the contents of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsChangesRequest} [groupUpdateContents]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupContents(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupUpdateContents, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateGroupContents(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupUpdateContents, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * update metadata on a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupMetadataUpdateRequest} [metadataUpdating]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMetadata(groupNamespace, groupName, metadataUpdating, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateGroupMetadata(groupNamespace, groupName, metadataUpdating, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
    };
};
/**
 * GroupsApi - factory interface
 * @export
 */
const GroupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = GroupsApiFp(configuration);
    return {
        /**
         * Creates an empty group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupCreationRequest} [groupCreation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupCreation, options) {
            return localVarFp.createGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupCreation, options).then((request) => request(axios, basePath));
        },
        /**
         * Deregisters a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return localVarFp.deregisterGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on a group using the requested config
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupMetadataRetrievalRequest} [metadataRetrieval]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMetadata(groupNamespace, groupName, metadataRetrieval, options) {
            return localVarFp.getGroupMetadata(groupNamespace, groupName, metadataRetrieval, options).then((request) => request(axios, basePath));
        },
        /**
         * can be used to check if the resource exists
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupNamespaceGroupNameOptions(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return localVarFp.groupsGroupNamespaceGroupNameOptions(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers an already existing group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupRegistrationRequest} [groupRegistration]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRegistration, options) {
            return localVarFp.registerGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRegistration, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the contents of a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsRetrievalRequest} [groupRetrieval]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRetrieval, options) {
            return localVarFp.retrieveGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRetrieval, options).then((request) => request(axios, basePath));
        },
        /**
         * Change the contents of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsChangesRequest} [groupUpdateContents]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupContents(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupUpdateContents, options) {
            return localVarFp.updateGroupContents(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupUpdateContents, options).then((request) => request(axios, basePath));
        },
        /**
         * update metadata on a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupMetadataUpdateRequest} [metadataUpdating]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMetadata(groupNamespace, groupName, metadataUpdating, options) {
            return localVarFp.updateGroupMetadata(groupNamespace, groupName, metadataUpdating, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
class GroupsApi extends BaseAPI {
    /**
     * Creates an empty group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupCreationRequest} [groupCreation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    createGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupCreation, options) {
        return GroupsApiFp(this.configuration).createGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupCreation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deregisters a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deregisterGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
        return GroupsApiFp(this.configuration).deregisterGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata on a group using the requested config
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataRetrievalRequest} [metadataRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupMetadata(groupNamespace, groupName, metadataRetrieval, options) {
        return GroupsApiFp(this.configuration).getGroupMetadata(groupNamespace, groupName, metadataRetrieval, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * can be used to check if the resource exists
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsGroupNamespaceGroupNameOptions(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
        return GroupsApiFp(this.configuration).groupsGroupNamespaceGroupNameOptions(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Registers an already existing group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupRegistrationRequest} [groupRegistration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    registerGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRegistration, options) {
        return GroupsApiFp(this.configuration).registerGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRegistration, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the contents of a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsRetrievalRequest} [groupRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    retrieveGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRetrieval, options) {
        return GroupsApiFp(this.configuration).retrieveGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRetrieval, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Change the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsChangesRequest} [groupUpdateContents]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroupContents(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupUpdateContents, options) {
        return GroupsApiFp(this.configuration).updateGroupContents(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupUpdateContents, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update metadata on a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataUpdateRequest} [metadataUpdating]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroupMetadata(groupNamespace, groupName, metadataUpdating, options) {
        return GroupsApiFp(this.configuration).updateGroupMetadata(groupNamespace, groupName, metadataUpdating, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * OrganizationApi - axios parameter creator
 * @export
 */
const OrganizationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential: (namespace, accessCredential, provider, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('addCredential', 'namespace', namespace);
            // verify required parameter 'accessCredential' is not null or undefined
            assertParamExists('addCredential', 'accessCredential', accessCredential);
            const localVarPath = `/credentials/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteCredential', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteCredential', 'name', name);
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getCredential', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getCredential', 'name', name);
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials: (namespace, provider, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listCredentials', 'namespace', namespace);
            const localVarPath = `/credentials/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential: (namespace, name, accessCredential, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateCredential', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateCredential', 'name', name);
            // verify required parameter 'accessCredential' is not null or undefined
            assertParamExists('updateCredential', 'accessCredential', accessCredential);
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * OrganizationApi - functional programming interface
 * @export
 */
const OrganizationApiFp = function (configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential(namespace, accessCredential, provider, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addCredential(namespace, accessCredential, provider, page, perPage, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteCredential(namespace, name, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCredential(namespace, name, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(namespace, provider, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCredentials(namespace, provider, page, perPage, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(namespace, name, accessCredential, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCredential(namespace, name, accessCredential, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
    };
};
/**
 * OrganizationApi - factory interface
 * @export
 */
const OrganizationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = OrganizationApiFp(configuration);
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential(namespace, accessCredential, provider, page, perPage, options) {
            return localVarFp.addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(namespace, name, options) {
            return localVarFp.deleteCredential(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential(namespace, name, options) {
            return localVarFp.getCredential(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(namespace, provider, page, perPage, options) {
            return localVarFp.listCredentials(namespace, provider, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(namespace, name, accessCredential, options) {
            return localVarFp.updateCredential(namespace, name, accessCredential, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
class OrganizationApi extends BaseAPI {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addCredential(namespace, accessCredential, provider, page, perPage, options) {
        return OrganizationApiFp(this.configuration).addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteCredential(namespace, name, options) {
        return OrganizationApiFp(this.configuration).deleteCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getCredential(namespace, name, options) {
        return OrganizationApiFp(this.configuration).getCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    listCredentials(namespace, provider, page, perPage, options) {
        return OrganizationApiFp(this.configuration).listCredentials(namespace, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateCredential(namespace, name, accessCredential, options) {
        return OrganizationApiFp(this.configuration).updateCredential(namespace, name, accessCredential, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * QueryApi - axios parameter creator
 * @export
 */
const QueryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery: (namespace, array, type, contentType, query, xPayer, openAt, readAll, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('submitQuery', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            assertParamExists('submitQuery', 'array', array);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('submitQuery', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('submitQuery', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            assertParamExists('submitQuery', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (readAll !== undefined) {
                localVarQueryParameter['read_all'] = readAll;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(query, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * QueryApi - functional programming interface
 * @export
 */
const QueryApiFp = function (configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration);
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
    };
};
/**
 * QueryApi - factory interface
 * @export
 */
const QueryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = QueryApiFp(configuration);
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options) {
            return localVarFp.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
class QueryApi extends BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options) {
        return QueryApiFp(this.configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserApi - axios parameter creator
 * @export
 */
const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential: (namespace, accessCredential, provider, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('addCredential', 'namespace', namespace);
            // verify required parameter 'accessCredential' is not null or undefined
            assertParamExists('addCredential', 'accessCredential', accessCredential);
            const localVarPath = `/credentials/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteCredential', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteCredential', 'name', name);
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getCredential', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getCredential', 'name', name);
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials: (namespace, provider, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listCredentials', 'namespace', namespace);
            const localVarPath = `/credentials/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential: (namespace, name, accessCredential, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateCredential', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateCredential', 'name', name);
            // verify required parameter 'accessCredential' is not null or undefined
            assertParamExists('updateCredential', 'accessCredential', accessCredential);
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
const UserApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential(namespace, accessCredential, provider, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addCredential(namespace, accessCredential, provider, page, perPage, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteCredential(namespace, name, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCredential(namespace, name, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(namespace, provider, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCredentials(namespace, provider, page, perPage, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(namespace, name, accessCredential, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCredential(namespace, name, accessCredential, options);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
const UserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserApiFp(configuration);
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential(namespace, accessCredential, provider, page, perPage, options) {
            return localVarFp.addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(namespace, name, options) {
            return localVarFp.deleteCredential(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential(namespace, name, options) {
            return localVarFp.getCredential(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(namespace, provider, page, perPage, options) {
            return localVarFp.listCredentials(namespace, provider, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(namespace, name, accessCredential, options) {
            return localVarFp.updateCredential(namespace, name, accessCredential, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends BaseAPI {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addCredential(namespace, accessCredential, provider, page, perPage, options) {
        return UserApiFp(this.configuration).addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteCredential(namespace, name, options) {
        return UserApiFp(this.configuration).deleteCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getCredential(namespace, name, options) {
        return UserApiFp(this.configuration).getCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    listCredentials(namespace, provider, page, perPage, options) {
        return UserApiFp(this.configuration).listCredentials(namespace, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateCredential(namespace, name, accessCredential, options) {
        return UserApiFp(this.configuration).updateCredential(namespace, name, accessCredential, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class Configuration {
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
    /**
     * Check if the given MIME is a capnp MIME.
     * JSON MIME examples:
     *   application/capnp
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is capnp, false otherwise.
     */
    isCapnpMime(mime) {
        return mime === 'application/capnp';
    }
}

/* tslint:disable */

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get ActivityEventType () { return ActivityEventType; },
    ArrayApi: ArrayApi,
    ArrayApiAxiosParamCreator: ArrayApiAxiosParamCreator,
    ArrayApiFactory: ArrayApiFactory,
    ArrayApiFp: ArrayApiFp,
    get CloudProvider () { return CloudProvider; },
    Configuration: Configuration,
    get Datatype () { return Datatype; },
    get GroupMemberAssetType () { return GroupMemberAssetType; },
    get GroupMemberType () { return GroupMemberType; },
    GroupsApi: GroupsApi,
    GroupsApiAxiosParamCreator: GroupsApiAxiosParamCreator,
    GroupsApiFactory: GroupsApiFactory,
    GroupsApiFp: GroupsApiFp,
    get Layout () { return Layout; },
    OrganizationApi: OrganizationApi,
    OrganizationApiAxiosParamCreator: OrganizationApiAxiosParamCreator,
    OrganizationApiFactory: OrganizationApiFactory,
    OrganizationApiFp: OrganizationApiFp,
    QueryApi: QueryApi,
    QueryApiAxiosParamCreator: QueryApiAxiosParamCreator,
    QueryApiFactory: QueryApiFactory,
    QueryApiFp: QueryApiFp,
    get Querystatus () { return Querystatus; },
    get Querytype () { return Querytype; },
    UserApi: UserApi,
    UserApiAxiosParamCreator: UserApiAxiosParamCreator,
    UserApiFactory: UserApiFactory,
    UserApiFp: UserApiFp
});

/**
 * Deserializes an ArrayBuffer to a Query object
 * @param buffer ArrayBuffer of the capnp Query object
 * @returns Query object
 */
const capnpQueryDeSerializer = (buffer) => {
    const message = new capnp.Message(buffer, false);
    const query = message.getRoot(Query);
    return {
        attributeBufferHeaders: deserializeAttributeBufferHeaders(query),
        layout: query.getLayout(),
        status: query.getStatus(),
        type: query.getType(),
        writer: deserializeWrite(query),
        reader: deserializeQueryReader(query.getReader()),
        array: deserializeArray(query.getArray()),
        totalFixedLengthBufferBytes: query
            .getTotalFixedLengthBufferBytes()
            .toNumber(),
        totalVarLenBufferBytes: query
            .getTotalVarLenBufferBytes()
            .toNumber(),
        totalValidityBufferBytes: query
            .getTotalValidityBufferBytes()
            .toNumber(),
        varOffsetsMode: query.getVarOffsetsMode(),
        varOffsetsAddExtraElement: query.getVarOffsetsAddExtraElement(),
        varOffsetsBitsize: query.getVarOffsetsBitsize(),
        config: deserializeConfig(query.getConfig()),
        stats: deserializeStats(query.getStats()),
    };
};
const deserializeArray = (arr) => {
    return {
        endTimestamp: arr.getEndTimestamp().toNumber(),
        queryType: arr.getQueryType(),
        uri: arr.getUri(),
        startTimestamp: arr.getStartTimestamp().toNumber(),
    };
};
const deserializeConfig = (config) => {
    const entries = config.getEntries().map((entry) => ({
        key: entry.getKey(),
        value: entry.getValue(),
    }));
    return { entries };
};
const deserializeQueryReader = (reader) => {
    return {
        layout: reader.getLayout(),
        subarray: deserializeSubarray(reader.getSubarray()),
        readState: deserializeReadState(reader.getReadState()),
        condition: deserializeCondition(reader.getCondition()),
        stats: deserializeStats(reader.getStats()),
    };
};
const deserializeCondition = (condition) => {
    return {
        clauses: condition.getClauses().map(deserializeConditionClause),
        clauseCombinationOps: condition
            .getClauseCombinationOps()
            .map((op) => op.toString()),
    };
};
const deserializeConditionClause = (conditionClause) => {
    return {
        fieldName: conditionClause.getFieldName(),
        // TODO: What kind of Data type? Is it an array of numbers?
        value: conditionClause.getValue().toArray(),
        op: conditionClause.getOp(),
    };
};
const deserializeReadState = (readState) => {
    return {
        overflowed: readState.getOverflowed(),
        unsplittable: readState.getUnsplittable(),
        initialized: readState.getInitialized(),
        subarrayPartitioner: deserializeSubarrayPartitioner(readState.getSubarrayPartitioner()),
    };
};
const deserializeSubarrayPartitioner = (subArrayPartitioner) => {
    return {
        subarray: deserializeSubarray(subArrayPartitioner.getSubarray()),
        budget: deserializeAttributeBufferSize(subArrayPartitioner.getBudget()),
        current: deserializeSubarrayPartitionerPartitionInfo(subArrayPartitioner.getCurrent()),
        state: deserializeSubarrayPartitionerState(subArrayPartitioner.getState()),
        memoryBudget: subArrayPartitioner
            .getMemoryBudget().toNumber(),
        memoryBudgetVar: subArrayPartitioner
            .getMemoryBudgetVar().toNumber(),
        memoryBudgetValidity: subArrayPartitioner
            .getMemoryBudgetValidity().toNumber(),
        stats: deserializeStats(subArrayPartitioner.getStats()),
    };
};
const deserializeSubarrayPartitionerState = (partitionerState) => {
    return {
        start: partitionerState.getStart().toNumber(),
        end: partitionerState.getEnd().toNumber(),
        singleRange: partitionerState
            .getSingleRange()
            .map((singleRange) => deserializeSubarray(singleRange)),
        multiRange: partitionerState
            .getMultiRange()
            .map((singleRange) => deserializeSubarray(singleRange)),
    };
};
const deserializeSubarrayPartitionerPartitionInfo = (partitionInfo) => {
    return {
        subarray: deserializeSubarray(partitionInfo.getSubarray()),
        start: partitionInfo.getStart().toNumber(),
        end: partitionInfo.getEnd().toNumber(),
        splitMultiRange: partitionInfo.getSplitMultiRange(),
    };
};
const deserializeAttributeBufferSize = (attrBufferSizeList) => {
    return attrBufferSizeList.map((attr) => ({
        attribute: attr.getAttribute(),
    }));
};
const deserializeAttributeBufferHeaders = (query) => {
    return query.getAttributeBufferHeaders().map((attrBufferHeader) => {
        return {
            name: attrBufferHeader.getName(),
            fixedLenBufferSizeInBytes: attrBufferHeader
                .getFixedLenBufferSizeInBytes().toNumber(),
            varLenBufferSizeInBytes: attrBufferHeader
                .getVarLenBufferSizeInBytes().toNumber(),
            validityLenBufferSizeInBytes: attrBufferHeader
                .getValidityLenBufferSizeInBytes().toNumber(),
            originalFixedLenBufferSizeInBytes: attrBufferHeader
                .getOriginalFixedLenBufferSizeInBytes().toNumber(),
            originalVarLenBufferSizeInBytes: attrBufferHeader
                .getOriginalVarLenBufferSizeInBytes().toNumber(),
            originalValidityLenBufferSizeInBytes: attrBufferHeader
                .getOriginalValidityLenBufferSizeInBytes().toNumber(),
        };
    });
};
const deserializeWrite = (query) => {
    const writer = query.getWriter();
    return {
        checkCoordDups: writer.getCheckCoordDups(),
        checkCoordOOB: writer.getCheckCoordOOB(),
        dedupCoords: writer.getDedupCoords(),
        subarray: deserializeDomainArray(writer.getSubarray()),
        subarrayRanges: deserializeSubarray(writer.getSubarrayRanges()),
        stats: deserializeStats(writer.getStats()),
    };
};
const deserializeDomainArray = (domainArray) => {
    return {
        int8: domainArray.getInt8().toArray(),
        uint8: domainArray.getUint8().toArray(),
        int16: domainArray.getInt16().toArray(),
        uint16: domainArray.getUint16().toArray(),
        int32: domainArray.getInt32().toArray(),
        uint32: domainArray.getUint32().toArray(),
        int64: domainArray.getInt64().toArray(),
        uint64: domainArray.getUint64().toArray(),
        float32: domainArray.getFloat32().toArray(),
        float64: domainArray.getFloat64().toArray(),
    };
};
const deserializeSubarray = (subArray) => {
    return ({
        layout: subArray.getLayout(),
        stats: deserializeStats(subArray.getStats()),
        ranges: subArray.getRanges().map((range) => {
            const type = range.getType();
            const bufferSizes = range
                .getBufferSizes()
                .map((uint64) => uint64.toNumber());
            return {
                type,
                hasDefaultRange: range.getHasDefaultRange(),
                buffer: range.getBuffer().toArray(),
                bufferSizes: bufferSizes,
                bufferStartSizes: range
                    .getBufferStartSizes()
                    .map((uint64) => uint64.toNumber()),
            };
        })
    });
};
const deserializeStats = (stats) => {
    return {
        timers: deserializeMapFloat64(stats.getTimers()),
        counters: deserializeMapUInt64(stats.getCounters()),
    };
};
const deserializeMapFloat64 = (mapFloat64) => {
    return mapFloat64.getEntries().map((entry) => {
        return {
            key: entry.getKey(),
            value: entry.getValue(),
        };
    });
};
const deserializeMapUInt64 = (mapUint64) => {
    return mapUint64.getEntries().map((entry) => {
        return {
            key: entry.getKey(),
            value: entry.getValue().toNumber(),
        };
    });
};

var DeserializableType;
(function (DeserializableType) {
    DeserializableType[DeserializableType["arrayMetadata"] = 0] = "arrayMetadata";
    DeserializableType[DeserializableType["query"] = 1] = "query";
})(DeserializableType || (DeserializableType = {}));
const deserializeCapnp = (data, type) => {
    if (!isArrayBuffer(data)) {
        throw new Error(`Data is not of type ArrayBuffer`);
    }
    if (type === DeserializableType.query) {
        return capnpQueryDeSerializer(data);
    }
    if (type === DeserializableType.arrayMetadata) {
        return capnpArrayMetadaDeSerializer(data);
    }
};
const capnpArrayMetadaDeSerializer = (buffer) => {
    const message = new capnp.Message(buffer, false);
    const arrayMetadata = message.getRoot(ArrayMetadata);
    const entries = arrayMetadata.getEntries().map((entry) => {
        const value = entry.getValue().toArray();
        return {
            value,
            del: entry.getDel(),
            key: entry.getKey(),
            type: entry.getType(),
            valueNum: entry.getValueNum(),
        };
    });
    return { entries };
};
const isArrayBuffer = (data) => {
    if (data && data.byteLength && data.slice) {
        return true;
    }
    return false;
};

/**
 * Flatten nested arrays to a single array
 */
const flatten = (list) => list.flat();

// DateTime types are Int64 numbers
const int64Types = [
    Datatype.Int64,
    Datatype.Uint64,
    Datatype.DatetimeAs,
    Datatype.DatetimeDay,
    Datatype.DatetimeFs,
    Datatype.DatetimeHr,
    Datatype.DatetimeMin,
    Datatype.DatetimeMonth,
    Datatype.DatetimeMs,
    Datatype.DatetimeNs,
    Datatype.DatetimePs,
    Datatype.DatetimeSec,
    Datatype.DatetimeUs,
    Datatype.DatetimeWeek,
    Datatype.DatetimeYear,
];
/**
 * If the type is an INT64 (e.g. Datetimes or Uint64 or Int64)
 * we convert the number array to an array of BigInts.
 */
const mapToBigIntIfNeeded = (data, type) => {
    let nums = data;
    if (int64Types.includes(type) && typeof nums[0] === "number") {
        nums = data.map(BigInt);
    }
    return nums;
};

/**
 * Get the TypedArray of every type
 */
const getTypedArrayFromDataType = (type) => {
    if (type === Datatype.Int32) {
        return Int32Array;
    }
    else if (type === Datatype.Int16) {
        return Int16Array;
    }
    else if (type === Datatype.Int8) {
        return Int8Array;
    }
    else if (type === Datatype.Int64) {
        return BigInt64Array;
    }
    else if (type === Datatype.Uint16) {
        return Uint16Array;
    }
    else if (type === Datatype.Uint32) {
        return Uint32Array;
    }
    else if (type === Datatype.Uint8) {
        return Uint8Array;
    }
    else if (type === Datatype.Uint64) {
        return BigUint64Array;
    }
    else if (type === Datatype.Float32) {
        return Float32Array;
    }
    else if (type === Datatype.Float64) {
        return Float64Array;
    }
    else if (int64Types.includes(type)) {
        return BigInt64Array;
    }
};

/**
 * Convert user defined ranges to a Uint8Array
 */
const rangesToBuffer = (ranges, type) => {
    const TypedArray = getTypedArrayFromDataType(type);
    if (TypedArray) {
        const nums = mapToBigIntIfNeeded(ranges, type);
        const dataview = TypedArray.from(nums);
        const uint8Array = new Uint8Array(dataview.buffer, 0, dataview.byteLength);
        return Array.from(uint8Array);
    }
    else if (type === Datatype.StringAscii) {
        const asciiArray = ranges.reduce((arr, str) => {
            const charCodes = str.split('').map((s, i) => str.charCodeAt(i));
            return [...arr, ...charCodes];
        }, []);
        return flatten(asciiArray);
    }
};

/**
 * Calculate the number of bytes of an array of numbers or strings
 * @param data Array of numbers or strings
 * @param type Datatype (e.g. UINT64, StringUcs2 etc)
 * @returns number of total bytes
 */
const getByteLengthOfData = (data, type) => {
    if (!data.length) {
        return 0;
    }
    const TypedArray = getTypedArrayFromDataType(type);
    // case 1: it's number of arrays
    if (TypedArray) {
        const nums = mapToBigIntIfNeeded(data, type);
        return TypedArray.from(nums).byteLength;
    }
    // otherwise it's string
    if (type === Datatype.Char || Datatype.StringAscii) {
        return data.reduce((accum, str) => accum + (str === null || str === void 0 ? void 0 : str.length), 0);
    }
    if (type === Datatype.StringUcs2) {
        return data.reduce((accum, str) => accum + (str === null || str === void 0 ? void 0 : str.length) * 2, 0);
    }
    if (type === Datatype.StringUcs4) {
        return data.reduce((accum, str) => accum + (str === null || str === void 0 ? void 0 : str.length) * 4, 0);
    }
    if (type === Datatype.StringUtf8) {
        const encoder = new TextEncoder();
        const encodedStr = data.map((str) => encoder.encode(str));
        return encodedStr.reduce((accum, encodedString) => {
            return accum + encodedString.byteLength;
        }, 0);
    }
};

/**
 * Checks if data is an array of numbers
 * @param data
 * @returns Boolean if data is an array of numbers
 */
const isNumberArray = (data) => {
    return typeof data[0] === "number";
};
const getRanges = (ranges, dimensions, hasDefaultRange) => {
    return ranges.map((range, i) => {
        const [firstRange] = range;
        const type = dimensions[i].type;
        const isArrayOfArrays = Array.isArray(firstRange);
        const isArrayOfInts = isNumberArray(flatten(range));
        const isEmpty = !range.length;
        const bufferSizes = isArrayOfArrays
            ? range.map((r) => getByteLengthOfData(r, type))
            : [getByteLengthOfData(range, type)];
        const startRanges = isArrayOfArrays ? range.map((r) => r[0]) : [firstRange];
        const bufferStartSizes = startRanges.map((startingRange) => {
            if (!startingRange) {
                return 0;
            }
            return getByteLengthOfData([startingRange], type);
        });
        /**
         * bufferStartSizes is used only for var length string ascii dimensions,
         * for ints is 0
         */
        if (isArrayOfInts) {
            bufferStartSizes.fill(0);
        }
        return {
            type,
            // TODO: How do we know "hasDefaultRange" ? Is it related with the domain?
            hasDefaultRange: isEmpty || !!hasDefaultRange,
            buffer: rangesToBuffer(flatten(range), type),
            bufferSizes,
            bufferStartSizes: isEmpty ? [0] : bufferStartSizes,
        };
    });
};

/**
 * Get the byte length of an individual element of every Datatype
 */
const getByteLengthOfDatatype = (type) => {
    const TypedArray = getTypedArrayFromDataType(type);
    if (TypedArray) {
        return TypedArray.BYTES_PER_ELEMENT;
    }
    else if (type === Datatype.StringAscii || type === Datatype.Char || type === Datatype.StringUtf8) {
        return 1;
    }
    else if (type === Datatype.StringUcs2 || type === Datatype.StringUtf16) {
        return 2;
    }
    else if (type === Datatype.StringUtf32 || type === Datatype.StringUcs4) {
        return 4;
    }
};

const emptyRangesToDomain = (ranges, dimensions) => {
    return ranges.map((range, i) => {
        const isEmpty = !range.length;
        const domain = dimensions[i].domain;
        if (!isEmpty) {
            return range;
        }
        // If there is a Domain for the dimension we return the dimension's domain as range
        if (domain) {
            const [firstValue] = Object.values(domain);
            return firstValue;
        }
        return range;
    });
};

const isDimension = (data) => {
    return data.hasOwnProperty("nullTileExtent");
};

const isAttributeVarLength = (attribute) => {
    if (isDimension(attribute)) {
        // Only StringAscii is var-length dimension
        return attribute.type === Datatype.StringAscii;
    }
    return attribute.cellValNum == 4294967295;
};

const isAttributeNullable = (attribute) => {
    if (isDimension(attribute)) {
        return false;
    }
    return attribute.nullable;
};

const createAttributeBufferHeaders = (attributes, bufferSize) => {
    const MAX_BYTES_PER_ELEMENT_OF_ATTRIBUTES = attributes.reduce((accum, attr) => accum + getMaxByteSizeOfAttribute(attr), 0);
    const attributeBufferHeaders = attributes.map((attr) => {
        const MAX_BYTES_FOR_ATTRIBUTE = getMaxByteSizeOfAttribute(attr);
        const WEIGHT = MAX_BYTES_FOR_ATTRIBUTE / MAX_BYTES_PER_ELEMENT_OF_ATTRIBUTES;
        const BYTES_FOR_ATTRIBUTE = bufferSize * WEIGHT;
        const isVarLength = isAttributeVarLength(attr);
        const isNullable = isAttributeNullable(attr);
        const BYTES_PER_ELEMENT = getByteLengthOfDatatype(attr.type);
        const BYTE_PER_OFFSET = getByteLengthOfDatatype(Datatype.Uint64);
        const TOTAL_BYTES_PER_ELEMENT = BYTES_FOR_ATTRIBUTE * (BYTES_PER_ELEMENT / MAX_BYTES_FOR_ATTRIBUTE);
        const TOTAL_BYTE_PER_VALIDITY = BYTES_FOR_ATTRIBUTE / MAX_BYTES_FOR_ATTRIBUTE;
        const TOTAL_BYTE_PER_OFFSET = BYTES_FOR_ATTRIBUTE * (BYTE_PER_OFFSET / MAX_BYTES_FOR_ATTRIBUTE);
        const fixedLenBufferSizeInBytes = isVarLength
            ? TOTAL_BYTE_PER_OFFSET
            : TOTAL_BYTES_PER_ELEMENT;
        const varLenBufferSizeInBytes = isVarLength ? TOTAL_BYTES_PER_ELEMENT : 0;
        const validityLenBufferSizeInBytes = isNullable
            ? TOTAL_BYTE_PER_VALIDITY
            : 0;
        return {
            name: attr.name,
            fixedLenBufferSizeInBytes: 0,
            varLenBufferSizeInBytes: 0,
            validityLenBufferSizeInBytes: 0,
            originalFixedLenBufferSizeInBytes: Math.floor(fixedLenBufferSizeInBytes),
            originalVarLenBufferSizeInBytes: Math.floor(varLenBufferSizeInBytes),
            originalValidityLenBufferSizeInBytes: Math.floor(validityLenBufferSizeInBytes),
        };
    });
    return attributeBufferHeaders;
};
const getMaxByteSizeOfAttribute = (attribute) => {
    const isVarLength = isAttributeVarLength(attribute);
    const isNullable = isAttributeNullable(attribute);
    const BYTES_PER_ELEMENT = getByteLengthOfDatatype(attribute.type);
    const BYTE_PER_VALIDITY = getByteLengthOfDatatype(Datatype.Uint8);
    const BYTE_PER_OFFSET = getByteLengthOfDatatype(Datatype.Uint64);
    return (Number(isVarLength) * BYTE_PER_OFFSET +
        BYTES_PER_ELEMENT +
        Number(isNullable) * BYTE_PER_VALIDITY);
};
/**
 * Helper function that takes user data and returns a Query object.
 * Since the Query object is really big we don't expect user to manually set all the values.
 * We get the essential minimal data needed from the user (such as the layout and ranges) and
 * convert it to a Query object.
 * @param data
 * @param attributes
 * @param dimensions
 * @returns Query object
 */
const dataToQuery = (data, attributes, dimensions, options) => {
    if (!data.layout) {
        return data;
    }
    const { bufferSize } = data;
    // Use default dimension's Domain for ranges that are set empty []
    const rangesWithDomain = emptyRangesToDomain(data.ranges, dimensions);
    const ranges = getRanges(rangesWithDomain, dimensions);
    const attributesAndDimensions = [...attributes, ...dimensions];
    // if user sets options.attributes we filter out all the other unwanted dimensions / attributes
    const selectedAttributes = options.attributes
        ? attributesAndDimensions.filter((attr) => options.attributes.includes(attr.name))
        : attributesAndDimensions;
    const attributeBufferHeaders = createAttributeBufferHeaders(selectedAttributes, bufferSize);
    return {
        attributeBufferHeaders,
        layout: data.layout,
        status: Querystatus.Uninitialized,
        type: Querytype.Read,
        reader: {
            layout: data.layout,
            subarray: {
                layout: data.layout,
                ranges,
            },
            readState: {
                subarrayPartitioner: {
                    subarray: {
                        layout: data.layout,
                        ranges: [],
                    },
                    budget: [],
                    current: {
                        subarray: {
                            layout: data.layout,
                            ranges: [],
                        },
                    },
                },
            },
        },
    };
};

const dataToQueryWriter = (data, dimensions, valueBuffer) => {
    const attributeBufferHeaders = Object.entries(valueBuffer).map(([key, val]) => {
        const isVarLength = val.offsetsBuffer.byteLength;
        return {
            name: key,
            fixedLenBufferSizeInBytes: val.offsetsBuffer.byteLength || val.valuesBuffer.byteLength,
            varLenBufferSizeInBytes: isVarLength ? val.valuesBuffer.byteLength : 0,
            validityLenBufferSizeInBytes: val.validityBuffer.byteLength,
            originalFixedLenBufferSizeInBytes: val.offsetsBuffer.byteLength || val.valuesBuffer.byteLength,
            originalVarLenBufferSizeInBytes: isVarLength
                ? val.valuesBuffer.byteLength
                : 0,
            originalValidityLenBufferSizeInBytes: val.validityBuffer.byteLength,
        };
    });
    const dimensionDomains = dimensions.map((dim) => {
        if (!dim.domain) {
            return [];
        }
        const [firstValue] = Object.values(dim.domain);
        return firstValue;
    });
    const { subarray: subarrayRanges } = data;
    const hasDefaultRange = subarrayRanges ? false : true;
    const ranges = getRanges(subarrayRanges || dimensionDomains, dimensions, hasDefaultRange);
    const subarray = getSubArray(subarrayRanges, dimensions);
    return {
        attributeBufferHeaders,
        layout: data.layout,
        status: Querystatus.Uninitialized,
        type: Querytype.Write,
        writer: {
            checkCoordDups: false,
            checkCoordOOB: false,
            dedupCoords: false,
            subarray,
            subarrayRanges: {
                layout: data.layout,
                ranges,
            },
        },
    };
};
const getSubArray = (ranges, dimensions) => {
    const subarray = {
        int8: [],
        uint8: [],
        int16: [],
        uint16: [],
        int32: [],
        uint32: [],
        int64: [],
        uint64: [],
        float32: [],
        float64: [],
    };
    if (!ranges) {
        return subarray;
    }
    const type = dimensions[0].type;
    subarray[type.toLocaleLowerCase()] = flatten(ranges);
    return subarray;
};

const dataToArrayBuffer = (data = [], type) => {
    if (!data.length) {
        return new ArrayBuffer(0);
    }
    const TypedArray = getTypedArrayFromDataType(type);
    if (TypedArray) {
        const typedArray = TypedArray.from(data);
        return typedArray.buffer;
    }
    else if (type === Datatype.StringAscii || type === Datatype.Char) {
        // If it's an array of CHARs join them together to a single string
        const str = Array.isArray(data) ? data.join('') : data;
        const textEncoder = new TextEncoder();
        return textEncoder.encode(str).buffer;
    }
    else if (type === Datatype.StringUtf8) {
        // If it's an array of CHARs join them together to a single string
        const str = Array.isArray(data) ? data.join('') : data;
        const textEncoder = new TextEncoder();
        return textEncoder.encode(str).buffer;
    }
    else if (type === Datatype.StringUtf16) {
        // If it's an array of CHARs join them together to a single string
        const str = Array.isArray(data) ? data.join('') : data;
        return utf16StrToArrayBuffer(str);
    }
    else if (type === Datatype.StringUtf32) {
        // If it's an array of CHARs join them together to a single string
        const str = Array.isArray(data) ? data.join('') : data;
        return utf32StrToArrayBuffer(str);
    }
    else if (type === Datatype.StringUcs2) {
        // If it's an array of CHARs join them together to a single string
        const str = Array.isArray(data) ? data.join('') : data;
        return utf16StrToArrayBuffer(str);
    }
    else if (type === Datatype.StringUcs4) {
        // If it's an array of CHARs join them together to a single string
        const str = Array.isArray(data) ? data.join('') : data;
        return utf32StrToArrayBuffer(str);
    }
};
function utf16StrToArrayBuffer(str) {
    var buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char
    var bufView = new Uint16Array(buf);
    for (var i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}
function utf32StrToArrayBuffer(str) {
    var buf = new ArrayBuffer(str.length * 4); // 4 bytes for each char
    var bufView = new Uint32Array(buf);
    for (var i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}

const attributeValuesToArrayBuffers = (values, dimensions, attributes) => {
    const data = {};
    const dimensionsAndAttributes = [...dimensions, ...attributes];
    for (let [attrName, attribute] of Object.entries(values)) {
        const selectedSchema = dimensionsAndAttributes.find((attr) => attr.name === attrName);
        const { type } = selectedSchema;
        const { validity = [], offsets = [], values = [] } = attribute;
        data[attrName] = {
            offsetsBuffer: dataToArrayBuffer(mapToBigIntIfNeeded(offsets, Datatype.Uint64), Datatype.Uint64),
            valuesBuffer: dataToArrayBuffer(mapToBigIntIfNeeded(values, type), type),
            validityBuffer: dataToArrayBuffer(validity, Datatype.Uint8),
        };
    }
    return data;
};

const concatArrayBuffers = (...buffers) => {
    const result = new Uint8Array(buffers.reduce((totalSize, buf) => totalSize + buf.byteLength, 0));
    buffers.reduce((offset, buf) => {
        result.set(new Uint8Array(buf), offset);
        return offset + buf.byteLength;
    }, 0);
    return result.buffer;
};

const emptyArrayBuffer = new ArrayBuffer(0);
const getWriterBody = (data, arraySchema) => {
    const dimensions = arraySchema.domain.dimensions;
    const attributes = arraySchema.attributes;
    const valueBuffers = attributeValuesToArrayBuffers(data.values, dimensions, attributes);
    const queryObject = dataToQueryWriter(data, dimensions, valueBuffers);
    const querySerialized = capnpQuerySerializer(queryObject);
    const attributeBuffersArray = Object.values(valueBuffers).reduce((accum, valueBuffer) => {
        const attributeBuffer = concatArrayBuffers(valueBuffer.offsetsBuffer, valueBuffer.valuesBuffer, valueBuffer.validityBuffer);
        return concatArrayBuffers(accum, attributeBuffer);
    }, emptyArrayBuffer);
    const body = concatArrayBuffers(querySerialized, attributeBuffersArray);
    return body;
};

/**
 * If buffer is a NodeJS Buffer object we convert it back to an ArrayBuffer
 * Axios is NodeJS environments returns a NodeJS buffer while in browsers, an ArrayBuffer
 * @param buffer ArrayBuffer or Nodejs Buffer
 * @returns ArrayBuffer
 */
function convertToArrayBufferIfNodeBuffer(buffer) {
    if (buffer.buffer) {
        return new Uint8Array(buffer).buffer;
    }
    return buffer;
}

/**
 * Add all buffers of an attribute
 * @param attr AttributeBufferHeader
 * @returns number of the total bytes of the attribute
 */
const getAttributeSizeInBytes = (attr) => {
    return (attr.fixedLenBufferSizeInBytes +
        attr.varLenBufferSizeInBytes +
        attr.validityLenBufferSizeInBytes);
};

/**
 * Calculate the total bytes of all the attributes
 * @param attributes
 * @returns number of the total bytes of all the attributes
 */
const getSizeInBytesOfAllAttributes = (attributes) => attributes.reduce((accum, attr) => accum + getAttributeSizeInBytes(attr), 0);

/**
 * Get attribute data from attribute name, attribute data contains the type of the attribute (e.g. INT32, StringUTF8 etc)
 */
const getAttributeSchema = (attrName, attributesSchema) => {
    return attributesSchema.find((attr) => attr.name === attrName);
};

/**
 * Convert a TypedArray (Uint8Array, Int32Array etc) to an Array
 */
const typedArrayToArray = (typedArray) => Array.from(typedArray);

const bufferToInt8 = (arrayBuffer) => new Int8Array(arrayBuffer);
const bufferToUint8 = (arrayBuffer) => new Uint8Array(arrayBuffer);
const bufferToUint16 = (arrayBuffer) => new Uint16Array(arrayBuffer);
const bufferToUint32 = (arrayBuffer) => new Uint32Array(arrayBuffer);
const bufferToInt16 = (arrayBuffer) => new Int16Array(arrayBuffer);
const bufferToInt32 = (arrayBuffer) => new Int32Array(arrayBuffer);
const bufferToUint64 = (arrayBuffer) => new BigUint64Array(arrayBuffer);
const bufferToInt64 = (arrayBuffer) => new BigInt64Array(arrayBuffer);
const bufferToFloat32 = (arrayBuffer) => new Float32Array(arrayBuffer);
const bufferToFloat64 = (arrayBuffer) => new Float64Array(arrayBuffer);
const bufferToString = (arrayBuffer) => {
    const utf8decoder = new TextDecoder();
    return utf8decoder.decode(arrayBuffer);
};
const bufferToAscii = (arrayBuffer) => {
    const utf8decoder = new TextDecoder("ascii");
    return utf8decoder.decode(arrayBuffer);
};
const bufferToUTF16 = (arrayBuffer) => {
    const utf8decoder = new TextDecoder("utf-16");
    return utf8decoder.decode(arrayBuffer);
};
const bufferToUTF32 = (arrayBuffer) => {
    const view = new DataView(arrayBuffer, 0, arrayBuffer.byteLength);
    let result = "";
    for (let i = 0; i < arrayBuffer.byteLength; i += 4) {
        result += String.fromCodePoint(view.getInt32(i, true));
    }
    return result;
};
/**
 * Convert an ArrayBuffer to its corresponding type
 */
const bufferToData = (arrayBuffer, type) => {
    if (type === Datatype.Int32) {
        return typedArrayToArray(bufferToInt32(arrayBuffer));
    }
    else if (type === Datatype.Uint64) {
        return typedArrayToArray(bufferToUint64(arrayBuffer));
    }
    else if (type === Datatype.Int64) {
        return typedArrayToArray(bufferToInt64(arrayBuffer));
    }
    else if (type === Datatype.Float32) {
        return typedArrayToArray(bufferToFloat32(arrayBuffer));
    }
    else if (type === Datatype.Float64) {
        return typedArrayToArray(bufferToFloat64(arrayBuffer));
    }
    else if (type === Datatype.Char) {
        const charCodes = typedArrayToArray(bufferToUint8(arrayBuffer));
        return String.fromCharCode(...charCodes);
    }
    else if (type === Datatype.Int8) {
        return typedArrayToArray(bufferToInt8(arrayBuffer));
    }
    else if (type === Datatype.Uint8) {
        return typedArrayToArray(bufferToUint8(arrayBuffer));
    }
    else if (type === Datatype.Int16) {
        return typedArrayToArray(bufferToInt16(arrayBuffer));
    }
    else if (type === Datatype.Uint16) {
        return typedArrayToArray(bufferToUint16(arrayBuffer));
    }
    else if (type === Datatype.Uint32) {
        return typedArrayToArray(bufferToUint32(arrayBuffer));
    }
    else if (type === Datatype.StringAscii) {
        return bufferToAscii(arrayBuffer);
    }
    else if (type === Datatype.StringUtf8) {
        return bufferToString(arrayBuffer);
    }
    else if (type === Datatype.StringUtf16) {
        return bufferToUTF16(arrayBuffer);
    }
    else if (type === Datatype.StringUtf32) {
        return bufferToUTF32(arrayBuffer);
    }
    else if (type === Datatype.StringUcs2) {
        return bufferToUTF16(arrayBuffer);
    }
    else if (type === Datatype.StringUcs4) {
        return bufferToUTF32(arrayBuffer);
    }
    else if (int64Types.includes(type)) {
        return typedArrayToArray(bufferToInt64(arrayBuffer));
    }
    return arrayBuffer;
};

/**
 * Set nullables on an array
 * @param vals [12, 15, 22, 34, 8]
 * @param nullables [0, 1, 1, 0, 1]
 * @param offsets []
 * @returns [NULL, 15, 22, NULL, 8]
 */
const setNullables = (values, nullables) => __awaiter(void 0, void 0, void 0, function* () {
    // We explicitly set as NULL index where nullable array is 0
    return values.map((val, i) => (nullables[i] ? val : null));
});

function range(start, end) {
    return new Array(end - start + 1).fill(undefined).map((_, i) => i + start);
}

/**
 * Group values together according to offsets
 * @param vals [1, 2, 3, 4]
 * @param offsets e.g. [0, 3, 4]
 * @returns [[1,2,3], 4]
 */
const groupValuesByOffsetBytes = (values, offsets) => {
    const offsetsLength = offsets.length;
    if (!offsetsLength) {
        return Promise.resolve([values]);
    }
    const offsetIndex = range(0, offsetsLength - 1);
    const offsetIndexTuple = offsets.map((off, i) => [off, offsetIndex[i]]);
    const offsetsP = new Parallel(offsetIndexTuple, {
        env: {
            values,
            offsets,
        },
    });
    return new Promise((resolve) => {
        offsetsP
            .map(([offset, i]) => {
            const vals = global.env.values;
            const globalOffsets = global.env.offsets;
            const nextOffset = globalOffsets[i + 1];
            // Note: Array.prototype.slice doesn't accept BigInt
            const grpoupedValues = vals.slice(offset, nextOffset);
            return grpoupedValues;
        })
            .then(resolve);
    });
};

/**
 * If result is an array of arrays of characters, eg:
 * [['T', 'i', 'l', 'e', 'D', 'B'], ['C', 'l', 'o', 'u', 'd']]
 * We concat characters to create an array of strings
 * ['TileDB', 'Cloud']
 */
const concatChars = (strings) => strings.map((s) => s === null || s === void 0 ? void 0 : s.join(""));

function convertToArray(arrayLike) {
    if (Array.isArray(arrayLike)) {
        return arrayLike;
    }
    return Array.from(arrayLike);
}

/**
 * Convert an ArrayBuffer to a map of attributes with their results
 * @param arrayBuffer The slice ArrayBuffer that contains the results
 * @param attributes
 * @param attributesSchema
 * @returns A map of attribute names with the results of every attribute
 */
const getResultsFromArrayBuffer = (arrayBuffer, attributeBufferHeaders, attributesSchema, options = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const data = {};
    /**
     * We start from the last attribute which is at the end of the buffer
     */
    yield attributeBufferHeaders
        .reverse()
        .reduce((offsetPromise, attribute) => __awaiter(void 0, void 0, void 0, function* () {
        const totalNumberOfBytesOfAttribute = getAttributeSizeInBytes(attribute);
        const offset = yield offsetPromise;
        if (!totalNumberOfBytesOfAttribute) {
            if (options.returnRawBuffers) {
                data[attribute.name] = new ArrayBuffer(0);
            }
            else {
                data[attribute.name] = [];
            }
            return offset;
        }
        // If there are validityLenBufferSizeInBytes the attribute is nullable
        const isNullable = !!attribute.validityLenBufferSizeInBytes;
        // If there are varLenBufferSizeInBytes the attribute is varLengthSized
        const isVarLengthSized = !!attribute.varLenBufferSizeInBytes;
        const selectedAttributeSchema = getAttributeSchema(attribute.name, attributesSchema);
        const negativeOffset = -1 * offset;
        /**
         * If attribute is varLengthSized, we ignore the first N bytes (where N = fixedLenBufferSizeInBytes)
         * These first N bytes contain the offsets of the attribute, which is a uint64 array.
         */
        const start = negativeOffset -
            totalNumberOfBytesOfAttribute +
            (isVarLengthSized ? attribute.fixedLenBufferSizeInBytes : 0);
        /**
         * If attribute is isNullable we ignore the last N bytes (where N = validityLenBufferSizeInBytes)
         * These last N bytes contain a uint8 array of zeros and ones, where every zero represents
         * that in that index the attribute is null.
         */
        const ending = negativeOffset -
            (isNullable ? attribute.validityLenBufferSizeInBytes : 0);
        const end = ending ? ending : undefined;
        if (options.returnRawBuffers) {
            data[attribute.name] = arrayBuffer.slice(start, end);
            return offset + totalNumberOfBytesOfAttribute;
        }
        let result = bufferToData(arrayBuffer.slice(start, end), selectedAttributeSchema.type);
        let offsets = [];
        if (isVarLengthSized && !options.ignoreOffsets) {
            const BYTE_PER_ELEMENT = getByteLengthOfDatatype(selectedAttributeSchema.type);
            const startOfBuffer = negativeOffset - totalNumberOfBytesOfAttribute;
            const offsetsBuffer = arrayBuffer.slice(startOfBuffer, startOfBuffer + attribute.fixedLenBufferSizeInBytes);
            /**
             * Offsets are Uint64 numbers, buffer contains byte offsets though,
             * e.g. if type of the attribute is an INT32 (4 bytes per number) and the offsets are [0, 3, 4]
             * the buffer contains the offsets * bytes of the element instead of just the offsets [0, 3 * 4, 4 * 4] = [0, 12, 16]
             */
            const byteOffsets = Array.from(new BigUint64Array(offsetsBuffer));
            // Convert byte offsets to offsets
            offsets = byteOffsets.map((o) => Number(o / BigInt(BYTE_PER_ELEMENT)));
            const isString = typeof result === "string";
            const groupedValues = yield groupValuesByOffsetBytes(convertToArray(result), offsets);
            // If it's a string we concat all the characters to create array of strings
            result = isString
                ? concatChars(groupedValues)
                : groupedValues;
        }
        if (isNullable && !options.ignoreNullables) {
            /**
             * If attribute is Nullable, we get the last N bytes, cast it to uint8 array to get
             * what is null.
             */
            const nullableArrayEnd = ending + attribute.validityLenBufferSizeInBytes;
            const nullableArrayBuffer = arrayBuffer.slice(ending, nullableArrayEnd ? nullableArrayEnd : undefined);
            const nullablesTypedArray = bufferToInt8(nullableArrayBuffer);
            /**
             * nullablesArray should be an array of zeros and ones (e.g. [0, 1, 1, 0])
             * Every zero represents that in that specific index the attribute is NULL
             */
            const nullablesArray = Array.from(nullablesTypedArray);
            const values = convertToArray(result);
            result = (yield setNullables(values, nullablesArray));
        }
        data[attribute.name] = result;
        return offset + totalNumberOfBytesOfAttribute;
    }), Promise.resolve(0));
    return data;
});

class TileDBQuery {
    constructor(params, axios = globalAxios) {
        var _a;
        this.configurationParams = params;
        const config = new Configuration(this.configurationParams);
        const baseV1 = (_a = config.basePath) === null || _a === void 0 ? void 0 : _a.replace("v2", "v1");
        // Add versioning if basePath exists
        const configV1 = new Configuration(Object.assign(Object.assign({}, this.configurationParams), (baseV1 ? { basePath: baseV1 } : {})));
        this.queryAPI = new QueryApi(config, undefined, this.axios);
        this.arrayAPI = new ArrayApi$1(configV1, undefined, this.axios);
    }
    WriteQuery(namespace, arrayName, data) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const arraySchemaResponse = yield this.arrayAPI.getArray(namespace, arrayName, "application/json");
                const arraySchema = arraySchemaResponse.data;
                const body = getWriterBody(data, arraySchema);
                const queryResponse = yield this.queryAPI.submitQuery(namespace, arrayName, Querytype.Write, "application/capnp", body, undefined, undefined, undefined, {
                    headers: {
                        "Content-Type": "application/capnp",
                    },
                    responseType: "arraybuffer",
                });
                /**
                 * Axios in nodeJS environments casts the response to a Buffer object
                 * we convert it back to an ArrayBuffer if needed
                 */
                const queryData = convertToArrayBufferIfNodeBuffer(queryResponse.data);
                const bufferWithoutFirstEightBytes = queryData.slice(8);
                return capnpQueryDeSerializer(bufferWithoutFirstEightBytes);
            }
            catch (e) {
                /**
                 * Since we set the responseType to "arrayBuffer", in case the
                 * response error message is a buffer, we deserialize the message before throwing
                 */
                const errorIsABuffer = ((_b = (_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.buffer) || ((_d = (_c = e === null || e === void 0 ? void 0 : e.response) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.length);
                if (errorIsABuffer) {
                    const errorArrayBuffer = convertToArrayBufferIfNodeBuffer(e.response.data);
                    const decodedMessage = new TextDecoder().decode(errorArrayBuffer);
                    throw new Error(decodedMessage);
                }
                else {
                    throw e;
                }
            }
        });
    }
    ReadIncompleteQuery(arraySchema, queryAsArrayBuffer, namespace, arrayName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryResponse = yield this.queryAPI.submitQuery(namespace, arrayName, Querytype.Read, "application/capnp", queryAsArrayBuffer, undefined, undefined, undefined, {
                headers: {
                    "Content-Type": "application/capnp",
                },
                responseType: "arraybuffer",
            });
            /**
             * Axios in nodeJS environments casts the response to a Buffer object
             * we convert it back to an ArrayBuffer if needed
             */
            const queryData = convertToArrayBufferIfNodeBuffer(queryResponse.data);
            /**
             * First 8 bytes of the response, contain a Uint64 number
             * which is the size of the response we skip it.
             */
            const bufferWithoutFirstEightBytes = queryData.slice(8);
            /**
             * Deserialize buffer to a Query object
             */
            const queryObject = capnpQueryDeSerializer(bufferWithoutFirstEightBytes);
            const attributeHeaders = queryObject.attributeBufferHeaders;
            const results = yield this.getResultsFromArrayBuffer(arraySchema, bufferWithoutFirstEightBytes, attributeHeaders, options);
            return {
                results,
                query: queryObject,
                queryAsArrayBuffer: bufferWithoutFirstEightBytes,
            };
        });
    }
    ReadQuery(namespace, arrayName, body, arraySchema) {
        return __asyncGenerator(this, arguments, function* ReadQuery_1() {
            try {
                // Get ArraySchema of arrray, to get type information of the dimensions and the attributes
                if (typeof arraySchema === 'undefined') {
                    const arraySchemaResponse = yield __await(this.arrayAPI.getArray(namespace, arrayName, "application/json"));
                    arraySchema = arraySchemaResponse.data;
                }
                const options = {
                    ignoreNullables: body.ignoreNullables,
                    ignoreOffsets: body.ignoreOffsets,
                    attributes: body.attributes,
                    returnRawBuffers: body.returnRawBuffers
                };
                /**
                 * Get the query response in capnp, we set responseType to arraybuffer instead of JSON
                 * in order to deserialize the query capnp object.
                 */
                const queryResponse = yield __await(this.queryAPI.submitQuery(namespace, arrayName, Querytype.Read, "application/capnp", dataToQuery(body, arraySchema.attributes, arraySchema.domain.dimensions, options), undefined, undefined, undefined, {
                    headers: {
                        "Content-Type": "application/capnp",
                    },
                    responseType: "arraybuffer",
                }));
                /**
                 * Axios in nodeJS environments casts the response to a Buffer object
                 * we convert it back to an ArrayBuffer if needed
                 */
                const queryData = convertToArrayBufferIfNodeBuffer(queryResponse.data);
                /**
                 * First 8 bytes of the response, contain a Uint64 number
                 * which is the size of the response we skip it.
                 */
                let bufferWithoutFirstEightBytes = queryData.slice(8);
                /**
                 * Deserialize buffer to a Query object
                 */
                const queryObject = capnpQueryDeSerializer(bufferWithoutFirstEightBytes);
                const attributeHeaders = queryObject.attributeBufferHeaders;
                // Case it's incomplete query
                if (queryObject.status === Querystatus.Incomplete) {
                    try {
                        yield yield __await(yield __await(this.getResultsFromArrayBuffer(arraySchema, bufferWithoutFirstEightBytes, attributeHeaders, options)));
                        while (true) {
                            const { results, query, queryAsArrayBuffer } = yield __await(this.ReadIncompleteQuery(arraySchema, bufferWithoutFirstEightBytes, namespace, arrayName, options));
                            // Override query object with the new one returned from `ReadIncompleteQuery`
                            bufferWithoutFirstEightBytes = queryAsArrayBuffer;
                            if (query.status === Querystatus.Incomplete) {
                                yield yield __await(results);
                            }
                            else {
                                // Case query is not incomplete
                                yield yield __await(results);
                                return yield __await(void 0);
                            }
                        }
                    }
                    catch (e) {
                        this.throwError(e);
                    }
                }
                yield yield __await(this.getResultsFromArrayBuffer(arraySchema, bufferWithoutFirstEightBytes, attributeHeaders, options));
                return yield __await(void 0);
            }
            catch (e) {
                this.throwError(e);
            }
        });
    }
    getResultsFromArrayBuffer(arraySchema, bufferResults, attributeHeaders, options) {
        return __awaiter(this, void 0, void 0, function* () {
            /**
             * Calculate the size of bytes of the attributes from the attributeBufferHeaders of the Query object.
             */
            const numberOfBytesOfResults = getSizeInBytesOfAllAttributes(attributeHeaders);
            /**
             * We get the last N bytes (N is the number of total bytes of the attributes), which contain
             * the results of all the attributes
             */
            const resultsBuffer = bufferResults.slice(-1 * numberOfBytesOfResults);
            const mergeAttributesAndDimensions = [
                ...arraySchema.domain.dimensions,
                ...arraySchema.attributes,
            ];
            // Calculate results
            const results = yield getResultsFromArrayBuffer(resultsBuffer, attributeHeaders, mergeAttributesAndDimensions, options);
            return results;
        });
    }
    throwError(e) {
        var _a, _b, _c, _d;
        /**
         * Since we set the responseType to "arrayBuffer", in case the
         * response error message is a buffer, we deserialize the message before throwing
         */
        const errorIsABuffer = ((_b = (_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.buffer) || ((_d = (_c = e === null || e === void 0 ? void 0 : e.response) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.length);
        if (errorIsABuffer) {
            const errorArrayBuffer = convertToArrayBufferIfNodeBuffer(e.response.data);
            const decodedMessage = new TextDecoder().decode(errorArrayBuffer);
            throw new Error(decodedMessage);
        }
        else {
            throw e;
        }
    }
}

class UDF {
    constructor(params, axios = globalAxios) {
        const config = new Configuration$1(params);
        this.config = config;
        this.API = new UdfApi(config, undefined, axios);
    }
    //NOTE: TDB: We could use `btoa` to encode64 the `exec` field.
    registerUdf(namespace, name, udf) {
        return this.API.registerUDFInfo(namespace, name, udf);
    }
    registerGenericUdf(namespace, name, udf) {
        const udfObject = Object.assign(Object.assign({}, udf), { type: UDFType.Generic });
        return this.API.registerUDFInfo(namespace, name, udfObject);
    }
    registerSingleArrayUdf(namespace, name, udf) {
        const udfObject = Object.assign(Object.assign({}, udf), { type: UDFType.SingleArray });
        return this.API.registerUDFInfo(namespace, name, udfObject);
    }
    updateUdf(namespace, name, udf) {
        return this.API.updateUDFInfo(namespace, name, udf);
    }
    updateGenericUdf(namespace, name, udf) {
        const udfObject = Object.assign(Object.assign({}, udf), { type: UDFType.Generic });
        return this.API.updateUDFInfo(namespace, name, udfObject);
    }
    updateSingleArrayUdf(namespace, name, udf) {
        const udfObject = Object.assign(Object.assign({}, udf), { type: UDFType.SingleArray });
        return this.API.updateUDFInfo(namespace, name, udfObject);
    }
    exec(namespaceAndUdf, args, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!namespaceAndUdf.includes('/')) {
                throw new Error("First argument should include namespace and the udf name separated by a '/' e.g. TileDB/myUDF");
            }
            if (args && !Array.isArray(args)) {
                throw new Error("Arguments should be contained in an array");
            }
            const [namespace] = namespaceAndUdf.split("/");
            const udf = Object.assign(Object.assign({ udf_info_name: namespaceAndUdf }, (args ? { argument: JSON.stringify(args) } : {})), options);
            const result = yield this.API.submitGenericUDF(namespace, udf);
            return result.data;
        });
    }
    info(namespace, udfName) {
        return this.API.getUDFInfo(namespace, udfName);
    }
    share(namespace, udfName, udfSharing) {
        return this.API.shareUDFInfo(namespace, udfName, udfSharing);
    }
    unshare(namespace, udfName, namespaceToUnshare) {
        const noActions = {
            namespace: namespaceToUnshare,
            actions: [],
        };
        return this.API.shareUDFInfo(namespace, udfName, noActions);
    }
    delete(namespace, udfName) {
        return this.API.deleteUDFInfo(namespace, udfName);
    }
}

class Sql {
    constructor(params, axios = globalAxios) {
        const config = new Configuration$1(params);
        this.config = config;
        this.API = new SqlApi(config, undefined, axios);
    }
    exec(namespace, query, options) {
        const sql = Object.assign({ query }, options);
        return this.API.runSQL(namespace, sql);
    }
}

class Groups {
    constructor(params, paramsV2, axios = globalAxios) {
        this.API = new GroupsApi$1(params, undefined, axios);
        this.V2API = new GroupsApi(paramsV2, undefined, axios);
    }
    getGroupContents(namespace, name) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.API.getGroupContents(namespace, name);
            return result.data;
        });
    }
}

const defaultConfig = {
    basePath: "https://api.tiledb.com",
};
const isNode = typeof process === "object";
if (isNode) {
    if (process.env.TILEDB_REST_HOST) {
        defaultConfig.basePath = process.env.TILEDB_REST_HOST;
    }
    if (process.env.TILEDB_REST_TOKEN) {
        defaultConfig.apiKey = process.env.TILEDB_REST_TOKEN;
    }
}
class TileDBClient {
    constructor(params = defaultConfig) {
        const config = Object.assign(Object.assign({}, defaultConfig), params);
        this.axios = globalAxios.create();
        this.config = new Configuration(Object.assign(Object.assign({}, config), { 
            // for v1 API calls basePath needs /v1 suffix
            basePath: config.basePath + "/v1" }));
        // Add versioning if basePath exists
        this.configV2 = new Configuration(Object.assign(Object.assign(Object.assign({}, defaultConfig), params), { 
            // for v2 API calls, basePath needs /v2 suffix
            basePath: config.basePath + "/v2" }));
        this.ArrayApi = new ArrayApi$1(this.config, undefined, this.axios);
        this.OrganizationApi = new OrganizationApi$1(this.config, undefined, this.axios);
        this.UserApi = new UserApi$1(this.config, undefined, this.axios);
        this.NotebookApi = new NotebookApi(this.config, undefined, this.axios);
        this.TasksApi = new TasksApi(this.config, undefined, this.axios);
        this.udf = new UDF(this.config, this.axios);
        this.sql = new Sql(this.config, this.axios);
        this.groups = new Groups(this.config, this.configV2, this.axios);
        this.query = new TileDBQuery(this.configV2, this.axios);
    }
    info(namespace, array, options) {
        return this.ArrayApi.getArrayMetadata(namespace, array, options);
    }
    arrayActivity(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {
        return this.ArrayApi.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options);
    }
    deregisterArray(namespace, array, options) {
        return this.ArrayApi.deregisterArray(namespace, array, options);
    }
    registerArray(namespace, array, arrayMetadata, options) {
        return this.ArrayApi.registerArray(namespace, array, arrayMetadata, options);
    }
    listSharedWith(namespace, array, options) {
        return this.ArrayApi.getArraySharingPolicies(namespace, array, options);
    }
    shareArray(namespace, array, arraySharing, options) {
        return this.ArrayApi.shareArray(namespace, array, arraySharing, options);
    }
    unshareArray(namespace, array, namespaceToUnshare, options) {
        const noActions = {
            actions: [],
            namespace: namespaceToUnshare,
        };
        return this.ArrayApi.shareArray(namespace, array, noActions, options);
    }
    /**
     * List arrays in a user account
     */
    listArrays(params = {}) {
        const { page = 1, perPage = 1000, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options, } = params;
        return this.ArrayApi.arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);
    }
    /**
     * List public arrays
     */
    listPublicArrays(params = {}) {
        const { page = 1, perPage = 1000, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options, } = params;
        return this.ArrayApi.arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);
    }
    /**
     * List shared arrays
     */
    listSharedArrays(params = {}) {
        const { page = 1, perPage = 1000, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options, } = params;
        return this.ArrayApi.arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);
    }
    /**
     * Organization to fetch
     */
    organization(organization, options) {
        return this.OrganizationApi.getOrganization(organization, options);
    }
    /**
     * List of all organizations user is part of
     */
    organizations(options) {
        return this.OrganizationApi.getAllOrganizations(options);
    }
    /**
     * Your user profile
     */
    userProfile(options) {
        return this.UserApi.getUser(options);
    }
    /**
     * Rename a notebook's name
     */
    renameNotebook(namespace, array, notebookName, options) {
        const notebookMetadata = {
            name: notebookName,
        };
        return this.NotebookApi.updateNotebookName(namespace, array, notebookMetadata, options);
    }
    task(id, options) {
        return this.TasksApi.taskIdGet(id, options);
    }
    downloadNotebookContents(namespace, notebook) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ArrayApi.getArrayMetaDataJson(namespace, notebook);
            const notebookSize = res.data.file_size;
            if (!notebookSize) {
                throw new Error(`file_size was not found inside the array's metadata, are you sure that "${namespace}/${notebook}" is a TileDB notebook?`);
            }
            const query = {
                layout: Layout.RowMajor,
                ranges: [[0, notebookSize]],
                bufferSize: notebookSize,
                attributes: ["contents"],
            };
            // NotebookContents is an Array of Uint8
            let notebookContents = [];
            try {
                for (var _b = __asyncValues(this.query.ReadQuery(namespace, notebook, query)), _c; _c = yield _b.next(), !_c.done;) {
                    let results = _c.value;
                    notebookContents = notebookContents.concat(results.contents);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            const buffer = Uint8Array.from(notebookContents);
            const decoder = new TextDecoder();
            const json = decoder.decode(buffer);
            // Replace unprintable characters
            return json.replace(/[^\x20-\x7E]/g, "");
        });
    }
    downloadNotebookToFile(namespace, notebook) {
        return __awaiter(this, void 0, void 0, function* () {
            const contents = yield this.downloadNotebookContents(namespace, notebook);
            yield save(contents, `${notebook}.ipynb`);
        });
    }
    getFileContents(namespace, file) {
        var e_2, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.ArrayApi.getArrayMetaDataJson(namespace, file);
            const { original_file_name, file_size, mime_type } = res.data;
            if (!original_file_name || !file_size) {
                throw new Error(`file_size or original_file_name were not found inside the array's metadata, are you sure that "${namespace}/${file}" is a TileDB file?`);
            }
            // FileContents is an Array of Uint8
            let fileContents = [];
            const query = {
                layout: Layout.RowMajor,
                ranges: [[0, file_size]],
                bufferSize: file_size,
                attributes: ["contents"],
            };
            try {
                for (var _b = __asyncValues(this.query.ReadQuery(namespace, file, query)), _c; _c = yield _b.next(), !_c.done;) {
                    let results = _c.value;
                    fileContents = fileContents.concat(results.contents);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            const buffer = Uint8Array.from(fileContents).buffer;
            return {
                buffer,
                originalFileName: original_file_name,
                mimeType: mime_type,
            };
        });
    }
    downloadFile(namespace, file) {
        return __awaiter(this, void 0, void 0, function* () {
            const { buffer, originalFileName } = yield this.getFileContents(namespace, file);
            yield save(buffer, originalFileName);
        });
    }
    // TODO: We need a way to create an array and save contents as "contents" attribute
    uploadNotebookContents() { }
    // TODO: We should read file and call uploadNotebookContents
    uploadNotebookFromFile() { }
    // TODO: add this method
    lastSqlTask() { }
    // TODO: add this method
    lastUDFTask() { }
}

/* tslint:disable */

export { DeserializableType, TileDBQuery, TileDBClient as default, deserializeCapnp, index$1 as v1, index as v2 };
