"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotebooksApiAxiosParamCreator = exports.NotebookApi = exports.NotebookApiFactory = exports.NotebookApiFp = exports.NotebookApiAxiosParamCreator = exports.InvitationApi = exports.InvitationApiFactory = exports.InvitationApiFp = exports.InvitationApiAxiosParamCreator = exports.FavoritesApi = exports.FavoritesApiFactory = exports.FavoritesApiFp = exports.FavoritesApiAxiosParamCreator = exports.ArrayTasksApi = exports.ArrayTasksApiFactory = exports.ArrayTasksApiFp = exports.ArrayTasksApiAxiosParamCreator = exports.ArrayApi = exports.ArrayApiFactory = exports.ArrayApiFp = exports.ArrayApiAxiosParamCreator = exports.UDFType = exports.UDFLanguage = exports.UDFActions = exports.SSOProvider = exports.ResultFormat = exports.Querytype = exports.Querystatus = exports.PublicShareFilter = exports.PricingUnitLabel = exports.PricingType = exports.PricingInterval = exports.PricingCurrency = exports.PricingAggregateUsage = exports.OrganizationRoles = exports.NamespaceActions = exports.Layout = exports.InvitationType = exports.InvitationStatus = exports.FilterType = exports.FilterOption = exports.FileType = exports.FilePropertyName = exports.FavoriteType = exports.Datatype = exports.ArrayType = exports.ArrayTaskType = exports.ArrayTaskStatus = exports.ArrayActions = exports.ActivityEventType = void 0;
exports.UserApi = exports.UserApiFactory = exports.UserApiFp = exports.UserApiAxiosParamCreator = exports.UdfApi = exports.UdfApiFactory = exports.UdfApiFp = exports.UdfApiAxiosParamCreator = exports.TasksApi = exports.TasksApiFactory = exports.TasksApiFp = exports.TasksApiAxiosParamCreator = exports.StatsApi = exports.StatsApiFactory = exports.StatsApiFp = exports.StatsApiAxiosParamCreator = exports.SqlApi = exports.SqlApiFactory = exports.SqlApiFp = exports.SqlApiAxiosParamCreator = exports.QueryApi = exports.QueryApiFactory = exports.QueryApiFp = exports.QueryApiAxiosParamCreator = exports.OrganizationApi = exports.OrganizationApiFactory = exports.OrganizationApiFp = exports.OrganizationApiAxiosParamCreator = exports.NotebooksApi = exports.NotebooksApiFactory = exports.NotebooksApiFp = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 * Type of activity logged
 * @export
 * @enum {string}
 */
var ActivityEventType;
(function (ActivityEventType) {
    ActivityEventType["ReadSchema"] = "read_schema";
    ActivityEventType["MaxBufferSizes"] = "max_buffer_sizes";
    ActivityEventType["NonEmptyDomain"] = "non_empty_domain";
    ActivityEventType["QueryRead"] = "query_read";
    ActivityEventType["QueryWrite"] = "query_write";
    ActivityEventType["Create"] = "create";
    ActivityEventType["Delete"] = "delete";
    ActivityEventType["Register"] = "register";
    ActivityEventType["Deregister"] = "deregister";
    ActivityEventType["Udf"] = "udf";
    ActivityEventType["ArrayMetadataGet"] = "array_metadata_get";
    ActivityEventType["ArrayMetadataUpdate"] = "array_metadata_update";
    ActivityEventType["EstimatedResultSizes"] = "estimated_result_sizes";
})(ActivityEventType = exports.ActivityEventType || (exports.ActivityEventType = {}));
/**
 * actions a user can take on an array
 * @export
 * @enum {string}
 */
var ArrayActions;
(function (ArrayActions) {
    ArrayActions["Read"] = "read";
    ArrayActions["Write"] = "write";
    ArrayActions["Edit"] = "edit";
    ArrayActions["ReadArrayLogs"] = "read_array_logs";
    ArrayActions["ReadArrayInfo"] = "read_array_info";
    ArrayActions["ReadArraySchema"] = "read_array_schema";
})(ArrayActions = exports.ArrayActions || (exports.ArrayActions = {}));
/**
 * Status of array task
 * @export
 * @enum {string}
 */
var ArrayTaskStatus;
(function (ArrayTaskStatus) {
    ArrayTaskStatus["Failed"] = "FAILED";
    ArrayTaskStatus["Completed"] = "COMPLETED";
    ArrayTaskStatus["Running"] = "RUNNING";
})(ArrayTaskStatus = exports.ArrayTaskStatus || (exports.ArrayTaskStatus = {}));
/**
 * Synchronous Task Type
 * @export
 * @enum {string}
 */
var ArrayTaskType;
(function (ArrayTaskType) {
    ArrayTaskType["Sql"] = "SQL";
    ArrayTaskType["Udf"] = "UDF";
    ArrayTaskType["Query"] = "QUERY";
    ArrayTaskType["GenericUdf"] = "GENERIC_UDF";
})(ArrayTaskType = exports.ArrayTaskType || (exports.ArrayTaskType = {}));
/**
 * TileDB array type
 * @export
 * @enum {string}
 */
var ArrayType;
(function (ArrayType) {
    ArrayType["Dense"] = "dense";
    ArrayType["Sparse"] = "sparse";
})(ArrayType = exports.ArrayType || (exports.ArrayType = {}));
/**
 * TileDB data type
 * @export
 * @enum {string}
 */
var Datatype;
(function (Datatype) {
    Datatype["Int32"] = "INT32";
    Datatype["Int64"] = "INT64";
    Datatype["Float32"] = "FLOAT32";
    Datatype["Float64"] = "FLOAT64";
    Datatype["Char"] = "CHAR";
    Datatype["Int8"] = "INT8";
    Datatype["Uint8"] = "UINT8";
    Datatype["Int16"] = "INT16";
    Datatype["Uint16"] = "UINT16";
    Datatype["Uint32"] = "UINT32";
    Datatype["Uint64"] = "UINT64";
    Datatype["StringAscii"] = "STRING_ASCII";
    Datatype["StringUtf8"] = "STRING_UTF8";
    Datatype["StringUtf16"] = "STRING_UTF16";
    Datatype["StringUtf32"] = "STRING_UTF32";
    Datatype["StringUcs2"] = "STRING_UCS2";
    Datatype["StringUcs4"] = "STRING_UCS4";
    Datatype["Any"] = "ANY";
})(Datatype = exports.Datatype || (exports.Datatype = {}));
/**
 * List of values that FavoriteType can take
 * @export
 * @enum {string}
 */
var FavoriteType;
(function (FavoriteType) {
    FavoriteType["Array"] = "ARRAY";
})(FavoriteType = exports.FavoriteType || (exports.FavoriteType = {}));
/**
 * File property assigned to a specific file (array)
 * @export
 * @enum {string}
 */
var FilePropertyName;
(function (FilePropertyName) {
    FilePropertyName["Image"] = "image";
    FilePropertyName["Size"] = "size";
    FilePropertyName["CodeBlock"] = "code_block";
})(FilePropertyName = exports.FilePropertyName || (exports.FilePropertyName = {}));
/**
 * File types represented as TileDB arrays
 * @export
 * @enum {string}
 */
var FileType;
(function (FileType) {
    FileType["Notebook"] = "notebook";
    FileType["UserDefinedFunction"] = "user_defined_function";
})(FileType = exports.FileType || (exports.FileType = {}));
/**
 * TileDB filter option
 * @export
 * @enum {string}
 */
var FilterOption;
(function (FilterOption) {
    FilterOption["CompressionLevel"] = "COMPRESSION_LEVEL";
    FilterOption["BitWidthMaxWindow"] = "BIT_WIDTH_MAX_WINDOW";
    FilterOption["PositiveDeltaMaxWindow"] = "POSITIVE_DELTA_MAX_WINDOW";
})(FilterOption = exports.FilterOption || (exports.FilterOption = {}));
/**
 * TileDB filter types
 * @export
 * @enum {string}
 */
var FilterType;
(function (FilterType) {
    FilterType["None"] = "FILTER_NONE";
    FilterType["Gzip"] = "FILTER_GZIP";
    FilterType["Zstd"] = "FILTER_ZSTD";
    FilterType["Lz4"] = "FILTER_LZ4";
    FilterType["Rle"] = "FILTER_RLE";
    FilterType["Bzip2"] = "FILTER_BZIP2";
    FilterType["DoubleDelta"] = "FILTER_DOUBLE_DELTA";
    FilterType["BitWidthReduction"] = "FILTER_BIT_WIDTH_REDUCTION";
    FilterType["Bitshuffle"] = "FILTER_BITSHUFFLE";
    FilterType["Byteshuffle"] = "FILTER_BYTESHUFFLE";
    FilterType["PositiveDelta"] = "FILTER_POSITIVE_DELTA";
})(FilterType = exports.FilterType || (exports.FilterType = {}));
/**
 * List of values that InvitationStatus can take
 * @export
 * @enum {string}
 */
var InvitationStatus;
(function (InvitationStatus) {
    InvitationStatus["Pending"] = "PENDING";
    InvitationStatus["Accepted"] = "ACCEPTED";
})(InvitationStatus = exports.InvitationStatus || (exports.InvitationStatus = {}));
/**
 * List of values that InvitationType can take
 * @export
 * @enum {string}
 */
var InvitationType;
(function (InvitationType) {
    InvitationType["ArrayShare"] = "ARRAY_SHARE";
    InvitationType["JoinOrganization"] = "JOIN_ORGANIZATION";
})(InvitationType = exports.InvitationType || (exports.InvitationType = {}));
/**
 * Layout of array
 * @export
 * @enum {string}
 */
var Layout;
(function (Layout) {
    Layout["RowMajor"] = "row-major";
    Layout["ColMajor"] = "col-major";
    Layout["GlobalOrder"] = "global-order";
    Layout["Unordered"] = "unordered";
})(Layout = exports.Layout || (exports.Layout = {}));
/**
 * actions a user can take on an organization
 * @export
 * @enum {string}
 */
var NamespaceActions;
(function (NamespaceActions) {
    NamespaceActions["Read"] = "read";
    NamespaceActions["Write"] = "write";
    NamespaceActions["Create"] = "create";
    NamespaceActions["Delete"] = "delete";
    NamespaceActions["Edit"] = "edit";
    NamespaceActions["ReadArrayLogs"] = "read_array_logs";
    NamespaceActions["ReadJobLogs"] = "read_job_logs";
    NamespaceActions["ReadObjectLogs"] = "read_object_logs";
    NamespaceActions["RunJob"] = "run_job";
    NamespaceActions["DeleteOrganization"] = "delete_organization";
    NamespaceActions["EditOrganization"] = "edit_organization";
    NamespaceActions["EditBilling"] = "edit_billing";
})(NamespaceActions = exports.NamespaceActions || (exports.NamespaceActions = {}));
/**
 * role user has in organization
 * @export
 * @enum {string}
 */
var OrganizationRoles;
(function (OrganizationRoles) {
    OrganizationRoles["Owner"] = "owner";
    OrganizationRoles["Admin"] = "admin";
    OrganizationRoles["ReadWrite"] = "read_write";
    OrganizationRoles["ReadOnly"] = "read_only";
})(OrganizationRoles = exports.OrganizationRoles || (exports.OrganizationRoles = {}));
/**
 * Specifies a usage aggregation strategy for pricings of usage_type=metered
 * @export
 * @enum {string}
 */
var PricingAggregateUsage;
(function (PricingAggregateUsage) {
    PricingAggregateUsage["Sum"] = "sum";
})(PricingAggregateUsage = exports.PricingAggregateUsage || (exports.PricingAggregateUsage = {}));
/**
 * Currency of pricing
 * @export
 * @enum {string}
 */
var PricingCurrency;
(function (PricingCurrency) {
    PricingCurrency["Usd"] = "USD";
})(PricingCurrency = exports.PricingCurrency || (exports.PricingCurrency = {}));
/**
 * Interval for pricing
 * @export
 * @enum {string}
 */
var PricingInterval;
(function (PricingInterval) {
    PricingInterval["Month"] = "month";
})(PricingInterval = exports.PricingInterval || (exports.PricingInterval = {}));
/**
 * Pricing types
 * @export
 * @enum {string}
 */
var PricingType;
(function (PricingType) {
    PricingType["Egress"] = "egress";
    PricingType["Access"] = "access";
})(PricingType = exports.PricingType || (exports.PricingType = {}));
/**
 * Unit label
 * @export
 * @enum {string}
 */
var PricingUnitLabel;
(function (PricingUnitLabel) {
    PricingUnitLabel["Byte"] = "byte";
    PricingUnitLabel["Second"] = "second";
})(PricingUnitLabel = exports.PricingUnitLabel || (exports.PricingUnitLabel = {}));
/**
 * Query parameter to get array metadatas
 * @export
 * @enum {string}
 */
var PublicShareFilter;
(function (PublicShareFilter) {
    PublicShareFilter["Exclude"] = "exclude";
    PublicShareFilter["Only"] = "only";
})(PublicShareFilter = exports.PublicShareFilter || (exports.PublicShareFilter = {}));
/**
 * Status of query
 * @export
 * @enum {string}
 */
var Querystatus;
(function (Querystatus) {
    Querystatus["Failed"] = "FAILED";
    Querystatus["Completed"] = "COMPLETED";
    Querystatus["Inprogress"] = "INPROGRESS";
    Querystatus["Incomplete"] = "INCOMPLETE";
    Querystatus["Uninitialized"] = "UNINITIALIZED";
})(Querystatus = exports.Querystatus || (exports.Querystatus = {}));
/**
 * Type of query
 * @export
 * @enum {string}
 */
var Querytype;
(function (Querytype) {
    Querytype["Read"] = "READ";
    Querytype["Write"] = "WRITE";
})(Querytype = exports.Querytype || (exports.Querytype = {}));
/**
 * Results type
 * @export
 * @enum {string}
 */
var ResultFormat;
(function (ResultFormat) {
    ResultFormat["Native"] = "native";
    ResultFormat["Json"] = "json";
    ResultFormat["Arrow"] = "arrow";
})(ResultFormat = exports.ResultFormat || (exports.ResultFormat = {}));
/**
 * Single sign on provider
 * @export
 * @enum {string}
 */
var SSOProvider;
(function (SSOProvider) {
    SSOProvider["Github"] = "github";
    SSOProvider["Google"] = "google";
    SSOProvider["Stripe"] = "stripe";
})(SSOProvider = exports.SSOProvider || (exports.SSOProvider = {}));
/**
 * actions a user can take on an udf
 * @export
 * @enum {string}
 */
var UDFActions;
(function (UDFActions) {
    UDFActions["FetchUdf"] = "fetch_udf";
    UDFActions["ShareUdf"] = "share_udf";
})(UDFActions = exports.UDFActions || (exports.UDFActions = {}));
/**
 * UDF Type
 * @export
 * @enum {string}
 */
var UDFLanguage;
(function (UDFLanguage) {
    UDFLanguage["Python"] = "python";
    UDFLanguage["R"] = "r";
})(UDFLanguage = exports.UDFLanguage || (exports.UDFLanguage = {}));
/**
 * UDF Type
 * @export
 * @enum {string}
 */
var UDFType;
(function (UDFType) {
    UDFType["SingleArray"] = "single_array";
    UDFType["Generic"] = "generic";
})(UDFType = exports.UDFType || (exports.UDFType = {}));
/**
 * ArrayApi - axios parameter creator
 * @export
 */
const ArrayApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog: (namespace, array, start, end, eventTypes, taskId, hasTaskId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('arrayActivityLog', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('arrayActivityLog', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/activity`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (eventTypes !== undefined) {
                localVarQueryParameter['event_types'] = eventTypes;
            }
            if (taskId !== undefined) {
                localVarQueryParameter['task_id'] = taskId;
            }
            if (hasTaskId !== undefined) {
                localVarQueryParameter['has_task_id'] = hasTaskId;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/owned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/owned/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/public/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/shared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/shared/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consolidateArray: (namespace, array, tiledbConfig, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('consolidateArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('consolidateArray', 'array', array);
            // verify required parameter 'tiledbConfig' is not null or undefined
            common_1.assertParamExists('consolidateArray', 'tiledbConfig', tiledbConfig);
            const localVarPath = `/arrays/{namespace}/{array}/consolidate`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(tiledbConfig, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray: (namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('createArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('createArray', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('createArray', 'contentType', contentType);
            // verify required parameter 'arraySchema' is not null or undefined
            common_1.assertParamExists('createArray', 'arraySchema', arraySchema);
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arraySchema, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray: (namespace, array, contentType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('deleteArray', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('deleteArray', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deregisterArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('deregisterArray', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/deregister`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata: (publicShare, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (publicShare !== undefined) {
                localVarQueryParameter['public_share'] = publicShare;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray: (namespace, array, contentType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArray', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getArray', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes: (namespace, array, subarray, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayMaxBufferSizes', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayMaxBufferSizes', 'array', array);
            // verify required parameter 'subarray' is not null or undefined
            common_1.assertParamExists('getArrayMaxBufferSizes', 'subarray', subarray);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getArrayMaxBufferSizes', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}/max_buffer_sizes`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (subarray !== undefined) {
                localVarQueryParameter['subarray'] = subarray;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson: (namespace, array, length, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayMetaDataJson', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayMetaDataJson', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/metadata_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayMetadata', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayMetadata', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadataCap: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayMetadataCap', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayMetadataCap', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/array_metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain: (namespace, array, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomain', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomain', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomain', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}/non_empty_domain`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomainJson: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomainJson', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomainJson', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/non_empty_domain_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData: (namespace, array, samples, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArraySampleData', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArraySampleData', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/sample`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (samples !== undefined) {
                localVarQueryParameter['samples'] = samples;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArraySharingPolicies', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArraySharingPolicies', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArraysInNamespace', 'namespace', namespace);
            const localVarPath = `/arrays/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/last_accessed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray: (namespace, array, arrayMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('registerArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('registerArray', 'array', array);
            // verify required parameter 'arrayMetadata' is not null or undefined
            common_1.assertParamExists('registerArray', 'arrayMetadata', arrayMetadata);
            const localVarPath = `/arrays/{namespace}/{array}/register`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arrayMetadata, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray: (namespace, array, arraySharing, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('shareArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('shareArray', 'array', array);
            // verify required parameter 'arraySharing' is not null or undefined
            common_1.assertParamExists('shareArray', 'arraySharing', arraySharing);
            const localVarPath = `/arrays/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arraySharing, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata: (namespace, array, arrayMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateArrayMetadata', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('updateArrayMetadata', 'array', array);
            // verify required parameter 'arrayMetadata' is not null or undefined
            common_1.assertParamExists('updateArrayMetadata', 'arrayMetadata', arrayMetadata);
            const localVarPath = `/arrays/{namespace}/{array}/metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arrayMetadata, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadataCap: (namespace, array, arrayMetadataEntries, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateArrayMetadataCap', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('updateArrayMetadataCap', 'array', array);
            // verify required parameter 'arrayMetadataEntries' is not null or undefined
            common_1.assertParamExists('updateArrayMetadataCap', 'arrayMetadataEntries', arrayMetadataEntries);
            const localVarPath = `/arrays/{namespace}/{array}/array_metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arrayMetadataEntries, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vacuumArray: (namespace, array, tiledbConfig, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('vacuumArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('vacuumArray', 'array', array);
            // verify required parameter 'tiledbConfig' is not null or undefined
            common_1.assertParamExists('vacuumArray', 'tiledbConfig', tiledbConfig);
            const localVarPath = `/arrays/{namespace}/{array}/vacuum`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(tiledbConfig, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ArrayApiAxiosParamCreator = ArrayApiAxiosParamCreator;
/**
 * ArrayApi - functional programming interface
 * @export
 */
const ArrayApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ArrayApiAxiosParamCreator(configuration);
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserOwnedSidebarGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserPublicSidebarGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserSharedSidebarGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consolidateArray(namespace, array, tiledbConfig, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.consolidateArray(namespace, array, tiledbConfig, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray(namespace, array, contentType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteArray(namespace, array, contentType, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deregisterArray(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata(publicShare, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllArrayMetadata(publicShare, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray(namespace, array, contentType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArray(namespace, array, contentType, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get metadata from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson(namespace, array, length, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetaDataJson(namespace, array, length, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetadata(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadataCap(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetadataCap(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomainJson(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayNonEmptyDomainJson(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData(namespace, array, samples, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraySampleData(namespace, array, samples, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraySharingPolicies(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraysInNamespace(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLastAccessedArrays(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray(namespace, array, arrayMetadata, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerArray(namespace, array, arrayMetadata, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray(namespace, array, arraySharing, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareArray(namespace, array, arraySharing, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata(namespace, array, arrayMetadata, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateArrayMetadata(namespace, array, arrayMetadata, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadataCap(namespace, array, arrayMetadataEntries, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateArrayMetadataCap(namespace, array, arrayMetadataEntries, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vacuumArray(namespace, array, tiledbConfig, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.vacuumArray(namespace, array, tiledbConfig, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ArrayApiFp = ArrayApiFp;
/**
 * ArrayApi - factory interface
 * @export
 */
const ArrayApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ArrayApiFp(configuration);
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {
            return localVarFp.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options) {
            return localVarFp.arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet(options) {
            return localVarFp.arraysBrowserOwnedSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options) {
            return localVarFp.arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet(options) {
            return localVarFp.arraysBrowserPublicSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options) {
            return localVarFp.arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet(options) {
            return localVarFp.arraysBrowserSharedSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consolidateArray(namespace, array, tiledbConfig, options) {
            return localVarFp.consolidateArray(namespace, array, tiledbConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return localVarFp.createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray(namespace, array, contentType, options) {
            return localVarFp.deleteArray(namespace, array, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray(namespace, array, options) {
            return localVarFp.deregisterArray(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata(publicShare, options) {
            return localVarFp.getAllArrayMetadata(publicShare, options).then((request) => request(axios, basePath));
        },
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray(namespace, array, contentType, options) {
            return localVarFp.getArray(namespace, array, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {
            return localVarFp.getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson(namespace, array, length, options) {
            return localVarFp.getArrayMetaDataJson(namespace, array, length, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata(namespace, array, options) {
            return localVarFp.getArrayMetadata(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadataCap(namespace, array, options) {
            return localVarFp.getArrayMetadataCap(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {
            return localVarFp.getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomainJson(namespace, array, options) {
            return localVarFp.getArrayNonEmptyDomainJson(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData(namespace, array, samples, options) {
            return localVarFp.getArraySampleData(namespace, array, samples, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies(namespace, array, options) {
            return localVarFp.getArraySharingPolicies(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace(namespace, options) {
            return localVarFp.getArraysInNamespace(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays(options) {
            return localVarFp.getLastAccessedArrays(options).then((request) => request(axios, basePath));
        },
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray(namespace, array, arrayMetadata, options) {
            return localVarFp.registerArray(namespace, array, arrayMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray(namespace, array, arraySharing, options) {
            return localVarFp.shareArray(namespace, array, arraySharing, options).then((request) => request(axios, basePath));
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata(namespace, array, arrayMetadata, options) {
            return localVarFp.updateArrayMetadata(namespace, array, arrayMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadataCap(namespace, array, arrayMetadataEntries, options) {
            return localVarFp.updateArrayMetadataCap(namespace, array, arrayMetadataEntries, options).then((request) => request(axios, basePath));
        },
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vacuumArray(namespace, array, tiledbConfig, options) {
            return localVarFp.vacuumArray(namespace, array, tiledbConfig, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ArrayApiFactory = ArrayApiFactory;
/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
class ArrayApi extends base_1.BaseAPI {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {
        return exports.ArrayApiFp(this.configuration).arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that are owned directly by user or user\'s organizations
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserOwnedSidebarGet(options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserOwnedSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that have been shared publically
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a sidebar of all arrays that have been shared publically
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserPublicSidebarGet(options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserPublicSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserSharedSidebarGet(options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserSharedSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * consolidate an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    consolidateArray(namespace, array, tiledbConfig, options) {
        return exports.ArrayApiFp(this.configuration).consolidateArray(namespace, array, tiledbConfig, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * create a array schema at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArraySchema} arraySchema ArraySchema being created
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
        return exports.ArrayApiFp(this.configuration).createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    deleteArray(namespace, array, contentType, options) {
        return exports.ArrayApiFp(this.configuration).deleteArray(namespace, array, contentType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * deregister a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    deregisterArray(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).deregisterArray(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get all array metadata user has access to
     * @param {string} [publicShare] Public share values can be one of exclude, only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getAllArrayMetadata(publicShare, options) {
        return exports.ArrayApiFp(this.configuration).getAllArrayMetadata(publicShare, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get an ArraySchema using a url encoded uri
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArray(namespace, array, contentType, options) {
        return exports.ArrayApiFp(this.configuration).getArray(namespace, array, contentType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get the max buffer sizes of an array for a subarray
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} subarray CSV string of subarray to get max buffer sizes for
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {
        return exports.ArrayApiFp(this.configuration).getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [length] (optional) limit character length of returned values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetaDataJson(namespace, array, length, options) {
        return exports.ArrayApiFp(this.configuration).getArrayMetaDataJson(namespace, array, length, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetadata(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).getArrayMetadata(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetadataCap(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).getArrayMetadataCap(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get the non empty domain of an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {
        return exports.ArrayApiFp(this.configuration).getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get non-empty domain from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayNonEmptyDomainJson(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).getArrayNonEmptyDomainJson(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get an sample set of data from the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [samples] Number of sample results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraySampleData(namespace, array, samples, options) {
        return exports.ArrayApiFp(this.configuration).getArraySampleData(namespace, array, samples, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all sharing details of the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraySharingPolicies(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).getArraySharingPolicies(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata on all arrays in a namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraysInNamespace(namespace, options) {
        return exports.ArrayApiFp(this.configuration).getArraysInNamespace(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getLastAccessedArrays(options) {
        return exports.ArrayApiFp(this.configuration).getLastAccessedArrays(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * register an array at a specified URI registered to the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    registerArray(namespace, array, arrayMetadata, options) {
        return exports.ArrayApiFp(this.configuration).registerArray(namespace, array, arrayMetadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Share an array with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    shareArray(namespace, array, arraySharing, options) {
        return exports.ArrayApiFp(this.configuration).shareArray(namespace, array, arraySharing, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    updateArrayMetadata(namespace, array, arrayMetadata, options) {
        return exports.ArrayApiFp(this.configuration).updateArrayMetadata(namespace, array, arrayMetadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    updateArrayMetadataCap(namespace, array, arrayMetadataEntries, options) {
        return exports.ArrayApiFp(this.configuration).updateArrayMetadataCap(namespace, array, arrayMetadataEntries, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * vacuum an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    vacuumArray(namespace, array, tiledbConfig, options) {
        return exports.ArrayApiFp(this.configuration).vacuumArray(namespace, array, tiledbConfig, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ArrayApi = ArrayApi;
/**
 * ArrayTasksApi - axios parameter creator
 * @export
 */
const ArrayTasksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar: (start, end, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tasks/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ArrayTasksApiAxiosParamCreator = ArrayTasksApiAxiosParamCreator;
/**
 * ArrayTasksApi - functional programming interface
 * @export
 */
const ArrayTasksApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ArrayTasksApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar(start, end, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayTasksSidebar(start, end, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ArrayTasksApiFp = ArrayTasksApiFp;
/**
 * ArrayTasksApi - factory interface
 * @export
 */
const ArrayTasksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ArrayTasksApiFp(configuration);
    return {
        /**
         *
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar(start, end, options) {
            return localVarFp.getArrayTasksSidebar(start, end, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ArrayTasksApiFactory = ArrayTasksApiFactory;
/**
 * ArrayTasksApi - object-oriented interface
 * @export
 * @class ArrayTasksApi
 * @extends {BaseAPI}
 */
class ArrayTasksApi extends base_1.BaseAPI {
    /**
     *
     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayTasksApi
     */
    getArrayTasksSidebar(start, end, options) {
        return exports.ArrayTasksApiFp(this.configuration).getArrayTasksSidebar(start, end, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ArrayTasksApi = ArrayTasksApi;
/**
 * FavoritesApi - axios parameter creator
 * @export
 */
const FavoritesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete specific favorite
         * @param {string} id The uuid of the favorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFavoriteId: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('deleteFavoriteId', 'id', id);
            const localVarPath = `/favorites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch specific favorite of a user
         * @param {string} id The uuid of the favorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorite: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getFavorite', 'id', id);
            const localVarPath = `/favorites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch all favorites of connected user
         * @param {string} [type] The type of the desired favorites e.g. arrays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorites: (type, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add a new favorite
         * @param {FavoriteUpdate} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFavorite: (body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(body, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FavoritesApiAxiosParamCreator = FavoritesApiAxiosParamCreator;
/**
 * FavoritesApi - functional programming interface
 * @export
 */
const FavoritesApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.FavoritesApiAxiosParamCreator(configuration);
    return {
        /**
         * Delete specific favorite
         * @param {string} id The uuid of the favorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFavoriteId(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteFavoriteId(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch specific favorite of a user
         * @param {string} id The uuid of the favorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorite(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFavorite(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch all favorites of connected user
         * @param {string} [type] The type of the desired favorites e.g. arrays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorites(type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFavorites(type, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Add a new favorite
         * @param {FavoriteUpdate} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFavorite(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postFavorite(body, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.FavoritesApiFp = FavoritesApiFp;
/**
 * FavoritesApi - factory interface
 * @export
 */
const FavoritesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.FavoritesApiFp(configuration);
    return {
        /**
         * Delete specific favorite
         * @param {string} id The uuid of the favorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFavoriteId(id, options) {
            return localVarFp.deleteFavoriteId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch specific favorite of a user
         * @param {string} id The uuid of the favorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorite(id, options) {
            return localVarFp.getFavorite(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all favorites of connected user
         * @param {string} [type] The type of the desired favorites e.g. arrays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorites(type, options) {
            return localVarFp.getFavorites(type, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new favorite
         * @param {FavoriteUpdate} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFavorite(body, options) {
            return localVarFp.postFavorite(body, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FavoritesApiFactory = FavoritesApiFactory;
/**
 * FavoritesApi - object-oriented interface
 * @export
 * @class FavoritesApi
 * @extends {BaseAPI}
 */
class FavoritesApi extends base_1.BaseAPI {
    /**
     * Delete specific favorite
     * @param {string} id The uuid of the favorite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    deleteFavoriteId(id, options) {
        return exports.FavoritesApiFp(this.configuration).deleteFavoriteId(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch specific favorite of a user
     * @param {string} id The uuid of the favorite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getFavorite(id, options) {
        return exports.FavoritesApiFp(this.configuration).getFavorite(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch all favorites of connected user
     * @param {string} [type] The type of the desired favorites e.g. arrays
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getFavorites(type, options) {
        return exports.FavoritesApiFp(this.configuration).getFavorites(type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add a new favorite
     * @param {FavoriteUpdate} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    postFavorite(body, options) {
        return exports.FavoritesApiFp(this.configuration).postFavorite(body, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FavoritesApi = FavoritesApi;
/**
 * InvitationApi - axios parameter creator
 * @export
 */
const InvitationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the id of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation: (invitation, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invitation' is not null or undefined
            common_1.assertParamExists('acceptInvitation', 'invitation', invitation);
            const localVarPath = `/invitations/{invitation}`
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Cancels join organization invitation
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} organization name or uuid of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization: (invitation, organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invitation' is not null or undefined
            common_1.assertParamExists('cancelJoinOrganization', 'invitation', invitation);
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('cancelJoinOrganization', 'organization', organization);
            const localVarPath = `/invitations/{invitation}/{organization}/join`
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)))
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite: (namespace, invitation, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('cancelShareArrayByInvite', 'namespace', namespace);
            // verify required parameter 'invitation' is not null or undefined
            common_1.assertParamExists('cancelShareArrayByInvite', 'invitation', invitation);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('cancelShareArrayByInvite', 'array', array);
            const localVarPath = `/invitations/{invitation}/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or id of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations: (organization, array, start, end, page, perPage, type, status, orderby, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (organization !== undefined) {
                localVarQueryParameter['organization'] = organization;
            }
            if (array !== undefined) {
                localVarQueryParameter['array'] = array;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or uuid of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization: (organization, emailInvite, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('joinOrganization', 'organization', organization);
            // verify required parameter 'emailInvite' is not null or undefined
            common_1.assertParamExists('joinOrganization', 'emailInvite', emailInvite);
            const localVarPath = `/invitations/{organization}/join`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(emailInvite, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite: (namespace, array, emailInvite, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('shareArrayByInvite', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('shareArrayByInvite', 'array', array);
            // verify required parameter 'emailInvite' is not null or undefined
            common_1.assertParamExists('shareArrayByInvite', 'emailInvite', emailInvite);
            const localVarPath = `/invitations/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(emailInvite, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InvitationApiAxiosParamCreator = InvitationApiAxiosParamCreator;
/**
 * InvitationApi - functional programming interface
 * @export
 */
const InvitationApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.InvitationApiAxiosParamCreator(configuration);
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the id of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(invitation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.acceptInvitation(invitation, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Cancels join organization invitation
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} organization name or uuid of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization(invitation, organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelJoinOrganization(invitation, organization, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite(namespace, invitation, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelShareArrayByInvite(namespace, invitation, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or id of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or uuid of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization(organization, emailInvite, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.joinOrganization(organization, emailInvite, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite(namespace, array, emailInvite, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareArrayByInvite(namespace, array, emailInvite, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.InvitationApiFp = InvitationApiFp;
/**
 * InvitationApi - factory interface
 * @export
 */
const InvitationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.InvitationApiFp(configuration);
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the id of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(invitation, options) {
            return localVarFp.acceptInvitation(invitation, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels join organization invitation
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} organization name or uuid of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization(invitation, organization, options) {
            return localVarFp.cancelJoinOrganization(invitation, organization, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite(namespace, invitation, array, options) {
            return localVarFp.cancelShareArrayByInvite(namespace, invitation, array, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or id of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {
            return localVarFp.fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or uuid of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization(organization, emailInvite, options) {
            return localVarFp.joinOrganization(organization, emailInvite, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite(namespace, array, emailInvite, options) {
            return localVarFp.shareArrayByInvite(namespace, array, emailInvite, options).then((request) => request(axios, basePath));
        },
    };
};
exports.InvitationApiFactory = InvitationApiFactory;
/**
 * InvitationApi - object-oriented interface
 * @export
 * @class InvitationApi
 * @extends {BaseAPI}
 */
class InvitationApi extends base_1.BaseAPI {
    /**
     * Accepts invitation
     * @param {string} invitation the id of invitation about to be accepted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    acceptInvitation(invitation, options) {
        return exports.InvitationApiFp(this.configuration).acceptInvitation(invitation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cancels join organization invitation
     * @param {string} invitation the id of invitation about to be cancelled
     * @param {string} organization name or uuid of organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    cancelJoinOrganization(invitation, organization, options) {
        return exports.InvitationApiFp(this.configuration).cancelJoinOrganization(invitation, organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cancels array sharing invitation
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} invitation the id of invitation about to be cancelled
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    cancelShareArrayByInvite(namespace, invitation, array, options) {
        return exports.InvitationApiFp(this.configuration).cancelShareArrayByInvite(namespace, invitation, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of invitations
     * @param {string} [organization] name or id of organization to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
     * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
     * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {
        return exports.InvitationApiFp(this.configuration).fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends email to multiple recipients with joining information regarding an organization
     * @param {string} organization name or uuid of organization
     * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    joinOrganization(organization, emailInvite, options) {
        return exports.InvitationApiFp(this.configuration).joinOrganization(organization, emailInvite, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends email to multiple recipients with sharing information regarding an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {InvitationArrayShareEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    shareArrayByInvite(namespace, array, emailInvite, options) {
        return exports.InvitationApiFp(this.configuration).shareArrayByInvite(namespace, array, emailInvite, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InvitationApi = InvitationApi;
/**
 * NotebookApi - axios parameter creator
 * @export
 */
const NotebookApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getNotebookServerStatus', 'namespace', namespace);
            const localVarPath = `/notebooks/server/{namespace}/status`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('shutdownNotebookServer', 'namespace', namespace);
            const localVarPath = `/notebooks/server/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update name on a notebok, moving related s3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotebookName: (namespace, array, notebookMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateNotebookName', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('updateNotebookName', 'array', array);
            // verify required parameter 'notebookMetadata' is not null or undefined
            common_1.assertParamExists('updateNotebookName', 'notebookMetadata', notebookMetadata);
            const localVarPath = `/notebooks/{namespace}/{array}/rename`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(notebookMetadata, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.NotebookApiAxiosParamCreator = NotebookApiAxiosParamCreator;
/**
 * NotebookApi - functional programming interface
 * @export
 */
const NotebookApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.NotebookApiAxiosParamCreator(configuration);
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getNotebookServerStatus(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shutdownNotebookServer(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update name on a notebok, moving related s3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotebookName(namespace, array, notebookMetadata, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateNotebookName(namespace, array, notebookMetadata, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.NotebookApiFp = NotebookApiFp;
/**
 * NotebookApi - factory interface
 * @export
 */
const NotebookApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.NotebookApiFp(configuration);
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus(namespace, options) {
            return localVarFp.getNotebookServerStatus(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer(namespace, options) {
            return localVarFp.shutdownNotebookServer(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * update name on a notebok, moving related s3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotebookName(namespace, array, notebookMetadata, options) {
            return localVarFp.updateNotebookName(namespace, array, notebookMetadata, options).then((request) => request(axios, basePath));
        },
    };
};
exports.NotebookApiFactory = NotebookApiFactory;
/**
 * NotebookApi - object-oriented interface
 * @export
 * @class NotebookApi
 * @extends {BaseAPI}
 */
class NotebookApi extends base_1.BaseAPI {
    /**
     * Get status of the notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    getNotebookServerStatus(namespace, options) {
        return exports.NotebookApiFp(this.configuration).getNotebookServerStatus(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Shutdown a notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    shutdownNotebookServer(namespace, options) {
        return exports.NotebookApiFp(this.configuration).shutdownNotebookServer(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update name on a notebok, moving related s3 object to new location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of notebook (array) that is url-encoded
     * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    updateNotebookName(namespace, array, notebookMetadata, options) {
        return exports.NotebookApiFp(this.configuration).updateNotebookName(namespace, array, notebookMetadata, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.NotebookApi = NotebookApi;
/**
 * NotebooksApi - axios parameter creator
 * @export
 */
const NotebooksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notebooksNamespaceArrayVersionsGet: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('notebooksNamespaceArrayVersionsGet', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('notebooksNamespaceArrayVersionsGet', 'array', array);
            const localVarPath = `/notebooks/{namespace}/{array}/versions`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.NotebooksApiAxiosParamCreator = NotebooksApiAxiosParamCreator;
/**
 * NotebooksApi - functional programming interface
 * @export
 */
const NotebooksApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.NotebooksApiAxiosParamCreator(configuration);
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notebooksNamespaceArrayVersionsGet(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.notebooksNamespaceArrayVersionsGet(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.NotebooksApiFp = NotebooksApiFp;
/**
 * NotebooksApi - factory interface
 * @export
 */
const NotebooksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.NotebooksApiFp(configuration);
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notebooksNamespaceArrayVersionsGet(namespace, array, options) {
            return localVarFp.notebooksNamespaceArrayVersionsGet(namespace, array, options).then((request) => request(axios, basePath));
        },
    };
};
exports.NotebooksApiFactory = NotebooksApiFactory;
/**
 * NotebooksApi - object-oriented interface
 * @export
 * @class NotebooksApi
 * @extends {BaseAPI}
 */
class NotebooksApi extends base_1.BaseAPI {
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    notebooksNamespaceArrayVersionsGet(namespace, array, options) {
        return exports.NotebooksApiFp(this.configuration).notebooksNamespaceArrayVersionsGet(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.NotebooksApi = NotebooksApi;
/**
 * OrganizationApi - axios parameter creator
 * @export
 */
const OrganizationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials: (namespace, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('addAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            common_1.assertParamExists('addAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization: (organization, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('addUserToOrganization', 'organization', organization);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('addUserToOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/user`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentials', 'namespace', namespace);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('createOrganization', 'organization', organization);
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(organization, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteAWSAccessCredentials', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('deleteOrganization', 'organization', organization);
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('deleteUserFromOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('deleteUserFromOrganization', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('getOrganization', 'organization', organization);
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('getOrganizationUser', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('getOrganizationUser', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials: (namespace, name, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'name', name);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a organization
         * @param {string} organization organization name or id
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: (organization, organizationDetails, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('updateOrganization', 'organization', organization);
            // verify required parameter 'organizationDetails' is not null or undefined
            common_1.assertParamExists('updateOrganization', 'organizationDetails', organizationDetails);
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(organizationDetails, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization: (organization, username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'username', username);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.OrganizationApiAxiosParamCreator = OrganizationApiAxiosParamCreator;
/**
 * OrganizationApi - functional programming interface
 * @export
 */
const OrganizationApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.OrganizationApiAxiosParamCreator(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addAWSAccessCredentials(namespace, awsAccessCredentials, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addUserToOrganization(organization, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentials(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentialsByName(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createOrganization(organization, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAWSAccessCredentials(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteOrganization(organization, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserFromOrganization(organization, username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllOrganizations(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganization(organization, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizationUser(organization, username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update a organization
         * @param {string} organization organization name or id
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organization, organizationDetails, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateOrganization(organization, organizationDetails, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserInOrganization(organization, username, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.OrganizationApiFp = OrganizationApiFp;
/**
 * OrganizationApi - factory interface
 * @export
 */
const OrganizationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.OrganizationApiFp(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return localVarFp.addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return localVarFp.addUserToOrganization(organization, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return localVarFp.checkAWSAccessCredentials(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return localVarFp.checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organization, options) {
            return localVarFp.createOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return localVarFp.deleteAWSAccessCredentials(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organization, options) {
            return localVarFp.deleteOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return localVarFp.deleteUserFromOrganization(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations(options) {
            return localVarFp.getAllOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * get a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organization, options) {
            return localVarFp.getOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return localVarFp.getOrganizationUser(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return localVarFp.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * update a organization
         * @param {string} organization organization name or id
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organization, organizationDetails, options) {
            return localVarFp.updateOrganization(organization, organizationDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return localVarFp.updateUserInOrganization(organization, username, user, options).then((request) => request(axios, basePath));
        },
    };
};
exports.OrganizationApiFactory = OrganizationApiFactory;
/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
class OrganizationApi extends base_1.BaseAPI {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
        return exports.OrganizationApiFp(this.configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addUserToOrganization(organization, user, options) {
        return exports.OrganizationApiFp(this.configuration).addUserToOrganization(organization, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    checkAWSAccessCredentials(namespace, options) {
        return exports.OrganizationApiFp(this.configuration).checkAWSAccessCredentials(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    checkAWSAccessCredentialsByName(namespace, name, options) {
        return exports.OrganizationApiFp(this.configuration).checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * create a organization, the user creating will be listed as owner
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    createOrganization(organization, options) {
        return exports.OrganizationApiFp(this.configuration).createOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteAWSAccessCredentials(namespace, name, options) {
        return exports.OrganizationApiFp(this.configuration).deleteAWSAccessCredentials(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a organization
     * @param {string} organization organization name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteOrganization(organization, options) {
        return exports.OrganizationApiFp(this.configuration).deleteOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteUserFromOrganization(organization, username, options) {
        return exports.OrganizationApiFp(this.configuration).deleteUserFromOrganization(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get all organizations that the user is member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getAllOrganizations(options) {
        return exports.OrganizationApiFp(this.configuration).getAllOrganizations(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a organization
     * @param {string} organization organization name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getOrganization(organization, options) {
        return exports.OrganizationApiFp(this.configuration).getOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getOrganizationUser(organization, username, options) {
        return exports.OrganizationApiFp(this.configuration).getOrganizationUser(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
        return exports.OrganizationApiFp(this.configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a organization
     * @param {string} organization organization name or id
     * @param {Organization} organizationDetails organization details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateOrganization(organization, organizationDetails, options) {
        return exports.OrganizationApiFp(this.configuration).updateOrganization(organization, organizationDetails, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateUserInOrganization(organization, username, user, options) {
        return exports.OrganizationApiFp(this.configuration).updateUserInOrganization(organization, username, user, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.OrganizationApi = OrganizationApi;
/**
 * QueryApi - axios parameter creator
 * @export
 */
const QueryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'array', array);
            // verify required parameter 'type' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/finalize`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'array', array);
            // verify required parameter 'type' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/est_result_sizes`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: (namespace, array, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getFile', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getFile', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getFile', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}/query/get_file`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitQuery', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('submitQuery', 'array', array);
            // verify required parameter 'type' is not null or undefined
            common_1.assertParamExists('submitQuery', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('submitQuery', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('submitQuery', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns json results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQueryJson: (namespace, array, contentType, queryJson, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitQueryJson', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('submitQueryJson', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('submitQueryJson', 'contentType', contentType);
            // verify required parameter 'queryJson' is not null or undefined
            common_1.assertParamExists('submitQueryJson', 'queryJson', queryJson);
            const localVarPath = `/arrays/{namespace}/{array}/query/submit_query_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(queryJson, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.QueryApiAxiosParamCreator = QueryApiAxiosParamCreator;
/**
 * QueryApi - functional programming interface
 * @export
 */
const QueryApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.QueryApiAxiosParamCreator(configuration);
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(namespace, array, contentType, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFile(namespace, array, contentType, xPayer, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns json results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitQueryJson(namespace, array, contentType, queryJson, xPayer, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.QueryApiFp = QueryApiFp;
/**
 * QueryApi - factory interface
 * @export
 */
const QueryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.QueryApiFp(configuration);
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return localVarFp.finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return localVarFp.getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(namespace, array, contentType, xPayer, options) {
            return localVarFp.getFile(namespace, array, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return localVarFp.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns json results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {
            return localVarFp.submitQueryJson(namespace, array, contentType, queryJson, xPayer, options).then((request) => request(axios, basePath));
        },
    };
};
exports.QueryApiFactory = QueryApiFactory;
/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
class QueryApi extends base_1.BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
        return exports.QueryApiFp(this.configuration).finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {
        return exports.QueryApiFp(this.configuration).getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns file bytes
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    getFile(namespace, array, contentType, xPayer, options) {
        return exports.QueryApiFp(this.configuration).getFile(namespace, array, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
        return exports.QueryApiFp(this.configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns json results
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {QueryJson} queryJson query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {
        return exports.QueryApiFp(this.configuration).submitQueryJson(namespace, array, contentType, queryJson, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.QueryApi = QueryApi;
/**
 * SqlApi - axios parameter creator
 * @export
 */
const SqlApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL: (namespace, sql, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('runSQL', 'namespace', namespace);
            // verify required parameter 'sql' is not null or undefined
            common_1.assertParamExists('runSQL', 'sql', sql);
            const localVarPath = `/sql/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(sql, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SqlApiAxiosParamCreator = SqlApiAxiosParamCreator;
/**
 * SqlApi - functional programming interface
 * @export
 */
const SqlApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.SqlApiAxiosParamCreator(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.runSQL(namespace, sql, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.SqlApiFp = SqlApiFp;
/**
 * SqlApi - factory interface
 * @export
 */
const SqlApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.SqlApiFp(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return localVarFp.runSQL(namespace, sql, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SqlApiFactory = SqlApiFactory;
/**
 * SqlApi - object-oriented interface
 * @export
 * @class SqlApi
 * @extends {BaseAPI}
 */
class SqlApi extends base_1.BaseAPI {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SqlApi
     */
    runSQL(namespace, sql, acceptEncoding, options) {
        return exports.SqlApiFp(this.configuration).runSQL(namespace, sql, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SqlApi = SqlApi;
/**
 * StatsApi - axios parameter creator
 * @export
 */
const StatsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/.stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.StatsApiAxiosParamCreator = StatsApiAxiosParamCreator;
/**
 * StatsApi - functional programming interface
 * @export
 */
const StatsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.StatsApiAxiosParamCreator(configuration);
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTiledbStats(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.StatsApiFp = StatsApiFp;
/**
 * StatsApi - factory interface
 * @export
 */
const StatsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.StatsApiFp(configuration);
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats(options) {
            return localVarFp.getTiledbStats(options).then((request) => request(axios, basePath));
        },
    };
};
exports.StatsApiFactory = StatsApiFactory;
/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
class StatsApi extends base_1.BaseAPI {
    /**
     * Fetch libtiledb stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    getTiledbStats(options) {
        return exports.StatsApiFp(this.configuration).getTiledbStats(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.StatsApi = StatsApi;
/**
 * TasksApi - axios parameter creator
 * @export
 */
const TasksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL: (namespace, sql, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('runSQL', 'namespace', namespace);
            // verify required parameter 'sql' is not null or undefined
            common_1.assertParamExists('runSQL', 'sql', sql);
            const localVarPath = `/sql/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(sql, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch an array task
         * @param {string} id task id to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('taskIdGet', 'id', id);
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve results of an array task
         * @param {string} id task id to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdResultGet: (id, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('taskIdResultGet', 'id', id);
            const localVarPath = `/task/{id}/result`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet: (namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }
            if (array !== undefined) {
                localVarQueryParameter['array'] = array;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (excludeType) {
                localVarQueryParameter['exclude_type'] = excludeType.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TasksApiAxiosParamCreator = TasksApiAxiosParamCreator;
/**
 * TasksApi - functional programming interface
 * @export
 */
const TasksApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.TasksApiAxiosParamCreator(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.runSQL(namespace, sql, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch an array task
         * @param {string} id task id to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.taskIdGet(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve results of an array task
         * @param {string} id task id to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdResultGet(id, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.taskIdResultGet(id, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TasksApiFp = TasksApiFp;
/**
 * TasksApi - factory interface
 * @export
 */
const TasksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.TasksApiFp(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return localVarFp.runSQL(namespace, sql, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch an array task
         * @param {string} id task id to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet(id, options) {
            return localVarFp.taskIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve results of an array task
         * @param {string} id task id to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdResultGet(id, acceptEncoding, options) {
            return localVarFp.taskIdResultGet(id, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {
            return localVarFp.tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TasksApiFactory = TasksApiFactory;
/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
class TasksApi extends base_1.BaseAPI {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    runSQL(namespace, sql, acceptEncoding, options) {
        return exports.TasksApiFp(this.configuration).runSQL(namespace, sql, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch an array task
     * @param {string} id task id to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    taskIdGet(id, options) {
        return exports.TasksApiFp(this.configuration).taskIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve results of an array task
     * @param {string} id task id to retrieve stored results
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    taskIdResultGet(id, acceptEncoding, options) {
        return exports.TasksApiFp(this.configuration).taskIdResultGet(id, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all array tasks a user has access to
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
     * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
     * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
     * @param {string} [status] Filter to only return these statuses
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include start_time, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {
        return exports.TasksApiFp(this.configuration).tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TasksApi = TasksApi;
/**
 * UdfApi - axios parameter creator
 * @export
 */
const UdfApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * delete a registerd UDF, this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFInfo: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteUDFInfo', 'name', name);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('getUDFInfo', 'name', name);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all sharing details of the udf
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getUDFInfoSharingPolicies', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('getUDFInfoSharingPolicies', 'name', name);
            const localVarPath = `/udf/{namespace}/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo: (namespace, name, udf, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('registerUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('registerUDFInfo', 'name', name);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('registerUDFInfo', 'udf', udf);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo: (namespace, name, udfSharing, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('shareUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('shareUDFInfo', 'name', name);
            // verify required parameter 'udfSharing' is not null or undefined
            common_1.assertParamExists('shareUDFInfo', 'udfSharing', udfSharing);
            const localVarPath = `/udf/{namespace}/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udfSharing, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF: (namespace, udf, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitGenericUDF', 'namespace', namespace);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('submitGenericUDF', 'udf', udf);
            const localVarPath = `/udfs/generic/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiArrayUDF: (namespace, udf, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitMultiArrayUDF', 'namespace', namespace);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('submitMultiArrayUDF', 'udf', udf);
            const localVarPath = `/udfs/arrays/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf udf to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array udfs should be used, currently in beta testing. Setting any value will enable v2 array udfs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF: (namespace, array, udf, xPayer, acceptEncoding, v2, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitUDF', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('submitUDF', 'array', array);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('submitUDF', 'udf', udf);
            const localVarPath = `/arrays/{namespace}/{array}/udf/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (v2 !== undefined) {
                localVarQueryParameter['v2'] = v2;
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        udfNamespaceArrayVersionsGet: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('udfNamespaceArrayVersionsGet', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('udfNamespaceArrayVersionsGet', 'array', array);
            const localVarPath = `/udf/{namespace}/{array}/versions`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * updated an existing registerd UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo: (namespace, name, udf, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('updateUDFInfo', 'name', name);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('updateUDFInfo', 'udf', udf);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UdfApiAxiosParamCreator = UdfApiAxiosParamCreator;
/**
 * UdfApi - functional programming interface
 * @export
 */
const UdfApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.UdfApiAxiosParamCreator(configuration);
    return {
        /**
         * delete a registerd UDF, this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFInfo(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUDFInfo(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUDFInfo(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get all sharing details of the udf
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUDFInfoSharingPolicies(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo(namespace, name, udf, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerUDFInfo(namespace, name, udf, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo(namespace, name, udfSharing, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareUDFInfo(namespace, name, udfSharing, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF(namespace, udf, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitGenericUDF(namespace, udf, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitMultiArrayUDF(namespace, udf, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf udf to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array udfs should be used, currently in beta testing. Setting any value will enable v2 array udfs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        udfNamespaceArrayVersionsGet(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.udfNamespaceArrayVersionsGet(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * updated an existing registerd UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo(namespace, name, udf, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUDFInfo(namespace, name, udf, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.UdfApiFp = UdfApiFp;
/**
 * UdfApi - factory interface
 * @export
 */
const UdfApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.UdfApiFp(configuration);
    return {
        /**
         * delete a registerd UDF, this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFInfo(namespace, name, options) {
            return localVarFp.deleteUDFInfo(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo(namespace, name, options) {
            return localVarFp.getUDFInfo(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sharing details of the udf
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies(namespace, name, options) {
            return localVarFp.getUDFInfoSharingPolicies(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo(namespace, name, udf, options) {
            return localVarFp.registerUDFInfo(namespace, name, udf, options).then((request) => request(axios, basePath));
        },
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo(namespace, name, udfSharing, options) {
            return localVarFp.shareUDFInfo(namespace, name, udfSharing, options).then((request) => request(axios, basePath));
        },
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF(namespace, udf, acceptEncoding, options) {
            return localVarFp.submitGenericUDF(namespace, udf, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {
            return localVarFp.submitMultiArrayUDF(namespace, udf, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf udf to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array udfs should be used, currently in beta testing. Setting any value will enable v2 array udfs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {
            return localVarFp.submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options).then((request) => request(axios, basePath));
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        udfNamespaceArrayVersionsGet(namespace, array, options) {
            return localVarFp.udfNamespaceArrayVersionsGet(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * updated an existing registerd UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo(namespace, name, udf, options) {
            return localVarFp.updateUDFInfo(namespace, name, udf, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UdfApiFactory = UdfApiFactory;
/**
 * UdfApi - object-oriented interface
 * @export
 * @class UdfApi
 * @extends {BaseAPI}
 */
class UdfApi extends base_1.BaseAPI {
    /**
     * delete a registerd UDF, this will remove all sharing and can not be undone
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    deleteUDFInfo(namespace, name, options) {
        return exports.UdfApiFp(this.configuration).deleteUDFInfo(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a specific UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    getUDFInfo(namespace, name, options) {
        return exports.UdfApiFp(this.configuration).getUDFInfo(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all sharing details of the udf
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    getUDFInfoSharingPolicies(namespace, name, options) {
        return exports.UdfApiFp(this.configuration).getUDFInfoSharingPolicies(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * register a UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {UDFInfoUpdate} udf udf to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    registerUDFInfo(namespace, name, udf, options) {
        return exports.UdfApiFp(this.configuration).registerUDFInfo(namespace, name, udf, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Share a UDF with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    shareUDFInfo(namespace, name, udfSharing, options) {
        return exports.UdfApiFp(this.configuration).shareUDFInfo(namespace, name, udfSharing, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * submit a generic UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {GenericUDF} udf udf to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitGenericUDF(namespace, udf, acceptEncoding, options) {
        return exports.UdfApiFp(this.configuration).submitGenericUDF(namespace, udf, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * submit a multi-array UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {MultiArrayUDF} udf udf to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {
        return exports.UdfApiFp(this.configuration).submitMultiArrayUDF(namespace, udf, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a UDF to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {MultiArrayUDF} udf udf to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {string} [acceptEncoding] Encoding to use
     * @param {string} [v2] flag to indicate if v2 array udfs should be used, currently in beta testing. Setting any value will enable v2 array udfs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {
        return exports.UdfApiFp(this.configuration).submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    udfNamespaceArrayVersionsGet(namespace, array, options) {
        return exports.UdfApiFp(this.configuration).udfNamespaceArrayVersionsGet(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * updated an existing registerd UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {UDFInfoUpdate} udf udf to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    updateUDFInfo(namespace, name, udf, options) {
        return exports.UdfApiFp(this.configuration).updateUDFInfo(namespace, name, udf, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UdfApi = UdfApi;
/**
 * UserApi - axios parameter creator
 * @export
 */
const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials: (namespace, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('addAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            common_1.assertParamExists('addAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization: (organization, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('addUserToOrganization', 'organization', organization);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('addUserToOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/user`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentials', 'namespace', namespace);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/user/confirm_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: (user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('createUser', 'user', user);
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteAWSAccessCredentials', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: (username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('deleteUser', 'username', username);
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('deleteUserFromOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('deleteUserFromOrganization', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('getOrganizationUser', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('getOrganizationUser', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: (rememberMe, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (rememberMe !== undefined) {
                localVarQueryParameter['remember_me'] = rememberMe;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername: (username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('getUserWithUsername', 'username', username);
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken: (tokenRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * reset user password
         * @param {InlineObject} user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword: (user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('resetUserPassword', 'user', user);
            const localVarPath = `/user/password_reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken: (token, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'token' is not null or undefined
            common_1.assertParamExists('revokeToken', 'token', token);
            const localVarPath = `/tokens/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensSessionGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tokens/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials: (namespace, name, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'name', name);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a user
         * @param {string} username username or id
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: (username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('updateUser', 'username', username);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('updateUser', 'user', user);
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization: (organization, username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'username', username);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UserApiAxiosParamCreator = UserApiAxiosParamCreator;
/**
 * UserApi - functional programming interface
 * @export
 */
const UserApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.UserApiAxiosParamCreator(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addAWSAccessCredentials(namespace, awsAccessCredentials, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addUserToOrganization(organization, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentials(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentialsByName(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.confirmEmail(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createUser(user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAWSAccessCredentials(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUser(username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserFromOrganization(organization, username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizationUser(organization, username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(rememberMe, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSession(rememberMe, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUser(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername(username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserWithUsername(username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken(tokenRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.requestToken(tokenRequest, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * reset user password
         * @param {InlineObject} user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resetUserPassword(user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(token, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.revokeToken(token, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokensGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensSessionGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokensSessionGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update a user
         * @param {string} username username or id
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUser(username, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserInOrganization(organization, username, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.UserApiFp = UserApiFp;
/**
 * UserApi - factory interface
 * @export
 */
const UserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.UserApiFp(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return localVarFp.addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return localVarFp.addUserToOrganization(organization, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return localVarFp.checkAWSAccessCredentials(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return localVarFp.checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail(options) {
            return localVarFp.confirmEmail(options).then((request) => request(axios, basePath));
        },
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user, options) {
            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return localVarFp.deleteAWSAccessCredentials(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username, options) {
            return localVarFp.deleteUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return localVarFp.deleteUserFromOrganization(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return localVarFp.getOrganizationUser(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(rememberMe, options) {
            return localVarFp.getSession(rememberMe, options).then((request) => request(axios, basePath));
        },
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options) {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * get a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername(username, options) {
            return localVarFp.getUserWithUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken(tokenRequest, options) {
            return localVarFp.requestToken(tokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * reset user password
         * @param {InlineObject} user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(user, options) {
            return localVarFp.resetUserPassword(user, options).then((request) => request(axios, basePath));
        },
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(token, options) {
            return localVarFp.revokeToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options) {
            return localVarFp.tokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensSessionGet(options) {
            return localVarFp.tokensSessionGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return localVarFp.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user
         * @param {string} username username or id
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username, user, options) {
            return localVarFp.updateUser(username, user, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return localVarFp.updateUserInOrganization(organization, username, user, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserApiFactory = UserApiFactory;
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends base_1.BaseAPI {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
        return exports.UserApiFp(this.configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addUserToOrganization(organization, user, options) {
        return exports.UserApiFp(this.configuration).addUserToOrganization(organization, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    checkAWSAccessCredentials(namespace, options) {
        return exports.UserApiFp(this.configuration).checkAWSAccessCredentials(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    checkAWSAccessCredentialsByName(namespace, name, options) {
        return exports.UserApiFp(this.configuration).checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * confirm user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    confirmEmail(options) {
        return exports.UserApiFp(this.configuration).confirmEmail(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createUser(user, options) {
        return exports.UserApiFp(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteAWSAccessCredentials(namespace, name, options) {
        return exports.UserApiFp(this.configuration).deleteAWSAccessCredentials(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a user
     * @param {string} username username or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUser(username, options) {
        return exports.UserApiFp(this.configuration).deleteUser(username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUserFromOrganization(organization, username, options) {
        return exports.UserApiFp(this.configuration).deleteUserFromOrganization(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getOrganizationUser(organization, username, options) {
        return exports.UserApiFp(this.configuration).getOrganizationUser(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get session token for user
     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getSession(rememberMe, options) {
        return exports.UserApiFp(this.configuration).getSession(rememberMe, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(options) {
        return exports.UserApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user
     * @param {string} username username or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserWithUsername(username, options) {
        return exports.UserApiFp(this.configuration).getUserWithUsername(username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
     * @param {TokenRequest} [tokenRequest] token request object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    requestToken(tokenRequest, options) {
        return exports.UserApiFp(this.configuration).requestToken(tokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * reset user password
     * @param {InlineObject} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    resetUserPassword(user, options) {
        return exports.UserApiFp(this.configuration).resetUserPassword(user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * revoke an authorization token
     * @param {string} token token name or token itself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    revokeToken(token, options) {
        return exports.UserApiFp(this.configuration).revokeToken(token, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of user tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokensGet(options) {
        return exports.UserApiFp(this.configuration).tokensGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of user session tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokensSessionGet(options) {
        return exports.UserApiFp(this.configuration).tokensSessionGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
        return exports.UserApiFp(this.configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a user
     * @param {string} username username or id
     * @param {User} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUser(username, user, options) {
        return exports.UserApiFp(this.configuration).updateUser(username, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUserInOrganization(organization, username, user, options) {
        return exports.UserApiFp(this.configuration).updateUserInOrganization(organization, username, user, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserApi = UserApi;
//# sourceMappingURL=api.js.map