"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryApi = exports.QueryApiFactory = exports.QueryApiFp = exports.QueryApiAxiosParamCreator = exports.ArrayApi = exports.ArrayApiFactory = exports.ArrayApiFp = exports.ArrayApiAxiosParamCreator = exports.Querytype = exports.Querystatus = exports.Layout = exports.Datatype = exports.ActivityEventType = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 * Type of activity logged
 * @export
 * @enum {string}
 */
var ActivityEventType;
(function (ActivityEventType) {
    ActivityEventType["ReadSchema"] = "read_schema";
    ActivityEventType["MaxBufferSizes"] = "max_buffer_sizes";
    ActivityEventType["NonEmptyDomain"] = "non_empty_domain";
    ActivityEventType["QueryRead"] = "query_read";
    ActivityEventType["QueryWrite"] = "query_write";
    ActivityEventType["Create"] = "create";
    ActivityEventType["Delete"] = "delete";
    ActivityEventType["Register"] = "register";
    ActivityEventType["Deregister"] = "deregister";
    ActivityEventType["Udf"] = "udf";
    ActivityEventType["ArrayMetadataGet"] = "array_metadata_get";
    ActivityEventType["ArrayMetadataUpdate"] = "array_metadata_update";
    ActivityEventType["EstimatedResultSizes"] = "estimated_result_sizes";
})(ActivityEventType = exports.ActivityEventType || (exports.ActivityEventType = {}));
/**
 * TileDB data type
 * @export
 * @enum {string}
 */
var Datatype;
(function (Datatype) {
    Datatype["Int32"] = "INT32";
    Datatype["Int64"] = "INT64";
    Datatype["Float32"] = "FLOAT32";
    Datatype["Float64"] = "FLOAT64";
    Datatype["Char"] = "CHAR";
    Datatype["Int8"] = "INT8";
    Datatype["Uint8"] = "UINT8";
    Datatype["Int16"] = "INT16";
    Datatype["Uint16"] = "UINT16";
    Datatype["Uint32"] = "UINT32";
    Datatype["Uint64"] = "UINT64";
    Datatype["StringAscii"] = "STRING_ASCII";
    Datatype["StringUtf8"] = "STRING_UTF8";
    Datatype["StringUtf16"] = "STRING_UTF16";
    Datatype["StringUtf32"] = "STRING_UTF32";
    Datatype["StringUcs2"] = "STRING_UCS2";
    Datatype["StringUcs4"] = "STRING_UCS4";
    Datatype["Any"] = "ANY";
})(Datatype = exports.Datatype || (exports.Datatype = {}));
/**
 * Layout of array
 * @export
 * @enum {string}
 */
var Layout;
(function (Layout) {
    Layout["RowMajor"] = "row-major";
    Layout["ColMajor"] = "col-major";
    Layout["GlobalOrder"] = "global-order";
    Layout["Unordered"] = "unordered";
})(Layout = exports.Layout || (exports.Layout = {}));
/**
 * Status of query
 * @export
 * @enum {string}
 */
var Querystatus;
(function (Querystatus) {
    Querystatus["Failed"] = "FAILED";
    Querystatus["Completed"] = "COMPLETED";
    Querystatus["Inprogress"] = "INPROGRESS";
    Querystatus["Incomplete"] = "INCOMPLETE";
    Querystatus["Uninitialized"] = "UNINITIALIZED";
})(Querystatus = exports.Querystatus || (exports.Querystatus = {}));
/**
 * Type of query
 * @export
 * @enum {string}
 */
var Querytype;
(function (Querytype) {
    Querytype["Read"] = "READ";
    Querytype["Write"] = "WRITE";
})(Querytype = exports.Querytype || (exports.Querytype = {}));
/**
 * ArrayApi - axios parameter creator
 * @export
 */
const ArrayApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog: (namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('arrayActivityLog', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('arrayActivityLog', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/activity`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (eventTypes) {
                localVarQueryParameter['event_types'] = eventTypes;
            }
            if (taskId !== undefined) {
                localVarQueryParameter['task_id'] = taskId;
            }
            if (hasTaskId !== undefined) {
                localVarQueryParameter['has_task_id'] = hasTaskId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ArrayApiAxiosParamCreator = ArrayApiAxiosParamCreator;
/**
 * ArrayApi - functional programming interface
 * @export
 */
const ArrayApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ArrayApiAxiosParamCreator(configuration);
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ArrayApiFp = ArrayApiFp;
/**
 * ArrayApi - factory interface
 * @export
 */
const ArrayApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ArrayApiFp(configuration);
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options) {
            return localVarFp.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ArrayApiFactory = ArrayApiFactory;
/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
class ArrayApi extends base_1.BaseAPI {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options) {
        return exports.ArrayApiFp(this.configuration).arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ArrayApi = ArrayApi;
/**
 * QueryApi - axios parameter creator
 * @export
 */
const QueryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery: (namespace, array, type, contentType, query, xPayer, openAt, readAll, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitQuery', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('submitQuery', 'array', array);
            // verify required parameter 'type' is not null or undefined
            common_1.assertParamExists('submitQuery', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('submitQuery', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('submitQuery', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (readAll !== undefined) {
                localVarQueryParameter['read_all'] = readAll;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.QueryApiAxiosParamCreator = QueryApiAxiosParamCreator;
/**
 * QueryApi - functional programming interface
 * @export
 */
const QueryApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.QueryApiAxiosParamCreator(configuration);
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.QueryApiFp = QueryApiFp;
/**
 * QueryApi - factory interface
 * @export
 */
const QueryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.QueryApiFp(configuration);
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options) {
            return localVarFp.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options).then((request) => request(axios, basePath));
        },
    };
};
exports.QueryApiFactory = QueryApiFactory;
/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
class QueryApi extends base_1.BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options) {
        return exports.QueryApiFp(this.configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.QueryApi = QueryApi;
//# sourceMappingURL=api.js.map