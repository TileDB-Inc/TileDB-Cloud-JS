/**
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Configuration } from './configuration';
import { AxiosPromise, AxiosInstance } from 'axios';
import { RequestArgs, BaseAPI } from './base';
/**
 * Credential information to access Amazon Web Services
 * @export
 * @interface AWSCredential
 */
export interface AWSCredential {
    /**
     * The ID of the access key
     * @type {string}
     * @memberof AWSCredential
     */
    access_key_id?: string;
    /**
     * The access key\'s secret. Never returned in responses.
     * @type {string}
     * @memberof AWSCredential
     */
    secret_access_key?: string;
    /**
     * The endpoint used for this credential
     * @type {string}
     * @memberof AWSCredential
     */
    endpoint?: string | null;
}
/**
 * Role information to access Amazon Web Services
 * @export
 * @interface AWSRole
 */
export interface AWSRole {
    /**
     * The role arn used to access
     * @type {string}
     * @memberof AWSRole
     */
    role_arn?: string;
    /**
     * The role external id used to access
     * @type {string}
     * @memberof AWSRole
     */
    external_id?: string;
    /**
     * The endpoint used for this role
     * @type {string}
     * @memberof AWSRole
     */
    endpoint?: string | null;
}
/**
 * A union type which may contain a credential to access any one cloud provider.
 * @export
 * @interface AccessCredential
 */
export interface AccessCredential {
    /**
     * A user-specified name for the key
     * @type {string}
     * @memberof AccessCredential
     */
    name?: string;
    /**
     *
     * @type {CloudProvider}
     * @memberof AccessCredential
     */
    provider?: CloudProvider;
    /**
     * True if this is the namespace\'s default credential to be used when connecting to the given cloud provider. There can be at most one default for each unique provider.
     * @type {boolean}
     * @memberof AccessCredential
     */
    provider_default?: boolean | null;
    /**
     * Time when the credential was created (rfc3339)
     * @type {string}
     * @memberof AccessCredential
     */
    created_at?: string;
    /**
     * Time when the credential was last updated (rfc3339)
     * @type {string}
     * @memberof AccessCredential
     */
    updated_at?: string;
    /**
     *
     * @type {AccessCredentialCredential}
     * @memberof AccessCredential
     */
    credential?: AccessCredentialCredential;
    /**
     *
     * @type {AccessCredentialRole}
     * @memberof AccessCredential
     */
    role?: AccessCredentialRole;
}
/**
 * The credential information itself. Exactly one sub-field may be set. The names match those in the CloudProvider enum.
 * @export
 * @interface AccessCredentialCredential
 */
export interface AccessCredentialCredential {
    /**
     *
     * @type {AWSCredential}
     * @memberof AccessCredentialCredential
     */
    aws?: AWSCredential | null;
    /**
     *
     * @type {AzureCredential}
     * @memberof AccessCredentialCredential
     */
    azure?: AzureCredential | null;
}
/**
 * The role information itself. Exactly one sub-field may be set. The names match those in the CloudProvider enum.
 * @export
 * @interface AccessCredentialRole
 */
export interface AccessCredentialRole {
    /**
     *
     * @type {AWSRole}
     * @memberof AccessCredentialRole
     */
    aws?: AWSRole | null;
}
/**
 * Object including credentials and pagination metadata
 * @export
 * @interface AccessCredentialsData
 */
export interface AccessCredentialsData {
    /**
     * List of credentials
     * @type {Array<AccessCredential>}
     * @memberof AccessCredentialsData
     */
    credentials?: Array<AccessCredential>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof AccessCredentialsData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * Type of activity logged
 * @export
 * @enum {string}
 */
export declare enum ActivityEventType {
    ReadSchema = "read_schema",
    MaxBufferSizes = "max_buffer_sizes",
    NonEmptyDomain = "non_empty_domain",
    QueryRead = "query_read",
    QueryWrite = "query_write",
    Create = "create",
    Delete = "delete",
    Register = "register",
    Deregister = "deregister",
    Udf = "udf",
    ArrayMetadataGet = "array_metadata_get",
    ArrayMetadataUpdate = "array_metadata_update",
    EstimatedResultSizes = "estimated_result_sizes",
    Update = "update",
    Info = "info",
    Run = "run"
}
/**
 * Actvity of an Array
 * @export
 * @interface ArrayActivityLog
 */
export interface ArrayActivityLog {
    /**
     * time event took place (RFC3339)
     * @type {string}
     * @memberof ArrayActivityLog
     */
    event_at?: string;
    /**
     *
     * @type {ActivityEventType}
     * @memberof ArrayActivityLog
     */
    action?: ActivityEventType;
    /**
     * User who performed action
     * @type {string}
     * @memberof ArrayActivityLog
     */
    username?: string;
    /**
     * Bytes sent to client
     * @type {number}
     * @memberof ArrayActivityLog
     */
    bytes_sent?: number;
    /**
     * Bytes recieved from client
     * @type {number}
     * @memberof ArrayActivityLog
     */
    bytes_received?: number;
    /**
     * uuid of associated array task
     * @type {string}
     * @memberof ArrayActivityLog
     */
    array_task_id?: string;
    /**
     * id of the activity
     * @type {string}
     * @memberof ArrayActivityLog
     */
    id?: string;
    /**
     * ranges for query
     * @type {string}
     * @memberof ArrayActivityLog
     */
    query_ranges?: string;
    /**
     * stats for query
     * @type {string}
     * @memberof ArrayActivityLog
     */
    query_stats?: string;
}
/**
 * Object including array tasks and metadata
 * @export
 * @interface ArrayActivityLogData
 */
export interface ArrayActivityLogData {
    /**
     * Array ArrayActivityLog
     * @type {Array<ArrayActivityLog>}
     * @memberof ArrayActivityLogData
     */
    activitylogs?: Array<ArrayActivityLog>;
    /**
     *
     * @type {PaginationMetadata}
     * @memberof ArrayActivityLogData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * Represents an open array
 * @export
 * @interface ArrayData
 */
export interface ArrayData {
    /**
     * timestamp (epoch milliseconds) array is opened at
     * @type {number}
     * @memberof ArrayData
     */
    timestamp: number;
    /**
     *
     * @type {Querytype}
     * @memberof ArrayData
     */
    queryType: Querytype;
    /**
     * Array uri
     * @type {string}
     * @memberof ArrayData
     */
    uri: string;
    /**
     *
     * @type {ArraySchema}
     * @memberof ArrayData
     */
    arraySchemaLatest?: ArraySchema;
    /**
     *
     * @type {ArrayMetadata}
     * @memberof ArrayData
     */
    arrayMetadata?: ArrayMetadata;
    /**
     *
     * @type {NonEmptyDomain}
     * @memberof ArrayData
     */
    nonEmptyDomain?: NonEmptyDomain;
}
/**
 * Model for opening an array v2
 * @export
 * @interface ArrayFetch
 */
export interface ArrayFetch {
    /**
     *
     * @type {TileDBConfig}
     * @memberof ArrayFetch
     */
    config?: TileDBConfig;
    /**
     *
     * @type {Querytype}
     * @memberof ArrayFetch
     */
    queryType?: Querytype;
}
/**
 * user\'s TileDB array metadata
 * @export
 * @interface ArrayMetadata
 */
export interface ArrayMetadata {
    /**
     * List of metadata entries
     * @type {Array<ArrayMetadataEntry>}
     * @memberof ArrayMetadata
     */
    entries?: Array<ArrayMetadataEntry>;
}
/**
 * key/value pair representing an array metadata map entry
 * @export
 * @interface ArrayMetadataEntry
 */
export interface ArrayMetadataEntry {
    /**
     *
     * @type {string}
     * @memberof ArrayMetadataEntry
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof ArrayMetadataEntry
     */
    type?: string;
    /**
     *
     * @type {number}
     * @memberof ArrayMetadataEntry
     */
    valueNum?: number;
    /**
     *
     * @type {Array<number>}
     * @memberof ArrayMetadataEntry
     */
    value?: Array<number>;
    /**
     *
     * @type {boolean}
     * @memberof ArrayMetadataEntry
     */
    del?: boolean;
}
/**
 * ArraySchema during creation or retrieval
 * @export
 * @interface ArraySchema
 */
export interface ArraySchema {
    /**
     * URI of schema
     * @type {string}
     * @memberof ArraySchema
     */
    uri?: string;
    /**
     * file format version
     * @type {Array<number>}
     * @memberof ArraySchema
     */
    version: Array<number>;
    /**
     *
     * @type {ArrayType}
     * @memberof ArraySchema
     */
    arrayType: ArrayType;
    /**
     *
     * @type {Layout}
     * @memberof ArraySchema
     */
    tileOrder: Layout;
    /**
     *
     * @type {Layout}
     * @memberof ArraySchema
     */
    cellOrder: Layout;
    /**
     * Capacity of array
     * @type {number}
     * @memberof ArraySchema
     */
    capacity: number;
    /**
     *
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    coordsFilterPipeline: FilterPipeline;
    /**
     *
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    offsetFilterPipeline: FilterPipeline;
    /**
     *
     * @type {Domain}
     * @memberof ArraySchema
     */
    domain: Domain;
    /**
     * Attributes of array
     * @type {Array<Attribute>}
     * @memberof ArraySchema
     */
    attributes: Array<Attribute>;
    /**
     * True if the array allows coordinate duplicates. Applicable only to sparse arrays.
     * @type {boolean}
     * @memberof ArraySchema
     */
    allowsDuplicates?: boolean;
}
/**
 * TileDB array type
 * @export
 * @enum {string}
 */
export declare enum ArrayType {
    Dense = "dense",
    Sparse = "sparse"
}
/**
 * Attribute of array
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * Attribute name
     * @type {string}
     * @memberof Attribute
     */
    name: string;
    /**
     *
     * @type {Datatype}
     * @memberof Attribute
     */
    type: Datatype;
    /**
     *
     * @type {FilterPipeline}
     * @memberof Attribute
     */
    filterPipeline: FilterPipeline;
    /**
     * Attribute number of values per cell
     * @type {number}
     * @memberof Attribute
     */
    cellValNum: number;
    /**
     * Is attribute nullable
     * @type {boolean}
     * @memberof Attribute
     */
    nullable?: boolean;
    /**
     * The default fill value
     * @type {Array<number>}
     * @memberof Attribute
     */
    fillValue?: Array<number>;
}
/**
 * Represents an attribute buffer header information
 * @export
 * @interface AttributeBufferHeader
 */
export interface AttributeBufferHeader {
    /**
     * Attribute name
     * @type {string}
     * @memberof AttributeBufferHeader
     */
    name: string;
    /**
     * Number of bytes in the fixed-length attribute data buffer (offsets for var-len attributes)
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    fixedLenBufferSizeInBytes: number;
    /**
     * Number of bytes in the var-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    varLenBufferSizeInBytes: number;
    /**
     * Number of bytes for validity in case attribute is nullable
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    validityLenBufferSizeInBytes?: number;
    /**
     * Original user set number of bytes in the fixed-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    originalFixedLenBufferSizeInBytes?: number;
    /**
     * Original user set number of bytes in the var-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    originalVarLenBufferSizeInBytes?: number;
    /**
     * Original user set number of bytes in the validity data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    originalValidityLenBufferSizeInBytes?: number;
}
/**
 * object representing buffer size of an attribute
 * @export
 * @interface AttributeBufferSize
 */
export interface AttributeBufferSize {
    /**
     * name of attribute
     * @type {string}
     * @memberof AttributeBufferSize
     */
    attribute: string;
    /**
     * buffer size (in bytes) of offset buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    offsetBytes: number;
    /**
     * buffer size (in bytes) of data buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    dataBytes: number;
}
/**
 * Credential information to access Microsoft Azure. Each supported property is the snake_case version of its name in an Azure Storage connection string.
 * @export
 * @interface AzureCredential
 */
export interface AzureCredential {
    /**
     * The name of the Azure account to access
     * @type {string}
     * @memberof AzureCredential
     */
    account_name?: string;
    /**
     * The secret key. Never returned in responses.
     * @type {string}
     * @memberof AzureCredential
     */
    account_key?: string;
}
/**
 * A service where data is stored or computations take place.
 * @export
 * @enum {string}
 */
export declare enum CloudProvider {
    Aws = "AWS",
    Azure = "AZURE"
}
/**
 * TileDB data type
 * @export
 * @enum {string}
 */
export declare enum Datatype {
    Int32 = "INT32",
    Int64 = "INT64",
    Float32 = "FLOAT32",
    Float64 = "FLOAT64",
    Char = "CHAR",
    Int8 = "INT8",
    Uint8 = "UINT8",
    Int16 = "INT16",
    Uint16 = "UINT16",
    Uint32 = "UINT32",
    Uint64 = "UINT64",
    StringAscii = "STRING_ASCII",
    StringUtf8 = "STRING_UTF8",
    StringUtf16 = "STRING_UTF16",
    StringUtf32 = "STRING_UTF32",
    StringUcs2 = "STRING_UCS2",
    StringUcs4 = "STRING_UCS4",
    DatetimeYear = "DATETIME_YEAR",
    DatetimeMonth = "DATETIME_MONTH",
    DatetimeWeek = "DATETIME_WEEK",
    DatetimeDay = "DATETIME_DAY",
    DatetimeHr = "DATETIME_HR",
    DatetimeMin = "DATETIME_MIN",
    DatetimeSec = "DATETIME_SEC",
    DatetimeMs = "DATETIME_MS",
    DatetimeUs = "DATETIME_US",
    DatetimeNs = "DATETIME_NS",
    DatetimePs = "DATETIME_PS",
    DatetimeFs = "DATETIME_FS",
    DatetimeAs = "DATETIME_AS",
    Any = "ANY"
}
/**
 * Dimension of array
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * Dimension name
     * @type {string}
     * @memberof Dimension
     */
    name?: string;
    /**
     *
     * @type {Datatype}
     * @memberof Dimension
     */
    type: Datatype;
    /**
     *
     * @type {DomainArray}
     * @memberof Dimension
     */
    domain: DomainArray;
    /**
     * Is tile extent null
     * @type {boolean}
     * @memberof Dimension
     */
    nullTileExtent: boolean;
    /**
     *
     * @type {DimensionTileExtent}
     * @memberof Dimension
     */
    tileExtent?: DimensionTileExtent;
    /**
     *
     * @type {FilterPipeline}
     * @memberof Dimension
     */
    filterPipeline?: FilterPipeline;
}
/**
 * Extent of tile
 * @export
 * @interface DimensionTileExtent
 */
export interface DimensionTileExtent {
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int8?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint8?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int16?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint16?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int64?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint64?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    float32?: number;
    /**
     *
     * @type {number}
     * @memberof DimensionTileExtent
     */
    float64?: number;
}
/**
 * Domain of array
 * @export
 * @interface Domain
 */
export interface Domain {
    /**
     *
     * @type {Datatype}
     * @memberof Domain
     */
    type: Datatype;
    /**
     *
     * @type {Layout}
     * @memberof Domain
     */
    tileOrder: Layout;
    /**
     *
     * @type {Layout}
     * @memberof Domain
     */
    cellOrder: Layout;
    /**
     * Array of dimensions
     * @type {Array<Dimension>}
     * @memberof Domain
     */
    dimensions: Array<Dimension>;
}
/**
 * Domain object for an array of each type
 * @export
 * @interface DomainArray
 */
export interface DomainArray {
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int8?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint8?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int16?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint16?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int32?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint32?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int64?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint64?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float32?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float64?: Array<number>;
}
/**
 * Uploaded file name and information
 * @export
 * @interface FileUploaded
 */
export interface FileUploaded {
    /**
     * output location of the TileDB File
     * @type {string}
     * @memberof FileUploaded
     */
    output_uri?: string;
    /**
     * name of the file uploaded
     * @type {string}
     * @memberof FileUploaded
     */
    file_name?: string;
    /**
     * unique ID of the uploaded file
     * @type {string}
     * @memberof FileUploaded
     */
    id: string;
}
/**
 * Filter
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     *
     * @type {FilterType}
     * @memberof Filter
     */
    type: FilterType;
    /**
     *
     * @type {FilterData}
     * @memberof Filter
     */
    data?: FilterData;
}
/**
 * Filter data
 * @export
 * @interface FilterData
 */
export interface FilterData {
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    int8?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    uint8?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    int16?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    uint16?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    int32?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    uint32?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    int64?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    uint64?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    float32?: number;
    /**
     *
     * @type {number}
     * @memberof FilterData
     */
    float64?: number;
}
/**
 * One or more filters to apply
 * @export
 * @interface FilterPipeline
 */
export interface FilterPipeline {
    /**
     *
     * @type {Array<Filter>}
     * @memberof FilterPipeline
     */
    filters?: Array<Filter>;
}
/**
 * TileDB filter types
 * @export
 * @enum {string}
 */
export declare enum FilterType {
    None = "FILTER_NONE",
    Gzip = "FILTER_GZIP",
    Zstd = "FILTER_ZSTD",
    Lz4 = "FILTER_LZ4",
    Rle = "FILTER_RLE",
    Bzip2 = "FILTER_BZIP2",
    DoubleDelta = "FILTER_DOUBLE_DELTA",
    BitWidthReduction = "FILTER_BIT_WIDTH_REDUCTION",
    Bitshuffle = "FILTER_BITSHUFFLE",
    Byteshuffle = "FILTER_BYTESHUFFLE",
    PositiveDelta = "FILTER_POSITIVE_DELTA"
}
/**
 * Updates the contents group
 * @export
 * @interface GroupContentsChangesRequest
 */
export interface GroupContentsChangesRequest {
    /**
     *
     * @type {TileDBConfig}
     * @memberof GroupContentsChangesRequest
     */
    config?: TileDBConfig;
    /**
     *
     * @type {GroupContentsChangesRequestGroupChanges}
     * @memberof GroupContentsChangesRequest
     */
    group_changes?: GroupContentsChangesRequestGroupChanges;
}
/**
 *
 * @export
 * @interface GroupContentsChangesRequestGroupChanges
 */
export interface GroupContentsChangesRequestGroupChanges {
    /**
     * optional series of members to remove
     * @type {Array<string>}
     * @memberof GroupContentsChangesRequestGroupChanges
     */
    members_to_remove?: Array<string>;
    /**
     * optional series of members to add
     * @type {Array<GroupMember>}
     * @memberof GroupContentsChangesRequestGroupChanges
     */
    members_to_add?: Array<GroupMember>;
}
/**
 * Request the contents of a group
 * @export
 * @interface GroupContentsRetrievalRequest
 */
export interface GroupContentsRetrievalRequest {
    /**
     *
     * @type {TileDBConfig}
     * @memberof GroupContentsRetrievalRequest
     */
    config?: TileDBConfig;
}
/**
 * Object including a page of members of a group and pagination metadata
 * @export
 * @interface GroupContentsRetrievalResponse
 */
export interface GroupContentsRetrievalResponse {
    /**
     * Groups members
     * @type {Array<GroupMember>}
     * @memberof GroupContentsRetrievalResponse
     */
    members?: Array<GroupMember>;
    /**
     *
     * @type {Metadata}
     * @memberof GroupContentsRetrievalResponse
     */
    metadata?: Metadata;
}
/**
 * information for creating a new group with the passed configuration
 * @export
 * @interface GroupCreationRequest
 */
export interface GroupCreationRequest {
    /**
     *
     * @type {TileDBConfig}
     * @memberof GroupCreationRequest
     */
    config?: TileDBConfig;
    /**
     *
     * @type {GroupCreationRequestGroupDetails}
     * @memberof GroupCreationRequest
     */
    group_details: GroupCreationRequestGroupDetails;
}
/**
 * Initial attributes for the creation of a group.
 * @export
 * @interface GroupCreationRequestGroupDetails
 */
export interface GroupCreationRequestGroupDetails {
    /**
     * A human readable description of the contents of the group.
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    description?: string;
    /**
     * The name of the group. If must be unique within the group.
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    name?: string;
    /**
     * uri of group.
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    uri?: string;
    /**
     * logo (base64 encoded) for the group. Optional
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    logo?: string;
    /**
     * optional tags for groups.
     * @type {Array<string>}
     * @memberof GroupCreationRequestGroupDetails
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom.
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    license_text?: string;
}
/**
 * A groups member, array or another groups, to add or remove from an existing group.
 * @export
 * @interface GroupMember
 */
export interface GroupMember {
    /**
     * The name of the member
     * @type {string}
     * @memberof GroupMember
     */
    name?: string;
    /**
     * The uri of the member
     * @type {string}
     * @memberof GroupMember
     */
    uri?: string;
    /**
     *
     * @type {GroupMemberType}
     * @memberof GroupMember
     */
    type?: GroupMemberType;
}
/**
 * Specific file types of group members
 * @export
 * @enum {string}
 */
export declare enum GroupMemberAssetType {
    Group = "group",
    Array = "array",
    Notebook = "notebook",
    Dashboard = "dashboard",
    UserDefinedFunction = "user_defined_function",
    MlModel = "ml_model",
    File = "file"
}
/**
 * File types that can be included in groups
 * @export
 * @enum {string}
 */
export declare enum GroupMemberType {
    Group = "GROUP",
    Array = "ARRAY"
}
/**
 * Retrieves the metadata of a group
 * @export
 * @interface GroupMetadataRetrievalRequest
 */
export interface GroupMetadataRetrievalRequest {
    /**
     *
     * @type {TileDBConfig}
     * @memberof GroupMetadataRetrievalRequest
     */
    config?: TileDBConfig;
}
/**
 * Updates the metadata of a group
 * @export
 * @interface GroupMetadataUpdateRequest
 */
export interface GroupMetadataUpdateRequest {
    /**
     *
     * @type {TileDBConfig}
     * @memberof GroupMetadataUpdateRequest
     */
    config?: TileDBConfig;
    /**
     *
     * @type {Metadata}
     * @memberof GroupMetadataUpdateRequest
     */
    metadata: Metadata;
}
/**
 * information for creating a new group with the passed configuration
 * @export
 * @interface GroupRegistrationRequest
 */
export interface GroupRegistrationRequest {
    /**
     *
     * @type {TileDBConfig}
     * @memberof GroupRegistrationRequest
     */
    config?: TileDBConfig;
    /**
     *
     * @type {GroupRegistrationRequestGroupDetails}
     * @memberof GroupRegistrationRequest
     */
    group_details: GroupRegistrationRequestGroupDetails;
}
/**
 * Initial attributes for the creation of a group.
 * @export
 * @interface GroupRegistrationRequestGroupDetails
 */
export interface GroupRegistrationRequestGroupDetails {
    /**
     * A human readable description of the contents of the group.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    description?: string;
    /**
     * The name of the group. If must be unique within the group.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    name?: string;
    /**
     * The unique name or id of the parent of the group. If empty, then the new group will be a top level group.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    parent?: string;
    /**
     * uri of group.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    uri?: string;
    /**
     * logo (base64 encoded) for the group. Optional
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    logo?: string;
    /**
     * optional tags for groups.
     * @type {Array<string>}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    license_text?: string;
    /**
     * region of the group
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    region?: string;
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    access_credentials_name?: string;
}
/**
 * Layout of array
 * @export
 * @enum {string}
 */
export declare enum Layout {
    RowMajor = "row-major",
    ColMajor = "col-major",
    GlobalOrder = "global-order",
    Unordered = "unordered"
}
/**
 * user\'s TileDB metadata
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * List of metadata entries
     * @type {Array<MetadataEntry>}
     * @memberof Metadata
     */
    entries?: Array<MetadataEntry>;
}
/**
 * key/value pair representing a group metadata map entry
 * @export
 * @interface MetadataEntry
 */
export interface MetadataEntry {
    /**
     *
     * @type {string}
     * @memberof MetadataEntry
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof MetadataEntry
     */
    type?: string;
    /**
     *
     * @type {number}
     * @memberof MetadataEntry
     */
    valueNum?: number;
    /**
     *
     * @type {object}
     * @memberof MetadataEntry
     */
    value?: object;
    /**
     *
     * @type {boolean}
     * @memberof MetadataEntry
     */
    del?: boolean;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     *
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
}
/**
 * object representing a non-empty domain
 * @export
 * @interface NonEmptyDomain
 */
export interface NonEmptyDomain {
    /**
     *
     * @type {DomainArray}
     * @memberof NonEmptyDomain
     */
    nonEmptyDomain: DomainArray;
    /**
     * Is non-empty domain really empty?
     * @type {boolean}
     * @memberof NonEmptyDomain
     */
    isEmpty: boolean;
}
/**
 *
 * @export
 * @interface PaginationMetadata
 */
export interface PaginationMetadata {
    /**
     * pagination offset. Use it to skip the first ((page - 1) * per_page) items
     * @type {number}
     * @memberof PaginationMetadata
     */
    page?: number;
    /**
     * pagination limit (page size)
     * @type {number}
     * @memberof PaginationMetadata
     */
    per_page?: number;
    /**
     * number of total pages with current limit
     * @type {number}
     * @memberof PaginationMetadata
     */
    total_pages?: number;
    /**
     * number of total available items
     * @type {number}
     * @memberof PaginationMetadata
     */
    total_items?: number;
}
/**
 *
 * @export
 * @interface Query
 */
export interface Query {
    /**
     *
     * @type {Querytype}
     * @memberof Query
     */
    type: Querytype;
    /**
     *
     * @type {Layout}
     * @memberof Query
     */
    layout: Layout;
    /**
     *
     * @type {Querystatus}
     * @memberof Query
     */
    status: Querystatus;
    /**
     * List of attribute buffer headers
     * @type {Array<AttributeBufferHeader>}
     * @memberof Query
     */
    attributeBufferHeaders: Array<AttributeBufferHeader>;
    /**
     *
     * @type {Writer}
     * @memberof Query
     */
    writer?: Writer;
    /**
     *
     * @type {QueryReader}
     * @memberof Query
     */
    reader?: QueryReader;
    /**
     *
     * @type {any}
     * @memberof Query
     */
    array: any;
    /**
     * Total number of bytes in fixed size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalFixedLengthBufferBytes: number;
    /**
     * Total number of bytes in variable size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalVarLenBufferBytes: number;
    /**
     * Total number of bytes in validity buffers
     * @type {number}
     * @memberof Query
     */
    totalValidityBufferBytes?: number;
}
/**
 * Read struct (can\'t be called reader due to class name conflict)
 * @export
 * @interface QueryReader
 */
export interface QueryReader {
    /**
     *
     * @type {Layout}
     * @memberof QueryReader
     */
    layout?: Layout;
    /**
     *
     * @type {Subarray}
     * @memberof QueryReader
     */
    subarray?: Subarray;
    /**
     *
     * @type {ReadState}
     * @memberof QueryReader
     */
    readState?: ReadState;
}
/**
 * Status of query
 * @export
 * @enum {string}
 */
export declare enum Querystatus {
    Failed = "FAILED",
    Completed = "COMPLETED",
    Inprogress = "INPROGRESS",
    Incomplete = "INCOMPLETE",
    Uninitialized = "UNINITIALIZED"
}
/**
 * Type of query
 * @export
 * @enum {string}
 */
export declare enum Querytype {
    Read = "READ",
    Write = "WRITE"
}
/**
 * state for reads
 * @export
 * @interface ReadState
 */
export interface ReadState {
    /**
     * True if the reader has been initialized.
     * @type {boolean}
     * @memberof ReadState
     */
    initialized?: boolean;
    /**
     * True if the query produced results that could not fit in some buffer.
     * @type {boolean}
     * @memberof ReadState
     */
    overflowed?: boolean;
    /**
     * True if the current subarray partition is unsplittable.
     * @type {boolean}
     * @memberof ReadState
     */
    unsplittable?: boolean;
    /**
     *
     * @type {SubarrayPartitioner}
     * @memberof ReadState
     */
    subarrayPartitioner?: SubarrayPartitioner;
}
/**
 * A Subarray
 * @export
 * @interface Subarray
 */
export interface Subarray {
    /**
     *
     * @type {Layout}
     * @memberof Subarray
     */
    layout?: Layout;
    /**
     * List of 1D ranges, one per dimension
     * @type {Array<SubarrayRanges>}
     * @memberof Subarray
     */
    ranges?: Array<SubarrayRanges>;
}
/**
 * The subarray partitioner
 * @export
 * @interface SubarrayPartitioner
 */
export interface SubarrayPartitioner {
    /**
     *
     * @type {Subarray}
     * @memberof SubarrayPartitioner
     */
    subarray?: Subarray;
    /**
     * Result size budget (in bytes) for all attributes.
     * @type {Array<AttributeBufferSize>}
     * @memberof SubarrayPartitioner
     */
    budget?: Array<AttributeBufferSize>;
    /**
     *
     * @type {SubarrayPartitionerCurrent}
     * @memberof SubarrayPartitioner
     */
    current?: SubarrayPartitionerCurrent;
    /**
     *
     * @type {SubarrayPartitionerState}
     * @memberof SubarrayPartitioner
     */
    state?: SubarrayPartitionerState;
    /**
     * The memory budget for the fixed-sized attributes and the offsets of the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudget?: number;
    /**
     * The memory budget for the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudgetVar?: number;
}
/**
 * The current partition info
 * @export
 * @interface SubarrayPartitionerCurrent
 */
export interface SubarrayPartitionerCurrent {
    /**
     *
     * @type {Subarray}
     * @memberof SubarrayPartitionerCurrent
     */
    subarray?: Subarray;
    /**
     * PartitionInfo start
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    start?: number;
    /**
     * PartitionInfo end
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    end?: number;
    /**
     * PartitionInfo splitMultiRange
     * @type {boolean}
     * @memberof SubarrayPartitionerCurrent
     */
    splitMultiRange?: boolean;
}
/**
 * The state information for the remaining partitions to be produced
 * @export
 * @interface SubarrayPartitionerState
 */
export interface SubarrayPartitionerState {
    /**
     * State start
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    start?: number;
    /**
     * State end
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    end?: number;
    /**
     * State singleRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    singleRange?: Array<Subarray>;
    /**
     * State multiRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    multiRange?: Array<Subarray>;
}
/**
 * A set of 1D ranges for a subarray
 * @export
 * @interface SubarrayRanges
 */
export interface SubarrayRanges {
    /**
     *
     * @type {Datatype}
     * @memberof SubarrayRanges
     */
    type?: Datatype;
    /**
     * True if the range is the default range
     * @type {boolean}
     * @memberof SubarrayRanges
     */
    hasDefaultRange?: boolean;
    /**
     * The bytes of the ranges
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    buffer?: Array<number>;
    /**
     * The list of sizes per range
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    bufferSizes?: Array<number>;
    /**
     * The list of start sizes per range
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    bufferStartSizes?: Array<number>;
}
/**
 * TileDB config used for interaction with the embedded library
 * @export
 * @interface TileDBConfig
 */
export interface TileDBConfig {
    /**
     *
     * @type {Array<TileDBConfigEntries>}
     * @memberof TileDBConfig
     */
    entries?: Array<TileDBConfigEntries>;
}
/**
 *
 * @export
 * @interface TileDBConfigEntries
 */
export interface TileDBConfigEntries {
    /**
     *
     * @type {string}
     * @memberof TileDBConfigEntries
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof TileDBConfigEntries
     */
    value?: string;
}
/**
 *
 * @export
 * @interface Writer
 */
export interface Writer {
    /**
     *
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordDups?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordOOB?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Writer
     */
    dedupCoords?: boolean;
    /**
     *
     * @type {Subarray}
     * @memberof Writer
     */
    subarrayRanges?: Subarray;
    /**
     *
     * @type {DomainArray}
     * @memberof Writer
     */
    subarray?: DomainArray;
}
/**
 * ArrayApi - axios parameter creator
 * @export
 */
export declare const ArrayApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arrayActivityLog: (namespace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options?: any) => Promise<RequestArgs>;
    /**
     * Get a array at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArrayFetch} arrayFetch Details for array being fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArray: (namespace: string, array: string, contentType: string, arrayFetch: ArrayFetch, options?: any) => Promise<RequestArgs>;
};
/**
 * ArrayApi - functional programming interface
 * @export
 */
export declare const ArrayApiFp: (configuration?: Configuration) => {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayActivityLogData>>;
    /**
     * Get a array at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArrayFetch} arrayFetch Details for array being fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArray(namespace: string, array: string, contentType: string, arrayFetch: ArrayFetch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayData>>;
};
/**
 * ArrayApi - factory interface
 * @export
 */
export declare const ArrayApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options?: any): AxiosPromise<ArrayActivityLogData>;
    /**
     * Get a array at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArrayFetch} arrayFetch Details for array being fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArray(namespace: string, array: string, contentType: string, arrayFetch: ArrayFetch, options?: any): AxiosPromise<ArrayData>;
};
/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
export declare class ArrayApi extends BaseAPI {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options?: any): Promise<import("axios").AxiosResponse<ArrayActivityLogData>>;
    /**
     * Get a array at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArrayFetch} arrayFetch Details for array being fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArray(namespace: string, array: string, contentType: string, arrayFetch: ArrayFetch, options?: any): Promise<import("axios").AxiosResponse<ArrayData>>;
}
/**
 * FilesApi - axios parameter creator
 * @export
 */
export declare const FilesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Upload a file at the specified location and wrap it in TileDB Array
     * @param {string} namespace The namespace of the file
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input
     * @param {number} filesize size of the file to upload in bytes
     * @param {any} file file to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [name] name of the TileDB array to create, if missing {array} is used
     * @param {string} [filename] original file name
     * @param {string} [mimetype] Mime type of the uploaded file. Autogenerated clients do not always support changing the content type param. Server will always use mimetype query param to set mimetype for file, if it is not set Content-Type will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleUploadFile: (namespace: string, array: string, contentType: string, filesize: number, file: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, filename?: string, mimetype?: string, options?: any) => Promise<RequestArgs>;
};
/**
 * FilesApi - functional programming interface
 * @export
 */
export declare const FilesApiFp: (configuration?: Configuration) => {
    /**
     * Upload a file at the specified location and wrap it in TileDB Array
     * @param {string} namespace The namespace of the file
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input
     * @param {number} filesize size of the file to upload in bytes
     * @param {any} file file to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [name] name of the TileDB array to create, if missing {array} is used
     * @param {string} [filename] original file name
     * @param {string} [mimetype] Mime type of the uploaded file. Autogenerated clients do not always support changing the content type param. Server will always use mimetype query param to set mimetype for file, if it is not set Content-Type will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleUploadFile(namespace: string, array: string, contentType: string, filesize: number, file: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, filename?: string, mimetype?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploaded>>;
};
/**
 * FilesApi - factory interface
 * @export
 */
export declare const FilesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Upload a file at the specified location and wrap it in TileDB Array
     * @param {string} namespace The namespace of the file
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input
     * @param {number} filesize size of the file to upload in bytes
     * @param {any} file file to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [name] name of the TileDB array to create, if missing {array} is used
     * @param {string} [filename] original file name
     * @param {string} [mimetype] Mime type of the uploaded file. Autogenerated clients do not always support changing the content type param. Server will always use mimetype query param to set mimetype for file, if it is not set Content-Type will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleUploadFile(namespace: string, array: string, contentType: string, filesize: number, file: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, filename?: string, mimetype?: string, options?: any): AxiosPromise<FileUploaded>;
};
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export declare class FilesApi extends BaseAPI {
    /**
     * Upload a file at the specified location and wrap it in TileDB Array
     * @param {string} namespace The namespace of the file
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input
     * @param {number} filesize size of the file to upload in bytes
     * @param {any} file file to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [name] name of the TileDB array to create, if missing {array} is used
     * @param {string} [filename] original file name
     * @param {string} [mimetype] Mime type of the uploaded file. Autogenerated clients do not always support changing the content type param. Server will always use mimetype query param to set mimetype for file, if it is not set Content-Type will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    handleUploadFile(namespace: string, array: string, contentType: string, filesize: number, file: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, filename?: string, mimetype?: string, options?: any): Promise<import("axios").AxiosResponse<FileUploaded>>;
}
/**
 * GroupsApi - axios parameter creator
 * @export
 */
export declare const GroupsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Creates an empty group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupCreationRequest} [groupCreation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup: (groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Deregisters a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterGroup: (groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any) => Promise<RequestArgs>;
    /**
     * get metadata on a group using the requested config
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataRetrievalRequest} [metadataRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMetadata: (groupNamespace: string, groupName: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options?: any) => Promise<RequestArgs>;
    /**
     * can be used to check if the resource exists
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsGroupNamespaceGroupNameOptions: (groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any) => Promise<RequestArgs>;
    /**
     * Registers an already existing group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupRegistrationRequest} [groupRegistration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGroup: (groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Retrieves the contents of a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsRetrievalRequest} [groupRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveGroup: (groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options?: any) => Promise<RequestArgs>;
    /**
     * Change the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsChangesRequest} [groupUpdateContents]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupContents: (groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options?: any) => Promise<RequestArgs>;
    /**
     * update metadata on a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataUpdateRequest} [metadataUpdating]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupMetadata: (groupNamespace: string, groupName: string, metadataUpdating?: GroupMetadataUpdateRequest, options?: any) => Promise<RequestArgs>;
};
/**
 * GroupsApi - functional programming interface
 * @export
 */
export declare const GroupsApiFp: (configuration?: Configuration) => {
    /**
     * Creates an empty group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupCreationRequest} [groupCreation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deregisters a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * get metadata on a group using the requested config
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataRetrievalRequest} [metadataRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMetadata(groupNamespace: string, groupName: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metadata>>;
    /**
     * can be used to check if the resource exists
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsGroupNamespaceGroupNameOptions(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Registers an already existing group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupRegistrationRequest} [groupRegistration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Retrieves the contents of a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsRetrievalRequest} [groupRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupContentsRetrievalResponse>>;
    /**
     * Change the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsChangesRequest} [groupUpdateContents]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupContents(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * update metadata on a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataUpdateRequest} [metadataUpdating]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupMetadata(groupNamespace: string, groupName: string, metadataUpdating?: GroupMetadataUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * GroupsApi - factory interface
 * @export
 */
export declare const GroupsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Creates an empty group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupCreationRequest} [groupCreation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options?: any): AxiosPromise<void>;
    /**
     * Deregisters a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): AxiosPromise<void>;
    /**
     * get metadata on a group using the requested config
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataRetrievalRequest} [metadataRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMetadata(groupNamespace: string, groupName: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options?: any): AxiosPromise<Metadata>;
    /**
     * can be used to check if the resource exists
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    groupsGroupNamespaceGroupNameOptions(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): AxiosPromise<void>;
    /**
     * Registers an already existing group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupRegistrationRequest} [groupRegistration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options?: any): AxiosPromise<void>;
    /**
     * Retrieves the contents of a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsRetrievalRequest} [groupRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options?: any): AxiosPromise<GroupContentsRetrievalResponse>;
    /**
     * Change the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsChangesRequest} [groupUpdateContents]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupContents(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options?: any): AxiosPromise<void>;
    /**
     * update metadata on a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataUpdateRequest} [metadataUpdating]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupMetadata(groupNamespace: string, groupName: string, metadataUpdating?: GroupMetadataUpdateRequest, options?: any): AxiosPromise<void>;
};
/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export declare class GroupsApi extends BaseAPI {
    /**
     * Creates an empty group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupCreationRequest} [groupCreation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    createGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Deregisters a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deregisterGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * get metadata on a group using the requested config
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataRetrievalRequest} [metadataRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupMetadata(groupNamespace: string, groupName: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options?: any): Promise<import("axios").AxiosResponse<Metadata>>;
    /**
     * can be used to check if the resource exists
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupsGroupNamespaceGroupNameOptions(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Registers an already existing group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupRegistrationRequest} [groupRegistration]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    registerGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Retrieves the contents of a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsRetrievalRequest} [groupRetrieval]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    retrieveGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options?: any): Promise<import("axios").AxiosResponse<GroupContentsRetrievalResponse>>;
    /**
     * Change the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsChangesRequest} [groupUpdateContents]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroupContents(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * update metadata on a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataUpdateRequest} [metadataUpdating]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroupMetadata(groupNamespace: string, groupName: string, metadataUpdating?: GroupMetadataUpdateRequest, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export declare const OrganizationApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCredential: (namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any) => Promise<RequestArgs>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential: (namespace: string, name: string, options?: any) => Promise<RequestArgs>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential: (namespace: string, name: string, options?: any) => Promise<RequestArgs>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials: (namespace: string, provider?: string, page?: number, perPage?: number, options?: any) => Promise<RequestArgs>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential: (namespace: string, name: string, accessCredential: AccessCredential, options?: any) => Promise<RequestArgs>;
};
/**
 * OrganizationApi - functional programming interface
 * @export
 */
export declare const OrganizationApiFp: (configuration?: Configuration) => {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredential>>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredentialsData>>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * OrganizationApi - factory interface
 * @export
 */
export declare const OrganizationApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): AxiosPromise<void>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential(namespace: string, name: string, options?: any): AxiosPromise<AccessCredential>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): AxiosPromise<AccessCredentialsData>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): AxiosPromise<void>;
};
/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export declare class OrganizationApi extends BaseAPI {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteCredential(namespace: string, name: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getCredential(namespace: string, name: string, options?: any): Promise<import("axios").AxiosResponse<AccessCredential>>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): Promise<import("axios").AxiosResponse<AccessCredentialsData>>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
/**
 * QueryApi - axios parameter creator
 * @export
 */
export declare const QueryApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQuery: (namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any) => Promise<RequestArgs>;
};
/**
 * QueryApi - functional programming interface
 * @export
 */
export declare const QueryApiFp: (configuration?: Configuration) => {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>>;
};
/**
 * QueryApi - factory interface
 * @export
 */
export declare const QueryApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any): AxiosPromise<any>;
};
/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export declare class QueryApi extends BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any): Promise<import("axios").AxiosResponse<any>>;
}
/**
 * UserApi - axios parameter creator
 * @export
 */
export declare const UserApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCredential: (namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any) => Promise<RequestArgs>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential: (namespace: string, name: string, options?: any) => Promise<RequestArgs>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential: (namespace: string, name: string, options?: any) => Promise<RequestArgs>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials: (namespace: string, provider?: string, page?: number, perPage?: number, options?: any) => Promise<RequestArgs>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential: (namespace: string, name: string, accessCredential: AccessCredential, options?: any) => Promise<RequestArgs>;
};
/**
 * UserApi - functional programming interface
 * @export
 */
export declare const UserApiFp: (configuration?: Configuration) => {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredential>>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredentialsData>>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * UserApi - factory interface
 * @export
 */
export declare const UserApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): AxiosPromise<void>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential(namespace: string, name: string, options?: any): AxiosPromise<void>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential(namespace: string, name: string, options?: any): AxiosPromise<AccessCredential>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): AxiosPromise<AccessCredentialsData>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): AxiosPromise<void>;
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export declare class UserApi extends BaseAPI {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteCredential(namespace: string, name: string, options?: any): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getCredential(namespace: string, name: string, options?: any): Promise<import("axios").AxiosResponse<AccessCredential>>;
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): Promise<import("axios").AxiosResponse<AccessCredentialsData>>;
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): Promise<import("axios").AxiosResponse<void>>;
}
