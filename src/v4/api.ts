/* tslint:disable */
/* eslint-disable */
/**
 * Specification file for tiledb-server v4 API
 * This spec is exposed to the public under /v4 route group
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: info@tiledb.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../commons/configuration';
import type { AxiosPromise, AxiosInstance } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../commons/common';
import type { RequestArgs } from '../commons/base';
// @ts-ignore
import { COLLECTION_FORMATS, RequiredError } from '../commons/base';
import updateBasePathAfterRedirect from '../utils/updateBasePathAfterRedirect';

export const BASE_PATH = "https://api.tiledb.com/v4".replace(/\/+$/, "");

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
        updateBasePathAfterRedirect(axios, BASE_PATH, this);
    }
};

/**
 * An API token
 * @export
 * @interface APIToken
 */
export interface APIToken {
    /**
     * The token\'s ID
     * @type {string}
     * @memberof APIToken
     */
    'token_id': string;
    /**
     * The name of the token
     * @type {string}
     * @memberof APIToken
     */
    'name': string;
    /**
     * The creation date and time of the token
     * @type {string}
     * @memberof APIToken
     */
    'created_at': string;
    /**
     * The expiration date and time of the token
     * @type {string}
     * @memberof APIToken
     */
    'expires_at': string;
    /**
     * The secret API key that\'s used for authentication. If workspace_id is set, the format of the key is \"tiledb_<random bytes>\". Otherwise, the format is a JWT. 
     * @type {string}
     * @memberof APIToken
     */
    'api_key': string;
    /**
     * The workspace ID of the token (if API token)
     * @type {string}
     * @memberof APIToken
     */
    'workspace_id'?: string;
    /**
     * 
     * @type {TokenScope}
     * @memberof APIToken
     */
    'scope': TokenScope;
}


/**
 * The version of the API that was used to perform the activity
 * @export
 * @enum {string}
 */

export const APIVersion = {
    V1: 'v1',
    V2: 'v2',
    V3: 'v3',
    V4: 'v4'
} as const;

export type APIVersion = typeof APIVersion[keyof typeof APIVersion];


/**
 * Credential information to access Amazon Web Services
 * @export
 * @interface AWSCredential
 */
export interface AWSCredential {
    /**
     * The ID of the access key
     * @type {string}
     * @memberof AWSCredential
     */
    'access_key_id': string;
    /**
     * The access key\'s secret. Never returned in responses.
     * @type {string}
     * @memberof AWSCredential
     */
    'secret_access_key': string;
    /**
     * The endpoint used for this credential
     * @type {string}
     * @memberof AWSCredential
     */
    'endpoint'?: string;
}
/**
 * The role information itself. Exactly one sub-field may be set. The names match those in the CloudProvider enum
 * @export
 * @interface AWSRole
 */
export interface AWSRole {
    /**
     * The role arn used to access
     * @type {string}
     * @memberof AWSRole
     */
    'role_arn': string;
    /**
     * The role external id used to access
     * @type {string}
     * @memberof AWSRole
     */
    'external_id': string;
    /**
     * The endpoint used for this role
     * @type {string}
     * @memberof AWSRole
     */
    'endpoint'?: string;
}
/**
 * The academy lesson object
 * @export
 * @interface AcademyLesson
 */
export interface AcademyLesson {
    /**
     * Unique ID of the lesson
     * @type {string}
     * @memberof AcademyLesson
     */
    'lesson_id': string;
    /**
     * Version of the lesson
     * @type {string}
     * @memberof AcademyLesson
     */
    'lesson_version': string;
    /**
     * Indicates if lesson is completed
     * @type {boolean}
     * @memberof AcademyLesson
     */
    'completed'?: boolean;
    /**
     * Indicates if lesson is pinned
     * @type {boolean}
     * @memberof AcademyLesson
     */
    'pinned'?: boolean;
}
/**
 * object for get academy lessons list response
 * @export
 * @interface AcademyLessonsListResponse
 */
export interface AcademyLessonsListResponse {
    /**
     * List of academy lessons items
     * @type {Array<AcademyLesson>}
     * @memberof AcademyLessonsListResponse
     */
    'data': Array<AcademyLesson>;
}
/**
 * The academy questionnaire object
 * @export
 * @interface AcademyQuestionnaire
 */
export interface AcademyQuestionnaire {
    /**
     * Unique ID of the questionnaire
     * @type {string}
     * @memberof AcademyQuestionnaire
     */
    'questionnaire_id': string;
    /**
     * Version of the questionnaire
     * @type {string}
     * @memberof AcademyQuestionnaire
     */
    'questionnaire_version': string;
    /**
     * Indicates if questionnaire is completed
     * @type {boolean}
     * @memberof AcademyQuestionnaire
     */
    'completed': boolean;
    /**
     * Array of user answers
     * @type {Array<UserAnswer>}
     * @memberof AcademyQuestionnaire
     */
    'user_answers': Array<UserAnswer>;
}
/**
 * object for get academy questionnaire list response
 * @export
 * @interface AcademyQuestionnaireListResponse
 */
export interface AcademyQuestionnaireListResponse {
    /**
     * List of academy questionnaires items
     * @type {Array<AcademyQuestionnaire>}
     * @memberof AcademyQuestionnaireListResponse
     */
    'data': Array<AcademyQuestionnaire>;
}
/**
 * parameters for build create academy questionnaire request
 * @export
 * @interface AcademyQuestionnairePutRequest
 */
export interface AcademyQuestionnairePutRequest {
    /**
     * Unique ID of the questionnaire
     * @type {string}
     * @memberof AcademyQuestionnairePutRequest
     */
    'questionnaire_id': string;
    /**
     * Version of the questionnaire
     * @type {string}
     * @memberof AcademyQuestionnairePutRequest
     */
    'questionnaire_version': string;
    /**
     * Indicates if questionnaire is completed
     * @type {boolean}
     * @memberof AcademyQuestionnairePutRequest
     */
    'completed': boolean;
    /**
     * Array of user answers
     * @type {Array<UserAnswer>}
     * @memberof AcademyQuestionnairePutRequest
     */
    'user_answers': Array<UserAnswer>;
}
/**
 * The user credential object
 * @export
 * @interface AccessCredential
 */
export interface AccessCredential {
    /**
     * 
     * @type {CredentialType}
     * @memberof AccessCredential
     */
    'credential_type': CredentialType;
    /**
     * The ID of the credential
     * @type {string}
     * @memberof AccessCredential
     */
    'id': string;
    /**
     * credential name
     * @type {string}
     * @memberof AccessCredential
     */
    'name': string;
    /**
     * 
     * @type {CloudProvider}
     * @memberof AccessCredential
     */
    'provider': CloudProvider;
    /**
     * True if this is the user\'s default credential to be used when connecting to the given cloud provider. There can be at most one default for each unique provider
     * @type {boolean}
     * @memberof AccessCredential
     */
    'provider_default'?: boolean;
    /**
     * Datetime credentials were created in UTC
     * @type {string}
     * @memberof AccessCredential
     */
    'created_at': string;
    /**
     * Datetime credentials were updated in UTC
     * @type {string}
     * @memberof AccessCredential
     */
    'updated_at'?: string;
    /**
     * Is this credential allowed to be used in tasks
     * @type {boolean}
     * @memberof AccessCredential
     */
    'allowed_in_tasks'?: boolean;
    /**
     * 
     * @type {Credential}
     * @memberof AccessCredential
     */
    'credential'?: Credential;
    /**
     * 
     * @type {AccessCredentialRole}
     * @memberof AccessCredential
     */
    'role'?: AccessCredentialRole;
    /**
     * 
     * @type {Token}
     * @memberof AccessCredential
     */
    'token'?: Token;
}


/**
 * object for access credential role
 * @export
 * @interface AccessCredentialRole
 */
export interface AccessCredentialRole {
    /**
     * 
     * @type {AWSRole}
     * @memberof AccessCredentialRole
     */
    'aws'?: AWSRole;
}
/**
 * The response object when requesting activities
 * @export
 * @interface ActivitiesListResponse
 */
export interface ActivitiesListResponse {
    /**
     * Array of activities
     * @type {Array<Activity>}
     * @memberof ActivitiesListResponse
     */
    'data': Array<Activity>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof ActivitiesListResponse
     */
    'pagination_metadata'?: PaginationMetadata;
}
/**
 * An activity is a record of an action taken by a user. Usually, an activity is an API request. 
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * The activity\'s ID
     * @type {string}
     * @memberof Activity
     */
    'activity_id': string;
    /**
     * 
     * @type {APIVersion}
     * @memberof Activity
     */
    'api_version': APIVersion;
    /**
     * 
     * @type {ActivitySubject}
     * @memberof Activity
     */
    'subject': ActivitySubject;
    /**
     * The action that was performed on the object
     * @type {string}
     * @memberof Activity
     */
    'action': ActivityActionEnum;
    /**
     * 
     * @type {ActivityObject}
     * @memberof Activity
     */
    'object': ActivityObject;
    /**
     * 
     * @type {ActivityArrayTask}
     * @memberof Activity
     */
    'array_task'?: ActivityArrayTask;
    /**
     * 
     * @type {ActivityExtraData}
     * @memberof Activity
     */
    'extra_data'?: ActivityExtraData;
    /**
     * 
     * @type {WorkspaceLight}
     * @memberof Activity
     */
    'workspace'?: WorkspaceLight;
    /**
     * 
     * @type {TeamspaceLight}
     * @memberof Activity
     */
    'teamspace'?: TeamspaceLight;
    /**
     * The time the activity was recorded
     * @type {string}
     * @memberof Activity
     */
    'recorded_at': string;
}

export const ActivityActionEnum = {
    Create: 'create',
    Read: 'read',
    Update: 'update',
    Delete: 'delete',
    StartNotebook: 'start-notebook',
    StopNotebook: 'stop-notebook',
    ReadMetadata: 'read-metadata',
    AddMetadata: 'add-metadata',
    RemoveMetadata: 'remove-metadata',
    AddContent: 'add-content',
    RemoveContent: 'remove-content',
    ReadContent: 'read-content',
    Move: 'move',
    QueryRead: 'query-read'
} as const;

export type ActivityActionEnum = typeof ActivityActionEnum[keyof typeof ActivityActionEnum];

/**
 * The array task that is associated with the activity. 
 * @export
 * @interface ActivityArrayTask
 */
export interface ActivityArrayTask {
    /**
     * The unique identifier for the array task.
     * @type {string}
     * @memberof ActivityArrayTask
     */
    'id': string;
    /**
     * The name of the array task.
     * @type {string}
     * @memberof ActivityArrayTask
     */
    'name'?: string;
}
/**
 * The asset that was affected by the activity. 
 * @export
 * @interface ActivityAsset
 */
export interface ActivityAsset {
    /**
     * The asset\'s ID.
     * @type {string}
     * @memberof ActivityAsset
     */
    'id': string;
    /**
     * The path of the asset.
     * @type {string}
     * @memberof ActivityAsset
     */
    'path': string;
    /**
     * 
     * @type {AssetType}
     * @memberof ActivityAsset
     */
    'type': AssetType;
    /**
     * The name of the asset.
     * @type {string}
     * @memberof ActivityAsset
     */
    'name': string;
}


/**
 * @type ActivityExtraData
 * @export
 */
export type ActivityExtraData = ExtraDataMembers | ExtraDataMetadata | ExtraDataMove;

/**
 * @type ActivityObject
 * @export
 */
export type ActivityObject = ActivityAsset | ActivityToken;

/**
 * @type ActivitySubject
 * @export
 */
export type ActivitySubject = User | WorkspaceUser;

/**
 * The token that was affected by the activity. 
 * @export
 * @interface ActivityToken
 */
export interface ActivityToken {
    /**
     * The token\'s ID
     * @type {string}
     * @memberof ActivityToken
     */
    'token_id': string;
    /**
     * The name of the token
     * @type {string}
     * @memberof ActivityToken
     */
    'name': string;
    /**
     * 
     * @type {TokenScope}
     * @memberof ActivityToken
     */
    'scope': TokenScope;
}


/**
 * 
 * @export
 * @interface ArrayInfo
 */
export interface ArrayInfo {
    /**
     * Size of the array in bytes.
     * @type {number}
     * @memberof ArrayInfo
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * The asset\'s ID
     * @type {string}
     * @memberof Asset
     */
    'id': string;
    /**
     * The workspace\'s ID
     * @type {string}
     * @memberof Asset
     */
    'workspace_id': string;
    /**
     * The teamspace\'s ID
     * @type {string}
     * @memberof Asset
     */
    'teamspace_id': string;
    /**
     * The name of the asset.
     * @type {string}
     * @memberof Asset
     */
    'name': string;
    /**
     * The description of the asset.
     * @type {string}
     * @memberof Asset
     */
    'description'?: string;
    /**
     * 
     * @type {AssetMemberType}
     * @memberof Asset
     */
    'member_type'?: AssetMemberType;
    /**
     * The MIME type of the asset.
     * @type {string}
     * @memberof Asset
     */
    'mime'?: string;
    /**
     * 
     * @type {AssetBackingType}
     * @memberof Asset
     */
    'backing_type': AssetBackingType;
    /**
     * 
     * @type {AssetType}
     * @memberof Asset
     */
    'type': AssetType;
    /**
     * The path of the asset.
     * @type {string}
     * @memberof Asset
     */
    'path': string;
    /**
     * Datetime asset was created in UTC
     * @type {string}
     * @memberof Asset
     */
    'created_at': string;
    /**
     * Datetime asset was updated in UTC
     * @type {string}
     * @memberof Asset
     */
    'updated_at'?: string;
    /**
     * 
     * @type {WorkspaceUser}
     * @memberof Asset
     */
    'created_by': WorkspaceUser;
    /**
     * 
     * @type {Array<AssetMetadata>}
     * @memberof Asset
     */
    'metadata'?: Array<AssetMetadata>;
    /**
     * URI where the asset is located.
     * @type {string}
     * @memberof Asset
     */
    'uri'?: string;
    /**
     * The TileDB URI in the form of tiledb://workspace_name/teamspace_name/asset_id
     * @type {string}
     * @memberof Asset
     */
    'tiledb_uri': string;
    /**
     * 
     * @type {FileInfo}
     * @memberof Asset
     */
    'fileInfo'?: FileInfo;
    /**
     * 
     * @type {ArrayInfo}
     * @memberof Asset
     */
    'arrayInfo'?: ArrayInfo;
    /**
     * 
     * @type {GroupInfo}
     * @memberof Asset
     */
    'groupInfo'?: GroupInfo;
    /**
     * 
     * @type {FolderInfo}
     * @memberof Asset
     */
    'folderInfo'?: FolderInfo;
}


/**
 * The backing type of the asset (e.g., array, group, file, folder).
 * @export
 * @enum {string}
 */

export const AssetBackingType = {
    Array: 'array',
    Group: 'group',
    File: 'file',
    Folder: 'folder'
} as const;

export type AssetBackingType = typeof AssetBackingType[keyof typeof AssetBackingType];


/**
 * The response object when requesting a single asset
 * @export
 * @interface AssetGetResponse
 */
export interface AssetGetResponse {
    /**
     * 
     * @type {Asset}
     * @memberof AssetGetResponse
     */
    'data': Asset;
}
/**
 * The response object when requesting the list of assets
 * @export
 * @interface AssetListResponse
 */
export interface AssetListResponse {
    /**
     * An array of assets
     * @type {Array<Asset>}
     * @memberof AssetListResponse
     */
    'data': Array<Asset>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof AssetListResponse
     */
    'pagination_metadata': PaginationMetadata;
}
/**
 * The member type associated with the asset.
 * @export
 * @enum {string}
 */

export const AssetMemberType = {
    VcfMember: 'vcf_member',
    SomaMember: 'soma_member',
    BioimgMember: 'bioimg_member',
    VectorSearchMember: 'vector_search_member',
    GeometryMember: 'geometry_member',
    RasterMember: 'raster_member',
    PointCloudMember: 'point_cloud_member'
} as const;

export type AssetMemberType = typeof AssetMemberType[keyof typeof AssetMemberType];


/**
 * key/value pair representing an asset metadata entry
 * @export
 * @interface AssetMetadata
 */
export interface AssetMetadata {
    /**
     * The key property of metadata pair.
     * @type {string}
     * @memberof AssetMetadata
     */
    'key': string;
    /**
     * The value property of metadata pair.
     * @type {string}
     * @memberof AssetMetadata
     */
    'value': string;
    /**
     * 
     * @type {AssetMetadataType}
     * @memberof AssetMetadata
     */
    'type': AssetMetadataType;
}


/**
 * The response object when requesting the list of asset metadata
 * @export
 * @interface AssetMetadataListResponse
 */
export interface AssetMetadataListResponse {
    /**
     * An array of asset\'s metadata
     * @type {Array<AssetMetadata>}
     * @memberof AssetMetadataListResponse
     */
    'data': Array<AssetMetadata>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof AssetMetadataListResponse
     */
    'pagination_metadata': PaginationMetadata;
}
/**
 * Asset metadata entry
 * @export
 * @interface AssetMetadataSaveRequestInner
 */
export interface AssetMetadataSaveRequestInner {
    /**
     * The key property of metadata pair.
     * @type {string}
     * @memberof AssetMetadataSaveRequestInner
     */
    'key': string;
    /**
     * The value property of metadata pair.
     * @type {string}
     * @memberof AssetMetadataSaveRequestInner
     */
    'value': string;
    /**
     * 
     * @type {AssetMetadataType}
     * @memberof AssetMetadataSaveRequestInner
     */
    'type': AssetMetadataType;
}


/**
 * object for save asset metadata response
 * @export
 * @interface AssetMetadataSaveResponse
 */
export interface AssetMetadataSaveResponse {
    /**
     * An array of asset\'s metadata that were saved
     * @type {Array<AssetMetadata>}
     * @memberof AssetMetadataSaveResponse
     */
    'data': Array<AssetMetadata>;
}
/**
 * The TileDB type property of metadata pair
 * @export
 * @enum {string}
 */

export const AssetMetadataType = {
    Int32: 'INT32',
    Int64: 'INT64',
    Float32: 'FLOAT32',
    Float64: 'FLOAT64',
    Char: 'CHAR',
    Int8: 'INT8',
    Uint8: 'UINT8',
    Int16: 'INT16',
    Uint16: 'UINT16',
    Uint32: 'UINT32',
    Uint64: 'UINT64',
    StringAscii: 'STRING_ASCII',
    StringUtf8: 'STRING_UTF8',
    StringUtf16: 'STRING_UTF16',
    StringUtf32: 'STRING_UTF32',
    StringUcs2: 'STRING_UCS2',
    StringUcs4: 'STRING_UCS4',
    Any: 'ANY',
    DatetimeYear: 'DATETIME_YEAR',
    DatetimeMonth: 'DATETIME_MONTH',
    DatetimeWeek: 'DATETIME_WEEK',
    DatetimeDay: 'DATETIME_DAY',
    DatetimeHr: 'DATETIME_HR',
    DatetimeMin: 'DATETIME_MIN',
    DatetimeSec: 'DATETIME_SEC',
    DatetimeMs: 'DATETIME_MS',
    DatetimeUs: 'DATETIME_US',
    DatetimeNs: 'DATETIME_NS',
    DatetimePs: 'DATETIME_PS',
    DatetimeFs: 'DATETIME_FS',
    DatetimeAs: 'DATETIME_AS',
    TimeHr: 'TIME_HR',
    TimeMin: 'TIME_MIN',
    TimeSec: 'TIME_SEC',
    TimeMs: 'TIME_MS',
    TimeUs: 'TIME_US',
    TimeNs: 'TIME_NS',
    TimePs: 'TIME_PS',
    TimeFs: 'TIME_FS',
    TimeAs: 'TIME_AS',
    Blob: 'BLOB',
    Bool: 'BOOL'
} as const;

export type AssetMetadataType = typeof AssetMetadataType[keyof typeof AssetMetadataType];


/**
 * The response object when requesting all assets in a given path
 * @export
 * @interface AssetPathResponse
 */
export interface AssetPathResponse {
    /**
     * An array of assets. The order of the assets corresponds to the order of the path elements. 
     * @type {Array<Asset>}
     * @memberof AssetPathResponse
     */
    'data': Array<Asset>;
}
/**
 * key/value pair representing an asset property entry
 * @export
 * @interface AssetProperty
 */
export interface AssetProperty {
    /**
     * The key property of property pair: * `image` - Image name to launch the notebook * `image_size` - Image size to launch the notebook * `default_region` - Default region to start the notebook server * `default_view` - Default view to open the asset in the UI * `version_pruning_limit` - The maximum number of versions to keep for a notebook * `version_pruning_enabled` - Flag indicating whether automatic version pruning is enabled for a notebook 
     * @type {string}
     * @memberof AssetProperty
     */
    'key': AssetPropertyKeyEnum;
    /**
     * The value property of property pair.
     * @type {string}
     * @memberof AssetProperty
     */
    'value': string;
    /**
     * The id of the asset property
     * @type {string}
     * @memberof AssetProperty
     */
    'id'?: string;
}

export const AssetPropertyKeyEnum = {
    Image: 'image',
    Size: 'size',
    DefaultRegion: 'default_region',
    DefaultView: 'default_view',
    VersionPruningLimit: 'version_pruning_limit',
    VersionPruningEnabled: 'version_pruning_enabled'
} as const;

export type AssetPropertyKeyEnum = typeof AssetPropertyKeyEnum[keyof typeof AssetPropertyKeyEnum];

/**
 * The response object when requesting the list of asset properties
 * @export
 * @interface AssetPropertyListResponse
 */
export interface AssetPropertyListResponse {
    /**
     * An array of asset\'s properties
     * @type {Array<AssetProperty>}
     * @memberof AssetPropertyListResponse
     */
    'data': Array<AssetProperty>;
}
/**
 * Asset property entry
 * @export
 * @interface AssetPropertySaveRequestInner
 */
export interface AssetPropertySaveRequestInner {
    /**
     * The key property of property pair: * `image` - Image name to launch the notebook * `image_size` - Image size to launch the notebook * `default_region` - Default region to start the notebook server * `default_view` - Default view to open the asset in the UI * `version_pruning_limit` - The maximum number of versions to keep for a notebook * `version_pruning_enabled` - Flag indicating whether automatic version pruning is enabled for a notebook 
     * @type {string}
     * @memberof AssetPropertySaveRequestInner
     */
    'key': AssetPropertySaveRequestInnerKeyEnum;
    /**
     * The value property of property pair.
     * @type {string}
     * @memberof AssetPropertySaveRequestInner
     */
    'value': string;
    /**
     * The id of the asset property if it has been set already
     * @type {string}
     * @memberof AssetPropertySaveRequestInner
     */
    'id'?: string | null;
}

export const AssetPropertySaveRequestInnerKeyEnum = {
    Image: 'image',
    Size: 'size',
    DefaultRegion: 'default_region',
    DefaultView: 'default_view',
    VersionPruningLimit: 'version_pruning_limit',
    VersionPruningEnabled: 'version_pruning_enabled'
} as const;

export type AssetPropertySaveRequestInnerKeyEnum = typeof AssetPropertySaveRequestInnerKeyEnum[keyof typeof AssetPropertySaveRequestInnerKeyEnum];

/**
 * object for save asset properties response
 * @export
 * @interface AssetPropertySaveResponse
 */
export interface AssetPropertySaveResponse {
    /**
     * An array of asset\'s properties that were saved
     * @type {Array<AssetProperty>}
     * @memberof AssetPropertySaveResponse
     */
    'data': Array<AssetProperty>;
}
/**
 * Request to register an asset
 * @export
 * @interface AssetRegisterRequest
 */
export interface AssetRegisterRequest {
    /**
     * Name of the asset
     * @type {string}
     * @memberof AssetRegisterRequest
     */
    'name': string;
    /**
     * URI of the asset (e.g., S3 location)
     * @type {string}
     * @memberof AssetRegisterRequest
     */
    'uri': string;
    /**
     * Named reference to access credentials
     * @type {string}
     * @memberof AssetRegisterRequest
     */
    'access_credentials_name': string;
    /**
     * Target path under the teamspace
     * @type {string}
     * @memberof AssetRegisterRequest
     */
    'path': string;
}
/**
 * The type of asset based on how it is represented.
 * @export
 * @enum {string}
 */

export const AssetType = {
    Array: 'array',
    Notebook: 'notebook',
    Dashboard: 'dashboard',
    UserDefinedFunction: 'user_defined_function',
    MlModel: 'ml_model',
    File: 'file',
    RegisteredTaskGraph: 'registered_task_graph',
    Group: 'group',
    Vcf: 'vcf',
    Soma: 'soma',
    Pointcloud: 'pointcloud',
    Bioimg: 'bioimg',
    Geometry: 'geometry',
    Raster: 'raster',
    VectorSearch: 'vector_search',
    Folder: 'folder'
} as const;

export type AssetType = typeof AssetType[keyof typeof AssetType];


/**
 * Request body for updating an asset.
 * @export
 * @interface AssetUpdateRequest
 */
export interface AssetUpdateRequest {
    /**
     * The name of the asset.
     * @type {string}
     * @memberof AssetUpdateRequest
     */
    'name'?: string;
    /**
     * The description of the asset.
     * @type {string}
     * @memberof AssetUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {AssetType}
     * @memberof AssetUpdateRequest
     */
    'type'?: AssetType;
}


/**
 * Request to move assets to a target folder
 * @export
 * @interface AssetsMoveRequest
 */
export interface AssetsMoveRequest {
    /**
     * An array of asset ids to move under a target folder
     * @type {Array<string>}
     * @memberof AssetsMoveRequest
     */
    'assets_to_add': Array<string>;
    /**
     * The asset id or path
     * @type {string}
     * @memberof AssetsMoveRequest
     */
    'target': string;
}
/**
 * Credential information to access Microsoft Azure. Each supported property is the snake_case version of its name in an Azure Storage connection string
 * @export
 * @interface AzureCredential
 */
export interface AzureCredential {
    /**
     * The name of the Azure account to access
     * @type {string}
     * @memberof AzureCredential
     */
    'account_name'?: string;
    /**
     * The secret key. Never returned in responses.
     * @type {string}
     * @memberof AzureCredential
     */
    'account_key'?: string;
}
/**
 * Token information to access Azure services
 * @export
 * @interface AzureToken
 */
export interface AzureToken {
    /**
     * The account name of the configuration
     * @type {string}
     * @memberof AzureToken
     */
    'account_name': string;
    /**
     * The token to use for this account
     * @type {string}
     * @memberof AzureToken
     */
    'sas_token': string;
}
/**
 * Object containing the necessary data to change a user\'s password
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * The user\'s current password
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'current_password': string;
    /**
     * The new password
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'new_password': string;
}
/**
 * A service where data is stored or computations take place
 * @export
 * @enum {string}
 */

export const CloudProvider = {
    Aws: 'AWS',
    Azure: 'AZURE',
    Gcp: 'GCP'
} as const;

export type CloudProvider = typeof CloudProvider[keyof typeof CloudProvider];


/**
 * A folder returned by FileList
 * @export
 * @interface CommonPrefix
 */
export interface CommonPrefix {
    /**
     * A prefix
     * @type {string}
     * @memberof CommonPrefix
     */
    'Prefix'?: string;
}
/**
 * The credential information itself. Exactly one sub-field may be set. The names match those in the CloudProvider enum.
 * @export
 * @interface Credential
 */
export interface Credential {
    /**
     * 
     * @type {AWSCredential}
     * @memberof Credential
     */
    'aws'?: AWSCredential;
    /**
     * 
     * @type {AzureCredential}
     * @memberof Credential
     */
    'azure'?: AzureCredential;
    /**
     * 
     * @type {GCPInteroperabilityCredential}
     * @memberof Credential
     */
    'gcp'?: GCPInteroperabilityCredential;
}
/**
 * object metadata for a credential that will be created
 * @export
 * @interface CredentialCreateRequest
 */
export interface CredentialCreateRequest {
    /**
     * credential name
     * @type {string}
     * @memberof CredentialCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {CloudProvider}
     * @memberof CredentialCreateRequest
     */
    'provider': CloudProvider;
    /**
     * True if this is the namespace\'s default credential to be used when connecting to the given cloud provider. There can be at most one default for each unique provider
     * @type {boolean}
     * @memberof CredentialCreateRequest
     */
    'provider_default'?: boolean;
    /**
     * Is this credential allowed to be used in tasks
     * @type {boolean}
     * @memberof CredentialCreateRequest
     */
    'allowed_in_tasks'?: boolean;
    /**
     * 
     * @type {Credential}
     * @memberof CredentialCreateRequest
     */
    'credential'?: Credential;
    /**
     * 
     * @type {AccessCredentialRole}
     * @memberof CredentialCreateRequest
     */
    'role'?: AccessCredentialRole;
    /**
     * 
     * @type {Token}
     * @memberof CredentialCreateRequest
     */
    'token'?: Token;
}


/**
 * object for get credential response
 * @export
 * @interface CredentialGetResponse
 */
export interface CredentialGetResponse {
    /**
     * 
     * @type {AccessCredential}
     * @memberof CredentialGetResponse
     */
    'data': AccessCredential;
}
/**
 * Enumeration of tileDB Credential types
 * @export
 * @enum {string}
 */

export const CredentialType = {
    Workspace: 'workspace',
    Teamspace: 'teamspace'
} as const;

export type CredentialType = typeof CredentialType[keyof typeof CredentialType];


/**
 * The credential update object
 * @export
 * @interface CredentialUpdateRequest
 */
export interface CredentialUpdateRequest {
    /**
     * A user-specified name for the key
     * @type {string}
     * @memberof CredentialUpdateRequest
     */
    'name'?: string;
    /**
     * True if this is the user\'s default credential to be used when connecting to the given cloud provider. There can be at most one default for each unique provider
     * @type {boolean}
     * @memberof CredentialUpdateRequest
     */
    'provider_default'?: boolean;
    /**
     * 
     * @type {CloudProvider}
     * @memberof CredentialUpdateRequest
     */
    'provider'?: CloudProvider;
    /**
     * Is this credential allowed to be used in tasks
     * @type {boolean}
     * @memberof CredentialUpdateRequest
     */
    'allowed_in_tasks'?: boolean;
    /**
     * 
     * @type {Credential}
     * @memberof CredentialUpdateRequest
     */
    'credential'?: Credential;
    /**
     * 
     * @type {AccessCredentialRole}
     * @memberof CredentialUpdateRequest
     */
    'role'?: AccessCredentialRole;
    /**
     * 
     * @type {Token}
     * @memberof CredentialUpdateRequest
     */
    'token'?: Token;
}


/**
 * object for get credentials list response
 * @export
 * @interface CredentialsListResponse
 */
export interface CredentialsListResponse {
    /**
     * List of credentials items
     * @type {Array<AccessCredential>}
     * @memberof CredentialsListResponse
     */
    'data': Array<AccessCredential>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof CredentialsListResponse
     */
    'pagination_metadata'?: PaginationMetadata;
}
/**
 * object metadata for a credential that will be created
 * @export
 * @interface CredentialsVerifyRequest
 */
export interface CredentialsVerifyRequest {
    /**
     * credential name
     * @type {string}
     * @memberof CredentialsVerifyRequest
     */
    'name': string;
    /**
     * 
     * @type {CloudProvider}
     * @memberof CredentialsVerifyRequest
     */
    'provider': CloudProvider;
    /**
     * True if this is the namespace\'s default credential to be used when connecting to the given cloud provider. There can be at most one default for each unique provider
     * @type {boolean}
     * @memberof CredentialsVerifyRequest
     */
    'provider_default'?: boolean;
    /**
     * Is this credential allowed to be used in tasks
     * @type {boolean}
     * @memberof CredentialsVerifyRequest
     */
    'allowed_in_tasks'?: boolean;
    /**
     * 
     * @type {Credential}
     * @memberof CredentialsVerifyRequest
     */
    'credential'?: Credential;
    /**
     * 
     * @type {AccessCredentialRole}
     * @memberof CredentialsVerifyRequest
     */
    'role'?: AccessCredentialRole;
    /**
     * 
     * @type {Token}
     * @memberof CredentialsVerifyRequest
     */
    'token'?: Token;
    /**
     * The workspace\'s ID. If provided, the given role will be verified in a daisy chain fashion, starting with the role ARN associated with the given workspace. 
     * @type {string}
     * @memberof CredentialsVerifyRequest
     */
    'workspace_id'?: string;
    /**
     * The teamspace\'s ID. If provided, the given role will be verified in a daisy chain fashion, starting with the role ARN associated with the given teamspace. 
     * @type {string}
     * @memberof CredentialsVerifyRequest
     */
    'teamspace_id'?: string;
}


/**
 * Delta share table change file object
 * @export
 * @interface DataChangeFile
 */
export interface DataChangeFile {
    /**
     * An https url that a client can use to read the file directly. The same file in different responses may have different urls.
     * @type {string}
     * @memberof DataChangeFile
     */
    'url': string;
    /**
     * A unique string for the file in a table. The same file is guaranteed to have the same id across multiple requests. A client may cache the file content and use this id as a key to decide whether to use the cached file content.
     * @type {string}
     * @memberof DataChangeFile
     */
    'id': string;
    /**
     * A map from partition column to value for this file. See Partition Value Serialization for how to parse the partition values. When the table doesn\'t have partition columns, this will be an empty map.
     * @type {{ [key: string]: any; }}
     * @memberof DataChangeFile
     */
    'partitionValues': { [key: string]: any; };
    /**
     * The size of this file in bytes.
     * @type {number}
     * @memberof DataChangeFile
     */
    'size': number;
    /**
     * The timestamp of the file in milliseconds from epoch.
     * @type {number}
     * @memberof DataChangeFile
     */
    'timestamp': number;
    /**
     * The table version of this file.
     * @type {number}
     * @memberof DataChangeFile
     */
    'version': number;
    /**
     * The unix timestamp corresponding to the expiration of the url, in milliseconds, returned when the server supports the feature.
     * @type {number}
     * @memberof DataChangeFile
     */
    'expirationTimestamp'?: number;
}
/**
 * Delta share table change file object for additions
 * @export
 * @interface DataChangeFileAdd
 */
export interface DataChangeFileAdd {
    /**
     * An https url that a client can use to read the file directly. The same file in different responses may have different urls.
     * @type {string}
     * @memberof DataChangeFileAdd
     */
    'url': string;
    /**
     * A unique string for the file in a table. The same file is guaranteed to have the same id across multiple requests. A client may cache the file content and use this id as a key to decide whether to use the cached file content.
     * @type {string}
     * @memberof DataChangeFileAdd
     */
    'id': string;
    /**
     * A map from partition column to value for this file. See Partition Value Serialization for how to parse the partition values. When the table doesn\'t have partition columns, this will be an empty map.
     * @type {{ [key: string]: any; }}
     * @memberof DataChangeFileAdd
     */
    'partitionValues': { [key: string]: any; };
    /**
     * The size of this file in bytes.
     * @type {number}
     * @memberof DataChangeFileAdd
     */
    'size': number;
    /**
     * The timestamp of the file in milliseconds from epoch.
     * @type {number}
     * @memberof DataChangeFileAdd
     */
    'timestamp': number;
    /**
     * The table version of this file.
     * @type {number}
     * @memberof DataChangeFileAdd
     */
    'version': number;
    /**
     * Contains statistics (e.g., count, min/max values for columns) about the data in this file. This field may be missing. A file may or may not have stats. This is a serialized JSON string which can be deserialized to a Statistics Struct. A client can decide whether to use stats or drop it.
     * @type {string}
     * @memberof DataChangeFileAdd
     */
    'stats'?: string;
    /**
     * The unix timestamp corresponding to the expiration of the url, in milliseconds, returned when the server supports the feature.
     * @type {number}
     * @memberof DataChangeFileAdd
     */
    'expirationTimestamp'?: number;
}
/**
 * Delta share table change file object for removals
 * @export
 * @interface DataChangeFileRemove
 */
export interface DataChangeFileRemove {
    /**
     * An https url that a client can use to read the file directly. The same file in different responses may have different urls.
     * @type {string}
     * @memberof DataChangeFileRemove
     */
    'url': string;
    /**
     * A unique string for the file in a table. The same file is guaranteed to have the same id across multiple requests. A client may cache the file content and use this id as a key to decide whether to use the cached file content.
     * @type {string}
     * @memberof DataChangeFileRemove
     */
    'id': string;
    /**
     * A map from partition column to value for this file. See Partition Value Serialization for how to parse the partition values. When the table doesn\'t have partition columns, this will be an empty map.
     * @type {{ [key: string]: any; }}
     * @memberof DataChangeFileRemove
     */
    'partitionValues': { [key: string]: any; };
    /**
     * The size of this file in bytes.
     * @type {number}
     * @memberof DataChangeFileRemove
     */
    'size': number;
    /**
     * The timestamp of the file in milliseconds from epoch.
     * @type {number}
     * @memberof DataChangeFileRemove
     */
    'timestamp': number;
    /**
     * The table version of this file.
     * @type {number}
     * @memberof DataChangeFileRemove
     */
    'version': number;
    /**
     * The unix timestamp corresponding to the expiration of the url, in milliseconds, returned when the server supports the feature.
     * @type {number}
     * @memberof DataChangeFileRemove
     */
    'expirationTimestamp'?: number;
}
/**
 * The type of the entity
 * @export
 * @enum {string}
 */

export const EntityTypes = {
    Array: 'array',
    Asset: 'asset',
    File: 'file',
    Folder: 'folder',
    Group: 'group',
    Notebook: 'notebook',
    Token: 'token',
    User: 'user'
} as const;

export type EntityTypes = typeof EntityTypes[keyof typeof EntityTypes];


/**
 * Object containing data about a handled error by REST server in delta format
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * A hardcoded integer which points to a specific file/line of the code that returned the error
     * @type {number}
     * @memberof ErrorResponse
     */
    'errorCode': number;
    /**
     * A friendly message to be shown to the client
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
}
/**
 * Object containing data about a handled error by REST server, presented in a format compatible with S3
 * @export
 * @interface ErrorXML
 */
export interface ErrorXML {
    /**
     * A machine-friendly string that describes the error
     * @type {string}
     * @memberof ErrorXML
     */
    'code': string;
    /**
     * A friendly message to be shown to the client
     * @type {string}
     * @memberof ErrorXML
     */
    'message': string;
    /**
     * The request id to be used for tracing/debugging
     * @type {string}
     * @memberof ErrorXML
     */
    'request_id': string;
}
/**
 * An array of asset IDs. Depending on the activity action, these asset IDs can be added or removed from a folder or a group. 
 * @export
 * @interface ExtraDataMembers
 */
export interface ExtraDataMembers {
    /**
     * The asset\'s ID
     * @type {string}
     * @memberof ExtraDataMembers
     */
    'asset_id': string;
}
/**
 * A key-value pair of metadata. 
 * @export
 * @interface ExtraDataMetadata
 */
export interface ExtraDataMetadata {
    /**
     * The key of the metadata.
     * @type {string}
     * @memberof ExtraDataMetadata
     */
    'key': string;
    /**
     * The value of the metadata.
     * @type {string}
     * @memberof ExtraDataMetadata
     */
    'value': string;
}
/**
 * The previous and new location of an asset. 
 * @export
 * @interface ExtraDataMove
 */
export interface ExtraDataMove {
    /**
     * The previous location of the asset.
     * @type {string}
     * @memberof ExtraDataMove
     */
    'from': string;
    /**
     * The new location of the asset.
     * @type {string}
     * @memberof ExtraDataMove
     */
    'to': string;
}
/**
 * 
 * @export
 * @interface FileInfo
 */
export interface FileInfo {
    /**
     * Size of the file in bytes.
     * @type {number}
     * @memberof FileInfo
     */
    'size': number;
}
/**
 * The result of a list files operation. Compatible with S3\'s ListObjectResult
 * @export
 * @interface FileListResponse
 */
export interface FileListResponse {
    /**
     * The name of the bucket (teamspace) with the objects
     * @type {string}
     * @memberof FileListResponse
     */
    'Name'?: string;
    /**
     * The prefix under which objects are listed
     * @type {string}
     * @memberof FileListResponse
     */
    'Prefix'?: string;
    /**
     * The string that delimits the path segments. Only forward slash is supported
     * @type {string}
     * @memberof FileListResponse
     */
    'Delimiter'?: string;
    /**
     * The maximum amount of objects to return
     * @type {number}
     * @memberof FileListResponse
     */
    'MaxKeys'?: number;
    /**
     * The continuation token that was passed to the operation
     * @type {string}
     * @memberof FileListResponse
     */
    'ContinuationToken'?: string;
    /**
     * The continuation token to pass to list the next items
     * @type {string}
     * @memberof FileListResponse
     */
    'NextContinuationToken'?: string;
    /**
     * Whether there are no more files to list
     * @type {boolean}
     * @memberof FileListResponse
     */
    'IsTruncated'?: boolean;
    /**
     * The common prefixes (folders) contained under prefix.
     * @type {Array<CommonPrefix>}
     * @memberof FileListResponse
     */
    'CommonPrefixes'?: Array<CommonPrefix>;
    /**
     * The objects (files) contained under prefix.
     * @type {Array<ModelObject>}
     * @memberof FileListResponse
     */
    'Objects'?: Array<ModelObject>;
}
/**
 * The prefixed URL for the given path.
 * @export
 * @interface FilePresignedURLResponse
 */
export interface FilePresignedURLResponse {
    /**
     * The prefixed URL for the given path. The URL will expire after a specified duration.
     * @type {string}
     * @memberof FilePresignedURLResponse
     */
    'SignedUrl'?: string;
    /**
     * The expiration date and time of the presigned url
     * @type {string}
     * @memberof FilePresignedURLResponse
     */
    'ExpiresAt'?: string;
}
/**
 * 
 * @export
 * @interface Folder
 */
export interface Folder {
    /**
     * The folder\'s ID
     * @type {string}
     * @memberof Folder
     */
    'id': string;
    /**
     * The workspace\'s ID
     * @type {string}
     * @memberof Folder
     */
    'workspace_id': string;
    /**
     * The teamspace\'s ID
     * @type {string}
     * @memberof Folder
     */
    'teamspace_id': string;
    /**
     * The group\'s ID
     * @type {string}
     * @memberof Folder
     */
    'group_id'?: string;
    /**
     * The asset\'s ID
     * @type {string}
     * @memberof Folder
     */
    'asset_id': string;
    /**
     * The folder\'s ID
     * @type {string}
     * @memberof Folder
     */
    'parent_folder_id'?: string;
    /**
     * The name of the folder.
     * @type {string}
     * @memberof Folder
     */
    'name': string;
    /**
     * Datetime asset was created in UTC
     * @type {string}
     * @memberof Folder
     */
    'created_at': string;
    /**
     * Datetime asset was updated in UTC
     * @type {string}
     * @memberof Folder
     */
    'updated_at'?: string;
    /**
     * 
     * @type {WorkspaceUser}
     * @memberof Folder
     */
    'created_by': WorkspaceUser;
    /**
     * The description of the folder.
     * @type {string}
     * @memberof Folder
     */
    'description'?: string;
}
/**
 * The response object when requesting the list of folder contents
 * @export
 * @interface FolderContentsResponse
 */
export interface FolderContentsResponse {
    /**
     * An array of assets
     * @type {Array<Asset>}
     * @memberof FolderContentsResponse
     */
    'data': Array<Asset>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof FolderContentsResponse
     */
    'pagination_metadata': PaginationMetadata;
}
/**
 * object metadata for folders that will be created
 * @export
 * @interface FolderCreateRequestInner
 */
export interface FolderCreateRequestInner {
    /**
     * Folder description
     * @type {string}
     * @memberof FolderCreateRequestInner
     */
    'description'?: string;
}
/**
 * object for create folder response
 * @export
 * @interface FolderCreateResponse
 */
export interface FolderCreateResponse {
    /**
     * 
     * @type {Folder}
     * @memberof FolderCreateResponse
     */
    'data': Folder;
}
/**
 * The response object when requesting a single folder
 * @export
 * @interface FolderGetResponse
 */
export interface FolderGetResponse {
    /**
     * 
     * @type {Folder}
     * @memberof FolderGetResponse
     */
    'data': Folder;
}
/**
 * 
 * @export
 * @interface FolderInfo
 */
export interface FolderInfo {
    /**
     * Number of items in the folder.
     * @type {number}
     * @memberof FolderInfo
     */
    'length': number;
}
/**
 * The request object for updating a folder
 * @export
 * @interface FolderUpdateRequest
 */
export interface FolderUpdateRequest {
    /**
     * The teamspace name
     * @type {string}
     * @memberof FolderUpdateRequest
     */
    'name'?: string;
    /**
     * The folder description
     * @type {string}
     * @memberof FolderUpdateRequest
     */
    'description'?: string;
}
/**
 * The request object to add or remove contents under a folder
 * @export
 * @interface FoldersContentsModifyInner
 */
export interface FoldersContentsModifyInner {
    /**
     * An array of asset ids to add under a folder
     * @type {Array<string>}
     * @memberof FoldersContentsModifyInner
     */
    'members_to_add': Array<string>;
    /**
     * An array of asset ids to remove from a folder
     * @type {Array<string>}
     * @memberof FoldersContentsModifyInner
     */
    'members_to_remove': Array<string>;
}
/**
 * Delta share table metadata object
 * @export
 * @interface Format
 */
export interface Format {
    /**
     * Name of the encoding for data files in this table. Currently the only valid value is parquet. This is to enable possible support for other formats in the future.
     * @type {string}
     * @memberof Format
     */
    'provider': string;
}
/**
 * Credential information to access Google Cloud. using well knows key/secret pair to access storage.
 * @export
 * @interface GCPInteroperabilityCredential
 */
export interface GCPInteroperabilityCredential {
    /**
     * The ID of the access key
     * @type {string}
     * @memberof GCPInteroperabilityCredential
     */
    'access_key_id'?: string;
    /**
     * The access key\'s secret. Never returned in responses.
     * @type {string}
     * @memberof GCPInteroperabilityCredential
     */
    'secret_access_key'?: string;
}
/**
 * The key to a Google Cloud Platform service account.
 * @export
 * @interface GCPServiceAccountKey
 */
export interface GCPServiceAccountKey {
    /**
     * The ID of the service account (i.e., its email address).  This is ignored when uploading key information, and is only provided by the server when downloading metadata about an existing key. 
     * @type {string}
     * @memberof GCPServiceAccountKey
     */
    'account_id': string;
    /**
     * The ID of the particular key. This identifies it among other keys issued for this service account.  This is ignored when uploading key information, and is only provided by the server when downloading metadata about an existing key. 
     * @type {string}
     * @memberof GCPServiceAccountKey
     */
    'key_id': string;
    /**
     * The full file provided by Google Cloud. This is usually in the form of a JSON document, but TileDB Cloud treats it as opaque (except to attempt to extract the service account ID and the key ID). 
     * @type {string}
     * @memberof GCPServiceAccountKey
     */
    'key_text': string;
}
/**
 * The generalspace object
 * @export
 * @interface Generalspace
 */
export interface Generalspace {
    /**
     * The generalspace\'s ID
     * @type {string}
     * @memberof Generalspace
     */
    'generalspace_id': string;
    /**
     * The generalspace name
     * @type {string}
     * @memberof Generalspace
     */
    'name': string;
    /**
     * The generalspace icon as a UTF8-encoded Unicode symbol, e.g. 🚀
     * @type {string}
     * @memberof Generalspace
     */
    'icon'?: string;
    /**
     * The datetime the generalspace was created (in UTC)
     * @type {string}
     * @memberof Generalspace
     */
    'created_at': string;
    /**
     * The generalspace description
     * @type {string}
     * @memberof Generalspace
     */
    'description'?: string;
    /**
     * The datetime the generalspace was updated (in UTC)
     * @type {string}
     * @memberof Generalspace
     */
    'updated_at'?: string;
}
/**
 * The response object when requesting a generalspace
 * @export
 * @interface GeneralspaceGetResponse
 */
export interface GeneralspaceGetResponse {
    /**
     * 
     * @type {Generalspace}
     * @memberof GeneralspaceGetResponse
     */
    'data': Generalspace;
}
/**
 * The request object for updating a generalspace
 * @export
 * @interface GeneralspaceUpdateRequest
 */
export interface GeneralspaceUpdateRequest {
    /**
     * The generalspace name
     * @type {string}
     * @memberof GeneralspaceUpdateRequest
     */
    'name'?: string;
    /**
     * The generalspace description
     * @type {string}
     * @memberof GeneralspaceUpdateRequest
     */
    'description'?: string;
    /**
     * The generalspace icon as a UTF8-encoded Unicode symbol, e.g. 🚀
     * @type {string}
     * @memberof GeneralspaceUpdateRequest
     */
    'icon'?: string;
    /**
     * 
     * @type {TeamspaceVisibility}
     * @memberof GeneralspaceUpdateRequest
     */
    'visibility_level'?: TeamspaceVisibility;
}


/**
 * 
 * @export
 * @interface GroupInfo
 */
export interface GroupInfo {
    /**
     * Number of items in the group.
     * @type {number}
     * @memberof GroupInfo
     */
    'length': number;
}
/**
 * The invitation object
 * @export
 * @interface Invitation
 */
export interface Invitation {
    /**
     * The invitation\'s ID
     * @type {string}
     * @memberof Invitation
     */
    'invitation_id': string;
    /**
     * The invited user\'s email address
     * @type {string}
     * @memberof Invitation
     */
    'invitee_email': string;
    /**
     * 
     * @type {InvitingUser}
     * @memberof Invitation
     */
    'created_by': InvitingUser;
    /**
     * The date and time the invitation was created
     * @type {string}
     * @memberof Invitation
     */
    'created_at': string;
    /**
     * 
     * @type {InvitationWorkspace}
     * @memberof Invitation
     */
    'workspace_invitation'?: InvitationWorkspace;
}
/**
 * The request body for responding to an invitation
 * @export
 * @interface InvitationRespondRequest
 */
export interface InvitationRespondRequest {
    /**
     * The JWT that authorizes the invitee to respond to the invitation
     * @type {string}
     * @memberof InvitationRespondRequest
     */
    'jwt': string;
    /**
     * The response to the invitation
     * @type {string}
     * @memberof InvitationRespondRequest
     */
    'response': InvitationRespondRequestResponseEnum;
}

export const InvitationRespondRequestResponseEnum = {
    Accept: 'accept',
    Reject: 'reject'
} as const;

export type InvitationRespondRequestResponseEnum = typeof InvitationRespondRequestResponseEnum[keyof typeof InvitationRespondRequestResponseEnum];

/**
 * The request body for retrieving an invitation
 * @export
 * @interface InvitationRetrieveRequest
 */
export interface InvitationRetrieveRequest {
    /**
     * The JWT that authorizes the invitee to retrieve the invitation
     * @type {string}
     * @memberof InvitationRetrieveRequest
     */
    'jwt': string;
}
/**
 * The response object when retrieving an invitation
 * @export
 * @interface InvitationRetrieveResponse
 */
export interface InvitationRetrieveResponse {
    /**
     * 
     * @type {Invitation}
     * @memberof InvitationRetrieveResponse
     */
    'data': Invitation;
}
/**
 * 
 * @export
 * @interface InvitationWorkspace
 */
export interface InvitationWorkspace {
    /**
     * The workspace\'s ID
     * @type {string}
     * @memberof InvitationWorkspace
     */
    'workspace_id': string;
    /**
     * The workspace\'s name
     * @type {string}
     * @memberof InvitationWorkspace
     */
    'name': string;
    /**
     * The workspace\'s description
     * @type {string}
     * @memberof InvitationWorkspace
     */
    'description'?: string;
    /**
     * The image\'s ID
     * @type {string}
     * @memberof InvitationWorkspace
     */
    'image_id'?: string;
    /**
     * 
     * @type {WorkspaceRole}
     * @memberof InvitationWorkspace
     */
    'prospective_role': WorkspaceRole;
}


/**
 * The invitations to create
 * @export
 * @interface InvitationsCreateRequestInner
 */
export interface InvitationsCreateRequestInner {
    /**
     * The invited user\'s email address
     * @type {string}
     * @memberof InvitationsCreateRequestInner
     */
    'invitee_email': string;
    /**
     * 
     * @type {InvitationsCreateRequestWorkspace}
     * @memberof InvitationsCreateRequestInner
     */
    'workspace_invitation'?: InvitationsCreateRequestWorkspace;
}
/**
 * 
 * @export
 * @interface InvitationsCreateRequestWorkspace
 */
export interface InvitationsCreateRequestWorkspace {
    /**
     * The workspace\'s ID
     * @type {string}
     * @memberof InvitationsCreateRequestWorkspace
     */
    'workspace_id': string;
    /**
     * 
     * @type {WorkspaceRole}
     * @memberof InvitationsCreateRequestWorkspace
     */
    'prospective_role': WorkspaceRole;
}


/**
 * The response object when requesting all invitations
 * @export
 * @interface InvitationsListResponse
 */
export interface InvitationsListResponse {
    /**
     * An array of invitations for the user
     * @type {Array<Invitation>}
     * @memberof InvitationsListResponse
     */
    'data': Array<Invitation>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof InvitationsListResponse
     */
    'pagination_metadata'?: PaginationMetadata;
}
/**
 * The user who sent the invitation
 * @export
 * @interface InvitingUser
 */
export interface InvitingUser {
    /**
     * The user\'s ID
     * @type {string}
     * @memberof InvitingUser
     */
    'user_id': string;
    /**
     * The user\'s display name
     * @type {string}
     * @memberof InvitingUser
     */
    'display_name': string;
    /**
     * The user\'s email
     * @type {string}
     * @memberof InvitingUser
     */
    'email': string;
    /**
     * The image\'s ID
     * @type {string}
     * @memberof InvitingUser
     */
    'image_id'?: string;
    /**
     * 
     * @type {WorkspaceRole}
     * @memberof InvitingUser
     */
    'workspace_role': WorkspaceRole;
}


/**
 * List of values that Item can take.
 * @export
 * @enum {string}
 */

export const Item = {
    ThemeSelection: 'theme_selection',
    ProfileInfo: 'profile_info',
    ClaimCredits: 'claim_credits',
    CloudStorage: 'cloud_storage',
    RootPath: 'root_path',
    Intro: 'intro',
    BasicTour: 'basic_tour',
    SkipUserOnboarding: 'skip_user_onboarding',
    AddAsset: 'add_asset',
    LaunchNotebook: 'launch_notebook',
    IndicateFinishUserOnboarding: 'indicate_finish_user_onboarding',
    OrganizationBasicTour: 'organization_basic_tour',
    IndicateFinishOrgOnboarding: 'indicate_finish_org_onboarding',
    SkipOrganizationOnboarding: 'skip_organization_onboarding'
} as const;

export type Item = typeof Item[keyof typeof Item];


/**
 * Listing of delta share schema tables
 * @export
 * @interface ListShareSchemaTablesResponse
 */
export interface ListShareSchemaTablesResponse {
    /**
     * The items in the list
     * @type {Array<TableItem>}
     * @memberof ListShareSchemaTablesResponse
     */
    'items': Array<TableItem>;
    /**
     * The next page token
     * @type {string}
     * @memberof ListShareSchemaTablesResponse
     */
    'nextPageToken'?: string;
}
/**
 * Listing of delta shares
 * @export
 * @interface ListShareSchemasResponse
 */
export interface ListShareSchemasResponse {
    /**
     * The items in the list
     * @type {Array<SchemaItem>}
     * @memberof ListShareSchemasResponse
     */
    'items': Array<SchemaItem>;
    /**
     * The next page token
     * @type {string}
     * @memberof ListShareSchemasResponse
     */
    'nextPageToken'?: string;
}
/**
 * Listing of delta shares
 * @export
 * @interface ListSharesResponse
 */
export interface ListSharesResponse {
    /**
     * The items in the list
     * @type {Array<ShareItem>}
     * @memberof ListSharesResponse
     */
    'items': Array<ShareItem>;
    /**
     * The next page token
     * @type {string}
     * @memberof ListSharesResponse
     */
    'nextPageToken'?: string;
}
/**
 * Listing of delta share schema tables
 * @export
 * @interface ListTablesResponse
 */
export interface ListTablesResponse {
    /**
     * The items in the list
     * @type {Array<TableItem>}
     * @memberof ListTablesResponse
     */
    'items': Array<TableItem>;
    /**
     * The next page token
     * @type {string}
     * @memberof ListTablesResponse
     */
    'nextPageToken'?: string;
}
/**
 * Delta share table metadata object
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * Unique identifier for this table
     * @type {string}
     * @memberof Metadata
     */
    'id': string;
    /**
     * User-provided identifier for this table
     * @type {string}
     * @memberof Metadata
     */
    'name'?: string;
    /**
     * User-provided description for this table
     * @type {string}
     * @memberof Metadata
     */
    'description'?: string;
    /**
     * 
     * @type {Format}
     * @memberof Metadata
     */
    'format': Format;
    /**
     * 
     * @type {Schema}
     * @memberof Metadata
     */
    'schema'?: Schema;
    /**
     * Schema of the table. This is a serialized JSON string which can be deserialized to a Schema Object.
     * @type {string}
     * @memberof Metadata
     */
    'schemaString': string;
    /**
     * An array containing the names of columns by which the data should be partitioned. When a table doesn’t have partition columns, this will be an empty array.
     * @type {Array<string>}
     * @memberof Metadata
     */
    'partitionColumns': Array<string>;
    /**
     * A map containing configuration options for the table
     * @type {{ [key: string]: any; }}
     * @memberof Metadata
     */
    'configuration'?: { [key: string]: any; };
    /**
     * The table version the metadata corresponds to, returned when querying table data with a version or timestamp parameter, or cdf query with includeHistoricalMetadata set to true.
     * @type {number}
     * @memberof Metadata
     */
    'version'?: number;
    /**
     * The size of the table in bytes, will be returned if available in the delta log.
     * @type {number}
     * @memberof Metadata
     */
    'size'?: number;
    /**
     * The number of files in the table, will be returned if available in the delta log.
     * @type {number}
     * @memberof Metadata
     */
    'numFiles'?: number;
}
/**
 * Object containing data about a handled error by REST server
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * A hardcoded integer which points to a specific file/line of the code that returned the error
     * @type {number}
     * @memberof ModelError
     */
    'code': number;
    /**
     * A friendly message to be shown to the client
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     * The request id to be used for tracing/debugging
     * @type {string}
     * @memberof ModelError
     */
    'request_id': string;
    /**
     * 
     * @type {ValidationError}
     * @memberof ModelError
     */
    'validation_error'?: ValidationError;
}
/**
 * Delta share table file object
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * An https url that a client can use to read the file directly. The same file in different responses may have different urls.
     * @type {string}
     * @memberof ModelFile
     */
    'url': string;
    /**
     * A unique string for the file in a table. The same file is guaranteed to have the same id across multiple requests. A client may cache the file content and use this id as a key to decide whether to use the cached file content.
     * @type {string}
     * @memberof ModelFile
     */
    'id': string;
    /**
     * A map from partition column to value for this file. See Partition Value Serialization for how to parse the partition values. When the table doesn\'t have partition columns, this will be an empty map.
     * @type {{ [key: string]: any; }}
     * @memberof ModelFile
     */
    'partitionValues': { [key: string]: any; };
    /**
     * The size of this file in bytes.
     * @type {number}
     * @memberof ModelFile
     */
    'size': number;
    /**
     * The timestamp of the file in milliseconds from epoch.
     * @type {number}
     * @memberof ModelFile
     */
    'timestamp'?: number;
    /**
     * The table version of this file.
     * @type {number}
     * @memberof ModelFile
     */
    'version'?: number;
    /**
     * Contains statistics (e.g., count, min/max values for columns) about the data in this file. This field may be missing. A file may or may not have stats. This is a serialized JSON string which can be deserialized to a Statistics Struct. A client can decide whether to use stats or drop it.
     * @type {string}
     * @memberof ModelFile
     */
    'stats'?: string;
    /**
     * The unix timestamp corresponding to the expiration of the url, in milliseconds, returned when the server supports the feature.
     * @type {number}
     * @memberof ModelFile
     */
    'expirationTimestamp'?: number;
}
/**
 * Description of a TileDB file.
 * @export
 * @interface ModelObject
 */
export interface ModelObject {
    /**
     * The path to the file
     * @type {string}
     * @memberof ModelObject
     */
    'Key'?: string;
    /**
     * The date the file was last modified
     * @type {string}
     * @memberof ModelObject
     */
    'LastModified'?: string;
    /**
     * The file\'s ETag
     * @type {string}
     * @memberof ModelObject
     */
    'ETag'?: string;
    /**
     * The file\'s size
     * @type {number}
     * @memberof ModelObject
     */
    'Size'?: number;
}
/**
 * object for get items response
 * @export
 * @interface OnboardingGetItemsResponse
 */
export interface OnboardingGetItemsResponse {
    /**
     * 
     * @type {OnboardingGetItemsResponseData}
     * @memberof OnboardingGetItemsResponse
     */
    'data': OnboardingGetItemsResponseData;
}
/**
 * user\'s onboarding items
 * @export
 * @interface OnboardingGetItemsResponseData
 */
export interface OnboardingGetItemsResponseData {
    /**
     * List of onboarding items
     * @type {Array<Item>}
     * @memberof OnboardingGetItemsResponseData
     */
    'entries': Array<Item>;
}
/**
 * object for get items response
 * @export
 * @interface OnboardingSetItemsRequest
 */
export interface OnboardingSetItemsRequest {
    /**
     * 
     * @type {OnboardingGetItemsResponseData}
     * @memberof OnboardingSetItemsRequest
     */
    'data': OnboardingGetItemsResponseData;
}
/**
 * Pagination metadata object
 * @export
 * @interface PaginationMetadata
 */
export interface PaginationMetadata {
    /**
     * pagination offset. Use it to skip the first ((page - 1) * per_page) items
     * @type {number}
     * @memberof PaginationMetadata
     */
    'page': number;
    /**
     * pagination limit (page size)
     * @type {number}
     * @memberof PaginationMetadata
     */
    'per_page': number;
    /**
     * number of total pages with current limit
     * @type {number}
     * @memberof PaginationMetadata
     */
    'total_pages': number;
    /**
     * number of total available items
     * @type {number}
     * @memberof PaginationMetadata
     */
    'total_items': number;
}
/**
 * Delta sharing protocol object
 * @export
 * @interface Protocol
 */
export interface Protocol {
    /**
     * The minimum version of the protocol that a client must implement in order to correctly read a Delta Lake table. Currently it’s always 1. It will be changed in future when we introduce non-forward-compatible changes that require clients to implement.
     * @type {number}
     * @memberof Protocol
     */
    'minReaderVersion': number;
}
/**
 * A sequence of JSON strings delimited by newline.  The response contains three or more lines:   The first line is a JSON wrapper object containing the table Protocol object.   The second line is a JSON wrapper object containing the table Metadata object.   The rest of the lines are JSON wrapper objects for Data Change Files of the change data feed.     Historical Metadata will be returned if includeHistoricalMetadata is set to true.     The ordering of the lines doesn\'t matter. 
 * @export
 * @interface QueryTableChangeResponse
 */
export interface QueryTableChangeResponse {
    /**
     * The minimum version of the protocol that a client must implement in order to correctly read a Delta Lake table. Currently it’s always 1. It will be changed in future when we introduce non-forward-compatible changes that require clients to implement.
     * @type {number}
     * @memberof QueryTableChangeResponse
     */
    'minReaderVersion': number;
    /**
     * A unique string for the file in a table. The same file is guaranteed to have the same id across multiple requests. A client may cache the file content and use this id as a key to decide whether to use the cached file content.
     * @type {string}
     * @memberof QueryTableChangeResponse
     */
    'id': string;
    /**
     * User-provided identifier for this table
     * @type {string}
     * @memberof QueryTableChangeResponse
     */
    'name'?: string;
    /**
     * User-provided description for this table
     * @type {string}
     * @memberof QueryTableChangeResponse
     */
    'description'?: string;
    /**
     * 
     * @type {Format}
     * @memberof QueryTableChangeResponse
     */
    'format': Format;
    /**
     * 
     * @type {Schema}
     * @memberof QueryTableChangeResponse
     */
    'schema'?: Schema;
    /**
     * Schema of the table. This is a serialized JSON string which can be deserialized to a Schema Object.
     * @type {string}
     * @memberof QueryTableChangeResponse
     */
    'schemaString': string;
    /**
     * An array containing the names of columns by which the data should be partitioned. When a table doesn’t have partition columns, this will be an empty array.
     * @type {Array<string>}
     * @memberof QueryTableChangeResponse
     */
    'partitionColumns': Array<string>;
    /**
     * A map containing configuration options for the table
     * @type {{ [key: string]: any; }}
     * @memberof QueryTableChangeResponse
     */
    'configuration'?: { [key: string]: any; };
    /**
     * The table version of this file.
     * @type {number}
     * @memberof QueryTableChangeResponse
     */
    'version': number;
    /**
     * The size of this file in bytes.
     * @type {number}
     * @memberof QueryTableChangeResponse
     */
    'size': number;
    /**
     * The number of files in the table, will be returned if available in the delta log.
     * @type {number}
     * @memberof QueryTableChangeResponse
     */
    'numFiles'?: number;
    /**
     * An https url that a client can use to read the file directly. The same file in different responses may have different urls.
     * @type {string}
     * @memberof QueryTableChangeResponse
     */
    'url': string;
    /**
     * A map from partition column to value for this file. See Partition Value Serialization for how to parse the partition values. When the table doesn\'t have partition columns, this will be an empty map.
     * @type {{ [key: string]: any; }}
     * @memberof QueryTableChangeResponse
     */
    'partitionValues': { [key: string]: any; };
    /**
     * The timestamp of the file in milliseconds from epoch.
     * @type {number}
     * @memberof QueryTableChangeResponse
     */
    'timestamp': number;
    /**
     * Contains statistics (e.g., count, min/max values for columns) about the data in this file. This field may be missing. A file may or may not have stats. This is a serialized JSON string which can be deserialized to a Statistics Struct. A client can decide whether to use stats or drop it.
     * @type {string}
     * @memberof QueryTableChangeResponse
     */
    'stats'?: string;
    /**
     * The unix timestamp corresponding to the expiration of the url, in milliseconds, returned when the server supports the feature.
     * @type {number}
     * @memberof QueryTableChangeResponse
     */
    'expirationTimestamp'?: number;
}
/**
 * Delta share table query request
 * @export
 * @interface QueryTableRequest
 */
export interface QueryTableRequest {
    /**
     * a list of SQL boolean expressions using a restricted subset of SQL, in a JSON array. When it\'s present, the server will use the provided predicates as a hint to apply the SQL predicates on the returned files.   Filtering files based on the SQL predicates is BEST EFFORT. The server may return files that don\'t satisfy the predicates.   If the server fails to parse one of the SQL predicates, or fails to evaluate it, the server may skip it.   Predicate expressions are conjunctive (AND-ed together). When it\'s absent, the server will return all of files in the table. This will be deprecated once all the client and server implementation move to using jsonPredicateHints below. 
     * @type {string}
     * @memberof QueryTableRequest
     */
    'predicateHints'?: string;
    /**
     * query predicates on partition columns specified using a structured JSON format. When it\'s present, the server will try to use the predicates to filter table\'s files, which could boost query performance.   As with predicateHints, this filtering is BEST EFFORT. The server may return files that don\'t satisfy the predicates.   If the server encounters any errors during predicate processing (for example, invalid syntax or non existing columns), it will skip filtering and return all the files. When it\'s absent, the server will return all the files in the table. 
     * @type {string}
     * @memberof QueryTableRequest
     */
    'jsonPredicateHints'?: string;
    /**
     * an optional limit number. It\'s a hint from the client to tell the server how many rows in the table the client plans to read. The server can use this hint to return only some files by using the file stats. For example, when running SELECT * FROM table LIMIT 1000, the client can set limitHint to 1000.
     * @type {string}
     * @memberof QueryTableRequest
     */
    'limitHint'?: string;
    /**
     * an optional version number. If set, will return files as of the specified version of the table. This is only supported on tables with history sharing enabled.
     * @type {number}
     * @memberof QueryTableRequest
     */
    'version'?: number;
    /**
     * an optional timestamp string in the Timestamp Format,. If set, will return files as of the table version corresponding to the specified timestamp. This is only supported on tables with history sharing enabled.
     * @type {string}
     * @memberof QueryTableRequest
     */
    'timestamp'?: string;
    /**
     * an optional version number. If set, will return all data change files since startingVersion, inclusive, including historical metadata if seen in the delta log.
     * @type {number}
     * @memberof QueryTableRequest
     */
    'startingVersion'?: number;
    /**
     * an optional version number, only used if startingVersion is set. If set, the server can use it as a hint to avoid returning data change files after endingVersion. This is not enforcement. Hence, when sending the endingVersion parameter, the client should still handle the case that it may receive files after endingVersion.
     * @type {number}
     * @memberof QueryTableRequest
     */
    'endingVersion'?: number;
}
/**
 * A sequence of JSON strings delimited by newline.  The response contains three or more lines:   The first line is a JSON wrapper object containing the table Protocol object.   The second line is a JSON wrapper object containing the table Metadata object.   The rest of the lines are JSON wrapper objects for data change files, Metadata, or files, the ordering of the lines doesn\'t matter. 
 * @export
 * @interface QueryTableResponse
 */
export interface QueryTableResponse {
    /**
     * The minimum version of the protocol that a client must implement in order to correctly read a Delta Lake table. Currently it’s always 1. It will be changed in future when we introduce non-forward-compatible changes that require clients to implement.
     * @type {number}
     * @memberof QueryTableResponse
     */
    'minReaderVersion': number;
    /**
     * A unique string for the file in a table. The same file is guaranteed to have the same id across multiple requests. A client may cache the file content and use this id as a key to decide whether to use the cached file content.
     * @type {string}
     * @memberof QueryTableResponse
     */
    'id': string;
    /**
     * User-provided identifier for this table
     * @type {string}
     * @memberof QueryTableResponse
     */
    'name'?: string;
    /**
     * User-provided description for this table
     * @type {string}
     * @memberof QueryTableResponse
     */
    'description'?: string;
    /**
     * 
     * @type {Format}
     * @memberof QueryTableResponse
     */
    'format': Format;
    /**
     * 
     * @type {Schema}
     * @memberof QueryTableResponse
     */
    'schema'?: Schema;
    /**
     * Schema of the table. This is a serialized JSON string which can be deserialized to a Schema Object.
     * @type {string}
     * @memberof QueryTableResponse
     */
    'schemaString': string;
    /**
     * An array containing the names of columns by which the data should be partitioned. When a table doesn’t have partition columns, this will be an empty array.
     * @type {Array<string>}
     * @memberof QueryTableResponse
     */
    'partitionColumns': Array<string>;
    /**
     * A map containing configuration options for the table
     * @type {{ [key: string]: any; }}
     * @memberof QueryTableResponse
     */
    'configuration'?: { [key: string]: any; };
    /**
     * The table version of this file.
     * @type {number}
     * @memberof QueryTableResponse
     */
    'version': number;
    /**
     * The size of this file in bytes.
     * @type {number}
     * @memberof QueryTableResponse
     */
    'size': number;
    /**
     * The number of files in the table, will be returned if available in the delta log.
     * @type {number}
     * @memberof QueryTableResponse
     */
    'numFiles'?: number;
    /**
     * An https url that a client can use to read the file directly. The same file in different responses may have different urls.
     * @type {string}
     * @memberof QueryTableResponse
     */
    'url': string;
    /**
     * A map from partition column to value for this file. See Partition Value Serialization for how to parse the partition values. When the table doesn\'t have partition columns, this will be an empty map.
     * @type {{ [key: string]: any; }}
     * @memberof QueryTableResponse
     */
    'partitionValues': { [key: string]: any; };
    /**
     * The timestamp of the file in milliseconds from epoch.
     * @type {number}
     * @memberof QueryTableResponse
     */
    'timestamp': number;
    /**
     * Contains statistics (e.g., count, min/max values for columns) about the data in this file. This field may be missing. A file may or may not have stats. This is a serialized JSON string which can be deserialized to a Statistics Struct. A client can decide whether to use stats or drop it.
     * @type {string}
     * @memberof QueryTableResponse
     */
    'stats'?: string;
    /**
     * The unix timestamp corresponding to the expiration of the url, in milliseconds, returned when the server supports the feature.
     * @type {number}
     * @memberof QueryTableResponse
     */
    'expirationTimestamp'?: number;
}
/**
 * Object containing the necessary data to request an email address confirmation email.
 * @export
 * @interface RequestEmailConfirmationRequest
 */
export interface RequestEmailConfirmationRequest {
    /**
     * username or email of the user that will receive the email with the required token
     * @type {string}
     * @memberof RequestEmailConfirmationRequest
     */
    'username_or_email': string;
}
/**
 * Object containing the necessary data to request a password reset link.
 * @export
 * @interface RequestPasswordResetRequest
 */
export interface RequestPasswordResetRequest {
    /**
     * username or email of the user that will receive the email with the password reset link
     * @type {string}
     * @memberof RequestPasswordResetRequest
     */
    'username_or_email': string;
}
/**
 * Object containing the necessary data to reset a user\'s password
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
    /**
     * the new password
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'new_password': string;
}
/**
 * Model representing REST capabilities
 * @export
 * @interface RestCapabilities
 */
export interface RestCapabilities {
    /**
     * 
     * @type {TileDBVersion}
     * @memberof RestCapabilities
     */
    'deployedTileDBVersion': TileDBVersion;
    /**
     * 
     * @type {TileDBVersion}
     * @memberof RestCapabilities
     */
    'minimumSupportedTileDBClientVersion': TileDBVersion;
}
/**
 * A struct is used to represent both the top-level schema of the table as well as struct columns that contain nested columns. A struct is encoded as a JSON object with the following fields
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * Always the string struct
     * @type {string}
     * @memberof Schema
     */
    'type': string;
    /**
     * User-provided identifier for this table
     * @type {Array<SchemaField>}
     * @memberof Schema
     */
    'fields': Array<SchemaField>;
}
/**
 * A struct field represents a top-level or nested column.
 * @export
 * @interface SchemaField
 */
export interface SchemaField {
    /**
     * Name of this (possibly nested) column
     * @type {string}
     * @memberof SchemaField
     */
    'name': string;
    /**
     * 
     * @type {SchemaFieldType}
     * @memberof SchemaField
     */
    'type': SchemaFieldType;
    /**
     * A JSON map containing information about this column. For example, the comment key means its value is the column comment.
     * @type {boolean}
     * @memberof SchemaField
     */
    'nullable': boolean;
    /**
     * A JSON map containing information about this column. For example, the comment key means its value is the column comment.
     * @type {{ [key: string]: any; }}
     * @memberof SchemaField
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * An array stores a variable length collection of items of some type.
 * @export
 * @interface SchemaFieldArray
 */
export interface SchemaFieldArray {
    /**
     * Always the string array
     * @type {string}
     * @memberof SchemaFieldArray
     */
    'type': string;
    /**
     * 
     * @type {SchemaFieldArrayElementType}
     * @memberof SchemaFieldArray
     */
    'elementType': SchemaFieldArrayElementType;
    /**
     * Boolean denoting whether this array can contain one or more null values
     * @type {boolean}
     * @memberof SchemaFieldArray
     */
    'containsNull': boolean;
}
/**
 * @type SchemaFieldArrayElementType
 * The type of element stored in this array represented as a string containing the name of a primitive type, a struct definition, an array definition or a map definition
 * @export
 */
export type SchemaFieldArrayElementType = SchemaFieldArray | SchemaFieldDataType | SchemaFieldMap;

/**
 * A enum represents a field type
 * @export
 * @enum {string}
 */

export const SchemaFieldDataType = {
    String: 'string',
    Long: 'long',
    Integer: 'integer',
    Short: 'short',
    Byte: 'byte',
    Float: 'float',
    Double: 'double',
    Boolean: 'boolean',
    Binary: 'binary',
    Date: 'date',
    Timestamp: 'timestamp',
    Decimal: 'decimal',
    Array: 'array',
    Struct: 'struct'
} as const;

export type SchemaFieldDataType = typeof SchemaFieldDataType[keyof typeof SchemaFieldDataType];


/**
 * A map stores an arbitrary length collection of key-value pairs with a single keyType and a single valueType.
 * @export
 * @interface SchemaFieldMap
 */
export interface SchemaFieldMap {
    /**
     * Always the string map
     * @type {string}
     * @memberof SchemaFieldMap
     */
    'type': string;
    /**
     * The type of element used for the key of this map, represented as a string containing the name of a primitive type, a struct definition, an array definition or a map definition
     * @type {string}
     * @memberof SchemaFieldMap
     */
    'keyType': string;
    /**
     * The type of element used for the key of this map, represented as a string containing the name of a primitive type, a struct definition, an array definition or a map definition
     * @type {string}
     * @memberof SchemaFieldMap
     */
    'valueType': string;
    /**
     * Indicates if map values have null values.
     * @type {boolean}
     * @memberof SchemaFieldMap
     */
    'valueContainsNull': boolean;
}
/**
 * @type SchemaFieldType
 * String containing the name of a primitive type, a struct definition, an array definition or a map definition
 * @export
 */
export type SchemaFieldType = SchemaFieldArray | SchemaFieldDataType | SchemaFieldMap;

/**
 * Delta share schema table item
 * @export
 * @interface SchemaItem
 */
export interface SchemaItem {
    /**
     * name of schema
     * @type {string}
     * @memberof SchemaItem
     */
    'name': string;
    /**
     * name of share
     * @type {string}
     * @memberof SchemaItem
     */
    'share': string;
}
/**
 * Delta share item
 * @export
 * @interface ShareItem
 */
export interface ShareItem {
    /**
     * name of share
     * @type {string}
     * @memberof ShareItem
     */
    'name': string;
    /**
     * optional ID of share
     * @type {string}
     * @memberof ShareItem
     */
    'id'?: string;
}
/**
 * Delta share details
 * @export
 * @interface ShareResponse
 */
export interface ShareResponse {
    /**
     * 
     * @type {ShareItem}
     * @memberof ShareResponse
     */
    'share': ShareItem;
}
/**
 * The path at which a given asset will be stored, and the credentials used to access that asset. Storage location contains a pair of storage path  and storage credentials 
 * @export
 * @interface StorageSetting
 */
export interface StorageSetting {
    /**
     * The storage setting\'s ID
     * @type {string}
     * @memberof StorageSetting
     */
    'storage_setting_id': string;
    /**
     * storage location name
     * @type {string}
     * @memberof StorageSetting
     */
    'name': string;
    /**
     * True if this is the workspace\'s or teamspace\'s default storage setting
     * @type {boolean}
     * @memberof StorageSetting
     */
    'is_default': boolean;
    /**
     * The path to store an asset.
     * @type {string}
     * @memberof StorageSetting
     */
    'path': string;
    /**
     * The name of the credentials used to access this storage path
     * @type {string}
     * @memberof StorageSetting
     */
    'credentials_name': string;
    /**
     * True if the storage settings pair is not valid
     * @type {boolean}
     * @memberof StorageSetting
     */
    'invalid': boolean;
    /**
     * The reason why the storage setting pair is not valid
     * @type {string}
     * @memberof StorageSetting
     */
    'reason'?: string;
}
/**
 * object for get storage setting response
 * @export
 * @interface StorageSettingGetResponse
 */
export interface StorageSettingGetResponse {
    /**
     * 
     * @type {StorageSetting}
     * @memberof StorageSettingGetResponse
     */
    'data': StorageSetting;
}
/**
 * The path at which a given asset will be stored, and the credentials used to access that asset. Storage setting contains a pair of storage path  and storage credentials 
 * @export
 * @interface StorageSettingUpdateRequest
 */
export interface StorageSettingUpdateRequest {
    /**
     * storage location name
     * @type {string}
     * @memberof StorageSettingUpdateRequest
     */
    'name'?: string;
    /**
     * True if this is the workspace\'s or teamspace\'s default storage setting
     * @type {boolean}
     * @memberof StorageSettingUpdateRequest
     */
    'is_default'?: boolean;
    /**
     * The path to store an asset.
     * @type {string}
     * @memberof StorageSettingUpdateRequest
     */
    'path'?: string;
    /**
     * The name of the credentials used to access this storage path
     * @type {string}
     * @memberof StorageSettingUpdateRequest
     */
    'credentials_name'?: string;
}
/**
 * The path at which a given asset will be stored, and the credentials used to access that asset. Storage setting contains a pair of storage path  and storage credentials 
 * @export
 * @interface StorageSettingsCreateRequest
 */
export interface StorageSettingsCreateRequest {
    /**
     * storage location name
     * @type {string}
     * @memberof StorageSettingsCreateRequest
     */
    'name': string;
    /**
     * True if this is the workspace\'s or teamspace\'s default storage setting
     * @type {boolean}
     * @memberof StorageSettingsCreateRequest
     */
    'is_default': boolean;
    /**
     * URI containing the VFS path of where assets will be stored. Local file paths must start with `file://`. 
     * @type {string}
     * @memberof StorageSettingsCreateRequest
     */
    'path': string;
    /**
     * The name of the credentials used to access this storage path
     * @type {string}
     * @memberof StorageSettingsCreateRequest
     */
    'credentials_name': string;
}
/**
 * object for create workspace response
 * @export
 * @interface StorageSettingsCreateResponse
 */
export interface StorageSettingsCreateResponse {
    /**
     * 
     * @type {StorageSetting}
     * @memberof StorageSettingsCreateResponse
     */
    'data': StorageSetting;
}
/**
 * The path at which a given asset will be stored, and the credentials used to access that asset. Storage setting contains a pair of storage path  and storage credentials 
 * @export
 * @interface StorageSettingsForTeamspaceCreateRequest
 */
export interface StorageSettingsForTeamspaceCreateRequest {
    /**
     * storage location name
     * @type {string}
     * @memberof StorageSettingsForTeamspaceCreateRequest
     */
    'name': string;
    /**
     * True if this is the workspace\'s or teamspace\'s default storage setting
     * @type {boolean}
     * @memberof StorageSettingsForTeamspaceCreateRequest
     */
    'is_default': boolean;
    /**
     * The path to store an asset.
     * @type {string}
     * @memberof StorageSettingsForTeamspaceCreateRequest
     */
    'path': string;
}
/**
 * object for get storage settings list response
 * @export
 * @interface StorageSettingsListResponse
 */
export interface StorageSettingsListResponse {
    /**
     * List of storage settings items
     * @type {Array<StorageSetting>}
     * @memberof StorageSettingsListResponse
     */
    'data': Array<StorageSetting>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof StorageSettingsListResponse
     */
    'pagination_metadata': PaginationMetadata;
}
/**
 * Delta share schema table item
 * @export
 * @interface TableItem
 */
export interface TableItem {
    /**
     * name of table
     * @type {string}
     * @memberof TableItem
     */
    'name': string;
    /**
     * name of schema
     * @type {string}
     * @memberof TableItem
     */
    'schema': string;
    /**
     * name of share
     * @type {string}
     * @memberof TableItem
     */
    'share': string;
    /**
     * optional ID of share
     * @type {string}
     * @memberof TableItem
     */
    'shareId'?: string;
    /**
     * optional ID of table
     * @type {string}
     * @memberof TableItem
     */
    'id'?: string;
}
/**
 * A sequence of JSON strings delimited by newline.  The response contains two lines:   The first line is a JSON wrapper object containing the table Protocol object.   The second line is a JSON wrapper object containing the table Metadata object. 
 * @export
 * @interface TableMetadataResponse
 */
export interface TableMetadataResponse {
    /**
     * The minimum version of the protocol that a client must implement in order to correctly read a Delta Lake table. Currently it’s always 1. It will be changed in future when we introduce non-forward-compatible changes that require clients to implement.
     * @type {number}
     * @memberof TableMetadataResponse
     */
    'minReaderVersion': number;
    /**
     * Unique identifier for this table
     * @type {string}
     * @memberof TableMetadataResponse
     */
    'id': string;
    /**
     * User-provided identifier for this table
     * @type {string}
     * @memberof TableMetadataResponse
     */
    'name'?: string;
    /**
     * User-provided description for this table
     * @type {string}
     * @memberof TableMetadataResponse
     */
    'description'?: string;
    /**
     * 
     * @type {Format}
     * @memberof TableMetadataResponse
     */
    'format': Format;
    /**
     * 
     * @type {Schema}
     * @memberof TableMetadataResponse
     */
    'schema'?: Schema;
    /**
     * Schema of the table. This is a serialized JSON string which can be deserialized to a Schema Object.
     * @type {string}
     * @memberof TableMetadataResponse
     */
    'schemaString': string;
    /**
     * An array containing the names of columns by which the data should be partitioned. When a table doesn’t have partition columns, this will be an empty array.
     * @type {Array<string>}
     * @memberof TableMetadataResponse
     */
    'partitionColumns': Array<string>;
    /**
     * A map containing configuration options for the table
     * @type {{ [key: string]: any; }}
     * @memberof TableMetadataResponse
     */
    'configuration'?: { [key: string]: any; };
    /**
     * The table version the metadata corresponds to, returned when querying table data with a version or timestamp parameter, or cdf query with includeHistoricalMetadata set to true.
     * @type {number}
     * @memberof TableMetadataResponse
     */
    'version'?: number;
    /**
     * The size of the table in bytes, will be returned if available in the delta log.
     * @type {number}
     * @memberof TableMetadataResponse
     */
    'size'?: number;
    /**
     * The number of files in the table, will be returned if available in the delta log.
     * @type {number}
     * @memberof TableMetadataResponse
     */
    'numFiles'?: number;
}
/**
 * The teamspace object
 * @export
 * @interface Teamspace
 */
export interface Teamspace {
    /**
     * The teamspace\'s ID
     * @type {string}
     * @memberof Teamspace
     */
    'teamspace_id': string;
    /**
     * The teamspace name
     * @type {string}
     * @memberof Teamspace
     */
    'name': string;
    /**
     * 
     * @type {TeamspaceType}
     * @memberof Teamspace
     */
    'space_type': TeamspaceType;
    /**
     * The teamspace icon as a UTF8-encoded Unicode symbol, e.g. 🚀
     * @type {string}
     * @memberof Teamspace
     */
    'icon'?: string;
    /**
     * The datetime the teamspace was created (in UTC)
     * @type {string}
     * @memberof Teamspace
     */
    'created_at': string;
    /**
     * 
     * @type {TeamspaceUser}
     * @memberof Teamspace
     */
    'created_by': TeamspaceUser;
    /**
     * The teamspace description
     * @type {string}
     * @memberof Teamspace
     */
    'description'?: string;
    /**
     * 
     * @type {TeamspaceUser}
     * @memberof Teamspace
     */
    'self'?: TeamspaceUser;
    /**
     * 
     * @type {TeamspaceVisibility}
     * @memberof Teamspace
     */
    'visibility': TeamspaceVisibility;
    /**
     * The datetime the teamspace was updated (in UTC)
     * @type {string}
     * @memberof Teamspace
     */
    'updated_at'?: string;
}


/**
 * default credential object for a teamspace. Gives the option to use an existing credential  from parent workspace or create a new credential on teamspace level 
 * @export
 * @interface TeamspaceDefaultCredential
 */
export interface TeamspaceDefaultCredential {
    /**
     * 
     * @type {CredentialCreateRequest}
     * @memberof TeamspaceDefaultCredential
     */
    'new_credential'?: CredentialCreateRequest;
    /**
     * Existing workspace credential name
     * @type {string}
     * @memberof TeamspaceDefaultCredential
     */
    'existing_credential_name'?: string;
}
/**
 * The response object when requesting a single teamspace
 * @export
 * @interface TeamspaceGetResponse
 */
export interface TeamspaceGetResponse {
    /**
     * 
     * @type {Teamspace}
     * @memberof TeamspaceGetResponse
     */
    'data': Teamspace;
}
/**
 * A lightweight version of the Teamspace object, containing only essential fields. 
 * @export
 * @interface TeamspaceLight
 */
export interface TeamspaceLight {
    /**
     * The teamspace\'s ID
     * @type {string}
     * @memberof TeamspaceLight
     */
    'teamspace_id': string;
    /**
     * The teamspace name
     * @type {string}
     * @memberof TeamspaceLight
     */
    'name': string;
    /**
     * 
     * @type {TeamspaceType}
     * @memberof TeamspaceLight
     */
    'space_type': TeamspaceType;
    /**
     * The teamspace icon as a UTF8-encoded Unicode symbol, e.g. 🚀
     * @type {string}
     * @memberof TeamspaceLight
     */
    'icon'?: string;
}


/**
 * The enumeration of roles a user can have within a teamspace
 * @export
 * @enum {string}
 */

export const TeamspaceRole = {
    Owner: 'owner',
    Editor: 'editor',
    Viewer: 'viewer'
} as const;

export type TeamspaceRole = typeof TeamspaceRole[keyof typeof TeamspaceRole];


/**
 * The enumeration of space types of a teamspace
 * @export
 * @enum {string}
 */

export const TeamspaceType = {
    Teamspace: 'teamspace',
    Userspace: 'userspace',
    Generalspace: 'generalspace'
} as const;

export type TeamspaceType = typeof TeamspaceType[keyof typeof TeamspaceType];


/**
 * The request object for updating a teamspace
 * @export
 * @interface TeamspaceUpdateRequest
 */
export interface TeamspaceUpdateRequest {
    /**
     * The teamspace name
     * @type {string}
     * @memberof TeamspaceUpdateRequest
     */
    'name'?: string;
    /**
     * The teamspace description
     * @type {string}
     * @memberof TeamspaceUpdateRequest
     */
    'description'?: string;
    /**
     * The teamspace icon as a UTF8-encoded Unicode symbol, e.g. 🚀
     * @type {string}
     * @memberof TeamspaceUpdateRequest
     */
    'icon'?: string;
    /**
     * 
     * @type {TeamspaceVisibility}
     * @memberof TeamspaceUpdateRequest
     */
    'visibility_level'?: TeamspaceVisibility;
}


/**
 * The teamspace user object
 * @export
 * @interface TeamspaceUser
 */
export interface TeamspaceUser {
    /**
     * The user\'s ID
     * @type {string}
     * @memberof TeamspaceUser
     */
    'user_id': string;
    /**
     * The user\'s username
     * @type {string}
     * @memberof TeamspaceUser
     */
    'username': string;
    /**
     * The user\'s display name
     * @type {string}
     * @memberof TeamspaceUser
     */
    'display_name': string;
    /**
     * The user\'s email
     * @type {string}
     * @memberof TeamspaceUser
     */
    'email': string;
    /**
     * The image\'s ID
     * @type {string}
     * @memberof TeamspaceUser
     */
    'image_id'?: string;
    /**
     * 
     * @type {TeamspaceRole}
     * @memberof TeamspaceUser
     */
    'role': TeamspaceRole;
    /**
     * The user\'s ID
     * @type {string}
     * @memberof TeamspaceUser
     */
    'added_by': string;
    /**
     * The datetime the teamspace user was created (in UTC)
     * @type {string}
     * @memberof TeamspaceUser
     */
    'created_at': string;
    /**
     * The datetime the teamspace user was deleted (in UTC)
     * @type {string}
     * @memberof TeamspaceUser
     */
    'deleted_at'?: string;
}


/**
 * The response object when requesting a single teamspace user
 * @export
 * @interface TeamspaceUserGetResponse
 */
export interface TeamspaceUserGetResponse {
    /**
     * 
     * @type {TeamspaceUser}
     * @memberof TeamspaceUserGetResponse
     */
    'data': TeamspaceUser;
}
/**
 * The request object for updating a single teamspace user
 * @export
 * @interface TeamspaceUserUpdateRequest
 */
export interface TeamspaceUserUpdateRequest {
    /**
     * 
     * @type {TeamspaceRole}
     * @memberof TeamspaceUserUpdateRequest
     */
    'role': TeamspaceRole;
}


/**
 * The teamspace user update object
 * @export
 * @interface TeamspaceUsersBulkUpdateRequestInner
 */
export interface TeamspaceUsersBulkUpdateRequestInner {
    /**
     * The user\'s ID
     * @type {string}
     * @memberof TeamspaceUsersBulkUpdateRequestInner
     */
    'user_id': string;
    /**
     * 
     * @type {TeamspaceRole}
     * @memberof TeamspaceUsersBulkUpdateRequestInner
     */
    'role': TeamspaceRole;
}


/**
 * The teamspace user that should be created
 * @export
 * @interface TeamspaceUsersCreateRequestInner
 */
export interface TeamspaceUsersCreateRequestInner {
    /**
     * The user\'s ID
     * @type {string}
     * @memberof TeamspaceUsersCreateRequestInner
     */
    'user_id': string;
    /**
     * 
     * @type {TeamspaceRole}
     * @memberof TeamspaceUsersCreateRequestInner
     */
    'role': TeamspaceRole;
}


/**
 * The response object when creating multiple teamspace users
 * @export
 * @interface TeamspaceUsersCreateResponse
 */
export interface TeamspaceUsersCreateResponse {
    /**
     * An array of teamspace users that were created
     * @type {Array<TeamspaceUser>}
     * @memberof TeamspaceUsersCreateResponse
     */
    'data': Array<TeamspaceUser>;
}
/**
 * The response object when joining a teamspace
 * @export
 * @interface TeamspaceUsersJoinResponse
 */
export interface TeamspaceUsersJoinResponse {
    /**
     * 
     * @type {TeamspaceUser}
     * @memberof TeamspaceUsersJoinResponse
     */
    'data': TeamspaceUser;
}
/**
 * The response object when requesting multiple teamspace users
 * @export
 * @interface TeamspaceUsersListResponse
 */
export interface TeamspaceUsersListResponse {
    /**
     * An array of teamspace users
     * @type {Array<TeamspaceUser>}
     * @memberof TeamspaceUsersListResponse
     */
    'data': Array<TeamspaceUser>;
}
/**
 * The enumeration of visibility levels for a teamspace
 * @export
 * @enum {string}
 */

export const TeamspaceVisibility = {
    Private: 'private',
    Public: 'public'
} as const;

export type TeamspaceVisibility = typeof TeamspaceVisibility[keyof typeof TeamspaceVisibility];


/**
 * The request object for creating a teamspace
 * @export
 * @interface TeamspacesCreateRequest
 */
export interface TeamspacesCreateRequest {
    /**
     * The teamspace name
     * @type {string}
     * @memberof TeamspacesCreateRequest
     */
    'name': string;
    /**
     * The teamspace description
     * @type {string}
     * @memberof TeamspacesCreateRequest
     */
    'description'?: string;
    /**
     * The teamspace icon as a UTF8-encoded Unicode symbol, e.g. 🚀
     * @type {string}
     * @memberof TeamspacesCreateRequest
     */
    'icon'?: string;
    /**
     * 
     * @type {TeamspaceVisibility}
     * @memberof TeamspacesCreateRequest
     */
    'visibility': TeamspaceVisibility;
    /**
     * 
     * @type {TeamspaceDefaultCredential}
     * @memberof TeamspacesCreateRequest
     */
    'default_credential'?: TeamspaceDefaultCredential;
    /**
     * 
     * @type {StorageSettingsForTeamspaceCreateRequest}
     * @memberof TeamspacesCreateRequest
     */
    'default_storage_setting'?: StorageSettingsForTeamspaceCreateRequest;
}


/**
 * The response object when creating one or more teamspaces
 * @export
 * @interface TeamspacesCreateResponse
 */
export interface TeamspacesCreateResponse {
    /**
     * 
     * @type {Teamspace}
     * @memberof TeamspacesCreateResponse
     */
    'data': Teamspace;
}
/**
 * The response object when requesting multiple teamspaces
 * @export
 * @interface TeamspacesListResponse
 */
export interface TeamspacesListResponse {
    /**
     * An array of teamspaces
     * @type {Array<Teamspace>}
     * @memberof TeamspacesListResponse
     */
    'data': Array<Teamspace>;
}
/**
 * Model representing TileDB version
 * @export
 * @interface TileDBVersion
 */
export interface TileDBVersion {
    /**
     * TileDB core major version
     * @type {number}
     * @memberof TileDBVersion
     */
    'major': number;
    /**
     * TileDB core minor version
     * @type {number}
     * @memberof TileDBVersion
     */
    'minor': number;
    /**
     * TileDB core patch version
     * @type {number}
     * @memberof TileDBVersion
     */
    'patch': number;
}
/**
 * The token information itself. Exactly one sub-field may be set. The names match those in the CloudProvider enum
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {AzureToken}
     * @memberof Token
     */
    'azure'?: AzureToken;
    /**
     * 
     * @type {GCPServiceAccountKey}
     * @memberof Token
     */
    'gcp'?: GCPServiceAccountKey;
}
/**
 * The request object for creating a token
 * @export
 * @interface TokenCreateRequest
 */
export interface TokenCreateRequest {
    /**
     * A human-readable name for the token. The name must be provided if the token is an API token (i.e. if `workspace_id` is provided). 
     * @type {string}
     * @memberof TokenCreateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {TokenScope}
     * @memberof TokenCreateRequest
     */
    'scope': TokenScope;
    /**
     * The workspace ID or Name that the token will be scoped for. This must be provided if the token is meant to be an API token (instead of a session token). 
     * @type {string}
     * @memberof TokenCreateRequest
     */
    'workspace_id'?: string;
    /**
     * The expiration date and time of the token. If no expiration date is provided, the server will set the default expiration date. 
     * @type {string}
     * @memberof TokenCreateRequest
     */
    'expires_at'?: string;
}


/**
 * The response object when creating a token
 * @export
 * @interface TokenCreateResponse
 */
export interface TokenCreateResponse {
    /**
     * 
     * @type {APIToken}
     * @memberof TokenCreateResponse
     */
    'data': APIToken;
}
/**
 * The response object when requesting all tokens
 * @export
 * @interface TokenListResponse
 */
export interface TokenListResponse {
    /**
     * An array of tokens
     * @type {Array<APIToken>}
     * @memberof TokenListResponse
     */
    'data': Array<APIToken>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof TokenListResponse
     */
    'pagination_metadata'?: PaginationMetadata;
}
/**
 * The scopes a token can have
 * @export
 * @enum {string}
 */

export const TokenScope = {
    Star: '*',
    PasswordReset: 'password_reset',
    ConfirmEmail: 'confirm_email',
    Userread: 'user:read',
    UserreadWrite: 'user:read-write',
    Useradmin: 'user:admin',
    Arrayread: 'array:read',
    ArrayreadWrite: 'array:read-write',
    Arrayadmin: 'array:admin',
    Organizationread: 'organization:read',
    OrganizationreadWrite: 'organization:read-write',
    Organizationadmin: 'organization:admin',
    Groupread: 'group:read',
    GroupreadWrite: 'group:read-write',
    Groupadmin: 'group:admin'
} as const;

export type TokenScope = typeof TokenScope[keyof typeof TokenScope];


/**
 * object for a registered user
 * @export
 * @interface User
 */
export interface User {
    /**
     * The user\'s ID
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * display name of the user
     * @type {string}
     * @memberof User
     */
    'display_name': string;
    /**
     * The image\'s ID
     * @type {string}
     * @memberof User
     */
    'image_id'?: string;
    /**
     * user email
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * if a user has validated their email
     * @type {boolean}
     * @memberof User
     */
    'is_valid_email'?: boolean;
    /**
     * 
     * @type {UserRole}
     * @memberof User
     */
    'role': UserRole;
    /**
     * user email
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * user timezone
     * @type {string}
     * @memberof User
     */
    'timezone': string;
    /**
     * Datetime the user was created in UTC
     * @type {string}
     * @memberof User
     */
    'created_at': string;
    /**
     * Datetime the user was updated in UTC
     * @type {string}
     * @memberof User
     */
    'updated_at'?: string;
    /**
     * Datetime the user was deleted in UTC
     * @type {string}
     * @memberof User
     */
    'deleted_at'?: string;
}


/**
 * The academy questionnaire user\'s answer
 * @export
 * @interface UserAnswer
 */
export interface UserAnswer {
    /**
     * ID of the question in the questionnaire
     * @type {string}
     * @memberof UserAnswer
     */
    'question_id': string;
    /**
     * ID of the answer in the questionnaire
     * @type {string}
     * @memberof UserAnswer
     */
    'answer_id': string;
}
/**
 * object metadata for a user that will be created
 * @export
 * @interface UserCreateRequest
 */
export interface UserCreateRequest {
    /**
     * display name of the user shown everywhere
     * @type {string}
     * @memberof UserCreateRequest
     */
    'display_name'?: string;
    /**
     * user email
     * @type {string}
     * @memberof UserCreateRequest
     */
    'email': string;
    /**
     * username that can be logged in with
     * @type {string}
     * @memberof UserCreateRequest
     */
    'username': string;
    /**
     * password for the user
     * @type {string}
     * @memberof UserCreateRequest
     */
    'password': string;
    /**
     * user timezone
     * @type {string}
     * @memberof UserCreateRequest
     */
    'timezone'?: string;
    /**
     * Image data in the form data:image/png;base64,iVBORw0KGgoAAAA
     * @type {string}
     * @memberof UserCreateRequest
     */
    'image'?: string;
}
/**
 * object for create user response
 * @export
 * @interface UserCreateResponse
 */
export interface UserCreateResponse {
    /**
     * 
     * @type {User}
     * @memberof UserCreateResponse
     */
    'data': User;
}
/**
 * object for get user response
 * @export
 * @interface UserGetResponse
 */
export interface UserGetResponse {
    /**
     * 
     * @type {User}
     * @memberof UserGetResponse
     */
    'data': User;
}
/**
 * Enumeration of possible roles a user can have within a deployment
 * @export
 * @enum {string}
 */

export const UserRole = {
    Owner: 'owner',
    Admin: 'admin',
    Member: 'member'
} as const;

export type UserRole = typeof UserRole[keyof typeof UserRole];


/**
 * object for get self user response
 * @export
 * @interface UserSelfResponse
 */
export interface UserSelfResponse {
    /**
     * 
     * @type {UserSelfResponseData}
     * @memberof UserSelfResponse
     */
    'data': UserSelfResponseData;
}
/**
 * 
 * @export
 * @interface UserSelfResponseData
 */
export interface UserSelfResponseData {
    /**
     * 
     * @type {User}
     * @memberof UserSelfResponseData
     */
    'user': User;
    /**
     * 
     * @type {Array<UserSelfWorkspace>}
     * @memberof UserSelfResponseData
     */
    'workspaces': Array<UserSelfWorkspace>;
}
/**
 * list of workspaces a user is a part of
 * @export
 * @interface UserSelfWorkspace
 */
export interface UserSelfWorkspace {
    /**
     * The workspace\'s ID
     * @type {string}
     * @memberof UserSelfWorkspace
     */
    'workspace_id': string;
    /**
     * workspace name
     * @type {string}
     * @memberof UserSelfWorkspace
     */
    'name': string;
    /**
     * 
     * @type {WorkspaceUser}
     * @memberof UserSelfWorkspace
     */
    'created_by': WorkspaceUser;
    /**
     * 
     * @type {WorkspaceUser}
     * @memberof UserSelfWorkspace
     */
    'self': WorkspaceUser;
    /**
     * Workspace description
     * @type {string}
     * @memberof UserSelfWorkspace
     */
    'description'?: string;
    /**
     * Datetime workspace was created in UTC
     * @type {string}
     * @memberof UserSelfWorkspace
     */
    'created_at': string;
    /**
     * Datetime workspace was updated in UTC
     * @type {string}
     * @memberof UserSelfWorkspace
     */
    'updated_at'?: string;
    /**
     * The image\'s ID
     * @type {string}
     * @memberof UserSelfWorkspace
     */
    'image_id'?: string;
}
/**
 * object metadata for updates made to a user
 * @export
 * @interface UserUpdateRequest
 */
export interface UserUpdateRequest {
    /**
     * display name of the user shown everywhere
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'display_name'?: string;
    /**
     * user email
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'email'?: string;
    /**
     * user timezone
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'timezone'?: string;
    /**
     * Image data in the form data:image/png;base64,iVBORw0KGgoAAAA
     * @type {string}
     * @memberof UserUpdateRequest
     */
    'image'?: string;
}
/**
 * The userspace object
 * @export
 * @interface Userspace
 */
export interface Userspace {
    /**
     * The userspace\'s ID
     * @type {string}
     * @memberof Userspace
     */
    'userspace_id': string;
    /**
     * The userspace name
     * @type {string}
     * @memberof Userspace
     */
    'name': string;
    /**
     * The userspace icon as a UTF8-encoded Unicode symbol, e.g. 🚀
     * @type {string}
     * @memberof Userspace
     */
    'icon'?: string;
    /**
     * The datetime the userspace was created (in UTC)
     * @type {string}
     * @memberof Userspace
     */
    'created_at': string;
    /**
     * The userspace description
     * @type {string}
     * @memberof Userspace
     */
    'description'?: string;
    /**
     * The datetime the userspace was updated (in UTC)
     * @type {string}
     * @memberof Userspace
     */
    'updated_at'?: string;
}
/**
 * The response object when requesting a userspace
 * @export
 * @interface UserspaceGetResponse
 */
export interface UserspaceGetResponse {
    /**
     * 
     * @type {Userspace}
     * @memberof UserspaceGetResponse
     */
    'data': Userspace;
}
/**
 * The request object for updating a userspace
 * @export
 * @interface UserspaceUpdateRequest
 */
export interface UserspaceUpdateRequest {
    /**
     * The userspace name
     * @type {string}
     * @memberof UserspaceUpdateRequest
     */
    'name'?: string;
    /**
     * The userspace description
     * @type {string}
     * @memberof UserspaceUpdateRequest
     */
    'description'?: string;
    /**
     * The userspace icon as a UTF8-encoded Unicode symbol, e.g. 🚀
     * @type {string}
     * @memberof UserspaceUpdateRequest
     */
    'icon'?: string;
}
/**
 * Object containing data about a handled error by REST server
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * The list of fields that failed validation
     * @type {Array<ValidationErrorField>}
     * @memberof ValidationError
     */
    'fields': Array<ValidationErrorField>;
}
/**
 * Object containing data about a handled error by REST server
 * @export
 * @interface ValidationErrorField
 */
export interface ValidationErrorField {
    /**
     * The name of the field that failed validation
     * @type {string}
     * @memberof ValidationErrorField
     */
    'field': string;
    /**
     * A friendly message about the validation error
     * @type {string}
     * @memberof ValidationErrorField
     */
    'message': string;
}
/**
 * Various version numbers for the server
 * @export
 * @interface Versions
 */
export interface Versions {
    /**
     * The version of Go used to build the server
     * @type {string}
     * @memberof Versions
     */
    'go_version': string;
    /**
     * The version of TileDB used by the server
     * @type {string}
     * @memberof Versions
     */
    'tiledb_version': string;
    /**
     * The UDF images that the server supports
     * @type {Array<string>}
     * @memberof Versions
     */
    'udf_images_version': Array<string>;
    /**
     * The name of the version control system (vcs) used to develop the server 
     * @type {string}
     * @memberof Versions
     */
    'vcs_name'?: string;
    /**
     * The vcs revision of the server
     * @type {string}
     * @memberof Versions
     */
    'vcs_revision'?: string;
    /**
     * The modification time associated with the vcs revision
     * @type {string}
     * @memberof Versions
     */
    'vcs_time'?: string;
    /**
     * The build ID of the server. If set, this will be either the branch name or the git tag. 
     * @type {string}
     * @memberof Versions
     */
    'build_id'?: string;
}
/**
 * Object for versions response
 * @export
 * @interface VersionsResponse
 */
export interface VersionsResponse {
    /**
     * 
     * @type {Versions}
     * @memberof VersionsResponse
     */
    'data': Versions;
}
/**
 * The response object of the GetWorkspace endpoint
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * The workspace\'s ID
     * @type {string}
     * @memberof Workspace
     */
    'workspace_id': string;
    /**
     * The image\'s ID
     * @type {string}
     * @memberof Workspace
     */
    'image_id'?: string;
    /**
     * workspace name
     * @type {string}
     * @memberof Workspace
     */
    'name': string;
    /**
     * 
     * @type {WorkspaceUser}
     * @memberof Workspace
     */
    'created_by': WorkspaceUser;
    /**
     * Workspace description
     * @type {string}
     * @memberof Workspace
     */
    'description'?: string;
    /**
     * 
     * @type {WorkspaceUser}
     * @memberof Workspace
     */
    'self': WorkspaceUser;
    /**
     * Datetime workspace was created in UTC
     * @type {string}
     * @memberof Workspace
     */
    'created_at': string;
    /**
     * Datetime workspace was updated in UTC
     * @type {string}
     * @memberof Workspace
     */
    'updated_at'?: string;
}
/**
 * object metadata for a workspace that will be created
 * @export
 * @interface WorkspaceCreateRequest
 */
export interface WorkspaceCreateRequest {
    /**
     * workspace name
     * @type {string}
     * @memberof WorkspaceCreateRequest
     */
    'name': string;
    /**
     * Workspace description
     * @type {string}
     * @memberof WorkspaceCreateRequest
     */
    'description'?: string;
    /**
     * Image data in the form data:image/png;base64,iVBORw0KGgoAAAA
     * @type {string}
     * @memberof WorkspaceCreateRequest
     */
    'image'?: string;
    /**
     * 
     * @type {CredentialCreateRequest}
     * @memberof WorkspaceCreateRequest
     */
    'default_credential': CredentialCreateRequest;
    /**
     * 
     * @type {StorageSettingsCreateRequest}
     * @memberof WorkspaceCreateRequest
     */
    'default_storage_setting': StorageSettingsCreateRequest;
}
/**
 * object for create workspace response
 * @export
 * @interface WorkspaceCreateResponse
 */
export interface WorkspaceCreateResponse {
    /**
     * 
     * @type {Workspace}
     * @memberof WorkspaceCreateResponse
     */
    'data': Workspace;
}
/**
 * object for get workspace response
 * @export
 * @interface WorkspaceGetResponse
 */
export interface WorkspaceGetResponse {
    /**
     * 
     * @type {Workspace}
     * @memberof WorkspaceGetResponse
     */
    'data': Workspace;
}
/**
 * A lightweight version of the Workspace object, containing only essential fields. 
 * @export
 * @interface WorkspaceLight
 */
export interface WorkspaceLight {
    /**
     * The workspace\'s ID
     * @type {string}
     * @memberof WorkspaceLight
     */
    'workspace_id': string;
    /**
     * The image\'s ID
     * @type {string}
     * @memberof WorkspaceLight
     */
    'image_id'?: string;
    /**
     * workspace name
     * @type {string}
     * @memberof WorkspaceLight
     */
    'name': string;
}
/**
 * The enumeration of roles a user can have within a workspace
 * @export
 * @enum {string}
 */

export const WorkspaceRole = {
    Owner: 'owner',
    Admin: 'admin',
    Member: 'member'
} as const;

export type WorkspaceRole = typeof WorkspaceRole[keyof typeof WorkspaceRole];


/**
 * The workspace update object of the UpdateWorkspace endpoint
 * @export
 * @interface WorkspaceUpdateRequest
 */
export interface WorkspaceUpdateRequest {
    /**
     * workspace name
     * @type {string}
     * @memberof WorkspaceUpdateRequest
     */
    'name'?: string;
    /**
     * Image data in the form data:image/png;base64,iVBORw0KGgoAAAA
     * @type {string}
     * @memberof WorkspaceUpdateRequest
     */
    'image'?: string;
    /**
     * Workspace description
     * @type {string}
     * @memberof WorkspaceUpdateRequest
     */
    'description'?: string;
}
/**
 * The workspace user object
 * @export
 * @interface WorkspaceUser
 */
export interface WorkspaceUser {
    /**
     * The user\'s ID
     * @type {string}
     * @memberof WorkspaceUser
     */
    'user_id': string;
    /**
     * The user\'s username
     * @type {string}
     * @memberof WorkspaceUser
     */
    'username': string;
    /**
     * The user\'s display name
     * @type {string}
     * @memberof WorkspaceUser
     */
    'display_name': string;
    /**
     * The user\'s email
     * @type {string}
     * @memberof WorkspaceUser
     */
    'email': string;
    /**
     * The image\'s ID
     * @type {string}
     * @memberof WorkspaceUser
     */
    'image_id'?: string;
    /**
     * 
     * @type {WorkspaceRole}
     * @memberof WorkspaceUser
     */
    'role': WorkspaceRole;
    /**
     * The user\'s ID
     * @type {string}
     * @memberof WorkspaceUser
     */
    'added_by': string;
    /**
     * Datetime workspace user was created in UTC
     * @type {string}
     * @memberof WorkspaceUser
     */
    'created_at': string;
    /**
     * Datetime workspace user was deleted in UTC
     * @type {string}
     * @memberof WorkspaceUser
     */
    'deleted_at'?: string;
}


/**
 * The response object when requesting a single workspace user
 * @export
 * @interface WorkspaceUserGetResponse
 */
export interface WorkspaceUserGetResponse {
    /**
     * 
     * @type {WorkspaceUser}
     * @memberof WorkspaceUserGetResponse
     */
    'data': WorkspaceUser;
}
/**
 * The request object for updating a single workspace users
 * @export
 * @interface WorkspaceUserUpdateRequest
 */
export interface WorkspaceUserUpdateRequest {
    /**
     * 
     * @type {WorkspaceRole}
     * @memberof WorkspaceUserUpdateRequest
     */
    'role': WorkspaceRole;
}


/**
 * The workspace user update object
 * @export
 * @interface WorkspaceUsersBulkUpdateRequestInner
 */
export interface WorkspaceUsersBulkUpdateRequestInner {
    /**
     * The user\'s ID
     * @type {string}
     * @memberof WorkspaceUsersBulkUpdateRequestInner
     */
    'user_id': string;
    /**
     * 
     * @type {WorkspaceRole}
     * @memberof WorkspaceUsersBulkUpdateRequestInner
     */
    'role': WorkspaceRole;
}


/**
 * The workspace user that should be created
 * @export
 * @interface WorkspaceUsersCreateRequestInner
 */
export interface WorkspaceUsersCreateRequestInner {
    /**
     * The user\'s ID
     * @type {string}
     * @memberof WorkspaceUsersCreateRequestInner
     */
    'user_id': string;
    /**
     * 
     * @type {WorkspaceRole}
     * @memberof WorkspaceUsersCreateRequestInner
     */
    'role': WorkspaceRole;
}


/**
 * The response object when creating multiple workspace users
 * @export
 * @interface WorkspaceUsersCreateResponse
 */
export interface WorkspaceUsersCreateResponse {
    /**
     * An array of workspace users that were created
     * @type {Array<WorkspaceUser>}
     * @memberof WorkspaceUsersCreateResponse
     */
    'data': Array<WorkspaceUser>;
}
/**
 * The response object when requesting multiple workspace users
 * @export
 * @interface WorkspaceUsersListResponse
 */
export interface WorkspaceUsersListResponse {
    /**
     * An array of workspace users
     * @type {Array<WorkspaceUser>}
     * @memberof WorkspaceUsersListResponse
     */
    'data': Array<WorkspaceUser>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof WorkspaceUsersListResponse
     */
    'pagination_metadata'?: PaginationMetadata;
}


/**
 * AcademyApi - axios parameter creator
 * @export
 */
export const AcademyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of user lessons with details about each of them
         * @summary Get information about user lessons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcademyLessons: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/academy/lessons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get academy questionnaire information for user. For example, questionnaire version, completion status and user answers
         * @summary Get academy questionnaire information for user
         * @param {string} questionnaireId questionnaire\&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcademyQuestionnaire: async (questionnaireId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionnaireId' is not null or undefined
            assertParamExists('getAcademyQuestionnaire', 'questionnaireId', questionnaireId)
            const localVarPath = `/academy/questionnaires/{questionnaire_id}`
                .replace(`{${"questionnaire_id"}}`, encodeURIComponent(String(questionnaireId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create one or more user lessons
         * @summary Academy lessons to create
         * @param {Array<AcademyLesson>} academyLesson Academy lesson to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAcademyLessons: async (academyLesson: Array<AcademyLesson>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'academyLesson' is not null or undefined
            assertParamExists('putAcademyLessons', 'academyLesson', academyLesson)
            const localVarPath = `/academy/lessons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(academyLesson, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new questionnaire or update an existing one
         * @summary Create or update academy questionnaire
         * @param {string} questionnaireId questionnaire\&#39;s id
         * @param {AcademyQuestionnairePutRequest} academyQuestionnairePutRequest academy lesson to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAcademyQuestionnaire: async (questionnaireId: string, academyQuestionnairePutRequest: AcademyQuestionnairePutRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionnaireId' is not null or undefined
            assertParamExists('putAcademyQuestionnaire', 'questionnaireId', questionnaireId)
            // verify required parameter 'academyQuestionnairePutRequest' is not null or undefined
            assertParamExists('putAcademyQuestionnaire', 'academyQuestionnairePutRequest', academyQuestionnairePutRequest)
            const localVarPath = `/academy/questionnaires/{questionnaire_id}`
                .replace(`{${"questionnaire_id"}}`, encodeURIComponent(String(questionnaireId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(academyQuestionnairePutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AcademyApi - functional programming interface
 * @export
 */
export const AcademyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AcademyApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of user lessons with details about each of them
         * @summary Get information about user lessons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAcademyLessons(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcademyLessonsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAcademyLessons(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get academy questionnaire information for user. For example, questionnaire version, completion status and user answers
         * @summary Get academy questionnaire information for user
         * @param {string} questionnaireId questionnaire\&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAcademyQuestionnaire(questionnaireId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcademyQuestionnaireListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAcademyQuestionnaire(questionnaireId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create one or more user lessons
         * @summary Academy lessons to create
         * @param {Array<AcademyLesson>} academyLesson Academy lesson to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAcademyLessons(academyLesson: Array<AcademyLesson>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAcademyLessons(academyLesson, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new questionnaire or update an existing one
         * @summary Create or update academy questionnaire
         * @param {string} questionnaireId questionnaire\&#39;s id
         * @param {AcademyQuestionnairePutRequest} academyQuestionnairePutRequest academy lesson to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAcademyQuestionnaire(questionnaireId: string, academyQuestionnairePutRequest: AcademyQuestionnairePutRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAcademyQuestionnaire(questionnaireId, academyQuestionnairePutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AcademyApi - factory interface
 * @export
 */
export const AcademyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AcademyApiFp(configuration)
    return {
        /**
         * Get a list of user lessons with details about each of them
         * @summary Get information about user lessons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcademyLessons(options?: any): AxiosPromise<AcademyLessonsListResponse> {
            return localVarFp.getAcademyLessons(options).then((request) => request(axios, basePath));
        },
        /**
         * Get academy questionnaire information for user. For example, questionnaire version, completion status and user answers
         * @summary Get academy questionnaire information for user
         * @param {string} questionnaireId questionnaire\&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcademyQuestionnaire(questionnaireId: string, options?: any): AxiosPromise<AcademyQuestionnaireListResponse> {
            return localVarFp.getAcademyQuestionnaire(questionnaireId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create one or more user lessons
         * @summary Academy lessons to create
         * @param {Array<AcademyLesson>} academyLesson Academy lesson to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAcademyLessons(academyLesson: Array<AcademyLesson>, options?: any): AxiosPromise<void> {
            return localVarFp.putAcademyLessons(academyLesson, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new questionnaire or update an existing one
         * @summary Create or update academy questionnaire
         * @param {string} questionnaireId questionnaire\&#39;s id
         * @param {AcademyQuestionnairePutRequest} academyQuestionnairePutRequest academy lesson to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAcademyQuestionnaire(questionnaireId: string, academyQuestionnairePutRequest: AcademyQuestionnairePutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.putAcademyQuestionnaire(questionnaireId, academyQuestionnairePutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AcademyApi - object-oriented interface
 * @export
 * @class AcademyApi
 * @extends {BaseAPI}
 */
export class AcademyApi extends BaseAPI {
    /**
     * Get a list of user lessons with details about each of them
     * @summary Get information about user lessons
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcademyApi
     */
    public getAcademyLessons(options?: any) {
        return AcademyApiFp(this.configuration).getAcademyLessons(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get academy questionnaire information for user. For example, questionnaire version, completion status and user answers
     * @summary Get academy questionnaire information for user
     * @param {string} questionnaireId questionnaire\&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcademyApi
     */
    public getAcademyQuestionnaire(questionnaireId: string, options?: any) {
        return AcademyApiFp(this.configuration).getAcademyQuestionnaire(questionnaireId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create one or more user lessons
     * @summary Academy lessons to create
     * @param {Array<AcademyLesson>} academyLesson Academy lesson to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcademyApi
     */
    public putAcademyLessons(academyLesson: Array<AcademyLesson>, options?: any) {
        return AcademyApiFp(this.configuration).putAcademyLessons(academyLesson, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new questionnaire or update an existing one
     * @summary Create or update academy questionnaire
     * @param {string} questionnaireId questionnaire\&#39;s id
     * @param {AcademyQuestionnairePutRequest} academyQuestionnairePutRequest academy lesson to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcademyApi
     */
    public putAcademyQuestionnaire(questionnaireId: string, academyQuestionnairePutRequest: AcademyQuestionnairePutRequest, options?: any) {
        return AcademyApiFp(this.configuration).putAcademyQuestionnaire(questionnaireId, academyQuestionnairePutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
export const ActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a list of activities based on the provided filters. The filters work cumulatively. For example, if you filter by subject and object, the response will include activities that match both filters. 
         * @summary Retrieve cloud activities in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [id] The ID of the activity to filter activities by
         * @param {APIVersion} [apiVersion] The API version to filter activities by
         * @param {EntityTypes} [subjectType] The type of the subject to filter activities by
         * @param {string} [subjectId] The ID of the subject to filter activities by
         * @param {EntityTypes} [objectType] The type of the object to filter activities by
         * @param {string} [objectId] The ID of the object to filter activities by
         * @param {'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read'} [actionType] The action (that was performed on the object) to filter activities by
         * @param {string} [recordedAfter] The time after which activities were recorded
         * @param {string} [recordedBefore] The time before which activities were recorded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivitiesInTeamspace: async (workspace: string, teamspace: string, page?: number, perPage?: number, id?: string, apiVersion?: APIVersion, subjectType?: EntityTypes, subjectId?: string, objectType?: EntityTypes, objectId?: string, actionType?: 'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read', recordedAfter?: string, recordedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('listActivitiesInTeamspace', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('listActivitiesInTeamspace', 'teamspace', teamspace)
            const localVarPath = `/activities/{workspace}/{teamspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api_version'] = apiVersion;
            }

            if (subjectType !== undefined) {
                localVarQueryParameter['subject_type'] = subjectType;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (objectType !== undefined) {
                localVarQueryParameter['object_type'] = objectType;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['object_id'] = objectId;
            }

            if (actionType !== undefined) {
                localVarQueryParameter['action_type'] = actionType;
            }

            if (recordedAfter !== undefined) {
                localVarQueryParameter['recorded_after'] = (recordedAfter as any instanceof Date) ?
                    (recordedAfter as any).toISOString() :
                    recordedAfter;
            }

            if (recordedBefore !== undefined) {
                localVarQueryParameter['recorded_before'] = (recordedBefore as any instanceof Date) ?
                    (recordedBefore as any).toISOString() :
                    recordedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a list of activities based on the provided filters. The filters work cumulatively. For example, if you filter by subject and object, the response will include activities that match both filters. 
         * @summary Retrieve cloud activities in a workspace
         * @param {string} workspace The workspace name or id
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [id] The ID of the activity to filter activities by
         * @param {APIVersion} [apiVersion] The API version to filter activities by
         * @param {EntityTypes} [subjectType] The type of the subject to filter activities by
         * @param {string} [subjectId] The ID of the subject to filter activities by
         * @param {EntityTypes} [objectType] The type of the object to filter activities by
         * @param {string} [objectId] The ID of the object to filter activities by
         * @param {'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read'} [actionType] The action (that was performed on the object) to filter activities by
         * @param {string} [recordedAfter] The time after which activities were recorded
         * @param {string} [recordedBefore] The time before which activities were recorded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivitiesInWorkspace: async (workspace: string, page?: number, perPage?: number, id?: string, apiVersion?: APIVersion, subjectType?: EntityTypes, subjectId?: string, objectType?: EntityTypes, objectId?: string, actionType?: 'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read', recordedAfter?: string, recordedBefore?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('listActivitiesInWorkspace', 'workspace', workspace)
            const localVarPath = `/activities/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api_version'] = apiVersion;
            }

            if (subjectType !== undefined) {
                localVarQueryParameter['subject_type'] = subjectType;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (objectType !== undefined) {
                localVarQueryParameter['object_type'] = objectType;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['object_id'] = objectId;
            }

            if (actionType !== undefined) {
                localVarQueryParameter['action_type'] = actionType;
            }

            if (recordedAfter !== undefined) {
                localVarQueryParameter['recorded_after'] = (recordedAfter as any instanceof Date) ?
                    (recordedAfter as any).toISOString() :
                    recordedAfter;
            }

            if (recordedBefore !== undefined) {
                localVarQueryParameter['recorded_before'] = (recordedBefore as any instanceof Date) ?
                    (recordedBefore as any).toISOString() :
                    recordedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns a list of activities based on the provided filters. The filters work cumulatively. For example, if you filter by subject and object, the response will include activities that match both filters. 
         * @summary Retrieve cloud activities in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [id] The ID of the activity to filter activities by
         * @param {APIVersion} [apiVersion] The API version to filter activities by
         * @param {EntityTypes} [subjectType] The type of the subject to filter activities by
         * @param {string} [subjectId] The ID of the subject to filter activities by
         * @param {EntityTypes} [objectType] The type of the object to filter activities by
         * @param {string} [objectId] The ID of the object to filter activities by
         * @param {'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read'} [actionType] The action (that was performed on the object) to filter activities by
         * @param {string} [recordedAfter] The time after which activities were recorded
         * @param {string} [recordedBefore] The time before which activities were recorded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActivitiesInTeamspace(workspace: string, teamspace: string, page?: number, perPage?: number, id?: string, apiVersion?: APIVersion, subjectType?: EntityTypes, subjectId?: string, objectType?: EntityTypes, objectId?: string, actionType?: 'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read', recordedAfter?: string, recordedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivitiesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActivitiesInTeamspace(workspace, teamspace, page, perPage, id, apiVersion, subjectType, subjectId, objectType, objectId, actionType, recordedAfter, recordedBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a list of activities based on the provided filters. The filters work cumulatively. For example, if you filter by subject and object, the response will include activities that match both filters. 
         * @summary Retrieve cloud activities in a workspace
         * @param {string} workspace The workspace name or id
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [id] The ID of the activity to filter activities by
         * @param {APIVersion} [apiVersion] The API version to filter activities by
         * @param {EntityTypes} [subjectType] The type of the subject to filter activities by
         * @param {string} [subjectId] The ID of the subject to filter activities by
         * @param {EntityTypes} [objectType] The type of the object to filter activities by
         * @param {string} [objectId] The ID of the object to filter activities by
         * @param {'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read'} [actionType] The action (that was performed on the object) to filter activities by
         * @param {string} [recordedAfter] The time after which activities were recorded
         * @param {string} [recordedBefore] The time before which activities were recorded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActivitiesInWorkspace(workspace: string, page?: number, perPage?: number, id?: string, apiVersion?: APIVersion, subjectType?: EntityTypes, subjectId?: string, objectType?: EntityTypes, objectId?: string, actionType?: 'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read', recordedAfter?: string, recordedBefore?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivitiesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActivitiesInWorkspace(workspace, page, perPage, id, apiVersion, subjectType, subjectId, objectType, objectId, actionType, recordedAfter, recordedBefore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivitiesApiFp(configuration)
    return {
        /**
         * This endpoint returns a list of activities based on the provided filters. The filters work cumulatively. For example, if you filter by subject and object, the response will include activities that match both filters. 
         * @summary Retrieve cloud activities in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [id] The ID of the activity to filter activities by
         * @param {APIVersion} [apiVersion] The API version to filter activities by
         * @param {EntityTypes} [subjectType] The type of the subject to filter activities by
         * @param {string} [subjectId] The ID of the subject to filter activities by
         * @param {EntityTypes} [objectType] The type of the object to filter activities by
         * @param {string} [objectId] The ID of the object to filter activities by
         * @param {'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read'} [actionType] The action (that was performed on the object) to filter activities by
         * @param {string} [recordedAfter] The time after which activities were recorded
         * @param {string} [recordedBefore] The time before which activities were recorded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivitiesInTeamspace(workspace: string, teamspace: string, page?: number, perPage?: number, id?: string, apiVersion?: APIVersion, subjectType?: EntityTypes, subjectId?: string, objectType?: EntityTypes, objectId?: string, actionType?: 'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read', recordedAfter?: string, recordedBefore?: string, options?: any): AxiosPromise<ActivitiesListResponse> {
            return localVarFp.listActivitiesInTeamspace(workspace, teamspace, page, perPage, id, apiVersion, subjectType, subjectId, objectType, objectId, actionType, recordedAfter, recordedBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a list of activities based on the provided filters. The filters work cumulatively. For example, if you filter by subject and object, the response will include activities that match both filters. 
         * @summary Retrieve cloud activities in a workspace
         * @param {string} workspace The workspace name or id
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [id] The ID of the activity to filter activities by
         * @param {APIVersion} [apiVersion] The API version to filter activities by
         * @param {EntityTypes} [subjectType] The type of the subject to filter activities by
         * @param {string} [subjectId] The ID of the subject to filter activities by
         * @param {EntityTypes} [objectType] The type of the object to filter activities by
         * @param {string} [objectId] The ID of the object to filter activities by
         * @param {'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read'} [actionType] The action (that was performed on the object) to filter activities by
         * @param {string} [recordedAfter] The time after which activities were recorded
         * @param {string} [recordedBefore] The time before which activities were recorded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivitiesInWorkspace(workspace: string, page?: number, perPage?: number, id?: string, apiVersion?: APIVersion, subjectType?: EntityTypes, subjectId?: string, objectType?: EntityTypes, objectId?: string, actionType?: 'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read', recordedAfter?: string, recordedBefore?: string, options?: any): AxiosPromise<ActivitiesListResponse> {
            return localVarFp.listActivitiesInWorkspace(workspace, page, perPage, id, apiVersion, subjectType, subjectId, objectType, objectId, actionType, recordedAfter, recordedBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * This endpoint returns a list of activities based on the provided filters. The filters work cumulatively. For example, if you filter by subject and object, the response will include activities that match both filters. 
     * @summary Retrieve cloud activities in a teamspace
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [id] The ID of the activity to filter activities by
     * @param {APIVersion} [apiVersion] The API version to filter activities by
     * @param {EntityTypes} [subjectType] The type of the subject to filter activities by
     * @param {string} [subjectId] The ID of the subject to filter activities by
     * @param {EntityTypes} [objectType] The type of the object to filter activities by
     * @param {string} [objectId] The ID of the object to filter activities by
     * @param {'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read'} [actionType] The action (that was performed on the object) to filter activities by
     * @param {string} [recordedAfter] The time after which activities were recorded
     * @param {string} [recordedBefore] The time before which activities were recorded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public listActivitiesInTeamspace(workspace: string, teamspace: string, page?: number, perPage?: number, id?: string, apiVersion?: APIVersion, subjectType?: EntityTypes, subjectId?: string, objectType?: EntityTypes, objectId?: string, actionType?: 'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read', recordedAfter?: string, recordedBefore?: string, options?: any) {
        return ActivitiesApiFp(this.configuration).listActivitiesInTeamspace(workspace, teamspace, page, perPage, id, apiVersion, subjectType, subjectId, objectType, objectId, actionType, recordedAfter, recordedBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a list of activities based on the provided filters. The filters work cumulatively. For example, if you filter by subject and object, the response will include activities that match both filters. 
     * @summary Retrieve cloud activities in a workspace
     * @param {string} workspace The workspace name or id
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [id] The ID of the activity to filter activities by
     * @param {APIVersion} [apiVersion] The API version to filter activities by
     * @param {EntityTypes} [subjectType] The type of the subject to filter activities by
     * @param {string} [subjectId] The ID of the subject to filter activities by
     * @param {EntityTypes} [objectType] The type of the object to filter activities by
     * @param {string} [objectId] The ID of the object to filter activities by
     * @param {'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read'} [actionType] The action (that was performed on the object) to filter activities by
     * @param {string} [recordedAfter] The time after which activities were recorded
     * @param {string} [recordedBefore] The time before which activities were recorded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public listActivitiesInWorkspace(workspace: string, page?: number, perPage?: number, id?: string, apiVersion?: APIVersion, subjectType?: EntityTypes, subjectId?: string, objectType?: EntityTypes, objectId?: string, actionType?: 'create' | 'read' | 'update' | 'delete' | 'start-notebook' | 'stop-notebook' | 'read-metadata' | 'add-metadata' | 'remove-metadata' | 'add-content' | 'remove-content' | 'read-content' | 'move' | 'query-read', recordedAfter?: string, recordedBefore?: string, options?: any) {
        return ActivitiesApiFp(this.configuration).listActivitiesInWorkspace(workspace, page, perPage, id, apiVersion, subjectType, subjectId, objectType, objectId, actionType, recordedAfter, recordedBefore, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Unregister or delete an asset in the specified workspace and teamspace.
         * @summary Unregister or delete an asset
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {boolean} [deleteAssets] If &#x60;true&#x60;, the entity\&#39;s assets will be deregistered in TileDB *and* deleted from the underlying storage (e.g., S3). If &#x60;false&#x60;, the entity\&#39;s assets will be deregistered in TileDB but remain in the underlying storage. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset: async (workspace: string, teamspace: string, asset: string, deleteAssets?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteAsset', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('deleteAsset', 'teamspace', teamspace)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('deleteAsset', 'asset', asset)
            const localVarPath = `/assets/item/{workspace}/{teamspace}/{asset}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (deleteAssets !== undefined) {
                localVarQueryParameter['delete-assets'] = deleteAssets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete one or more metadata keys for the given asset
         * @summary Delete asset metadata
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {Array<string>} metadataKey One or more metadata keys to delete
         * @param {number} [startTimestamp] Start timestamp in milliseconds since epoch
         * @param {number} [endTimestamp] End timestamp in milliseconds since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetMetadata: async (workspace: string, teamspace: string, asset: string, metadataKey: Array<string>, startTimestamp?: number, endTimestamp?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteAssetMetadata', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('deleteAssetMetadata', 'teamspace', teamspace)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('deleteAssetMetadata', 'asset', asset)
            // verify required parameter 'metadataKey' is not null or undefined
            assertParamExists('deleteAssetMetadata', 'metadataKey', metadataKey)
            const localVarPath = `/assets/item/{workspace}/{teamspace}/{asset}/metadata`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (startTimestamp !== undefined) {
                localVarQueryParameter['start_timestamp'] = startTimestamp;
            }

            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }

            if (metadataKey) {
                localVarQueryParameter['metadata_key'] = metadataKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the asset by the given asset_id or path
         * @summary Retrieve asset
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset: async (workspace: string, teamspace: string, asset: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getAsset', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('getAsset', 'teamspace', teamspace)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getAsset', 'asset', asset)
            const localVarPath = `/assets/item/{workspace}/{teamspace}/{asset}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the given asset\'s metadata
         * @summary Retrieve asset\'s metadata
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {number} [startTimestamp] Start timestamp in milliseconds since epoch
         * @param {number} [endTimestamp] End timestamp in milliseconds since epoch
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetMetadata: async (workspace: string, teamspace: string, asset: string, startTimestamp?: number, endTimestamp?: number, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getAssetMetadata', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('getAssetMetadata', 'teamspace', teamspace)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getAssetMetadata', 'asset', asset)
            const localVarPath = `/assets/item/{workspace}/{teamspace}/{asset}/metadata`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (startTimestamp !== undefined) {
                localVarQueryParameter['start_timestamp'] = startTimestamp;
            }

            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the given asset\'s properties
         * @summary Retrieve asset\'s properties
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetProperties: async (workspace: string, teamspace: string, asset: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getAssetProperties', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('getAssetProperties', 'teamspace', teamspace)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getAssetProperties', 'asset', asset)
            const localVarPath = `/assets/item/{workspace}/{teamspace}/{asset}/properties`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all assets in a given path, e.g., a request for `/a/b/c` will return the assets `a`, `b`, and `c`. 
         * @summary Retrieve all assets in a given path
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path for which to retrieve assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsInPath: async (workspace: string, teamspace: string, path: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getAssetsInPath', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('getAssetsInPath', 'teamspace', teamspace)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getAssetsInPath', 'path', path)
            const localVarPath = `/assets/path/{workspace}/{teamspace}/{path}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End point to retrieve assets for the passed teamspace 
         * @summary Retrieves asset listing for the given teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path for which to retrieve assets
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {AssetType} [assetType] asset type to filter to
         * @param {string} [createdBy] users that created the asset to filter to
         * @param {string} [orderBy] order by string
         * @param {string} [expand] expand api response with supplemental information
         * @param {boolean} [includeSystemAssets] if true, system assets (like overlay arrays and groups) are returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssets: async (workspace: string, teamspace: string, path: string, page?: number, perPage?: number, assetType?: AssetType, createdBy?: string, orderBy?: string, expand?: string, includeSystemAssets?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('listAssets', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('listAssets', 'teamspace', teamspace)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('listAssets', 'path', path)
            const localVarPath = `/assets/list/{workspace}/{teamspace}/{path}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (assetType !== undefined) {
                localVarQueryParameter['asset_type'] = assetType;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (includeSystemAssets !== undefined) {
                localVarQueryParameter['include_system_assets'] = includeSystemAssets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move assets (array, group & files) in the specified workspace and teamspace to a target folder.
         * @summary Move assets (array, group & files)
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {AssetsMoveRequest} assetsMoveRequest The assets move request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveAssets: async (workspace: string, teamspace: string, assetsMoveRequest: AssetsMoveRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('moveAssets', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('moveAssets', 'teamspace', teamspace)
            // verify required parameter 'assetsMoveRequest' is not null or undefined
            assertParamExists('moveAssets', 'assetsMoveRequest', assetsMoveRequest)
            const localVarPath = `/assets/move/{workspace}/{teamspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(assetsMoveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register an asset for the given user in the specified workspace and teamspace.
         * @summary Register an asset (array, group & files)
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {AssetRegisterRequest} assetRegisterRequest The asset registration request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAsset: async (workspace: string, teamspace: string, assetRegisterRequest: AssetRegisterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('registerAsset', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('registerAsset', 'teamspace', teamspace)
            // verify required parameter 'assetRegisterRequest' is not null or undefined
            assertParamExists('registerAsset', 'assetRegisterRequest', assetRegisterRequest)
            const localVarPath = `/assets/register/{workspace}/{teamspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(assetRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the asset by the given asset_id or path
         * @summary Update asset
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {AssetUpdateRequest} assetUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset: async (workspace: string, teamspace: string, asset: string, assetUpdateRequest: AssetUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateAsset', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('updateAsset', 'teamspace', teamspace)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('updateAsset', 'asset', asset)
            // verify required parameter 'assetUpdateRequest' is not null or undefined
            assertParamExists('updateAsset', 'assetUpdateRequest', assetUpdateRequest)
            const localVarPath = `/assets/item/{workspace}/{teamspace}/{asset}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(assetUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update asset\'s metadata
         * @summary Update the given asset\'s metadata pair
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {Array<AssetMetadataSaveRequestInner>} assetMetadataSaveRequestInner asset metadata pairs to update
         * @param {number} [startTimestamp] Start timestamp in milliseconds since epoch
         * @param {number} [endTimestamp] End timestamp in milliseconds since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetMetadata: async (workspace: string, teamspace: string, asset: string, assetMetadataSaveRequestInner: Array<AssetMetadataSaveRequestInner>, startTimestamp?: number, endTimestamp?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateAssetMetadata', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('updateAssetMetadata', 'teamspace', teamspace)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('updateAssetMetadata', 'asset', asset)
            // verify required parameter 'assetMetadataSaveRequestInner' is not null or undefined
            assertParamExists('updateAssetMetadata', 'assetMetadataSaveRequestInner', assetMetadataSaveRequestInner)
            const localVarPath = `/assets/item/{workspace}/{teamspace}/{asset}/metadata`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (startTimestamp !== undefined) {
                localVarQueryParameter['start_timestamp'] = startTimestamp;
            }

            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(assetMetadataSaveRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update asset\'s properties
         * @summary Update the given asset\'s property pair
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {Array<AssetPropertySaveRequestInner>} assetPropertySaveRequestInner asset property pairs to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetProperties: async (workspace: string, teamspace: string, asset: string, assetPropertySaveRequestInner: Array<AssetPropertySaveRequestInner>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateAssetProperties', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('updateAssetProperties', 'teamspace', teamspace)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('updateAssetProperties', 'asset', asset)
            // verify required parameter 'assetPropertySaveRequestInner' is not null or undefined
            assertParamExists('updateAssetProperties', 'assetPropertySaveRequestInner', assetPropertySaveRequestInner)
            const localVarPath = `/assets/item/{workspace}/{teamspace}/{asset}/properties`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(assetPropertySaveRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Unregister or delete an asset in the specified workspace and teamspace.
         * @summary Unregister or delete an asset
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {boolean} [deleteAssets] If &#x60;true&#x60;, the entity\&#39;s assets will be deregistered in TileDB *and* deleted from the underlying storage (e.g., S3). If &#x60;false&#x60;, the entity\&#39;s assets will be deregistered in TileDB but remain in the underlying storage. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAsset(workspace: string, teamspace: string, asset: string, deleteAssets?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAsset(workspace, teamspace, asset, deleteAssets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete one or more metadata keys for the given asset
         * @summary Delete asset metadata
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {Array<string>} metadataKey One or more metadata keys to delete
         * @param {number} [startTimestamp] Start timestamp in milliseconds since epoch
         * @param {number} [endTimestamp] End timestamp in milliseconds since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAssetMetadata(workspace: string, teamspace: string, asset: string, metadataKey: Array<string>, startTimestamp?: number, endTimestamp?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAssetMetadata(workspace, teamspace, asset, metadataKey, startTimestamp, endTimestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the asset by the given asset_id or path
         * @summary Retrieve asset
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAsset(workspace: string, teamspace: string, asset: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(workspace, teamspace, asset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the given asset\'s metadata
         * @summary Retrieve asset\'s metadata
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {number} [startTimestamp] Start timestamp in milliseconds since epoch
         * @param {number} [endTimestamp] End timestamp in milliseconds since epoch
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetMetadata(workspace: string, teamspace: string, asset: string, startTimestamp?: number, endTimestamp?: number, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetMetadataListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetMetadata(workspace, teamspace, asset, startTimestamp, endTimestamp, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the given asset\'s properties
         * @summary Retrieve asset\'s properties
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetProperties(workspace: string, teamspace: string, asset: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetPropertyListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetProperties(workspace, teamspace, asset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all assets in a given path, e.g., a request for `/a/b/c` will return the assets `a`, `b`, and `c`. 
         * @summary Retrieve all assets in a given path
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path for which to retrieve assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetsInPath(workspace: string, teamspace: string, path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetPathResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetsInPath(workspace, teamspace, path, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * End point to retrieve assets for the passed teamspace 
         * @summary Retrieves asset listing for the given teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path for which to retrieve assets
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {AssetType} [assetType] asset type to filter to
         * @param {string} [createdBy] users that created the asset to filter to
         * @param {string} [orderBy] order by string
         * @param {string} [expand] expand api response with supplemental information
         * @param {boolean} [includeSystemAssets] if true, system assets (like overlay arrays and groups) are returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAssets(workspace: string, teamspace: string, path: string, page?: number, perPage?: number, assetType?: AssetType, createdBy?: string, orderBy?: string, expand?: string, includeSystemAssets?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAssets(workspace, teamspace, path, page, perPage, assetType, createdBy, orderBy, expand, includeSystemAssets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Move assets (array, group & files) in the specified workspace and teamspace to a target folder.
         * @summary Move assets (array, group & files)
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {AssetsMoveRequest} assetsMoveRequest The assets move request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveAssets(workspace: string, teamspace: string, assetsMoveRequest: AssetsMoveRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveAssets(workspace, teamspace, assetsMoveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register an asset for the given user in the specified workspace and teamspace.
         * @summary Register an asset (array, group & files)
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {AssetRegisterRequest} assetRegisterRequest The asset registration request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerAsset(workspace: string, teamspace: string, assetRegisterRequest: AssetRegisterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerAsset(workspace, teamspace, assetRegisterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the asset by the given asset_id or path
         * @summary Update asset
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {AssetUpdateRequest} assetUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAsset(workspace: string, teamspace: string, asset: string, assetUpdateRequest: AssetUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAsset(workspace, teamspace, asset, assetUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update asset\'s metadata
         * @summary Update the given asset\'s metadata pair
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {Array<AssetMetadataSaveRequestInner>} assetMetadataSaveRequestInner asset metadata pairs to update
         * @param {number} [startTimestamp] Start timestamp in milliseconds since epoch
         * @param {number} [endTimestamp] End timestamp in milliseconds since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAssetMetadata(workspace: string, teamspace: string, asset: string, assetMetadataSaveRequestInner: Array<AssetMetadataSaveRequestInner>, startTimestamp?: number, endTimestamp?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetMetadataSaveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAssetMetadata(workspace, teamspace, asset, assetMetadataSaveRequestInner, startTimestamp, endTimestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update asset\'s properties
         * @summary Update the given asset\'s property pair
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {Array<AssetPropertySaveRequestInner>} assetPropertySaveRequestInner asset property pairs to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAssetProperties(workspace: string, teamspace: string, asset: string, assetPropertySaveRequestInner: Array<AssetPropertySaveRequestInner>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetPropertySaveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAssetProperties(workspace, teamspace, asset, assetPropertySaveRequestInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsApiFp(configuration)
    return {
        /**
         * Unregister or delete an asset in the specified workspace and teamspace.
         * @summary Unregister or delete an asset
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {boolean} [deleteAssets] If &#x60;true&#x60;, the entity\&#39;s assets will be deregistered in TileDB *and* deleted from the underlying storage (e.g., S3). If &#x60;false&#x60;, the entity\&#39;s assets will be deregistered in TileDB but remain in the underlying storage. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset(workspace: string, teamspace: string, asset: string, deleteAssets?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAsset(workspace, teamspace, asset, deleteAssets, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete one or more metadata keys for the given asset
         * @summary Delete asset metadata
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {Array<string>} metadataKey One or more metadata keys to delete
         * @param {number} [startTimestamp] Start timestamp in milliseconds since epoch
         * @param {number} [endTimestamp] End timestamp in milliseconds since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetMetadata(workspace: string, teamspace: string, asset: string, metadataKey: Array<string>, startTimestamp?: number, endTimestamp?: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAssetMetadata(workspace, teamspace, asset, metadataKey, startTimestamp, endTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the asset by the given asset_id or path
         * @summary Retrieve asset
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset(workspace: string, teamspace: string, asset: string, options?: any): AxiosPromise<AssetGetResponse> {
            return localVarFp.getAsset(workspace, teamspace, asset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the given asset\'s metadata
         * @summary Retrieve asset\'s metadata
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {number} [startTimestamp] Start timestamp in milliseconds since epoch
         * @param {number} [endTimestamp] End timestamp in milliseconds since epoch
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetMetadata(workspace: string, teamspace: string, asset: string, startTimestamp?: number, endTimestamp?: number, page?: number, perPage?: number, options?: any): AxiosPromise<AssetMetadataListResponse> {
            return localVarFp.getAssetMetadata(workspace, teamspace, asset, startTimestamp, endTimestamp, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the given asset\'s properties
         * @summary Retrieve asset\'s properties
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetProperties(workspace: string, teamspace: string, asset: string, options?: any): AxiosPromise<AssetPropertyListResponse> {
            return localVarFp.getAssetProperties(workspace, teamspace, asset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all assets in a given path, e.g., a request for `/a/b/c` will return the assets `a`, `b`, and `c`. 
         * @summary Retrieve all assets in a given path
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path for which to retrieve assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsInPath(workspace: string, teamspace: string, path: string, options?: any): AxiosPromise<AssetPathResponse> {
            return localVarFp.getAssetsInPath(workspace, teamspace, path, options).then((request) => request(axios, basePath));
        },
        /**
         * End point to retrieve assets for the passed teamspace 
         * @summary Retrieves asset listing for the given teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path for which to retrieve assets
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {AssetType} [assetType] asset type to filter to
         * @param {string} [createdBy] users that created the asset to filter to
         * @param {string} [orderBy] order by string
         * @param {string} [expand] expand api response with supplemental information
         * @param {boolean} [includeSystemAssets] if true, system assets (like overlay arrays and groups) are returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssets(workspace: string, teamspace: string, path: string, page?: number, perPage?: number, assetType?: AssetType, createdBy?: string, orderBy?: string, expand?: string, includeSystemAssets?: boolean, options?: any): AxiosPromise<AssetListResponse> {
            return localVarFp.listAssets(workspace, teamspace, path, page, perPage, assetType, createdBy, orderBy, expand, includeSystemAssets, options).then((request) => request(axios, basePath));
        },
        /**
         * Move assets (array, group & files) in the specified workspace and teamspace to a target folder.
         * @summary Move assets (array, group & files)
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {AssetsMoveRequest} assetsMoveRequest The assets move request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveAssets(workspace: string, teamspace: string, assetsMoveRequest: AssetsMoveRequest, options?: any): AxiosPromise<void> {
            return localVarFp.moveAssets(workspace, teamspace, assetsMoveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register an asset for the given user in the specified workspace and teamspace.
         * @summary Register an asset (array, group & files)
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {AssetRegisterRequest} assetRegisterRequest The asset registration request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAsset(workspace: string, teamspace: string, assetRegisterRequest: AssetRegisterRequest, options?: any): AxiosPromise<void> {
            return localVarFp.registerAsset(workspace, teamspace, assetRegisterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the asset by the given asset_id or path
         * @summary Update asset
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {AssetUpdateRequest} assetUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset(workspace: string, teamspace: string, asset: string, assetUpdateRequest: AssetUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateAsset(workspace, teamspace, asset, assetUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update asset\'s metadata
         * @summary Update the given asset\'s metadata pair
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {Array<AssetMetadataSaveRequestInner>} assetMetadataSaveRequestInner asset metadata pairs to update
         * @param {number} [startTimestamp] Start timestamp in milliseconds since epoch
         * @param {number} [endTimestamp] End timestamp in milliseconds since epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetMetadata(workspace: string, teamspace: string, asset: string, assetMetadataSaveRequestInner: Array<AssetMetadataSaveRequestInner>, startTimestamp?: number, endTimestamp?: number, options?: any): AxiosPromise<AssetMetadataSaveResponse> {
            return localVarFp.updateAssetMetadata(workspace, teamspace, asset, assetMetadataSaveRequestInner, startTimestamp, endTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Update asset\'s properties
         * @summary Update the given asset\'s property pair
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {Array<AssetPropertySaveRequestInner>} assetPropertySaveRequestInner asset property pairs to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetProperties(workspace: string, teamspace: string, asset: string, assetPropertySaveRequestInner: Array<AssetPropertySaveRequestInner>, options?: any): AxiosPromise<AssetPropertySaveResponse> {
            return localVarFp.updateAssetProperties(workspace, teamspace, asset, assetPropertySaveRequestInner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
    /**
     * Unregister or delete an asset in the specified workspace and teamspace.
     * @summary Unregister or delete an asset
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} asset The asset id or path for which to retrieve assets
     * @param {boolean} [deleteAssets] If &#x60;true&#x60;, the entity\&#39;s assets will be deregistered in TileDB *and* deleted from the underlying storage (e.g., S3). If &#x60;false&#x60;, the entity\&#39;s assets will be deregistered in TileDB but remain in the underlying storage. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public deleteAsset(workspace: string, teamspace: string, asset: string, deleteAssets?: boolean, options?: any) {
        return AssetsApiFp(this.configuration).deleteAsset(workspace, teamspace, asset, deleteAssets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete one or more metadata keys for the given asset
     * @summary Delete asset metadata
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} asset The asset id or path for which to retrieve assets
     * @param {Array<string>} metadataKey One or more metadata keys to delete
     * @param {number} [startTimestamp] Start timestamp in milliseconds since epoch
     * @param {number} [endTimestamp] End timestamp in milliseconds since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public deleteAssetMetadata(workspace: string, teamspace: string, asset: string, metadataKey: Array<string>, startTimestamp?: number, endTimestamp?: number, options?: any) {
        return AssetsApiFp(this.configuration).deleteAssetMetadata(workspace, teamspace, asset, metadataKey, startTimestamp, endTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the asset by the given asset_id or path
     * @summary Retrieve asset
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} asset The asset id or path for which to retrieve assets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getAsset(workspace: string, teamspace: string, asset: string, options?: any) {
        return AssetsApiFp(this.configuration).getAsset(workspace, teamspace, asset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the given asset\'s metadata
     * @summary Retrieve asset\'s metadata
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} asset The asset id or path for which to retrieve assets
     * @param {number} [startTimestamp] Start timestamp in milliseconds since epoch
     * @param {number} [endTimestamp] End timestamp in milliseconds since epoch
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getAssetMetadata(workspace: string, teamspace: string, asset: string, startTimestamp?: number, endTimestamp?: number, page?: number, perPage?: number, options?: any) {
        return AssetsApiFp(this.configuration).getAssetMetadata(workspace, teamspace, asset, startTimestamp, endTimestamp, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the given asset\'s properties
     * @summary Retrieve asset\'s properties
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} asset The asset id or path for which to retrieve assets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getAssetProperties(workspace: string, teamspace: string, asset: string, options?: any) {
        return AssetsApiFp(this.configuration).getAssetProperties(workspace, teamspace, asset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all assets in a given path, e.g., a request for `/a/b/c` will return the assets `a`, `b`, and `c`. 
     * @summary Retrieve all assets in a given path
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} path The path for which to retrieve assets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getAssetsInPath(workspace: string, teamspace: string, path: string, options?: any) {
        return AssetsApiFp(this.configuration).getAssetsInPath(workspace, teamspace, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End point to retrieve assets for the passed teamspace 
     * @summary Retrieves asset listing for the given teamspace
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} path The path for which to retrieve assets
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {AssetType} [assetType] asset type to filter to
     * @param {string} [createdBy] users that created the asset to filter to
     * @param {string} [orderBy] order by string
     * @param {string} [expand] expand api response with supplemental information
     * @param {boolean} [includeSystemAssets] if true, system assets (like overlay arrays and groups) are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public listAssets(workspace: string, teamspace: string, path: string, page?: number, perPage?: number, assetType?: AssetType, createdBy?: string, orderBy?: string, expand?: string, includeSystemAssets?: boolean, options?: any) {
        return AssetsApiFp(this.configuration).listAssets(workspace, teamspace, path, page, perPage, assetType, createdBy, orderBy, expand, includeSystemAssets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Move assets (array, group & files) in the specified workspace and teamspace to a target folder.
     * @summary Move assets (array, group & files)
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {AssetsMoveRequest} assetsMoveRequest The assets move request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public moveAssets(workspace: string, teamspace: string, assetsMoveRequest: AssetsMoveRequest, options?: any) {
        return AssetsApiFp(this.configuration).moveAssets(workspace, teamspace, assetsMoveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register an asset for the given user in the specified workspace and teamspace.
     * @summary Register an asset (array, group & files)
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {AssetRegisterRequest} assetRegisterRequest The asset registration request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public registerAsset(workspace: string, teamspace: string, assetRegisterRequest: AssetRegisterRequest, options?: any) {
        return AssetsApiFp(this.configuration).registerAsset(workspace, teamspace, assetRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the asset by the given asset_id or path
     * @summary Update asset
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} asset The asset id or path for which to retrieve assets
     * @param {AssetUpdateRequest} assetUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public updateAsset(workspace: string, teamspace: string, asset: string, assetUpdateRequest: AssetUpdateRequest, options?: any) {
        return AssetsApiFp(this.configuration).updateAsset(workspace, teamspace, asset, assetUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update asset\'s metadata
     * @summary Update the given asset\'s metadata pair
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} asset The asset id or path for which to retrieve assets
     * @param {Array<AssetMetadataSaveRequestInner>} assetMetadataSaveRequestInner asset metadata pairs to update
     * @param {number} [startTimestamp] Start timestamp in milliseconds since epoch
     * @param {number} [endTimestamp] End timestamp in milliseconds since epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public updateAssetMetadata(workspace: string, teamspace: string, asset: string, assetMetadataSaveRequestInner: Array<AssetMetadataSaveRequestInner>, startTimestamp?: number, endTimestamp?: number, options?: any) {
        return AssetsApiFp(this.configuration).updateAssetMetadata(workspace, teamspace, asset, assetMetadataSaveRequestInner, startTimestamp, endTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update asset\'s properties
     * @summary Update the given asset\'s property pair
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} asset The asset id or path for which to retrieve assets
     * @param {Array<AssetPropertySaveRequestInner>} assetPropertySaveRequestInner asset property pairs to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public updateAssetProperties(workspace: string, teamspace: string, asset: string, assetPropertySaveRequestInner: Array<AssetPropertySaveRequestInner>, options?: any) {
        return AssetsApiFp(this.configuration).updateAssetProperties(workspace, teamspace, asset, assetPropertySaveRequestInner, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CapabilitiesApi - axios parameter creator
 * @export
 */
export const CapabilitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get REST capabilities
         * @summary Get REST capabilities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleGetCapabilities: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/capabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CapabilitiesApi - functional programming interface
 * @export
 */
export const CapabilitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CapabilitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get REST capabilities
         * @summary Get REST capabilities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleGetCapabilities(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestCapabilities>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleGetCapabilities(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CapabilitiesApi - factory interface
 * @export
 */
export const CapabilitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CapabilitiesApiFp(configuration)
    return {
        /**
         * Get REST capabilities
         * @summary Get REST capabilities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleGetCapabilities(options?: any): AxiosPromise<RestCapabilities> {
            return localVarFp.handleGetCapabilities(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CapabilitiesApi - object-oriented interface
 * @export
 * @class CapabilitiesApi
 * @extends {BaseAPI}
 */
export class CapabilitiesApi extends BaseAPI {
    /**
     * Get REST capabilities
     * @summary Get REST capabilities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapabilitiesApi
     */
    public handleGetCapabilities(options?: any) {
        return CapabilitiesApiFp(this.configuration).handleGetCapabilities(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CredentialsApi - axios parameter creator
 * @export
 */
export const CredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create a new credential, the user will create a new credential to access assets
         * @summary Create a credential
         * @param {string} workspace The workspace name or id
         * @param {CredentialCreateRequest} credentialCreateRequest the new credentials to be created
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredential: async (workspace: string, credentialCreateRequest: CredentialCreateRequest, teamspaceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createCredential', 'workspace', workspace)
            // verify required parameter 'credentialCreateRequest' is not null or undefined
            assertParamExists('createCredential', 'credentialCreateRequest', credentialCreateRequest)
            const localVarPath = `/credentials/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (teamspaceId !== undefined) {
                localVarQueryParameter['teamspace_id'] = teamspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(credentialCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the user\'s default and may become unreachable
         * @summary Delete user credential
         * @param {string} workspace The workspace name or id
         * @param {string} name The name of the credentials to run CRUD operations against
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredentialByName: async (workspace: string, name: string, teamspaceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteCredentialByName', 'workspace', workspace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteCredentialByName', 'name', name)
            const localVarPath = `/credentials/{workspace}/{name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (teamspaceId !== undefined) {
                localVarQueryParameter['teamspace_id'] = teamspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get information about user credential by name
         * @summary Get user credential
         * @param {string} workspace The workspace name or id
         * @param {string} name The name of the credentials to run CRUD operations against
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredentialByName: async (workspace: string, name: string, teamspaceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getCredentialByName', 'workspace', workspace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getCredentialByName', 'name', name)
            const localVarPath = `/credentials/{workspace}/{name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (teamspaceId !== undefined) {
                localVarQueryParameter['teamspace_id'] = teamspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list the credentials available for the user
         * @summary Get user credentials
         * @param {string} workspace The workspace name or id
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {CloudProvider} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredentials: async (workspace: string, teamspaceId?: string, provider?: CloudProvider, type?: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getCredentials', 'workspace', workspace)
            const localVarPath = `/credentials/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (teamspaceId !== undefined) {
                localVarQueryParameter['teamspace_id'] = teamspaceId;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update user credential given by the user
         * @summary Update user credential
         * @param {string} workspace The workspace name or id
         * @param {string} name The name of the credentials to run CRUD operations against
         * @param {CredentialUpdateRequest} credentialUpdateRequest credential update details
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCredentialByName: async (workspace: string, name: string, credentialUpdateRequest: CredentialUpdateRequest, teamspaceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('patchCredentialByName', 'workspace', workspace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('patchCredentialByName', 'name', name)
            // verify required parameter 'credentialUpdateRequest' is not null or undefined
            assertParamExists('patchCredentialByName', 'credentialUpdateRequest', credentialUpdateRequest)
            const localVarPath = `/credentials/{workspace}/{name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (teamspaceId !== undefined) {
                localVarQueryParameter['teamspace_id'] = teamspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(credentialUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * verify the credentials connection for a namespace
         * @summary Verify a given credential
         * @param {CredentialsVerifyRequest} credentialsVerifyRequest credential to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCredential: async (credentialsVerifyRequest: CredentialsVerifyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialsVerifyRequest' is not null or undefined
            assertParamExists('verifyCredential', 'credentialsVerifyRequest', credentialsVerifyRequest)
            const localVarPath = `/actions/credentials/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(credentialsVerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialsApi - functional programming interface
 * @export
 */
export const CredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * create a new credential, the user will create a new credential to access assets
         * @summary Create a credential
         * @param {string} workspace The workspace name or id
         * @param {CredentialCreateRequest} credentialCreateRequest the new credentials to be created
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredential(workspace: string, credentialCreateRequest: CredentialCreateRequest, teamspaceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredential(workspace, credentialCreateRequest, teamspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the user\'s default and may become unreachable
         * @summary Delete user credential
         * @param {string} workspace The workspace name or id
         * @param {string} name The name of the credentials to run CRUD operations against
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCredentialByName(workspace: string, name: string, teamspaceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredentialByName(workspace, name, teamspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get information about user credential by name
         * @summary Get user credential
         * @param {string} workspace The workspace name or id
         * @param {string} name The name of the credentials to run CRUD operations against
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCredentialByName(workspace: string, name: string, teamspaceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCredentialByName(workspace, name, teamspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * list the credentials available for the user
         * @summary Get user credentials
         * @param {string} workspace The workspace name or id
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {CloudProvider} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCredentials(workspace: string, teamspaceId?: string, provider?: CloudProvider, type?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCredentials(workspace, teamspaceId, provider, type, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update user credential given by the user
         * @summary Update user credential
         * @param {string} workspace The workspace name or id
         * @param {string} name The name of the credentials to run CRUD operations against
         * @param {CredentialUpdateRequest} credentialUpdateRequest credential update details
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCredentialByName(workspace: string, name: string, credentialUpdateRequest: CredentialUpdateRequest, teamspaceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCredentialByName(workspace, name, credentialUpdateRequest, teamspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * verify the credentials connection for a namespace
         * @summary Verify a given credential
         * @param {CredentialsVerifyRequest} credentialsVerifyRequest credential to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyCredential(credentialsVerifyRequest: CredentialsVerifyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyCredential(credentialsVerifyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CredentialsApi - factory interface
 * @export
 */
export const CredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CredentialsApiFp(configuration)
    return {
        /**
         * create a new credential, the user will create a new credential to access assets
         * @summary Create a credential
         * @param {string} workspace The workspace name or id
         * @param {CredentialCreateRequest} credentialCreateRequest the new credentials to be created
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredential(workspace: string, credentialCreateRequest: CredentialCreateRequest, teamspaceId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.createCredential(workspace, credentialCreateRequest, teamspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the user\'s default and may become unreachable
         * @summary Delete user credential
         * @param {string} workspace The workspace name or id
         * @param {string} name The name of the credentials to run CRUD operations against
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredentialByName(workspace: string, name: string, teamspaceId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCredentialByName(workspace, name, teamspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * get information about user credential by name
         * @summary Get user credential
         * @param {string} workspace The workspace name or id
         * @param {string} name The name of the credentials to run CRUD operations against
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredentialByName(workspace: string, name: string, teamspaceId?: string, options?: any): AxiosPromise<CredentialGetResponse> {
            return localVarFp.getCredentialByName(workspace, name, teamspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * list the credentials available for the user
         * @summary Get user credentials
         * @param {string} workspace The workspace name or id
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {CloudProvider} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredentials(workspace: string, teamspaceId?: string, provider?: CloudProvider, type?: string, page?: number, perPage?: number, options?: any): AxiosPromise<CredentialsListResponse> {
            return localVarFp.getCredentials(workspace, teamspaceId, provider, type, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * update user credential given by the user
         * @summary Update user credential
         * @param {string} workspace The workspace name or id
         * @param {string} name The name of the credentials to run CRUD operations against
         * @param {CredentialUpdateRequest} credentialUpdateRequest credential update details
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCredentialByName(workspace: string, name: string, credentialUpdateRequest: CredentialUpdateRequest, teamspaceId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.patchCredentialByName(workspace, name, credentialUpdateRequest, teamspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * verify the credentials connection for a namespace
         * @summary Verify a given credential
         * @param {CredentialsVerifyRequest} credentialsVerifyRequest credential to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCredential(credentialsVerifyRequest: CredentialsVerifyRequest, options?: any): AxiosPromise<void> {
            return localVarFp.verifyCredential(credentialsVerifyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CredentialsApi - object-oriented interface
 * @export
 * @class CredentialsApi
 * @extends {BaseAPI}
 */
export class CredentialsApi extends BaseAPI {
    /**
     * create a new credential, the user will create a new credential to access assets
     * @summary Create a credential
     * @param {string} workspace The workspace name or id
     * @param {CredentialCreateRequest} credentialCreateRequest the new credentials to be created
     * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public createCredential(workspace: string, credentialCreateRequest: CredentialCreateRequest, teamspaceId?: string, options?: any) {
        return CredentialsApiFp(this.configuration).createCredential(workspace, credentialCreateRequest, teamspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the user\'s default and may become unreachable
     * @summary Delete user credential
     * @param {string} workspace The workspace name or id
     * @param {string} name The name of the credentials to run CRUD operations against
     * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public deleteCredentialByName(workspace: string, name: string, teamspaceId?: string, options?: any) {
        return CredentialsApiFp(this.configuration).deleteCredentialByName(workspace, name, teamspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get information about user credential by name
     * @summary Get user credential
     * @param {string} workspace The workspace name or id
     * @param {string} name The name of the credentials to run CRUD operations against
     * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public getCredentialByName(workspace: string, name: string, teamspaceId?: string, options?: any) {
        return CredentialsApiFp(this.configuration).getCredentialByName(workspace, name, teamspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list the credentials available for the user
     * @summary Get user credentials
     * @param {string} workspace The workspace name or id
     * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
     * @param {CloudProvider} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public getCredentials(workspace: string, teamspaceId?: string, provider?: CloudProvider, type?: string, page?: number, perPage?: number, options?: any) {
        return CredentialsApiFp(this.configuration).getCredentials(workspace, teamspaceId, provider, type, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update user credential given by the user
     * @summary Update user credential
     * @param {string} workspace The workspace name or id
     * @param {string} name The name of the credentials to run CRUD operations against
     * @param {CredentialUpdateRequest} credentialUpdateRequest credential update details
     * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public patchCredentialByName(workspace: string, name: string, credentialUpdateRequest: CredentialUpdateRequest, teamspaceId?: string, options?: any) {
        return CredentialsApiFp(this.configuration).patchCredentialByName(workspace, name, credentialUpdateRequest, teamspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * verify the credentials connection for a namespace
     * @summary Verify a given credential
     * @param {CredentialsVerifyRequest} credentialsVerifyRequest credential to verify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public verifyCredential(credentialsVerifyRequest: CredentialsVerifyRequest, options?: any) {
        return CredentialsApiFp(this.configuration).verifyCredential(credentialsVerifyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Search Assets
         * @summary Search Assets
         * @param {string} workspace The workspace name or id
         * @param {string} [q] query text
         * @param {string} [path] asset path prefix
         * @param {number} [limit] maximum number of results to return
         * @param {Array<string>} [teamspace] teamspace_id, limit results to assets of one or more teamspaces
         * @param {Array<string>} [filters] subexpressions for matching asset system fields {key}{op}{value} op one of: &lt; &gt; &lt;&#x3D; &gt;&#x3D; &#x3D; !&#x3D; 
         * @param {Array<string>} [metadata] subexpressions for matching user metadata {key}{op}{value} op one of: &lt; &gt; &lt;&#x3D; &gt;&#x3D; &#x3D; !&#x3D; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAssets: async (workspace: string, q?: string, path?: string, limit?: number, teamspace?: Array<string>, filters?: Array<string>, metadata?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('searchAssets', 'workspace', workspace)
            const localVarPath = `/assets/search/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (teamspace) {
                localVarQueryParameter['teamspace'] = teamspace;
            }

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (metadata) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Search Assets
         * @summary Search Assets
         * @param {string} workspace The workspace name or id
         * @param {string} [q] query text
         * @param {string} [path] asset path prefix
         * @param {number} [limit] maximum number of results to return
         * @param {Array<string>} [teamspace] teamspace_id, limit results to assets of one or more teamspaces
         * @param {Array<string>} [filters] subexpressions for matching asset system fields {key}{op}{value} op one of: &lt; &gt; &lt;&#x3D; &gt;&#x3D; &#x3D; !&#x3D; 
         * @param {Array<string>} [metadata] subexpressions for matching user metadata {key}{op}{value} op one of: &lt; &gt; &lt;&#x3D; &gt;&#x3D; &#x3D; !&#x3D; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAssets(workspace: string, q?: string, path?: string, limit?: number, teamspace?: Array<string>, filters?: Array<string>, metadata?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAssets(workspace, q, path, limit, teamspace, filters, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Search Assets
         * @summary Search Assets
         * @param {string} workspace The workspace name or id
         * @param {string} [q] query text
         * @param {string} [path] asset path prefix
         * @param {number} [limit] maximum number of results to return
         * @param {Array<string>} [teamspace] teamspace_id, limit results to assets of one or more teamspaces
         * @param {Array<string>} [filters] subexpressions for matching asset system fields {key}{op}{value} op one of: &lt; &gt; &lt;&#x3D; &gt;&#x3D; &#x3D; !&#x3D; 
         * @param {Array<string>} [metadata] subexpressions for matching user metadata {key}{op}{value} op one of: &lt; &gt; &lt;&#x3D; &gt;&#x3D; &#x3D; !&#x3D; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAssets(workspace: string, q?: string, path?: string, limit?: number, teamspace?: Array<string>, filters?: Array<string>, metadata?: Array<string>, options?: any): AxiosPromise<AssetListResponse> {
            return localVarFp.searchAssets(workspace, q, path, limit, teamspace, filters, metadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Search Assets
     * @summary Search Assets
     * @param {string} workspace The workspace name or id
     * @param {string} [q] query text
     * @param {string} [path] asset path prefix
     * @param {number} [limit] maximum number of results to return
     * @param {Array<string>} [teamspace] teamspace_id, limit results to assets of one or more teamspaces
     * @param {Array<string>} [filters] subexpressions for matching asset system fields {key}{op}{value} op one of: &lt; &gt; &lt;&#x3D; &gt;&#x3D; &#x3D; !&#x3D; 
     * @param {Array<string>} [metadata] subexpressions for matching user metadata {key}{op}{value} op one of: &lt; &gt; &lt;&#x3D; &gt;&#x3D; &#x3D; !&#x3D; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchAssets(workspace: string, q?: string, path?: string, limit?: number, teamspace?: Array<string>, filters?: Array<string>, metadata?: Array<string>, options?: any) {
        return DefaultApiFp(this.configuration).searchAssets(workspace, q, path, limit, teamspace, filters, metadata, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeltasharingApi - axios parameter creator
 * @export
 */
export const DeltasharingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This is the API to get the metadata of a share.
         * @summary get a delta share
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShare: async (workspace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getShare', 'workspace', workspace)
            const localVarPath = `/deltasharing/shares/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is the API to list tables in a schema.
         * @summary list delta share schema tables
         * @param {string} workspace The workspace name or id
         * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
         * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShareAllTables: async (workspace: string, maxResults?: number, pageToken?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('listShareAllTables', 'workspace', workspace)
            const localVarPath = `/deltasharing/shares/{workspace}/all-tables`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is the API to list tables in a schema.
         * @summary list delta share schema tables
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
         * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShareSchemaTables: async (workspace: string, teamspace: string, maxResults?: number, pageToken?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('listShareSchemaTables', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('listShareSchemaTables', 'teamspace', teamspace)
            const localVarPath = `/deltasharing/shares/{workspace}/schemas/{teamspace}/tables`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is the API to list schemas in a share.
         * @summary list delta share schemas
         * @param {string} workspace The workspace name or id
         * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
         * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShareSchemas: async (workspace: string, maxResults?: number, pageToken?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('listShareSchemas', 'workspace', workspace)
            const localVarPath = `/deltasharing/shares/{workspace}/schemas`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is the API to list shares accessible to a recipient.
         * @summary list delta shares
         * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
         * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShares: async (maxResults?: number, pageToken?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/deltasharing/shares`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is the API for clients to read data from a table.
         * @summary query table
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {QueryTableRequest} queryTableRequest query table request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTable: async (workspace: string, teamspace: string, asset: string, queryTableRequest: QueryTableRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('queryTable', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('queryTable', 'teamspace', teamspace)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('queryTable', 'asset', asset)
            // verify required parameter 'queryTableRequest' is not null or undefined
            assertParamExists('queryTable', 'queryTableRequest', queryTableRequest)
            const localVarPath = `/deltasharing/shares/{workspace}/schemas/{teamspace}/tables/{asset}/query`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(queryTableRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is the API for clients to read change data feed from a table.
         * @summary query table changes
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {number} [startingVersion] The starting version of the query, inclusive
         * @param {string} [startingTimestamp] The starting timestamp of the query, a string in the Timestamp Format, which will be converted to a version created greater or equal to this timestamp.
         * @param {number} [endingVersion] The ending version of the query, inclusive
         * @param {string} [endingTimestamp] The ending timestamp of the query, a string in the Timestamp Format, which will be converted to a version created earlier than or at the timestamp.
         * @param {boolean} [includeHistoricalMetadata] If set to true, return the historical metadata if seen in the delta log. This is for the streaming client to check if the table schema is still read compatible.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTableChanges: async (workspace: string, teamspace: string, asset: string, startingVersion?: number, startingTimestamp?: string, endingVersion?: number, endingTimestamp?: string, includeHistoricalMetadata?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('queryTableChanges', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('queryTableChanges', 'teamspace', teamspace)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('queryTableChanges', 'asset', asset)
            const localVarPath = `/deltasharing/shares/{workspace}/schemas/{teamspace}/tables/{asset}/changes`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (startingVersion !== undefined) {
                localVarQueryParameter['startingVersion'] = startingVersion;
            }

            if (startingTimestamp !== undefined) {
                localVarQueryParameter['startingTimestamp'] = startingTimestamp;
            }

            if (endingVersion !== undefined) {
                localVarQueryParameter['endingVersion'] = endingVersion;
            }

            if (endingTimestamp !== undefined) {
                localVarQueryParameter['endingTimestamp'] = endingTimestamp;
            }

            if (includeHistoricalMetadata !== undefined) {
                localVarQueryParameter['includeHistoricalMetadata'] = includeHistoricalMetadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is the API for clients to query the table schema and other metadata.
         * @summary fetch table metadata
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTableMetadata: async (workspace: string, teamspace: string, asset: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('queryTableMetadata', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('queryTableMetadata', 'teamspace', teamspace)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('queryTableMetadata', 'asset', asset)
            const localVarPath = `/deltasharing/shares/{workspace}/schemas/{teamspace}/tables/{asset}/metadata`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is the API for clients to get a table version without any other extra information
         * @summary fetch table version
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {string} [startingTimestamp] The startingTimestamp of the query, a string in the Timestamp Format, the server needs to return the earliest table version at or after the provided timestamp, can be earlier than the timestamp of table version 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTableVerison: async (workspace: string, teamspace: string, asset: string, startingTimestamp?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('queryTableVerison', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('queryTableVerison', 'teamspace', teamspace)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('queryTableVerison', 'asset', asset)
            const localVarPath = `/deltasharing/shares/{workspace}/schemas/{teamspace}/tables/{asset}/version`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"asset"}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (startingTimestamp !== undefined) {
                localVarQueryParameter['startingTimestamp'] = startingTimestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeltasharingApi - functional programming interface
 * @export
 */
export const DeltasharingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeltasharingApiAxiosParamCreator(configuration)
    return {
        /**
         * This is the API to get the metadata of a share.
         * @summary get a delta share
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShare(workspace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShare(workspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is the API to list tables in a schema.
         * @summary list delta share schema tables
         * @param {string} workspace The workspace name or id
         * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
         * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShareAllTables(workspace: string, maxResults?: number, pageToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTablesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShareAllTables(workspace, maxResults, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is the API to list tables in a schema.
         * @summary list delta share schema tables
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
         * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShareSchemaTables(workspace: string, teamspace: string, maxResults?: number, pageToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListShareSchemaTablesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShareSchemaTables(workspace, teamspace, maxResults, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is the API to list schemas in a share.
         * @summary list delta share schemas
         * @param {string} workspace The workspace name or id
         * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
         * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShareSchemas(workspace: string, maxResults?: number, pageToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListShareSchemasResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShareSchemas(workspace, maxResults, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is the API to list shares accessible to a recipient.
         * @summary list delta shares
         * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
         * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShares(maxResults?: number, pageToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSharesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShares(maxResults, pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is the API for clients to read data from a table.
         * @summary query table
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {QueryTableRequest} queryTableRequest query table request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryTable(workspace: string, teamspace: string, asset: string, queryTableRequest: QueryTableRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryTableResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryTable(workspace, teamspace, asset, queryTableRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is the API for clients to read change data feed from a table.
         * @summary query table changes
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {number} [startingVersion] The starting version of the query, inclusive
         * @param {string} [startingTimestamp] The starting timestamp of the query, a string in the Timestamp Format, which will be converted to a version created greater or equal to this timestamp.
         * @param {number} [endingVersion] The ending version of the query, inclusive
         * @param {string} [endingTimestamp] The ending timestamp of the query, a string in the Timestamp Format, which will be converted to a version created earlier than or at the timestamp.
         * @param {boolean} [includeHistoricalMetadata] If set to true, return the historical metadata if seen in the delta log. This is for the streaming client to check if the table schema is still read compatible.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryTableChanges(workspace: string, teamspace: string, asset: string, startingVersion?: number, startingTimestamp?: string, endingVersion?: number, endingTimestamp?: string, includeHistoricalMetadata?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryTableChangeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryTableChanges(workspace, teamspace, asset, startingVersion, startingTimestamp, endingVersion, endingTimestamp, includeHistoricalMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is the API for clients to query the table schema and other metadata.
         * @summary fetch table metadata
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryTableMetadata(workspace: string, teamspace: string, asset: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryTableMetadata(workspace, teamspace, asset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is the API for clients to get a table version without any other extra information
         * @summary fetch table version
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {string} [startingTimestamp] The startingTimestamp of the query, a string in the Timestamp Format, the server needs to return the earliest table version at or after the provided timestamp, can be earlier than the timestamp of table version 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryTableVerison(workspace: string, teamspace: string, asset: string, startingTimestamp?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryTableVerison(workspace, teamspace, asset, startingTimestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeltasharingApi - factory interface
 * @export
 */
export const DeltasharingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeltasharingApiFp(configuration)
    return {
        /**
         * This is the API to get the metadata of a share.
         * @summary get a delta share
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShare(workspace: string, options?: any): AxiosPromise<ShareResponse> {
            return localVarFp.getShare(workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * This is the API to list tables in a schema.
         * @summary list delta share schema tables
         * @param {string} workspace The workspace name or id
         * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
         * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShareAllTables(workspace: string, maxResults?: number, pageToken?: string, options?: any): AxiosPromise<ListTablesResponse> {
            return localVarFp.listShareAllTables(workspace, maxResults, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * This is the API to list tables in a schema.
         * @summary list delta share schema tables
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
         * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShareSchemaTables(workspace: string, teamspace: string, maxResults?: number, pageToken?: string, options?: any): AxiosPromise<ListShareSchemaTablesResponse> {
            return localVarFp.listShareSchemaTables(workspace, teamspace, maxResults, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * This is the API to list schemas in a share.
         * @summary list delta share schemas
         * @param {string} workspace The workspace name or id
         * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
         * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShareSchemas(workspace: string, maxResults?: number, pageToken?: string, options?: any): AxiosPromise<ListShareSchemasResponse> {
            return localVarFp.listShareSchemas(workspace, maxResults, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * This is the API to list shares accessible to a recipient.
         * @summary list delta shares
         * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
         * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShares(maxResults?: number, pageToken?: string, options?: any): AxiosPromise<ListSharesResponse> {
            return localVarFp.listShares(maxResults, pageToken, options).then((request) => request(axios, basePath));
        },
        /**
         * This is the API for clients to read data from a table.
         * @summary query table
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {QueryTableRequest} queryTableRequest query table request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTable(workspace: string, teamspace: string, asset: string, queryTableRequest: QueryTableRequest, options?: any): AxiosPromise<QueryTableResponse> {
            return localVarFp.queryTable(workspace, teamspace, asset, queryTableRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This is the API for clients to read change data feed from a table.
         * @summary query table changes
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {number} [startingVersion] The starting version of the query, inclusive
         * @param {string} [startingTimestamp] The starting timestamp of the query, a string in the Timestamp Format, which will be converted to a version created greater or equal to this timestamp.
         * @param {number} [endingVersion] The ending version of the query, inclusive
         * @param {string} [endingTimestamp] The ending timestamp of the query, a string in the Timestamp Format, which will be converted to a version created earlier than or at the timestamp.
         * @param {boolean} [includeHistoricalMetadata] If set to true, return the historical metadata if seen in the delta log. This is for the streaming client to check if the table schema is still read compatible.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTableChanges(workspace: string, teamspace: string, asset: string, startingVersion?: number, startingTimestamp?: string, endingVersion?: number, endingTimestamp?: string, includeHistoricalMetadata?: boolean, options?: any): AxiosPromise<QueryTableChangeResponse> {
            return localVarFp.queryTableChanges(workspace, teamspace, asset, startingVersion, startingTimestamp, endingVersion, endingTimestamp, includeHistoricalMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * This is the API for clients to query the table schema and other metadata.
         * @summary fetch table metadata
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTableMetadata(workspace: string, teamspace: string, asset: string, options?: any): AxiosPromise<TableMetadataResponse> {
            return localVarFp.queryTableMetadata(workspace, teamspace, asset, options).then((request) => request(axios, basePath));
        },
        /**
         * This is the API for clients to get a table version without any other extra information
         * @summary fetch table version
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} asset The asset id or path for which to retrieve assets
         * @param {string} [startingTimestamp] The startingTimestamp of the query, a string in the Timestamp Format, the server needs to return the earliest table version at or after the provided timestamp, can be earlier than the timestamp of table version 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTableVerison(workspace: string, teamspace: string, asset: string, startingTimestamp?: string, options?: any): AxiosPromise<void> {
            return localVarFp.queryTableVerison(workspace, teamspace, asset, startingTimestamp, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeltasharingApi - object-oriented interface
 * @export
 * @class DeltasharingApi
 * @extends {BaseAPI}
 */
export class DeltasharingApi extends BaseAPI {
    /**
     * This is the API to get the metadata of a share.
     * @summary get a delta share
     * @param {string} workspace The workspace name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltasharingApi
     */
    public getShare(workspace: string, options?: any) {
        return DeltasharingApiFp(this.configuration).getShare(workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is the API to list tables in a schema.
     * @summary list delta share schema tables
     * @param {string} workspace The workspace name or id
     * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
     * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltasharingApi
     */
    public listShareAllTables(workspace: string, maxResults?: number, pageToken?: string, options?: any) {
        return DeltasharingApiFp(this.configuration).listShareAllTables(workspace, maxResults, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is the API to list tables in a schema.
     * @summary list delta share schema tables
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
     * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltasharingApi
     */
    public listShareSchemaTables(workspace: string, teamspace: string, maxResults?: number, pageToken?: string, options?: any) {
        return DeltasharingApiFp(this.configuration).listShareSchemaTables(workspace, teamspace, maxResults, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is the API to list schemas in a share.
     * @summary list delta share schemas
     * @param {string} workspace The workspace name or id
     * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
     * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltasharingApi
     */
    public listShareSchemas(workspace: string, maxResults?: number, pageToken?: string, options?: any) {
        return DeltasharingApiFp(this.configuration).listShareSchemas(workspace, maxResults, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is the API to list shares accessible to a recipient.
     * @summary list delta shares
     * @param {number} [maxResults] The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, the response will provide a nextPageToken that can be used to get the next page of results in subsequent list requests. The server may return fewer than maxResults items even if there are more available. The client should check nextPageToken in the response to determine if there are more available. Must be non-negative. 0 will return no results but nextPageToken may be populated.
     * @param {string} [pageToken] Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results. nextPageToken will not be returned in a response if there are no more results available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltasharingApi
     */
    public listShares(maxResults?: number, pageToken?: string, options?: any) {
        return DeltasharingApiFp(this.configuration).listShares(maxResults, pageToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is the API for clients to read data from a table.
     * @summary query table
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} asset The asset id or path for which to retrieve assets
     * @param {QueryTableRequest} queryTableRequest query table request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltasharingApi
     */
    public queryTable(workspace: string, teamspace: string, asset: string, queryTableRequest: QueryTableRequest, options?: any) {
        return DeltasharingApiFp(this.configuration).queryTable(workspace, teamspace, asset, queryTableRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is the API for clients to read change data feed from a table.
     * @summary query table changes
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} asset The asset id or path for which to retrieve assets
     * @param {number} [startingVersion] The starting version of the query, inclusive
     * @param {string} [startingTimestamp] The starting timestamp of the query, a string in the Timestamp Format, which will be converted to a version created greater or equal to this timestamp.
     * @param {number} [endingVersion] The ending version of the query, inclusive
     * @param {string} [endingTimestamp] The ending timestamp of the query, a string in the Timestamp Format, which will be converted to a version created earlier than or at the timestamp.
     * @param {boolean} [includeHistoricalMetadata] If set to true, return the historical metadata if seen in the delta log. This is for the streaming client to check if the table schema is still read compatible.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltasharingApi
     */
    public queryTableChanges(workspace: string, teamspace: string, asset: string, startingVersion?: number, startingTimestamp?: string, endingVersion?: number, endingTimestamp?: string, includeHistoricalMetadata?: boolean, options?: any) {
        return DeltasharingApiFp(this.configuration).queryTableChanges(workspace, teamspace, asset, startingVersion, startingTimestamp, endingVersion, endingTimestamp, includeHistoricalMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is the API for clients to query the table schema and other metadata.
     * @summary fetch table metadata
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} asset The asset id or path for which to retrieve assets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltasharingApi
     */
    public queryTableMetadata(workspace: string, teamspace: string, asset: string, options?: any) {
        return DeltasharingApiFp(this.configuration).queryTableMetadata(workspace, teamspace, asset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is the API for clients to get a table version without any other extra information
     * @summary fetch table version
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} asset The asset id or path for which to retrieve assets
     * @param {string} [startingTimestamp] The startingTimestamp of the query, a string in the Timestamp Format, the server needs to return the earliest table version at or after the provided timestamp, can be earlier than the timestamp of table version 0.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltasharingApi
     */
    public queryTableVerison(workspace: string, teamspace: string, asset: string, startingTimestamp?: string, options?: any) {
        return DeltasharingApiFp(this.configuration).queryTableVerison(workspace, teamspace, asset, startingTimestamp, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * End point to download the file at the given path 
         * @summary Download the file at the given path
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path to the file
         * @param {string} [range] The range of bytes to fetch. Supports only single ranges.
         * @param {boolean} [presigned] If true, returns a presigned S3 URL instead of the file contents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileGet: async (workspace: string, teamspace: string, path: string, range?: string, presigned?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('fileGet', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('fileGet', 'teamspace', teamspace)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('fileGet', 'path', path)
            const localVarPath = `/files/{workspace}/{teamspace}/{path}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (presigned !== undefined) {
                localVarQueryParameter['presigned'] = presigned;
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = String(range);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End point to get information about the file at the given path 
         * @summary Get information about the file at the given path
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path to the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileHead: async (workspace: string, teamspace: string, path: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('fileHead', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('fileHead', 'teamspace', teamspace)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('fileHead', 'path', path)
            const localVarPath = `/files/{workspace}/{teamspace}/{path}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End point to list files and folders for the passed teamspace 
         * @summary List folders and files contained in a folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {number} listType Required for S3 API compatibility, must be set to 2.
         * @param {string} delimiter The string that delimits the path segments. Only forward slash is supported
         * @param {string} [prefix] The directory of files to list.
         * @param {number} [maxKeys] The maximum number of items to return.
         * @param {string} [continuationToken] Used to resume an incomplete list operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderList: async (workspace: string, teamspace: string, listType: number, delimiter: string, prefix?: string, maxKeys?: number, continuationToken?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('folderList', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('folderList', 'teamspace', teamspace)
            // verify required parameter 'listType' is not null or undefined
            assertParamExists('folderList', 'listType', listType)
            // verify required parameter 'delimiter' is not null or undefined
            assertParamExists('folderList', 'delimiter', delimiter)
            const localVarPath = `/files/{workspace}/{teamspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (listType !== undefined) {
                localVarQueryParameter['list-type'] = listType;
            }

            if (delimiter !== undefined) {
                localVarQueryParameter['delimiter'] = delimiter;
            }

            if (maxKeys !== undefined) {
                localVarQueryParameter['max-keys'] = maxKeys;
            }

            if (continuationToken !== undefined) {
                localVarQueryParameter['continuation-token'] = continuationToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a part in a multipart upload session.
         * @summary Upload Part
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path to the file
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPart: async (workspace: string, teamspace: string, path: string, body: File, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('uploadPart', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('uploadPart', 'teamspace', teamspace)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('uploadPart', 'path', path)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadPart', 'body', body)
            const localVarPath = `/files/{workspace}/{teamspace}/{path}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * End point to download the file at the given path 
         * @summary Download the file at the given path
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path to the file
         * @param {string} [range] The range of bytes to fetch. Supports only single ranges.
         * @param {boolean} [presigned] If true, returns a presigned S3 URL instead of the file contents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileGet(workspace: string, teamspace: string, path: string, range?: string, presigned?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilePresignedURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileGet(workspace, teamspace, path, range, presigned, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * End point to get information about the file at the given path 
         * @summary Get information about the file at the given path
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path to the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileHead(workspace: string, teamspace: string, path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileHead(workspace, teamspace, path, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * End point to list files and folders for the passed teamspace 
         * @summary List folders and files contained in a folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {number} listType Required for S3 API compatibility, must be set to 2.
         * @param {string} delimiter The string that delimits the path segments. Only forward slash is supported
         * @param {string} [prefix] The directory of files to list.
         * @param {number} [maxKeys] The maximum number of items to return.
         * @param {string} [continuationToken] Used to resume an incomplete list operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderList(workspace: string, teamspace: string, listType: number, delimiter: string, prefix?: string, maxKeys?: number, continuationToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderList(workspace, teamspace, listType, delimiter, prefix, maxKeys, continuationToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Uploads a part in a multipart upload session.
         * @summary Upload Part
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path to the file
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPart(workspace: string, teamspace: string, path: string, body: File, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPart(workspace, teamspace, path, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * End point to download the file at the given path 
         * @summary Download the file at the given path
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path to the file
         * @param {string} [range] The range of bytes to fetch. Supports only single ranges.
         * @param {boolean} [presigned] If true, returns a presigned S3 URL instead of the file contents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileGet(workspace: string, teamspace: string, path: string, range?: string, presigned?: boolean, options?: any): AxiosPromise<FilePresignedURLResponse> {
            return localVarFp.fileGet(workspace, teamspace, path, range, presigned, options).then((request) => request(axios, basePath));
        },
        /**
         * End point to get information about the file at the given path 
         * @summary Get information about the file at the given path
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path to the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileHead(workspace: string, teamspace: string, path: string, options?: any): AxiosPromise<File> {
            return localVarFp.fileHead(workspace, teamspace, path, options).then((request) => request(axios, basePath));
        },
        /**
         * End point to list files and folders for the passed teamspace 
         * @summary List folders and files contained in a folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {number} listType Required for S3 API compatibility, must be set to 2.
         * @param {string} delimiter The string that delimits the path segments. Only forward slash is supported
         * @param {string} [prefix] The directory of files to list.
         * @param {number} [maxKeys] The maximum number of items to return.
         * @param {string} [continuationToken] Used to resume an incomplete list operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderList(workspace: string, teamspace: string, listType: number, delimiter: string, prefix?: string, maxKeys?: number, continuationToken?: string, options?: any): AxiosPromise<FileListResponse> {
            return localVarFp.folderList(workspace, teamspace, listType, delimiter, prefix, maxKeys, continuationToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a part in a multipart upload session.
         * @summary Upload Part
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} path The path to the file
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPart(workspace: string, teamspace: string, path: string, body: File, options?: any): AxiosPromise<void> {
            return localVarFp.uploadPart(workspace, teamspace, path, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * End point to download the file at the given path 
     * @summary Download the file at the given path
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} path The path to the file
     * @param {string} [range] The range of bytes to fetch. Supports only single ranges.
     * @param {boolean} [presigned] If true, returns a presigned S3 URL instead of the file contents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public fileGet(workspace: string, teamspace: string, path: string, range?: string, presigned?: boolean, options?: any) {
        return FilesApiFp(this.configuration).fileGet(workspace, teamspace, path, range, presigned, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End point to get information about the file at the given path 
     * @summary Get information about the file at the given path
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} path The path to the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public fileHead(workspace: string, teamspace: string, path: string, options?: any) {
        return FilesApiFp(this.configuration).fileHead(workspace, teamspace, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End point to list files and folders for the passed teamspace 
     * @summary List folders and files contained in a folder
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {number} listType Required for S3 API compatibility, must be set to 2.
     * @param {string} delimiter The string that delimits the path segments. Only forward slash is supported
     * @param {string} [prefix] The directory of files to list.
     * @param {number} [maxKeys] The maximum number of items to return.
     * @param {string} [continuationToken] Used to resume an incomplete list operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public folderList(workspace: string, teamspace: string, listType: number, delimiter: string, prefix?: string, maxKeys?: number, continuationToken?: string, options?: any) {
        return FilesApiFp(this.configuration).folderList(workspace, teamspace, listType, delimiter, prefix, maxKeys, continuationToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a part in a multipart upload session.
     * @summary Upload Part
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} path The path to the file
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public uploadPart(workspace: string, teamspace: string, path: string, body: File, options?: any) {
        return FilesApiFp(this.configuration).uploadPart(workspace, teamspace, path, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FoldersApi - axios parameter creator
 * @export
 */
export const FoldersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new folder in the given teamspace 
         * @summary Create a folder in the given teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {FolderCreateRequestInner} folderCreateRequestInner folder to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (workspace: string, teamspace: string, folder: string, folderCreateRequestInner: FolderCreateRequestInner, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createFolder', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('createFolder', 'teamspace', teamspace)
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('createFolder', 'folder', folder)
            // verify required parameter 'folderCreateRequestInner' is not null or undefined
            assertParamExists('createFolder', 'folderCreateRequestInner', folderCreateRequestInner)
            const localVarPath = `/folders/{workspace}/{teamspace}/{folder}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(folderCreateRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a folder
         * @summary Delete a folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {boolean} [deleteAssets] If &#x60;true&#x60;, the entity\&#39;s assets will be deregistered in TileDB *and* deleted from the underlying storage (e.g., S3). If &#x60;false&#x60;, the entity\&#39;s assets will be deregistered in TileDB but remain in the underlying storage. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder: async (workspace: string, teamspace: string, folder: string, deleteAssets?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteFolder', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('deleteFolder', 'teamspace', teamspace)
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('deleteFolder', 'folder', folder)
            const localVarPath = `/folders/{workspace}/{teamspace}/{folder}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (deleteAssets !== undefined) {
                localVarQueryParameter['delete-assets'] = deleteAssets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the given folder\'s content
         * @summary Retrieve a folder\'s content
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder: async (workspace: string, teamspace: string, folder: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getFolder', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('getFolder', 'teamspace', teamspace)
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getFolder', 'folder', folder)
            const localVarPath = `/folders/{workspace}/{teamspace}/{folder}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the given folder
         * @summary Retrieve a folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderContents: async (workspace: string, teamspace: string, folder: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getFolderContents', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('getFolderContents', 'teamspace', teamspace)
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('getFolderContents', 'folder', folder)
            const localVarPath = `/folders/{workspace}/{teamspace}/{folder}/contents`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or remove assets under a folder 
         * @summary Add or remove assets under a folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {FoldersContentsModifyInner} foldersContentsModifyInner assets to add or remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyFolderContents: async (workspace: string, teamspace: string, folder: string, foldersContentsModifyInner: FoldersContentsModifyInner, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('modifyFolderContents', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('modifyFolderContents', 'teamspace', teamspace)
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('modifyFolderContents', 'folder', folder)
            // verify required parameter 'foldersContentsModifyInner' is not null or undefined
            assertParamExists('modifyFolderContents', 'foldersContentsModifyInner', foldersContentsModifyInner)
            const localVarPath = `/folders/{workspace}/{teamspace}/{folder}/contents`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(foldersContentsModifyInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a folder
         * @summary Update the given folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {FolderUpdateRequest} folderUpdateRequest The request body containing the folder to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolder: async (workspace: string, teamspace: string, folder: string, folderUpdateRequest: FolderUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateFolder', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('updateFolder', 'teamspace', teamspace)
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('updateFolder', 'folder', folder)
            // verify required parameter 'folderUpdateRequest' is not null or undefined
            assertParamExists('updateFolder', 'folderUpdateRequest', folderUpdateRequest)
            const localVarPath = `/folders/{workspace}/{teamspace}/{folder}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"folder"}}`, encodeURIComponent(String(folder)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(folderUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoldersApi - functional programming interface
 * @export
 */
export const FoldersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoldersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new folder in the given teamspace 
         * @summary Create a folder in the given teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {FolderCreateRequestInner} folderCreateRequestInner folder to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(workspace: string, teamspace: string, folder: string, folderCreateRequestInner: FolderCreateRequestInner, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(workspace, teamspace, folder, folderCreateRequestInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete a folder
         * @summary Delete a folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {boolean} [deleteAssets] If &#x60;true&#x60;, the entity\&#39;s assets will be deregistered in TileDB *and* deleted from the underlying storage (e.g., S3). If &#x60;false&#x60;, the entity\&#39;s assets will be deregistered in TileDB but remain in the underlying storage. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolder(workspace: string, teamspace: string, folder: string, deleteAssets?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolder(workspace, teamspace, folder, deleteAssets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the given folder\'s content
         * @summary Retrieve a folder\'s content
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolder(workspace: string, teamspace: string, folder: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(workspace, teamspace, folder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the given folder
         * @summary Retrieve a folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderContents(workspace: string, teamspace: string, folder: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderContentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderContents(workspace, teamspace, folder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add or remove assets under a folder 
         * @summary Add or remove assets under a folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {FoldersContentsModifyInner} foldersContentsModifyInner assets to add or remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyFolderContents(workspace: string, teamspace: string, folder: string, foldersContentsModifyInner: FoldersContentsModifyInner, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyFolderContents(workspace, teamspace, folder, foldersContentsModifyInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a folder
         * @summary Update the given folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {FolderUpdateRequest} folderUpdateRequest The request body containing the folder to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFolder(workspace: string, teamspace: string, folder: string, folderUpdateRequest: FolderUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFolder(workspace, teamspace, folder, folderUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FoldersApi - factory interface
 * @export
 */
export const FoldersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoldersApiFp(configuration)
    return {
        /**
         * Create a new folder in the given teamspace 
         * @summary Create a folder in the given teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {FolderCreateRequestInner} folderCreateRequestInner folder to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(workspace: string, teamspace: string, folder: string, folderCreateRequestInner: FolderCreateRequestInner, options?: any): AxiosPromise<FolderCreateResponse> {
            return localVarFp.createFolder(workspace, teamspace, folder, folderCreateRequestInner, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a folder
         * @summary Delete a folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {boolean} [deleteAssets] If &#x60;true&#x60;, the entity\&#39;s assets will be deregistered in TileDB *and* deleted from the underlying storage (e.g., S3). If &#x60;false&#x60;, the entity\&#39;s assets will be deregistered in TileDB but remain in the underlying storage. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder(workspace: string, teamspace: string, folder: string, deleteAssets?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFolder(workspace, teamspace, folder, deleteAssets, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the given folder\'s content
         * @summary Retrieve a folder\'s content
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder(workspace: string, teamspace: string, folder: string, options?: any): AxiosPromise<FolderGetResponse> {
            return localVarFp.getFolder(workspace, teamspace, folder, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the given folder
         * @summary Retrieve a folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderContents(workspace: string, teamspace: string, folder: string, options?: any): AxiosPromise<FolderContentsResponse> {
            return localVarFp.getFolderContents(workspace, teamspace, folder, options).then((request) => request(axios, basePath));
        },
        /**
         * Add or remove assets under a folder 
         * @summary Add or remove assets under a folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {FoldersContentsModifyInner} foldersContentsModifyInner assets to add or remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyFolderContents(workspace: string, teamspace: string, folder: string, foldersContentsModifyInner: FoldersContentsModifyInner, options?: any): AxiosPromise<void> {
            return localVarFp.modifyFolderContents(workspace, teamspace, folder, foldersContentsModifyInner, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a folder
         * @summary Update the given folder
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} folder The path to the folder or the folder\&#39;s assetID
         * @param {FolderUpdateRequest} folderUpdateRequest The request body containing the folder to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolder(workspace: string, teamspace: string, folder: string, folderUpdateRequest: FolderUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateFolder(workspace, teamspace, folder, folderUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
export class FoldersApi extends BaseAPI {
    /**
     * Create a new folder in the given teamspace 
     * @summary Create a folder in the given teamspace
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} folder The path to the folder or the folder\&#39;s assetID
     * @param {FolderCreateRequestInner} folderCreateRequestInner folder to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public createFolder(workspace: string, teamspace: string, folder: string, folderCreateRequestInner: FolderCreateRequestInner, options?: any) {
        return FoldersApiFp(this.configuration).createFolder(workspace, teamspace, folder, folderCreateRequestInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a folder
     * @summary Delete a folder
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} folder The path to the folder or the folder\&#39;s assetID
     * @param {boolean} [deleteAssets] If &#x60;true&#x60;, the entity\&#39;s assets will be deregistered in TileDB *and* deleted from the underlying storage (e.g., S3). If &#x60;false&#x60;, the entity\&#39;s assets will be deregistered in TileDB but remain in the underlying storage. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public deleteFolder(workspace: string, teamspace: string, folder: string, deleteAssets?: boolean, options?: any) {
        return FoldersApiFp(this.configuration).deleteFolder(workspace, teamspace, folder, deleteAssets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the given folder\'s content
     * @summary Retrieve a folder\'s content
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} folder The path to the folder or the folder\&#39;s assetID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolder(workspace: string, teamspace: string, folder: string, options?: any) {
        return FoldersApiFp(this.configuration).getFolder(workspace, teamspace, folder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the given folder
     * @summary Retrieve a folder
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} folder The path to the folder or the folder\&#39;s assetID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolderContents(workspace: string, teamspace: string, folder: string, options?: any) {
        return FoldersApiFp(this.configuration).getFolderContents(workspace, teamspace, folder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add or remove assets under a folder 
     * @summary Add or remove assets under a folder
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} folder The path to the folder or the folder\&#39;s assetID
     * @param {FoldersContentsModifyInner} foldersContentsModifyInner assets to add or remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public modifyFolderContents(workspace: string, teamspace: string, folder: string, foldersContentsModifyInner: FoldersContentsModifyInner, options?: any) {
        return FoldersApiFp(this.configuration).modifyFolderContents(workspace, teamspace, folder, foldersContentsModifyInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a folder
     * @summary Update the given folder
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} folder The path to the folder or the folder\&#39;s assetID
     * @param {FolderUpdateRequest} folderUpdateRequest The request body containing the folder to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public updateFolder(workspace: string, teamspace: string, folder: string, folderUpdateRequest: FolderUpdateRequest, options?: any) {
        return FoldersApiFp(this.configuration).updateFolder(workspace, teamspace, folder, folderUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GeneralspacesApi - axios parameter creator
 * @export
 */
export const GeneralspacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the given general space
         * @summary Retrieve a generalspace
         * @param {string} workspace The workspace name or id
         * @param {string} generalspace The generalspace id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralSpace: async (workspace: string, generalspace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getGeneralSpace', 'workspace', workspace)
            // verify required parameter 'generalspace' is not null or undefined
            assertParamExists('getGeneralSpace', 'generalspace', generalspace)
            const localVarPath = `/generalspaces/{workspace}/{generalspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"generalspace"}}`, encodeURIComponent(String(generalspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the given general space
         * @summary Retrieve a generalspace
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralspaceByWorkspace: async (workspace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getGeneralspaceByWorkspace', 'workspace', workspace)
            const localVarPath = `/generalspaces/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a generalspace
         * @summary Update the given generalspace
         * @param {string} workspace The workspace name or id
         * @param {string} generalspace The generalspace id or name
         * @param {GeneralspaceUpdateRequest} generalspaceUpdateRequest The request body containing the generalspace to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGeneralspaceByID: async (workspace: string, generalspace: string, generalspaceUpdateRequest: GeneralspaceUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateGeneralspaceByID', 'workspace', workspace)
            // verify required parameter 'generalspace' is not null or undefined
            assertParamExists('updateGeneralspaceByID', 'generalspace', generalspace)
            // verify required parameter 'generalspaceUpdateRequest' is not null or undefined
            assertParamExists('updateGeneralspaceByID', 'generalspaceUpdateRequest', generalspaceUpdateRequest)
            const localVarPath = `/generalspaces/{workspace}/{generalspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"generalspace"}}`, encodeURIComponent(String(generalspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(generalspaceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a generalspace
         * @summary Update the given generalspace
         * @param {string} workspace The workspace name or id
         * @param {GeneralspaceUpdateRequest} generalspaceUpdateRequest The request body containing the generalspace to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGeneralspaceByWorkspace: async (workspace: string, generalspaceUpdateRequest: GeneralspaceUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateGeneralspaceByWorkspace', 'workspace', workspace)
            // verify required parameter 'generalspaceUpdateRequest' is not null or undefined
            assertParamExists('updateGeneralspaceByWorkspace', 'generalspaceUpdateRequest', generalspaceUpdateRequest)
            const localVarPath = `/generalspaces/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(generalspaceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeneralspacesApi - functional programming interface
 * @export
 */
export const GeneralspacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeneralspacesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the given general space
         * @summary Retrieve a generalspace
         * @param {string} workspace The workspace name or id
         * @param {string} generalspace The generalspace id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneralSpace(workspace: string, generalspace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralspaceGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeneralSpace(workspace, generalspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the given general space
         * @summary Retrieve a generalspace
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneralspaceByWorkspace(workspace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneralspaceGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeneralspaceByWorkspace(workspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a generalspace
         * @summary Update the given generalspace
         * @param {string} workspace The workspace name or id
         * @param {string} generalspace The generalspace id or name
         * @param {GeneralspaceUpdateRequest} generalspaceUpdateRequest The request body containing the generalspace to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGeneralspaceByID(workspace: string, generalspace: string, generalspaceUpdateRequest: GeneralspaceUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGeneralspaceByID(workspace, generalspace, generalspaceUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a generalspace
         * @summary Update the given generalspace
         * @param {string} workspace The workspace name or id
         * @param {GeneralspaceUpdateRequest} generalspaceUpdateRequest The request body containing the generalspace to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGeneralspaceByWorkspace(workspace: string, generalspaceUpdateRequest: GeneralspaceUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGeneralspaceByWorkspace(workspace, generalspaceUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GeneralspacesApi - factory interface
 * @export
 */
export const GeneralspacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeneralspacesApiFp(configuration)
    return {
        /**
         * Retrieve the given general space
         * @summary Retrieve a generalspace
         * @param {string} workspace The workspace name or id
         * @param {string} generalspace The generalspace id or name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralSpace(workspace: string, generalspace: string, options?: any): AxiosPromise<GeneralspaceGetResponse> {
            return localVarFp.getGeneralSpace(workspace, generalspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the given general space
         * @summary Retrieve a generalspace
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralspaceByWorkspace(workspace: string, options?: any): AxiosPromise<GeneralspaceGetResponse> {
            return localVarFp.getGeneralspaceByWorkspace(workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a generalspace
         * @summary Update the given generalspace
         * @param {string} workspace The workspace name or id
         * @param {string} generalspace The generalspace id or name
         * @param {GeneralspaceUpdateRequest} generalspaceUpdateRequest The request body containing the generalspace to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGeneralspaceByID(workspace: string, generalspace: string, generalspaceUpdateRequest: GeneralspaceUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateGeneralspaceByID(workspace, generalspace, generalspaceUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a generalspace
         * @summary Update the given generalspace
         * @param {string} workspace The workspace name or id
         * @param {GeneralspaceUpdateRequest} generalspaceUpdateRequest The request body containing the generalspace to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGeneralspaceByWorkspace(workspace: string, generalspaceUpdateRequest: GeneralspaceUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateGeneralspaceByWorkspace(workspace, generalspaceUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeneralspacesApi - object-oriented interface
 * @export
 * @class GeneralspacesApi
 * @extends {BaseAPI}
 */
export class GeneralspacesApi extends BaseAPI {
    /**
     * Retrieve the given general space
     * @summary Retrieve a generalspace
     * @param {string} workspace The workspace name or id
     * @param {string} generalspace The generalspace id or name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralspacesApi
     */
    public getGeneralSpace(workspace: string, generalspace: string, options?: any) {
        return GeneralspacesApiFp(this.configuration).getGeneralSpace(workspace, generalspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the given general space
     * @summary Retrieve a generalspace
     * @param {string} workspace The workspace name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralspacesApi
     */
    public getGeneralspaceByWorkspace(workspace: string, options?: any) {
        return GeneralspacesApiFp(this.configuration).getGeneralspaceByWorkspace(workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a generalspace
     * @summary Update the given generalspace
     * @param {string} workspace The workspace name or id
     * @param {string} generalspace The generalspace id or name
     * @param {GeneralspaceUpdateRequest} generalspaceUpdateRequest The request body containing the generalspace to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralspacesApi
     */
    public updateGeneralspaceByID(workspace: string, generalspace: string, generalspaceUpdateRequest: GeneralspaceUpdateRequest, options?: any) {
        return GeneralspacesApiFp(this.configuration).updateGeneralspaceByID(workspace, generalspace, generalspaceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a generalspace
     * @summary Update the given generalspace
     * @param {string} workspace The workspace name or id
     * @param {GeneralspaceUpdateRequest} generalspaceUpdateRequest The request body containing the generalspace to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralspacesApi
     */
    public updateGeneralspaceByWorkspace(workspace: string, generalspaceUpdateRequest: GeneralspaceUpdateRequest, options?: any) {
        return GeneralspacesApiFp(this.configuration).updateGeneralspaceByWorkspace(workspace, generalspaceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * End point to get the given workspace 
         * @summary Retrieves the given image
         * @param {string} imageId The image id in the form img_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage: async (imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getImage', 'imageId', imageId)
            const localVarPath = `/static/images/{image_id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * End point to get the given workspace 
         * @summary Retrieves the given image
         * @param {string} imageId The image id in the form img_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImage(imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImage(imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * End point to get the given workspace 
         * @summary Retrieves the given image
         * @param {string} imageId The image id in the form img_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage(imageId: string, options?: any): AxiosPromise<File> {
            return localVarFp.getImage(imageId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     * End point to get the given workspace 
     * @summary Retrieves the given image
     * @param {string} imageId The image id in the form img_9m4e2mr0ui3e8a215n4g
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public getImage(imageId: string, options?: any) {
        return ImagesApiFp(this.configuration).getImage(imageId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvitationsApi - axios parameter creator
 * @export
 */
export const InvitationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create one or more invitations
         * @summary Create one or more invitations
         * @param {string} workspace The workspace name or id
         * @param {Array<InvitationsCreateRequestInner>} invitationsCreateRequestInner The request body containing the invitation to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvitations: async (workspace: string, invitationsCreateRequestInner: Array<InvitationsCreateRequestInner>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createInvitations', 'workspace', workspace)
            // verify required parameter 'invitationsCreateRequestInner' is not null or undefined
            assertParamExists('createInvitations', 'invitationsCreateRequestInner', invitationsCreateRequestInner)
            const localVarPath = `/invitations/admin/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(invitationsCreateRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invitee retrieves an invitation
         * @summary Retrieve an invitation
         * @param {string} invitationId The invitation ID in the form inv_9m4e2mr0ui3e8a215n4g
         * @param {InvitationRetrieveRequest} invitationRetrieveRequest The request body for retrieving an invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitation: async (invitationId: string, invitationRetrieveRequest: InvitationRetrieveRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invitationId' is not null or undefined
            assertParamExists('getInvitation', 'invitationId', invitationId)
            // verify required parameter 'invitationRetrieveRequest' is not null or undefined
            assertParamExists('getInvitation', 'invitationRetrieveRequest', invitationRetrieveRequest)
            const localVarPath = `/invitations/{invitation_id}`
                .replace(`{${"invitation_id"}}`, encodeURIComponent(String(invitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(invitationRetrieveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all invitations that the user has sent
         * @summary Retrieve all sent invitations
         * @param {string} workspace The workspace name or id
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitations: async (workspace: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('listInvitations', 'workspace', workspace)
            const localVarPath = `/invitations/admin/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invitee responds to an invitation
         * @summary Respond to an invitation
         * @param {string} invitationId The invitation ID in the form inv_9m4e2mr0ui3e8a215n4g
         * @param {InvitationRespondRequest} invitationRespondRequest The request body for responding to an invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondInvitation: async (invitationId: string, invitationRespondRequest: InvitationRespondRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invitationId' is not null or undefined
            assertParamExists('respondInvitation', 'invitationId', invitationId)
            // verify required parameter 'invitationRespondRequest' is not null or undefined
            assertParamExists('respondInvitation', 'invitationRespondRequest', invitationRespondRequest)
            const localVarPath = `/invitations/{invitation_id}`
                .replace(`{${"invitation_id"}}`, encodeURIComponent(String(invitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(invitationRespondRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inviter revokes a previously-sent invitation
         * @summary Revoke an invitation
         * @param {string} workspace The workspace name or id
         * @param {string} invitationId The invitation ID in the form inv_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeInvitation: async (workspace: string, invitationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('revokeInvitation', 'workspace', workspace)
            // verify required parameter 'invitationId' is not null or undefined
            assertParamExists('revokeInvitation', 'invitationId', invitationId)
            const localVarPath = `/invitations/admin/{workspace}/{invitation_id}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"invitation_id"}}`, encodeURIComponent(String(invitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitationsApi - functional programming interface
 * @export
 */
export const InvitationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create one or more invitations
         * @summary Create one or more invitations
         * @param {string} workspace The workspace name or id
         * @param {Array<InvitationsCreateRequestInner>} invitationsCreateRequestInner The request body containing the invitation to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvitations(workspace: string, invitationsCreateRequestInner: Array<InvitationsCreateRequestInner>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvitations(workspace, invitationsCreateRequestInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Invitee retrieves an invitation
         * @summary Retrieve an invitation
         * @param {string} invitationId The invitation ID in the form inv_9m4e2mr0ui3e8a215n4g
         * @param {InvitationRetrieveRequest} invitationRetrieveRequest The request body for retrieving an invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvitation(invitationId: string, invitationRetrieveRequest: InvitationRetrieveRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvitationRetrieveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvitation(invitationId, invitationRetrieveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all invitations that the user has sent
         * @summary Retrieve all sent invitations
         * @param {string} workspace The workspace name or id
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvitations(workspace: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvitationsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInvitations(workspace, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Invitee responds to an invitation
         * @summary Respond to an invitation
         * @param {string} invitationId The invitation ID in the form inv_9m4e2mr0ui3e8a215n4g
         * @param {InvitationRespondRequest} invitationRespondRequest The request body for responding to an invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async respondInvitation(invitationId: string, invitationRespondRequest: InvitationRespondRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.respondInvitation(invitationId, invitationRespondRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inviter revokes a previously-sent invitation
         * @summary Revoke an invitation
         * @param {string} workspace The workspace name or id
         * @param {string} invitationId The invitation ID in the form inv_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeInvitation(workspace: string, invitationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeInvitation(workspace, invitationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvitationsApi - factory interface
 * @export
 */
export const InvitationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitationsApiFp(configuration)
    return {
        /**
         * Create one or more invitations
         * @summary Create one or more invitations
         * @param {string} workspace The workspace name or id
         * @param {Array<InvitationsCreateRequestInner>} invitationsCreateRequestInner The request body containing the invitation to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvitations(workspace: string, invitationsCreateRequestInner: Array<InvitationsCreateRequestInner>, options?: any): AxiosPromise<void> {
            return localVarFp.createInvitations(workspace, invitationsCreateRequestInner, options).then((request) => request(axios, basePath));
        },
        /**
         * Invitee retrieves an invitation
         * @summary Retrieve an invitation
         * @param {string} invitationId The invitation ID in the form inv_9m4e2mr0ui3e8a215n4g
         * @param {InvitationRetrieveRequest} invitationRetrieveRequest The request body for retrieving an invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitation(invitationId: string, invitationRetrieveRequest: InvitationRetrieveRequest, options?: any): AxiosPromise<InvitationRetrieveResponse> {
            return localVarFp.getInvitation(invitationId, invitationRetrieveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all invitations that the user has sent
         * @summary Retrieve all sent invitations
         * @param {string} workspace The workspace name or id
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitations(workspace: string, page?: number, perPage?: number, options?: any): AxiosPromise<InvitationsListResponse> {
            return localVarFp.listInvitations(workspace, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Invitee responds to an invitation
         * @summary Respond to an invitation
         * @param {string} invitationId The invitation ID in the form inv_9m4e2mr0ui3e8a215n4g
         * @param {InvitationRespondRequest} invitationRespondRequest The request body for responding to an invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondInvitation(invitationId: string, invitationRespondRequest: InvitationRespondRequest, options?: any): AxiosPromise<void> {
            return localVarFp.respondInvitation(invitationId, invitationRespondRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Inviter revokes a previously-sent invitation
         * @summary Revoke an invitation
         * @param {string} workspace The workspace name or id
         * @param {string} invitationId The invitation ID in the form inv_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeInvitation(workspace: string, invitationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.revokeInvitation(workspace, invitationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitationsApi - object-oriented interface
 * @export
 * @class InvitationsApi
 * @extends {BaseAPI}
 */
export class InvitationsApi extends BaseAPI {
    /**
     * Create one or more invitations
     * @summary Create one or more invitations
     * @param {string} workspace The workspace name or id
     * @param {Array<InvitationsCreateRequestInner>} invitationsCreateRequestInner The request body containing the invitation to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationsApi
     */
    public createInvitations(workspace: string, invitationsCreateRequestInner: Array<InvitationsCreateRequestInner>, options?: any) {
        return InvitationsApiFp(this.configuration).createInvitations(workspace, invitationsCreateRequestInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invitee retrieves an invitation
     * @summary Retrieve an invitation
     * @param {string} invitationId The invitation ID in the form inv_9m4e2mr0ui3e8a215n4g
     * @param {InvitationRetrieveRequest} invitationRetrieveRequest The request body for retrieving an invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationsApi
     */
    public getInvitation(invitationId: string, invitationRetrieveRequest: InvitationRetrieveRequest, options?: any) {
        return InvitationsApiFp(this.configuration).getInvitation(invitationId, invitationRetrieveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all invitations that the user has sent
     * @summary Retrieve all sent invitations
     * @param {string} workspace The workspace name or id
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationsApi
     */
    public listInvitations(workspace: string, page?: number, perPage?: number, options?: any) {
        return InvitationsApiFp(this.configuration).listInvitations(workspace, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invitee responds to an invitation
     * @summary Respond to an invitation
     * @param {string} invitationId The invitation ID in the form inv_9m4e2mr0ui3e8a215n4g
     * @param {InvitationRespondRequest} invitationRespondRequest The request body for responding to an invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationsApi
     */
    public respondInvitation(invitationId: string, invitationRespondRequest: InvitationRespondRequest, options?: any) {
        return InvitationsApiFp(this.configuration).respondInvitation(invitationId, invitationRespondRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inviter revokes a previously-sent invitation
     * @summary Revoke an invitation
     * @param {string} workspace The workspace name or id
     * @param {string} invitationId The invitation ID in the form inv_9m4e2mr0ui3e8a215n4g
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationsApi
     */
    public revokeInvitation(workspace: string, invitationId: string, options?: any) {
        return InvitationsApiFp(this.configuration).revokeInvitation(workspace, invitationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OnboardingApi - axios parameter creator
 * @export
 */
export const OnboardingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete Onboarding items
         * @summary Delete Onboarding items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOnboardingItems: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/onboarding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get onboarding items
         * @summary Get onboarding items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnboardingItems: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/onboarding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set Onboarding items
         * @summary Set Onboarding items
         * @param {OnboardingSetItemsRequest} onboardingSetItemsRequest workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOnboardingItems: async (onboardingSetItemsRequest: OnboardingSetItemsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'onboardingSetItemsRequest' is not null or undefined
            assertParamExists('setOnboardingItems', 'onboardingSetItemsRequest', onboardingSetItemsRequest)
            const localVarPath = `/onboarding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(onboardingSetItemsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OnboardingApi - functional programming interface
 * @export
 */
export const OnboardingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OnboardingApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete Onboarding items
         * @summary Delete Onboarding items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOnboardingItems(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOnboardingItems(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get onboarding items
         * @summary Get onboarding items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOnboardingItems(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnboardingGetItemsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOnboardingItems(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set Onboarding items
         * @summary Set Onboarding items
         * @param {OnboardingSetItemsRequest} onboardingSetItemsRequest workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOnboardingItems(onboardingSetItemsRequest: OnboardingSetItemsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOnboardingItems(onboardingSetItemsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OnboardingApi - factory interface
 * @export
 */
export const OnboardingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OnboardingApiFp(configuration)
    return {
        /**
         * Delete Onboarding items
         * @summary Delete Onboarding items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOnboardingItems(options?: any): AxiosPromise<void> {
            return localVarFp.deleteOnboardingItems(options).then((request) => request(axios, basePath));
        },
        /**
         * Get onboarding items
         * @summary Get onboarding items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnboardingItems(options?: any): AxiosPromise<OnboardingGetItemsResponse> {
            return localVarFp.getOnboardingItems(options).then((request) => request(axios, basePath));
        },
        /**
         * Set Onboarding items
         * @summary Set Onboarding items
         * @param {OnboardingSetItemsRequest} onboardingSetItemsRequest workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOnboardingItems(onboardingSetItemsRequest: OnboardingSetItemsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setOnboardingItems(onboardingSetItemsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OnboardingApi - object-oriented interface
 * @export
 * @class OnboardingApi
 * @extends {BaseAPI}
 */
export class OnboardingApi extends BaseAPI {
    /**
     * Delete Onboarding items
     * @summary Delete Onboarding items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public deleteOnboardingItems(options?: any) {
        return OnboardingApiFp(this.configuration).deleteOnboardingItems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get onboarding items
     * @summary Get onboarding items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public getOnboardingItems(options?: any) {
        return OnboardingApiFp(this.configuration).getOnboardingItems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set Onboarding items
     * @summary Set Onboarding items
     * @param {OnboardingSetItemsRequest} onboardingSetItemsRequest workspace to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public setOnboardingItems(onboardingSetItemsRequest: OnboardingSetItemsRequest, options?: any) {
        return OnboardingApiFp(this.configuration).setOnboardingItems(onboardingSetItemsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StoragesettingsApi - axios parameter creator
 * @export
 */
export const StoragesettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create a storage setting
         * @summary Create a new storage setting
         * @param {string} workspace The workspace name or id
         * @param {StorageSettingsCreateRequest} storageSettingsCreateRequest The request body containing the storage setting to create
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorageSetting: async (workspace: string, storageSettingsCreateRequest: StorageSettingsCreateRequest, teamspaceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createStorageSetting', 'workspace', workspace)
            // verify required parameter 'storageSettingsCreateRequest' is not null or undefined
            assertParamExists('createStorageSetting', 'storageSettingsCreateRequest', storageSettingsCreateRequest)
            const localVarPath = `/storagesettings/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (teamspaceId !== undefined) {
                localVarQueryParameter['teamspace_id'] = teamspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(storageSettingsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the storage setting.
         * @summary Delete storage setting
         * @param {string} stsetId The storage setting id in the form stset_9m4e2mr0ui3e8a215n4g
         * @param {string} workspace The workspace name or id
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStorageSettingByID: async (stsetId: string, workspace: string, teamspaceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stsetId' is not null or undefined
            assertParamExists('deleteStorageSettingByID', 'stsetId', stsetId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteStorageSettingByID', 'workspace', workspace)
            const localVarPath = `/storagesettings/{workspace}/{stset_id}`
                .replace(`{${"stset_id"}}`, encodeURIComponent(String(stsetId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (teamspaceId !== undefined) {
                localVarQueryParameter['teamspace_id'] = teamspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get information about storage setting by ID
         * @summary Get storage setting
         * @param {string} stsetId The storage setting id in the form stset_9m4e2mr0ui3e8a215n4g
         * @param {string} workspace The workspace name or id
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageSettingByID: async (stsetId: string, workspace: string, teamspaceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stsetId' is not null or undefined
            assertParamExists('getStorageSettingByID', 'stsetId', stsetId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getStorageSettingByID', 'workspace', workspace)
            const localVarPath = `/storagesettings/{workspace}/{stset_id}`
                .replace(`{${"stset_id"}}`, encodeURIComponent(String(stsetId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (teamspaceId !== undefined) {
                localVarQueryParameter['teamspace_id'] = teamspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list the storage settings available for the user
         * @summary Get storage settings
         * @param {string} workspace The workspace name or id
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorageSettings: async (workspace: string, teamspaceId?: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('listStorageSettings', 'workspace', workspace)
            const localVarPath = `/storagesettings/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (teamspaceId !== undefined) {
                localVarQueryParameter['teamspace_id'] = teamspaceId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update storage setting given by the user
         * @summary Update storage setting
         * @param {string} stsetId The storage setting id in the form stset_9m4e2mr0ui3e8a215n4g
         * @param {string} workspace The workspace name or id
         * @param {StorageSettingUpdateRequest} storageSettingUpdateRequest storage setting update details
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStorageSettingByID: async (stsetId: string, workspace: string, storageSettingUpdateRequest: StorageSettingUpdateRequest, teamspaceId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stsetId' is not null or undefined
            assertParamExists('patchStorageSettingByID', 'stsetId', stsetId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('patchStorageSettingByID', 'workspace', workspace)
            // verify required parameter 'storageSettingUpdateRequest' is not null or undefined
            assertParamExists('patchStorageSettingByID', 'storageSettingUpdateRequest', storageSettingUpdateRequest)
            const localVarPath = `/storagesettings/{workspace}/{stset_id}`
                .replace(`{${"stset_id"}}`, encodeURIComponent(String(stsetId)))
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (teamspaceId !== undefined) {
                localVarQueryParameter['teamspace_id'] = teamspaceId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(storageSettingUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoragesettingsApi - functional programming interface
 * @export
 */
export const StoragesettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoragesettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * create a storage setting
         * @summary Create a new storage setting
         * @param {string} workspace The workspace name or id
         * @param {StorageSettingsCreateRequest} storageSettingsCreateRequest The request body containing the storage setting to create
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStorageSetting(workspace: string, storageSettingsCreateRequest: StorageSettingsCreateRequest, teamspaceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSettingsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStorageSetting(workspace, storageSettingsCreateRequest, teamspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the storage setting.
         * @summary Delete storage setting
         * @param {string} stsetId The storage setting id in the form stset_9m4e2mr0ui3e8a215n4g
         * @param {string} workspace The workspace name or id
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStorageSettingByID(stsetId: string, workspace: string, teamspaceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStorageSettingByID(stsetId, workspace, teamspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get information about storage setting by ID
         * @summary Get storage setting
         * @param {string} stsetId The storage setting id in the form stset_9m4e2mr0ui3e8a215n4g
         * @param {string} workspace The workspace name or id
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageSettingByID(stsetId: string, workspace: string, teamspaceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSettingGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageSettingByID(stsetId, workspace, teamspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * list the storage settings available for the user
         * @summary Get storage settings
         * @param {string} workspace The workspace name or id
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStorageSettings(workspace: string, teamspaceId?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSettingsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStorageSettings(workspace, teamspaceId, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update storage setting given by the user
         * @summary Update storage setting
         * @param {string} stsetId The storage setting id in the form stset_9m4e2mr0ui3e8a215n4g
         * @param {string} workspace The workspace name or id
         * @param {StorageSettingUpdateRequest} storageSettingUpdateRequest storage setting update details
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchStorageSettingByID(stsetId: string, workspace: string, storageSettingUpdateRequest: StorageSettingUpdateRequest, teamspaceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchStorageSettingByID(stsetId, workspace, storageSettingUpdateRequest, teamspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoragesettingsApi - factory interface
 * @export
 */
export const StoragesettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoragesettingsApiFp(configuration)
    return {
        /**
         * create a storage setting
         * @summary Create a new storage setting
         * @param {string} workspace The workspace name or id
         * @param {StorageSettingsCreateRequest} storageSettingsCreateRequest The request body containing the storage setting to create
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorageSetting(workspace: string, storageSettingsCreateRequest: StorageSettingsCreateRequest, teamspaceId?: string, options?: any): AxiosPromise<StorageSettingsCreateResponse> {
            return localVarFp.createStorageSetting(workspace, storageSettingsCreateRequest, teamspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the storage setting.
         * @summary Delete storage setting
         * @param {string} stsetId The storage setting id in the form stset_9m4e2mr0ui3e8a215n4g
         * @param {string} workspace The workspace name or id
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStorageSettingByID(stsetId: string, workspace: string, teamspaceId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteStorageSettingByID(stsetId, workspace, teamspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * get information about storage setting by ID
         * @summary Get storage setting
         * @param {string} stsetId The storage setting id in the form stset_9m4e2mr0ui3e8a215n4g
         * @param {string} workspace The workspace name or id
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageSettingByID(stsetId: string, workspace: string, teamspaceId?: string, options?: any): AxiosPromise<StorageSettingGetResponse> {
            return localVarFp.getStorageSettingByID(stsetId, workspace, teamspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * list the storage settings available for the user
         * @summary Get storage settings
         * @param {string} workspace The workspace name or id
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorageSettings(workspace: string, teamspaceId?: string, page?: number, perPage?: number, options?: any): AxiosPromise<StorageSettingsListResponse> {
            return localVarFp.listStorageSettings(workspace, teamspaceId, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * update storage setting given by the user
         * @summary Update storage setting
         * @param {string} stsetId The storage setting id in the form stset_9m4e2mr0ui3e8a215n4g
         * @param {string} workspace The workspace name or id
         * @param {StorageSettingUpdateRequest} storageSettingUpdateRequest storage setting update details
         * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchStorageSettingByID(stsetId: string, workspace: string, storageSettingUpdateRequest: StorageSettingUpdateRequest, teamspaceId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.patchStorageSettingByID(stsetId, workspace, storageSettingUpdateRequest, teamspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoragesettingsApi - object-oriented interface
 * @export
 * @class StoragesettingsApi
 * @extends {BaseAPI}
 */
export class StoragesettingsApi extends BaseAPI {
    /**
     * create a storage setting
     * @summary Create a new storage setting
     * @param {string} workspace The workspace name or id
     * @param {StorageSettingsCreateRequest} storageSettingsCreateRequest The request body containing the storage setting to create
     * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesettingsApi
     */
    public createStorageSetting(workspace: string, storageSettingsCreateRequest: StorageSettingsCreateRequest, teamspaceId?: string, options?: any) {
        return StoragesettingsApiFp(this.configuration).createStorageSetting(workspace, storageSettingsCreateRequest, teamspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the storage setting.
     * @summary Delete storage setting
     * @param {string} stsetId The storage setting id in the form stset_9m4e2mr0ui3e8a215n4g
     * @param {string} workspace The workspace name or id
     * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesettingsApi
     */
    public deleteStorageSettingByID(stsetId: string, workspace: string, teamspaceId?: string, options?: any) {
        return StoragesettingsApiFp(this.configuration).deleteStorageSettingByID(stsetId, workspace, teamspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get information about storage setting by ID
     * @summary Get storage setting
     * @param {string} stsetId The storage setting id in the form stset_9m4e2mr0ui3e8a215n4g
     * @param {string} workspace The workspace name or id
     * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesettingsApi
     */
    public getStorageSettingByID(stsetId: string, workspace: string, teamspaceId?: string, options?: any) {
        return StoragesettingsApiFp(this.configuration).getStorageSettingByID(stsetId, workspace, teamspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list the storage settings available for the user
     * @summary Get storage settings
     * @param {string} workspace The workspace name or id
     * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesettingsApi
     */
    public listStorageSettings(workspace: string, teamspaceId?: string, page?: number, perPage?: number, options?: any) {
        return StoragesettingsApiFp(this.configuration).listStorageSettings(workspace, teamspaceId, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update storage setting given by the user
     * @summary Update storage setting
     * @param {string} stsetId The storage setting id in the form stset_9m4e2mr0ui3e8a215n4g
     * @param {string} workspace The workspace name or id
     * @param {StorageSettingUpdateRequest} storageSettingUpdateRequest storage setting update details
     * @param {string} [teamspaceId] Teamspace id should be empty, if the request is about an action on workspace level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoragesettingsApi
     */
    public patchStorageSettingByID(stsetId: string, workspace: string, storageSettingUpdateRequest: StorageSettingUpdateRequest, teamspaceId?: string, options?: any) {
        return StoragesettingsApiFp(this.configuration).patchStorageSettingByID(stsetId, workspace, storageSettingUpdateRequest, teamspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamspacesApi - axios parameter creator
 * @export
 */
export const TeamspacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create one or more teamspace users in a teamspace
         * @summary Create one or more teamspace users in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {Array<TeamspaceUsersCreateRequestInner>} teamspaceUsersCreateRequestInner The request body containing the teamspace users to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamspaceUsers: async (workspace: string, teamspace: string, teamspaceUsersCreateRequestInner: Array<TeamspaceUsersCreateRequestInner>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createTeamspaceUsers', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('createTeamspaceUsers', 'teamspace', teamspace)
            // verify required parameter 'teamspaceUsersCreateRequestInner' is not null or undefined
            assertParamExists('createTeamspaceUsers', 'teamspaceUsersCreateRequestInner', teamspaceUsersCreateRequestInner)
            const localVarPath = `/teamspaces/{workspace}/{teamspace}/users`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(teamspaceUsersCreateRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a teamspace. The user creating the teamspace will be the teamspace owner. 
         * @summary Create a teamspace
         * @param {string} workspace The workspace name or id
         * @param {TeamspacesCreateRequest} teamspacesCreateRequest The request body containing the teamspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamspaces: async (workspace: string, teamspacesCreateRequest: TeamspacesCreateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createTeamspaces', 'workspace', workspace)
            // verify required parameter 'teamspacesCreateRequest' is not null or undefined
            assertParamExists('createTeamspaces', 'teamspacesCreateRequest', teamspacesCreateRequest)
            const localVarPath = `/teamspaces/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(teamspacesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the given teamspace
         * @summary Delete a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {boolean} [deleteAssets] If &#x60;true&#x60;, the entity\&#39;s assets will be deregistered in TileDB *and* deleted from the underlying storage (e.g., S3). If &#x60;false&#x60;, the entity\&#39;s assets will be deregistered in TileDB but remain in the underlying storage. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamspace: async (workspace: string, teamspace: string, deleteAssets?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteTeamspace', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('deleteTeamspace', 'teamspace', teamspace)
            const localVarPath = `/teamspaces/{workspace}/{teamspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (deleteAssets !== undefined) {
                localVarQueryParameter['delete-assets'] = deleteAssets;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the given teamspace user
         * @summary Delete a teamspace user
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} userId The user ID in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamspaceUser: async (workspace: string, teamspace: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteTeamspaceUser', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('deleteTeamspaceUser', 'teamspace', teamspace)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteTeamspaceUser', 'userId', userId)
            const localVarPath = `/teamspaces/{workspace}/{teamspace}/users/{user_id}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the given teamspace users in a teamspace
         * @summary Delete the given teamspace users in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {Array<string>} requestBody The request body containing the teamspace users to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamspaceUsers: async (workspace: string, teamspace: string, requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteTeamspaceUsers', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('deleteTeamspaceUsers', 'teamspace', teamspace)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('deleteTeamspaceUsers', 'requestBody', requestBody)
            const localVarPath = `/actions/teamspaces/{workspace}/{teamspace}/users/bulk_delete`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all teamspaces in the workspace
         * @summary Delete all teamspaces in the workspace
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamspaces: async (workspace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteTeamspaces', 'workspace', workspace)
            const localVarPath = `/teamspaces/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the given teamspace
         * @summary Retrieve a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamspace: async (workspace: string, teamspace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getTeamspace', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('getTeamspace', 'teamspace', teamspace)
            const localVarPath = `/teamspaces/{workspace}/{teamspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the given teamspace user
         * @summary Retrieve a teamspace user
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} userId The user ID in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamspaceUser: async (workspace: string, teamspace: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getTeamspaceUser', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('getTeamspaceUser', 'teamspace', teamspace)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getTeamspaceUser', 'userId', userId)
            const localVarPath = `/teamspaces/{workspace}/{teamspace}/users/{user_id}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows users to join a public teamspace if they are a member of the corresponding workspace 
         * @summary Join the given public teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinTeamspace: async (workspace: string, teamspace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('joinTeamspace', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('joinTeamspace', 'teamspace', teamspace)
            const localVarPath = `/actions/teamspaces/{workspace}/{teamspace}/users/join`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows teamspace members to leave a teamspace
         * @summary Leave the given teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveTeamspace: async (workspace: string, teamspace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('leaveTeamspace', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('leaveTeamspace', 'teamspace', teamspace)
            const localVarPath = `/actions/teamspaces/{workspace}/{teamspace}/users/leave`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all teamspace users in a teamspace
         * @summary Retrieve all teamspace users in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamspaceUsers: async (workspace: string, teamspace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('listTeamspaceUsers', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('listTeamspaceUsers', 'teamspace', teamspace)
            const localVarPath = `/teamspaces/{workspace}/{teamspace}/users`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If `memberships=true`, fetches teamspaces the user is a member of. If `memberships=false`, fetches public teamspaces the user is not a member of. 
         * @summary Retrieve teamspaces in the workspace
         * @param {string} workspace The workspace name or id
         * @param {'name' | 'created_at' | 'updated_at'} [orderBy] The field to order the results by. Defaults to &#x60;created_at&#x60;. Can be one of the following: - name - created_at - updated_at 
         * @param {'asc' | 'desc'} [order] Specifies the sorting direction for the results returned by the query. Defaults to &#x60;desc&#x60;. Can be one of the following: - asc - desc 
         * @param {boolean} [memberships] If true, returns teamspaces the user is a member of. If false, returns public teamspaces in the workspace that the user is NOT a member of. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamspaces: async (workspace: string, orderBy?: 'name' | 'created_at' | 'updated_at', order?: 'asc' | 'desc', memberships?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('listTeamspaces', 'workspace', workspace)
            const localVarPath = `/teamspaces/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (memberships !== undefined) {
                localVarQueryParameter['memberships'] = memberships;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a teamspace
         * @summary Update the given teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {TeamspaceUpdateRequest} teamspaceUpdateRequest The request body containing the teamspace to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamspace: async (workspace: string, teamspace: string, teamspaceUpdateRequest: TeamspaceUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateTeamspace', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('updateTeamspace', 'teamspace', teamspace)
            // verify required parameter 'teamspaceUpdateRequest' is not null or undefined
            assertParamExists('updateTeamspace', 'teamspaceUpdateRequest', teamspaceUpdateRequest)
            const localVarPath = `/teamspaces/{workspace}/{teamspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(teamspaceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the given teamspace user
         * @summary Update a teamspace user
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} userId The user ID in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {TeamspaceUserUpdateRequest} teamspaceUserUpdateRequest The request body containing the teamspace user to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamspaceUser: async (workspace: string, teamspace: string, userId: string, teamspaceUserUpdateRequest: TeamspaceUserUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateTeamspaceUser', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('updateTeamspaceUser', 'teamspace', teamspace)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateTeamspaceUser', 'userId', userId)
            // verify required parameter 'teamspaceUserUpdateRequest' is not null or undefined
            assertParamExists('updateTeamspaceUser', 'teamspaceUserUpdateRequest', teamspaceUserUpdateRequest)
            const localVarPath = `/teamspaces/{workspace}/{teamspace}/users/{user_id}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(teamspaceUserUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple teamspace users in a teamspace
         * @summary Update multiple teamspace users in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {Array<TeamspaceUsersBulkUpdateRequestInner>} teamspaceUsersBulkUpdateRequestInner The request body containing the teamspace users to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamspaceUsers: async (workspace: string, teamspace: string, teamspaceUsersBulkUpdateRequestInner: Array<TeamspaceUsersBulkUpdateRequestInner>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateTeamspaceUsers', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('updateTeamspaceUsers', 'teamspace', teamspace)
            // verify required parameter 'teamspaceUsersBulkUpdateRequestInner' is not null or undefined
            assertParamExists('updateTeamspaceUsers', 'teamspaceUsersBulkUpdateRequestInner', teamspaceUsersBulkUpdateRequestInner)
            const localVarPath = `/actions/teamspaces/{workspace}/{teamspace}/users/bulk_update`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(teamspaceUsersBulkUpdateRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamspacesApi - functional programming interface
 * @export
 */
export const TeamspacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamspacesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create one or more teamspace users in a teamspace
         * @summary Create one or more teamspace users in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {Array<TeamspaceUsersCreateRequestInner>} teamspaceUsersCreateRequestInner The request body containing the teamspace users to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeamspaceUsers(workspace: string, teamspace: string, teamspaceUsersCreateRequestInner: Array<TeamspaceUsersCreateRequestInner>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamspaceUsersCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeamspaceUsers(workspace, teamspace, teamspaceUsersCreateRequestInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a teamspace. The user creating the teamspace will be the teamspace owner. 
         * @summary Create a teamspace
         * @param {string} workspace The workspace name or id
         * @param {TeamspacesCreateRequest} teamspacesCreateRequest The request body containing the teamspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeamspaces(workspace: string, teamspacesCreateRequest: TeamspacesCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamspacesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeamspaces(workspace, teamspacesCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the given teamspace
         * @summary Delete a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {boolean} [deleteAssets] If &#x60;true&#x60;, the entity\&#39;s assets will be deregistered in TileDB *and* deleted from the underlying storage (e.g., S3). If &#x60;false&#x60;, the entity\&#39;s assets will be deregistered in TileDB but remain in the underlying storage. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeamspace(workspace: string, teamspace: string, deleteAssets?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeamspace(workspace, teamspace, deleteAssets, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the given teamspace user
         * @summary Delete a teamspace user
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} userId The user ID in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeamspaceUser(workspace: string, teamspace: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeamspaceUser(workspace, teamspace, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the given teamspace users in a teamspace
         * @summary Delete the given teamspace users in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {Array<string>} requestBody The request body containing the teamspace users to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeamspaceUsers(workspace: string, teamspace: string, requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeamspaceUsers(workspace, teamspace, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete all teamspaces in the workspace
         * @summary Delete all teamspaces in the workspace
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeamspaces(workspace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeamspaces(workspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the given teamspace
         * @summary Retrieve a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamspace(workspace: string, teamspace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamspaceGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamspace(workspace, teamspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the given teamspace user
         * @summary Retrieve a teamspace user
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} userId The user ID in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamspaceUser(workspace: string, teamspace: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamspaceUserGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamspaceUser(workspace, teamspace, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows users to join a public teamspace if they are a member of the corresponding workspace 
         * @summary Join the given public teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinTeamspace(workspace: string, teamspace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamspaceUsersJoinResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinTeamspace(workspace, teamspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows teamspace members to leave a teamspace
         * @summary Leave the given teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveTeamspace(workspace: string, teamspace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveTeamspace(workspace, teamspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of all teamspace users in a teamspace
         * @summary Retrieve all teamspace users in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTeamspaceUsers(workspace: string, teamspace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamspaceUsersListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTeamspaceUsers(workspace, teamspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If `memberships=true`, fetches teamspaces the user is a member of. If `memberships=false`, fetches public teamspaces the user is not a member of. 
         * @summary Retrieve teamspaces in the workspace
         * @param {string} workspace The workspace name or id
         * @param {'name' | 'created_at' | 'updated_at'} [orderBy] The field to order the results by. Defaults to &#x60;created_at&#x60;. Can be one of the following: - name - created_at - updated_at 
         * @param {'asc' | 'desc'} [order] Specifies the sorting direction for the results returned by the query. Defaults to &#x60;desc&#x60;. Can be one of the following: - asc - desc 
         * @param {boolean} [memberships] If true, returns teamspaces the user is a member of. If false, returns public teamspaces in the workspace that the user is NOT a member of. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTeamspaces(workspace: string, orderBy?: 'name' | 'created_at' | 'updated_at', order?: 'asc' | 'desc', memberships?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamspacesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTeamspaces(workspace, orderBy, order, memberships, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a teamspace
         * @summary Update the given teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {TeamspaceUpdateRequest} teamspaceUpdateRequest The request body containing the teamspace to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeamspace(workspace: string, teamspace: string, teamspaceUpdateRequest: TeamspaceUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeamspace(workspace, teamspace, teamspaceUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the given teamspace user
         * @summary Update a teamspace user
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} userId The user ID in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {TeamspaceUserUpdateRequest} teamspaceUserUpdateRequest The request body containing the teamspace user to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeamspaceUser(workspace: string, teamspace: string, userId: string, teamspaceUserUpdateRequest: TeamspaceUserUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeamspaceUser(workspace, teamspace, userId, teamspaceUserUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update multiple teamspace users in a teamspace
         * @summary Update multiple teamspace users in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {Array<TeamspaceUsersBulkUpdateRequestInner>} teamspaceUsersBulkUpdateRequestInner The request body containing the teamspace users to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeamspaceUsers(workspace: string, teamspace: string, teamspaceUsersBulkUpdateRequestInner: Array<TeamspaceUsersBulkUpdateRequestInner>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeamspaceUsers(workspace, teamspace, teamspaceUsersBulkUpdateRequestInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamspacesApi - factory interface
 * @export
 */
export const TeamspacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamspacesApiFp(configuration)
    return {
        /**
         * Create one or more teamspace users in a teamspace
         * @summary Create one or more teamspace users in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {Array<TeamspaceUsersCreateRequestInner>} teamspaceUsersCreateRequestInner The request body containing the teamspace users to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamspaceUsers(workspace: string, teamspace: string, teamspaceUsersCreateRequestInner: Array<TeamspaceUsersCreateRequestInner>, options?: any): AxiosPromise<TeamspaceUsersCreateResponse> {
            return localVarFp.createTeamspaceUsers(workspace, teamspace, teamspaceUsersCreateRequestInner, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a teamspace. The user creating the teamspace will be the teamspace owner. 
         * @summary Create a teamspace
         * @param {string} workspace The workspace name or id
         * @param {TeamspacesCreateRequest} teamspacesCreateRequest The request body containing the teamspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamspaces(workspace: string, teamspacesCreateRequest: TeamspacesCreateRequest, options?: any): AxiosPromise<TeamspacesCreateResponse> {
            return localVarFp.createTeamspaces(workspace, teamspacesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the given teamspace
         * @summary Delete a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {boolean} [deleteAssets] If &#x60;true&#x60;, the entity\&#39;s assets will be deregistered in TileDB *and* deleted from the underlying storage (e.g., S3). If &#x60;false&#x60;, the entity\&#39;s assets will be deregistered in TileDB but remain in the underlying storage. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamspace(workspace: string, teamspace: string, deleteAssets?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTeamspace(workspace, teamspace, deleteAssets, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the given teamspace user
         * @summary Delete a teamspace user
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} userId The user ID in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamspaceUser(workspace: string, teamspace: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTeamspaceUser(workspace, teamspace, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the given teamspace users in a teamspace
         * @summary Delete the given teamspace users in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {Array<string>} requestBody The request body containing the teamspace users to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamspaceUsers(workspace: string, teamspace: string, requestBody: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTeamspaceUsers(workspace, teamspace, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all teamspaces in the workspace
         * @summary Delete all teamspaces in the workspace
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamspaces(workspace: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTeamspaces(workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the given teamspace
         * @summary Retrieve a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamspace(workspace: string, teamspace: string, options?: any): AxiosPromise<TeamspaceGetResponse> {
            return localVarFp.getTeamspace(workspace, teamspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the given teamspace user
         * @summary Retrieve a teamspace user
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} userId The user ID in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamspaceUser(workspace: string, teamspace: string, userId: string, options?: any): AxiosPromise<TeamspaceUserGetResponse> {
            return localVarFp.getTeamspaceUser(workspace, teamspace, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows users to join a public teamspace if they are a member of the corresponding workspace 
         * @summary Join the given public teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinTeamspace(workspace: string, teamspace: string, options?: any): AxiosPromise<TeamspaceUsersJoinResponse> {
            return localVarFp.joinTeamspace(workspace, teamspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows teamspace members to leave a teamspace
         * @summary Leave the given teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveTeamspace(workspace: string, teamspace: string, options?: any): AxiosPromise<void> {
            return localVarFp.leaveTeamspace(workspace, teamspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all teamspace users in a teamspace
         * @summary Retrieve all teamspace users in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamspaceUsers(workspace: string, teamspace: string, options?: any): AxiosPromise<TeamspaceUsersListResponse> {
            return localVarFp.listTeamspaceUsers(workspace, teamspace, options).then((request) => request(axios, basePath));
        },
        /**
         * If `memberships=true`, fetches teamspaces the user is a member of. If `memberships=false`, fetches public teamspaces the user is not a member of. 
         * @summary Retrieve teamspaces in the workspace
         * @param {string} workspace The workspace name or id
         * @param {'name' | 'created_at' | 'updated_at'} [orderBy] The field to order the results by. Defaults to &#x60;created_at&#x60;. Can be one of the following: - name - created_at - updated_at 
         * @param {'asc' | 'desc'} [order] Specifies the sorting direction for the results returned by the query. Defaults to &#x60;desc&#x60;. Can be one of the following: - asc - desc 
         * @param {boolean} [memberships] If true, returns teamspaces the user is a member of. If false, returns public teamspaces in the workspace that the user is NOT a member of. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamspaces(workspace: string, orderBy?: 'name' | 'created_at' | 'updated_at', order?: 'asc' | 'desc', memberships?: boolean, options?: any): AxiosPromise<TeamspacesListResponse> {
            return localVarFp.listTeamspaces(workspace, orderBy, order, memberships, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a teamspace
         * @summary Update the given teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {TeamspaceUpdateRequest} teamspaceUpdateRequest The request body containing the teamspace to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamspace(workspace: string, teamspace: string, teamspaceUpdateRequest: TeamspaceUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTeamspace(workspace, teamspace, teamspaceUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the given teamspace user
         * @summary Update a teamspace user
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} userId The user ID in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {TeamspaceUserUpdateRequest} teamspaceUserUpdateRequest The request body containing the teamspace user to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamspaceUser(workspace: string, teamspace: string, userId: string, teamspaceUserUpdateRequest: TeamspaceUserUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateTeamspaceUser(workspace, teamspace, userId, teamspaceUserUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple teamspace users in a teamspace
         * @summary Update multiple teamspace users in a teamspace
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {Array<TeamspaceUsersBulkUpdateRequestInner>} teamspaceUsersBulkUpdateRequestInner The request body containing the teamspace users to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamspaceUsers(workspace: string, teamspace: string, teamspaceUsersBulkUpdateRequestInner: Array<TeamspaceUsersBulkUpdateRequestInner>, options?: any): AxiosPromise<void> {
            return localVarFp.updateTeamspaceUsers(workspace, teamspace, teamspaceUsersBulkUpdateRequestInner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamspacesApi - object-oriented interface
 * @export
 * @class TeamspacesApi
 * @extends {BaseAPI}
 */
export class TeamspacesApi extends BaseAPI {
    /**
     * Create one or more teamspace users in a teamspace
     * @summary Create one or more teamspace users in a teamspace
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {Array<TeamspaceUsersCreateRequestInner>} teamspaceUsersCreateRequestInner The request body containing the teamspace users to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public createTeamspaceUsers(workspace: string, teamspace: string, teamspaceUsersCreateRequestInner: Array<TeamspaceUsersCreateRequestInner>, options?: any) {
        return TeamspacesApiFp(this.configuration).createTeamspaceUsers(workspace, teamspace, teamspaceUsersCreateRequestInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a teamspace. The user creating the teamspace will be the teamspace owner. 
     * @summary Create a teamspace
     * @param {string} workspace The workspace name or id
     * @param {TeamspacesCreateRequest} teamspacesCreateRequest The request body containing the teamspace to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public createTeamspaces(workspace: string, teamspacesCreateRequest: TeamspacesCreateRequest, options?: any) {
        return TeamspacesApiFp(this.configuration).createTeamspaces(workspace, teamspacesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the given teamspace
     * @summary Delete a teamspace
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {boolean} [deleteAssets] If &#x60;true&#x60;, the entity\&#39;s assets will be deregistered in TileDB *and* deleted from the underlying storage (e.g., S3). If &#x60;false&#x60;, the entity\&#39;s assets will be deregistered in TileDB but remain in the underlying storage. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public deleteTeamspace(workspace: string, teamspace: string, deleteAssets?: boolean, options?: any) {
        return TeamspacesApiFp(this.configuration).deleteTeamspace(workspace, teamspace, deleteAssets, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the given teamspace user
     * @summary Delete a teamspace user
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} userId The user ID in the form usr_9m4e2mr0ui3e8a215n4g
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public deleteTeamspaceUser(workspace: string, teamspace: string, userId: string, options?: any) {
        return TeamspacesApiFp(this.configuration).deleteTeamspaceUser(workspace, teamspace, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the given teamspace users in a teamspace
     * @summary Delete the given teamspace users in a teamspace
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {Array<string>} requestBody The request body containing the teamspace users to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public deleteTeamspaceUsers(workspace: string, teamspace: string, requestBody: Array<string>, options?: any) {
        return TeamspacesApiFp(this.configuration).deleteTeamspaceUsers(workspace, teamspace, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all teamspaces in the workspace
     * @summary Delete all teamspaces in the workspace
     * @param {string} workspace The workspace name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public deleteTeamspaces(workspace: string, options?: any) {
        return TeamspacesApiFp(this.configuration).deleteTeamspaces(workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the given teamspace
     * @summary Retrieve a teamspace
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public getTeamspace(workspace: string, teamspace: string, options?: any) {
        return TeamspacesApiFp(this.configuration).getTeamspace(workspace, teamspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the given teamspace user
     * @summary Retrieve a teamspace user
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} userId The user ID in the form usr_9m4e2mr0ui3e8a215n4g
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public getTeamspaceUser(workspace: string, teamspace: string, userId: string, options?: any) {
        return TeamspacesApiFp(this.configuration).getTeamspaceUser(workspace, teamspace, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows users to join a public teamspace if they are a member of the corresponding workspace 
     * @summary Join the given public teamspace
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public joinTeamspace(workspace: string, teamspace: string, options?: any) {
        return TeamspacesApiFp(this.configuration).joinTeamspace(workspace, teamspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows teamspace members to leave a teamspace
     * @summary Leave the given teamspace
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public leaveTeamspace(workspace: string, teamspace: string, options?: any) {
        return TeamspacesApiFp(this.configuration).leaveTeamspace(workspace, teamspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all teamspace users in a teamspace
     * @summary Retrieve all teamspace users in a teamspace
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public listTeamspaceUsers(workspace: string, teamspace: string, options?: any) {
        return TeamspacesApiFp(this.configuration).listTeamspaceUsers(workspace, teamspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If `memberships=true`, fetches teamspaces the user is a member of. If `memberships=false`, fetches public teamspaces the user is not a member of. 
     * @summary Retrieve teamspaces in the workspace
     * @param {string} workspace The workspace name or id
     * @param {'name' | 'created_at' | 'updated_at'} [orderBy] The field to order the results by. Defaults to &#x60;created_at&#x60;. Can be one of the following: - name - created_at - updated_at 
     * @param {'asc' | 'desc'} [order] Specifies the sorting direction for the results returned by the query. Defaults to &#x60;desc&#x60;. Can be one of the following: - asc - desc 
     * @param {boolean} [memberships] If true, returns teamspaces the user is a member of. If false, returns public teamspaces in the workspace that the user is NOT a member of. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public listTeamspaces(workspace: string, orderBy?: 'name' | 'created_at' | 'updated_at', order?: 'asc' | 'desc', memberships?: boolean, options?: any) {
        return TeamspacesApiFp(this.configuration).listTeamspaces(workspace, orderBy, order, memberships, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a teamspace
     * @summary Update the given teamspace
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {TeamspaceUpdateRequest} teamspaceUpdateRequest The request body containing the teamspace to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public updateTeamspace(workspace: string, teamspace: string, teamspaceUpdateRequest: TeamspaceUpdateRequest, options?: any) {
        return TeamspacesApiFp(this.configuration).updateTeamspace(workspace, teamspace, teamspaceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the given teamspace user
     * @summary Update a teamspace user
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} userId The user ID in the form usr_9m4e2mr0ui3e8a215n4g
     * @param {TeamspaceUserUpdateRequest} teamspaceUserUpdateRequest The request body containing the teamspace user to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public updateTeamspaceUser(workspace: string, teamspace: string, userId: string, teamspaceUserUpdateRequest: TeamspaceUserUpdateRequest, options?: any) {
        return TeamspacesApiFp(this.configuration).updateTeamspaceUser(workspace, teamspace, userId, teamspaceUserUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple teamspace users in a teamspace
     * @summary Update multiple teamspace users in a teamspace
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {Array<TeamspaceUsersBulkUpdateRequestInner>} teamspaceUsersBulkUpdateRequestInner The request body containing the teamspace users to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamspacesApi
     */
    public updateTeamspaceUsers(workspace: string, teamspace: string, teamspaceUsersBulkUpdateRequestInner: Array<TeamspaceUsersBulkUpdateRequestInner>, options?: any) {
        return TeamspacesApiFp(this.configuration).updateTeamspaceUsers(workspace, teamspace, teamspaceUsersBulkUpdateRequestInner, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new token
         * @summary Create a new token
         * @param {TokenCreateRequest} tokenCreateRequest The request body containing the token to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToken: async (tokenCreateRequest: TokenCreateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenCreateRequest' is not null or undefined
            assertParamExists('createToken', 'tokenCreateRequest', tokenCreateRequest)
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(tokenCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all of the user\'s tokens of the given type
         * @summary Retrieve all of the user\'s tokens
         * @param {'api' | 'session'} type The type of tokens to retrieve
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens: async (type: 'api' | 'session', page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('listTokens', 'type', type)
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a token that was previously created
         * @summary Revoke a token
         * @param {string} tokenId The ID of the token to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken: async (tokenId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('revokeToken', 'tokenId', tokenId)
            const localVarPath = `/tokens/{token_id}`
                .replace(`{${"token_id"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new token
         * @summary Create a new token
         * @param {TokenCreateRequest} tokenCreateRequest The request body containing the token to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createToken(tokenCreateRequest: TokenCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createToken(tokenCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all of the user\'s tokens of the given type
         * @summary Retrieve all of the user\'s tokens
         * @param {'api' | 'session'} type The type of tokens to retrieve
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTokens(type: 'api' | 'session', page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTokens(type, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Revoke a token that was previously created
         * @summary Revoke a token
         * @param {string} tokenId The ID of the token to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeToken(tokenId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeToken(tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokensApiFp(configuration)
    return {
        /**
         * Create a new token
         * @summary Create a new token
         * @param {TokenCreateRequest} tokenCreateRequest The request body containing the token to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToken(tokenCreateRequest: TokenCreateRequest, options?: any): AxiosPromise<TokenCreateResponse> {
            return localVarFp.createToken(tokenCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all of the user\'s tokens of the given type
         * @summary Retrieve all of the user\'s tokens
         * @param {'api' | 'session'} type The type of tokens to retrieve
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens(type: 'api' | 'session', page?: number, perPage?: number, options?: any): AxiosPromise<TokenListResponse> {
            return localVarFp.listTokens(type, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a token that was previously created
         * @summary Revoke a token
         * @param {string} tokenId The ID of the token to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(tokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.revokeToken(tokenId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
    /**
     * Create a new token
     * @summary Create a new token
     * @param {TokenCreateRequest} tokenCreateRequest The request body containing the token to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public createToken(tokenCreateRequest: TokenCreateRequest, options?: any) {
        return TokensApiFp(this.configuration).createToken(tokenCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all of the user\'s tokens of the given type
     * @summary Retrieve all of the user\'s tokens
     * @param {'api' | 'session'} type The type of tokens to retrieve
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public listTokens(type: 'api' | 'session', page?: number, perPage?: number, options?: any) {
        return TokensApiFp(this.configuration).listTokens(type, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a token that was previously created
     * @summary Revoke a token
     * @param {string} tokenId The ID of the token to revoke
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public revokeToken(tokenId: string, options?: any) {
        return TokensApiFp(this.configuration).revokeToken(tokenId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows a user to change their password. The user must provide the current password along with the new password. 
         * @summary Changes a user\'s password.
         * @param {ChangePasswordRequest} changePasswordRequest data required to changes a user\&#39;s password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordRequest: ChangePasswordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordRequest' is not null or undefined
            assertParamExists('changePassword', 'changePasswordRequest', changePasswordRequest)
            const localVarPath = `/actions/users/change_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Operation to confirm the email address by providing the token sent to user\'s email address
         * @summary Confirm an email address
         * @param {string} xTILEDBRESTAPIKEY The confirm email scoped token to validate the user\&#39;s email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail: async (xTILEDBRESTAPIKEY: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTILEDBRESTAPIKEY' is not null or undefined
            assertParamExists('confirmEmail', 'xTILEDBRESTAPIKEY', xTILEDBRESTAPIKEY)
            const localVarPath = `/actions/users/confirm_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (xTILEDBRESTAPIKEY !== undefined && xTILEDBRESTAPIKEY !== null) {
                localVarHeaderParameter['X-TILEDB-REST-API-KEY'] = String(xTILEDBRESTAPIKEY);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a user for a new registration
         * @summary Create a user
         * @param {UserCreateRequest} userCreateRequest user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (userCreateRequest: UserCreateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateRequest' is not null or undefined
            assertParamExists('createUser', 'userCreateRequest', userCreateRequest)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing user based on the provided user id
         * @summary Delete a user
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the user that is currently logged in
         * @summary Retrieve the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/self`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an existing user based on the provided user id
         * @summary Retrieve a user
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Operation to request for a new email to allow the user to confirm their email address. This email contains a link with the required api token. 
         * @summary Request a new email to be sent containing the email confirmation token
         * @param {RequestEmailConfirmationRequest} requestEmailConfirmationRequest data required to initiate a password reset request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestEmailConfirmation: async (requestEmailConfirmationRequest: RequestEmailConfirmationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestEmailConfirmationRequest' is not null or undefined
            assertParamExists('requestEmailConfirmation', 'requestEmailConfirmationRequest', requestEmailConfirmationRequest)
            const localVarPath = `/actions/users/request_email_confirmation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(requestEmailConfirmationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint sends an email to the user\'s registered email address with a password reset link.   The link contains a scoped token that authorizes the user to reset their password securely. 
         * @summary Request a password reset while unauthorized
         * @param {RequestPasswordResetRequest} requestPasswordResetRequest data required to initiate a password reset request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordReset: async (requestPasswordResetRequest: RequestPasswordResetRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestPasswordResetRequest' is not null or undefined
            assertParamExists('requestPasswordReset', 'requestPasswordResetRequest', requestPasswordResetRequest)
            const localVarPath = `/actions/users/request_password_reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(requestPasswordResetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows a user to reset their password.  The user must provide a valid scoped token, received via email, along with their new password. The token ensures secure and authorized access to update the password. 
         * @summary Reset a user\'s password using a scoped token.
         * @param {string} xTILEDBRESTAPIKEY The reset password scoped token to reset the user\&#39;s password
         * @param {ResetPasswordRequest} resetPasswordRequest data required to initiate a password reset request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (xTILEDBRESTAPIKEY: string, resetPasswordRequest: ResetPasswordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTILEDBRESTAPIKEY' is not null or undefined
            assertParamExists('resetPassword', 'xTILEDBRESTAPIKEY', xTILEDBRESTAPIKEY)
            // verify required parameter 'resetPasswordRequest' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordRequest', resetPasswordRequest)
            const localVarPath = `/actions/users/reset_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (xTILEDBRESTAPIKEY !== undefined && xTILEDBRESTAPIKEY !== null) {
                localVarHeaderParameter['X-TILEDB-REST-API-KEY'] = String(xTILEDBRESTAPIKEY);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing user based on the provided data
         * @summary Update a user
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {UserUpdateRequest} userUpdateRequest userUpdateDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, userUpdateRequest: UserUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            // verify required parameter 'userUpdateRequest' is not null or undefined
            assertParamExists('updateUser', 'userUpdateRequest', userUpdateRequest)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows a user to change their password. The user must provide the current password along with the new password. 
         * @summary Changes a user\'s password.
         * @param {ChangePasswordRequest} changePasswordRequest data required to changes a user\&#39;s password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordRequest: ChangePasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Operation to confirm the email address by providing the token sent to user\'s email address
         * @summary Confirm an email address
         * @param {string} xTILEDBRESTAPIKEY The confirm email scoped token to validate the user\&#39;s email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmEmail(xTILEDBRESTAPIKEY: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmEmail(xTILEDBRESTAPIKEY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create a user for a new registration
         * @summary Create a user
         * @param {UserCreateRequest} userCreateRequest user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(userCreateRequest: UserCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing user based on the provided user id
         * @summary Delete a user
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the user that is currently logged in
         * @summary Retrieve the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSelfUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSelfResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSelfUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an existing user based on the provided user id
         * @summary Retrieve a user
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Operation to request for a new email to allow the user to confirm their email address. This email contains a link with the required api token. 
         * @summary Request a new email to be sent containing the email confirmation token
         * @param {RequestEmailConfirmationRequest} requestEmailConfirmationRequest data required to initiate a password reset request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestEmailConfirmation(requestEmailConfirmationRequest: RequestEmailConfirmationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestEmailConfirmation(requestEmailConfirmationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint sends an email to the user\'s registered email address with a password reset link.   The link contains a scoped token that authorizes the user to reset their password securely. 
         * @summary Request a password reset while unauthorized
         * @param {RequestPasswordResetRequest} requestPasswordResetRequest data required to initiate a password reset request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestPasswordReset(requestPasswordResetRequest: RequestPasswordResetRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestPasswordReset(requestPasswordResetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows a user to reset their password.  The user must provide a valid scoped token, received via email, along with their new password. The token ensures secure and authorized access to update the password. 
         * @summary Reset a user\'s password using a scoped token.
         * @param {string} xTILEDBRESTAPIKEY The reset password scoped token to reset the user\&#39;s password
         * @param {ResetPasswordRequest} resetPasswordRequest data required to initiate a password reset request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(xTILEDBRESTAPIKEY: string, resetPasswordRequest: ResetPasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(xTILEDBRESTAPIKEY, resetPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing user based on the provided data
         * @summary Update a user
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {UserUpdateRequest} userUpdateRequest userUpdateDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, userUpdateRequest: UserUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, userUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * This endpoint allows a user to change their password. The user must provide the current password along with the new password. 
         * @summary Changes a user\'s password.
         * @param {ChangePasswordRequest} changePasswordRequest data required to changes a user\&#39;s password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordRequest: ChangePasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.changePassword(changePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Operation to confirm the email address by providing the token sent to user\'s email address
         * @summary Confirm an email address
         * @param {string} xTILEDBRESTAPIKEY The confirm email scoped token to validate the user\&#39;s email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail(xTILEDBRESTAPIKEY: string, options?: any): AxiosPromise<void> {
            return localVarFp.confirmEmail(xTILEDBRESTAPIKEY, options).then((request) => request(axios, basePath));
        },
        /**
         * create a user for a new registration
         * @summary Create a user
         * @param {UserCreateRequest} userCreateRequest user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userCreateRequest: UserCreateRequest, options?: any): AxiosPromise<UserCreateResponse> {
            return localVarFp.createUser(userCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing user based on the provided user id
         * @summary Delete a user
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the user that is currently logged in
         * @summary Retrieve the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfUser(options?: any): AxiosPromise<UserSelfResponse> {
            return localVarFp.getSelfUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an existing user based on the provided user id
         * @summary Retrieve a user
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: any): AxiosPromise<UserGetResponse> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Operation to request for a new email to allow the user to confirm their email address. This email contains a link with the required api token. 
         * @summary Request a new email to be sent containing the email confirmation token
         * @param {RequestEmailConfirmationRequest} requestEmailConfirmationRequest data required to initiate a password reset request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestEmailConfirmation(requestEmailConfirmationRequest: RequestEmailConfirmationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.requestEmailConfirmation(requestEmailConfirmationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint sends an email to the user\'s registered email address with a password reset link.   The link contains a scoped token that authorizes the user to reset their password securely. 
         * @summary Request a password reset while unauthorized
         * @param {RequestPasswordResetRequest} requestPasswordResetRequest data required to initiate a password reset request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordReset(requestPasswordResetRequest: RequestPasswordResetRequest, options?: any): AxiosPromise<void> {
            return localVarFp.requestPasswordReset(requestPasswordResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows a user to reset their password.  The user must provide a valid scoped token, received via email, along with their new password. The token ensures secure and authorized access to update the password. 
         * @summary Reset a user\'s password using a scoped token.
         * @param {string} xTILEDBRESTAPIKEY The reset password scoped token to reset the user\&#39;s password
         * @param {ResetPasswordRequest} resetPasswordRequest data required to initiate a password reset request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(xTILEDBRESTAPIKEY: string, resetPasswordRequest: ResetPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.resetPassword(xTILEDBRESTAPIKEY, resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing user based on the provided data
         * @summary Update a user
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {UserUpdateRequest} userUpdateRequest userUpdateDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, userUpdateRequest: UserUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(userId, userUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * This endpoint allows a user to change their password. The user must provide the current password along with the new password. 
     * @summary Changes a user\'s password.
     * @param {ChangePasswordRequest} changePasswordRequest data required to changes a user\&#39;s password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changePassword(changePasswordRequest: ChangePasswordRequest, options?: any) {
        return UsersApiFp(this.configuration).changePassword(changePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Operation to confirm the email address by providing the token sent to user\'s email address
     * @summary Confirm an email address
     * @param {string} xTILEDBRESTAPIKEY The confirm email scoped token to validate the user\&#39;s email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public confirmEmail(xTILEDBRESTAPIKEY: string, options?: any) {
        return UsersApiFp(this.configuration).confirmEmail(xTILEDBRESTAPIKEY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create a user for a new registration
     * @summary Create a user
     * @param {UserCreateRequest} userCreateRequest user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(userCreateRequest: UserCreateRequest, options?: any) {
        return UsersApiFp(this.configuration).createUser(userCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing user based on the provided user id
     * @summary Delete a user
     * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(userId: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the user that is currently logged in
     * @summary Retrieve the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getSelfUser(options?: any) {
        return UsersApiFp(this.configuration).getSelfUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an existing user based on the provided user id
     * @summary Retrieve a user
     * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(userId: string, options?: any) {
        return UsersApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Operation to request for a new email to allow the user to confirm their email address. This email contains a link with the required api token. 
     * @summary Request a new email to be sent containing the email confirmation token
     * @param {RequestEmailConfirmationRequest} requestEmailConfirmationRequest data required to initiate a password reset request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public requestEmailConfirmation(requestEmailConfirmationRequest: RequestEmailConfirmationRequest, options?: any) {
        return UsersApiFp(this.configuration).requestEmailConfirmation(requestEmailConfirmationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint sends an email to the user\'s registered email address with a password reset link.   The link contains a scoped token that authorizes the user to reset their password securely. 
     * @summary Request a password reset while unauthorized
     * @param {RequestPasswordResetRequest} requestPasswordResetRequest data required to initiate a password reset request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public requestPasswordReset(requestPasswordResetRequest: RequestPasswordResetRequest, options?: any) {
        return UsersApiFp(this.configuration).requestPasswordReset(requestPasswordResetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows a user to reset their password.  The user must provide a valid scoped token, received via email, along with their new password. The token ensures secure and authorized access to update the password. 
     * @summary Reset a user\'s password using a scoped token.
     * @param {string} xTILEDBRESTAPIKEY The reset password scoped token to reset the user\&#39;s password
     * @param {ResetPasswordRequest} resetPasswordRequest data required to initiate a password reset request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resetPassword(xTILEDBRESTAPIKEY: string, resetPasswordRequest: ResetPasswordRequest, options?: any) {
        return UsersApiFp(this.configuration).resetPassword(xTILEDBRESTAPIKEY, resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing user based on the provided data
     * @summary Update a user
     * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
     * @param {UserUpdateRequest} userUpdateRequest userUpdateDetails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(userId: string, userUpdateRequest: UserUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).updateUser(userId, userUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserspacesApi - axios parameter creator
 * @export
 */
export const UserspacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the given userspace
         * @summary Retrieve a userspace
         * @param {string} workspace The workspace name or id
         * @param {string} userspace The userspace id or the user\&#39;s username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserspace: async (workspace: string, userspace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getUserspace', 'workspace', workspace)
            // verify required parameter 'userspace' is not null or undefined
            assertParamExists('getUserspace', 'userspace', userspace)
            const localVarPath = `/userspaces/{workspace}/{userspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"userspace"}}`, encodeURIComponent(String(userspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a userspace
         * @summary Update the given userspace
         * @param {string} workspace The workspace name or id
         * @param {string} userspace The userspace id or the user\&#39;s username
         * @param {UserspaceUpdateRequest} userspaceUpdateRequest The request body containing the userspace to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserspace: async (workspace: string, userspace: string, userspaceUpdateRequest: UserspaceUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateUserspace', 'workspace', workspace)
            // verify required parameter 'userspace' is not null or undefined
            assertParamExists('updateUserspace', 'userspace', userspace)
            // verify required parameter 'userspaceUpdateRequest' is not null or undefined
            assertParamExists('updateUserspace', 'userspaceUpdateRequest', userspaceUpdateRequest)
            const localVarPath = `/userspaces/{workspace}/{userspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"userspace"}}`, encodeURIComponent(String(userspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(userspaceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserspacesApi - functional programming interface
 * @export
 */
export const UserspacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserspacesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the given userspace
         * @summary Retrieve a userspace
         * @param {string} workspace The workspace name or id
         * @param {string} userspace The userspace id or the user\&#39;s username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserspace(workspace: string, userspace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserspaceGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserspace(workspace, userspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a userspace
         * @summary Update the given userspace
         * @param {string} workspace The workspace name or id
         * @param {string} userspace The userspace id or the user\&#39;s username
         * @param {UserspaceUpdateRequest} userspaceUpdateRequest The request body containing the userspace to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserspace(workspace: string, userspace: string, userspaceUpdateRequest: UserspaceUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserspace(workspace, userspace, userspaceUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserspacesApi - factory interface
 * @export
 */
export const UserspacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserspacesApiFp(configuration)
    return {
        /**
         * Retrieve the given userspace
         * @summary Retrieve a userspace
         * @param {string} workspace The workspace name or id
         * @param {string} userspace The userspace id or the user\&#39;s username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserspace(workspace: string, userspace: string, options?: any): AxiosPromise<UserspaceGetResponse> {
            return localVarFp.getUserspace(workspace, userspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a userspace
         * @summary Update the given userspace
         * @param {string} workspace The workspace name or id
         * @param {string} userspace The userspace id or the user\&#39;s username
         * @param {UserspaceUpdateRequest} userspaceUpdateRequest The request body containing the userspace to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserspace(workspace: string, userspace: string, userspaceUpdateRequest: UserspaceUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserspace(workspace, userspace, userspaceUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserspacesApi - object-oriented interface
 * @export
 * @class UserspacesApi
 * @extends {BaseAPI}
 */
export class UserspacesApi extends BaseAPI {
    /**
     * Retrieve the given userspace
     * @summary Retrieve a userspace
     * @param {string} workspace The workspace name or id
     * @param {string} userspace The userspace id or the user\&#39;s username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserspacesApi
     */
    public getUserspace(workspace: string, userspace: string, options?: any) {
        return UserspacesApiFp(this.configuration).getUserspace(workspace, userspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a userspace
     * @summary Update the given userspace
     * @param {string} workspace The workspace name or id
     * @param {string} userspace The userspace id or the user\&#39;s username
     * @param {UserspaceUpdateRequest} userspaceUpdateRequest The request body containing the userspace to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserspacesApi
     */
    public updateUserspace(workspace: string, userspace: string, userspaceUpdateRequest: UserspaceUpdateRequest, options?: any) {
        return UserspacesApiFp(this.configuration).updateUserspace(workspace, userspace, userspaceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VersionsApi - axios parameter creator
 * @export
 */
export const VersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns various version numbers pertaining to the server. 
         * @summary Get Server versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsApi - functional programming interface
 * @export
 */
export const VersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns various version numbers pertaining to the server. 
         * @summary Get Server versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VersionsApi - factory interface
 * @export
 */
export const VersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionsApiFp(configuration)
    return {
        /**
         * This endpoint returns various version numbers pertaining to the server. 
         * @summary Get Server versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: any): AxiosPromise<VersionsResponse> {
            return localVarFp.getVersions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionsApi - object-oriented interface
 * @export
 * @class VersionsApi
 * @extends {BaseAPI}
 */
export class VersionsApi extends BaseAPI {
    /**
     * This endpoint returns various version numbers pertaining to the server. 
     * @summary Get Server versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getVersions(options?: any) {
        return VersionsApiFp(this.configuration).getVersions(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspacesApi - axios parameter creator
 * @export
 */
export const WorkspacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create a workspace, the user creating will be listed as owner
         * @summary Create a workspace
         * @param {WorkspaceCreateRequest} workspaceCreateRequest workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace: async (workspaceCreateRequest: WorkspaceCreateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceCreateRequest' is not null or undefined
            assertParamExists('createWorkspace', 'workspaceCreateRequest', workspaceCreateRequest)
            const localVarPath = `/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create one or more workspace users
         * @summary Create one or more workspace users
         * @param {string} workspace The workspace name or id
         * @param {Array<WorkspaceUsersCreateRequestInner>} workspaceUsersCreateRequestInner The request body containing the workspace users to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceUsers: async (workspace: string, workspaceUsersCreateRequestInner: Array<WorkspaceUsersCreateRequestInner>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createWorkspaceUsers', 'workspace', workspace)
            // verify required parameter 'workspaceUsersCreateRequestInner' is not null or undefined
            assertParamExists('createWorkspaceUsers', 'workspaceUsersCreateRequestInner', workspaceUsersCreateRequestInner)
            const localVarPath = `/workspaceusers/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUsersCreateRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a workspace
         * @summary Delete a workspace
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace: async (workspace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteWorkspace', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the given workspace user
         * @summary Delete a workspace user
         * @param {string} workspace The workspace name or id
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceUser: async (workspace: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteWorkspaceUser', 'workspace', workspace)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteWorkspaceUser', 'userId', userId)
            const localVarPath = `/workspaceusers/{workspace}/{user_id}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the given workspace users in a workspace
         * @summary Delete the given workspace users in a workspace
         * @param {string} workspace The workspace name or id
         * @param {Array<string>} requestBody The request body containing the workspace users to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceUsers: async (workspace: string, requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteWorkspaceUsers', 'workspace', workspace)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('deleteWorkspaceUsers', 'requestBody', requestBody)
            const localVarPath = `/actions/workspaces/{workspace}/users/bulk_delete`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End point to retrieve metadata for the passed workspace 
         * @summary Retrieves metadata for the given workspace
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace: async (workspace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getWorkspace', 'workspace', workspace)
            const localVarPath = `/workspaces/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the given workspace user
         * @summary Retrieve a workspace user
         * @param {string} workspace The workspace name or id
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceUser: async (workspace: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getWorkspaceUser', 'workspace', workspace)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getWorkspaceUser', 'userId', userId)
            const localVarPath = `/workspaceusers/{workspace}/{user_id}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of workspace users
         * @summary Retrieve multiple workspace users
         * @param {string} workspace The workspace name or id
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] Search filter to find users by username or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceUsers: async (workspace: string, page?: number, perPage?: number, search?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('listWorkspaceUsers', 'workspace', workspace)
            const localVarPath = `/workspaceusers/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a workspace
         * @summary Update a workspace
         * @param {string} workspace The workspace name or id
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest workspaceUpdateDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace: async (workspace: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateWorkspace', 'workspace', workspace)
            // verify required parameter 'workspaceUpdateRequest' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceUpdateRequest', workspaceUpdateRequest)
            const localVarPath = `/workspaces/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the given workspace user
         * @summary Update a workspace user
         * @param {string} workspace The workspace name or id
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {WorkspaceUserUpdateRequest} workspaceUserUpdateRequest The request body containing the workspace user to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceUser: async (workspace: string, userId: string, workspaceUserUpdateRequest: WorkspaceUserUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateWorkspaceUser', 'workspace', workspace)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateWorkspaceUser', 'userId', userId)
            // verify required parameter 'workspaceUserUpdateRequest' is not null or undefined
            assertParamExists('updateWorkspaceUser', 'workspaceUserUpdateRequest', workspaceUserUpdateRequest)
            const localVarPath = `/workspaceusers/{workspace}/{user_id}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUserUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple workspace users in a workspace
         * @summary Update multiple workspace users in a workspace
         * @param {string} workspace The workspace name or id
         * @param {Array<WorkspaceUsersBulkUpdateRequestInner>} workspaceUsersBulkUpdateRequestInner The request body containing the workspace users to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceUsers: async (workspace: string, workspaceUsersBulkUpdateRequestInner: Array<WorkspaceUsersBulkUpdateRequestInner>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateWorkspaceUsers', 'workspace', workspace)
            // verify required parameter 'workspaceUsersBulkUpdateRequestInner' is not null or undefined
            assertParamExists('updateWorkspaceUsers', 'workspaceUsersBulkUpdateRequestInner', workspaceUsersBulkUpdateRequestInner)
            const localVarPath = `/actions/workspaces/{workspace}/users/bulk_update`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUsersBulkUpdateRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export const WorkspacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspacesApiAxiosParamCreator(configuration)
    return {
        /**
         * create a workspace, the user creating will be listed as owner
         * @summary Create a workspace
         * @param {WorkspaceCreateRequest} workspaceCreateRequest workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspace(workspaceCreateRequest: WorkspaceCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspace(workspaceCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create one or more workspace users
         * @summary Create one or more workspace users
         * @param {string} workspace The workspace name or id
         * @param {Array<WorkspaceUsersCreateRequestInner>} workspaceUsersCreateRequestInner The request body containing the workspace users to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspaceUsers(workspace: string, workspaceUsersCreateRequestInner: Array<WorkspaceUsersCreateRequestInner>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceUsersCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspaceUsers(workspace, workspaceUsersCreateRequestInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete a workspace
         * @summary Delete a workspace
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspace(workspace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspace(workspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the given workspace user
         * @summary Delete a workspace user
         * @param {string} workspace The workspace name or id
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceUser(workspace: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceUser(workspace, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the given workspace users in a workspace
         * @summary Delete the given workspace users in a workspace
         * @param {string} workspace The workspace name or id
         * @param {Array<string>} requestBody The request body containing the workspace users to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceUsers(workspace: string, requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceUsers(workspace, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * End point to retrieve metadata for the passed workspace 
         * @summary Retrieves metadata for the given workspace
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspace(workspace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspace(workspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the given workspace user
         * @summary Retrieve a workspace user
         * @param {string} workspace The workspace name or id
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceUser(workspace: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceUserGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceUser(workspace, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of workspace users
         * @summary Retrieve multiple workspace users
         * @param {string} workspace The workspace name or id
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] Search filter to find users by username or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkspaceUsers(workspace: string, page?: number, perPage?: number, search?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceUsersListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaceUsers(workspace, page, perPage, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update a workspace
         * @summary Update a workspace
         * @param {string} workspace The workspace name or id
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest workspaceUpdateDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspace(workspace: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspace(workspace, workspaceUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the given workspace user
         * @summary Update a workspace user
         * @param {string} workspace The workspace name or id
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {WorkspaceUserUpdateRequest} workspaceUserUpdateRequest The request body containing the workspace user to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceUser(workspace: string, userId: string, workspaceUserUpdateRequest: WorkspaceUserUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceUser(workspace, userId, workspaceUserUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update multiple workspace users in a workspace
         * @summary Update multiple workspace users in a workspace
         * @param {string} workspace The workspace name or id
         * @param {Array<WorkspaceUsersBulkUpdateRequestInner>} workspaceUsersBulkUpdateRequestInner The request body containing the workspace users to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceUsers(workspace: string, workspaceUsersBulkUpdateRequestInner: Array<WorkspaceUsersBulkUpdateRequestInner>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceUsers(workspace, workspaceUsersBulkUpdateRequestInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkspacesApi - factory interface
 * @export
 */
export const WorkspacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspacesApiFp(configuration)
    return {
        /**
         * create a workspace, the user creating will be listed as owner
         * @summary Create a workspace
         * @param {WorkspaceCreateRequest} workspaceCreateRequest workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(workspaceCreateRequest: WorkspaceCreateRequest, options?: any): AxiosPromise<WorkspaceCreateResponse> {
            return localVarFp.createWorkspace(workspaceCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create one or more workspace users
         * @summary Create one or more workspace users
         * @param {string} workspace The workspace name or id
         * @param {Array<WorkspaceUsersCreateRequestInner>} workspaceUsersCreateRequestInner The request body containing the workspace users to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceUsers(workspace: string, workspaceUsersCreateRequestInner: Array<WorkspaceUsersCreateRequestInner>, options?: any): AxiosPromise<WorkspaceUsersCreateResponse> {
            return localVarFp.createWorkspaceUsers(workspace, workspaceUsersCreateRequestInner, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a workspace
         * @summary Delete a workspace
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(workspace: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkspace(workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the given workspace user
         * @summary Delete a workspace user
         * @param {string} workspace The workspace name or id
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceUser(workspace: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkspaceUser(workspace, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the given workspace users in a workspace
         * @summary Delete the given workspace users in a workspace
         * @param {string} workspace The workspace name or id
         * @param {Array<string>} requestBody The request body containing the workspace users to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceUsers(workspace: string, requestBody: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkspaceUsers(workspace, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * End point to retrieve metadata for the passed workspace 
         * @summary Retrieves metadata for the given workspace
         * @param {string} workspace The workspace name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(workspace: string, options?: any): AxiosPromise<WorkspaceGetResponse> {
            return localVarFp.getWorkspace(workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the given workspace user
         * @summary Retrieve a workspace user
         * @param {string} workspace The workspace name or id
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceUser(workspace: string, userId: string, options?: any): AxiosPromise<WorkspaceUserGetResponse> {
            return localVarFp.getWorkspaceUser(workspace, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of workspace users
         * @summary Retrieve multiple workspace users
         * @param {string} workspace The workspace name or id
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] Search filter to find users by username or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceUsers(workspace: string, page?: number, perPage?: number, search?: string, options?: any): AxiosPromise<WorkspaceUsersListResponse> {
            return localVarFp.listWorkspaceUsers(workspace, page, perPage, search, options).then((request) => request(axios, basePath));
        },
        /**
         * update a workspace
         * @summary Update a workspace
         * @param {string} workspace The workspace name or id
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest workspaceUpdateDetails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(workspace: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateWorkspace(workspace, workspaceUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the given workspace user
         * @summary Update a workspace user
         * @param {string} workspace The workspace name or id
         * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
         * @param {WorkspaceUserUpdateRequest} workspaceUserUpdateRequest The request body containing the workspace user to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceUser(workspace: string, userId: string, workspaceUserUpdateRequest: WorkspaceUserUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateWorkspaceUser(workspace, userId, workspaceUserUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple workspace users in a workspace
         * @summary Update multiple workspace users in a workspace
         * @param {string} workspace The workspace name or id
         * @param {Array<WorkspaceUsersBulkUpdateRequestInner>} workspaceUsersBulkUpdateRequestInner The request body containing the workspace users to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceUsers(workspace: string, workspaceUsersBulkUpdateRequestInner: Array<WorkspaceUsersBulkUpdateRequestInner>, options?: any): AxiosPromise<void> {
            return localVarFp.updateWorkspaceUsers(workspace, workspaceUsersBulkUpdateRequestInner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
export class WorkspacesApi extends BaseAPI {
    /**
     * create a workspace, the user creating will be listed as owner
     * @summary Create a workspace
     * @param {WorkspaceCreateRequest} workspaceCreateRequest workspace to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public createWorkspace(workspaceCreateRequest: WorkspaceCreateRequest, options?: any) {
        return WorkspacesApiFp(this.configuration).createWorkspace(workspaceCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create one or more workspace users
     * @summary Create one or more workspace users
     * @param {string} workspace The workspace name or id
     * @param {Array<WorkspaceUsersCreateRequestInner>} workspaceUsersCreateRequestInner The request body containing the workspace users to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public createWorkspaceUsers(workspace: string, workspaceUsersCreateRequestInner: Array<WorkspaceUsersCreateRequestInner>, options?: any) {
        return WorkspacesApiFp(this.configuration).createWorkspaceUsers(workspace, workspaceUsersCreateRequestInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a workspace
     * @summary Delete a workspace
     * @param {string} workspace The workspace name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public deleteWorkspace(workspace: string, options?: any) {
        return WorkspacesApiFp(this.configuration).deleteWorkspace(workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the given workspace user
     * @summary Delete a workspace user
     * @param {string} workspace The workspace name or id
     * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public deleteWorkspaceUser(workspace: string, userId: string, options?: any) {
        return WorkspacesApiFp(this.configuration).deleteWorkspaceUser(workspace, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the given workspace users in a workspace
     * @summary Delete the given workspace users in a workspace
     * @param {string} workspace The workspace name or id
     * @param {Array<string>} requestBody The request body containing the workspace users to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public deleteWorkspaceUsers(workspace: string, requestBody: Array<string>, options?: any) {
        return WorkspacesApiFp(this.configuration).deleteWorkspaceUsers(workspace, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End point to retrieve metadata for the passed workspace 
     * @summary Retrieves metadata for the given workspace
     * @param {string} workspace The workspace name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public getWorkspace(workspace: string, options?: any) {
        return WorkspacesApiFp(this.configuration).getWorkspace(workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the given workspace user
     * @summary Retrieve a workspace user
     * @param {string} workspace The workspace name or id
     * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public getWorkspaceUser(workspace: string, userId: string, options?: any) {
        return WorkspacesApiFp(this.configuration).getWorkspaceUser(workspace, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of workspace users
     * @summary Retrieve multiple workspace users
     * @param {string} workspace The workspace name or id
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] Search filter to find users by username or email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public listWorkspaceUsers(workspace: string, page?: number, perPage?: number, search?: string, options?: any) {
        return WorkspacesApiFp(this.configuration).listWorkspaceUsers(workspace, page, perPage, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a workspace
     * @summary Update a workspace
     * @param {string} workspace The workspace name or id
     * @param {WorkspaceUpdateRequest} workspaceUpdateRequest workspaceUpdateDetails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public updateWorkspace(workspace: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options?: any) {
        return WorkspacesApiFp(this.configuration).updateWorkspace(workspace, workspaceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the given workspace user
     * @summary Update a workspace user
     * @param {string} workspace The workspace name or id
     * @param {string} userId The user id in the form usr_9m4e2mr0ui3e8a215n4g
     * @param {WorkspaceUserUpdateRequest} workspaceUserUpdateRequest The request body containing the workspace user to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public updateWorkspaceUser(workspace: string, userId: string, workspaceUserUpdateRequest: WorkspaceUserUpdateRequest, options?: any) {
        return WorkspacesApiFp(this.configuration).updateWorkspaceUser(workspace, userId, workspaceUserUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple workspace users in a workspace
     * @summary Update multiple workspace users in a workspace
     * @param {string} workspace The workspace name or id
     * @param {Array<WorkspaceUsersBulkUpdateRequestInner>} workspaceUsersBulkUpdateRequestInner The request body containing the workspace users to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public updateWorkspaceUsers(workspace: string, workspaceUsersBulkUpdateRequestInner: Array<WorkspaceUsersBulkUpdateRequestInner>, options?: any) {
        return WorkspacesApiFp(this.configuration).updateWorkspaceUsers(workspace, workspaceUsersBulkUpdateRequestInner, options).then((request) => request(this.axios, this.basePath));
    }
}


