/* tslint:disable */
/* eslint-disable */
/**
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Represents an open array
 * @export
 * @interface ArrayData
 */
export interface ArrayData {
    /**
     * 
     * @type {Querytype}
     * @memberof ArrayData
     */
    queryType: Querytype;
    /**
     * Array uri
     * @type {string}
     * @memberof ArrayData
     */
    uri: string;
    /**
     * Ending timestamp (epoch milliseconds) array is opened at
     * @type {number}
     * @memberof ArrayData
     */
    endTimestamp?: number;
    /**
     * Starting timestamp (epoch milliseconds) array is opened at
     * @type {number}
     * @memberof ArrayData
     */
    startTimestamp?: number;
    /**
     * 
     * @type {ArraySchema}
     * @memberof ArrayData
     */
    arraySchemaLatest?: ArraySchema;
    /**
     * 
     * @type {ArraySchemaMap}
     * @memberof ArrayData
     */
    arraySchemasAll?: ArraySchemaMap;
    /**
     * 
     * @type {ArrayMetadata}
     * @memberof ArrayData
     */
    arrayMetadata?: ArrayMetadata;
    /**
     * 
     * @type {NonEmptyDomainList}
     * @memberof ArrayData
     */
    nonEmptyDomain?: NonEmptyDomainList;
    /**
     * 
     * @type {ArrayDirectory}
     * @memberof ArrayData
     */
    arrayDirectory?: ArrayDirectory;
    /**
     * metadata for all fragments (for reads)
     * @type {Array<FragmentMetadata>}
     * @memberof ArrayData
     */
    fragmentMetadataAll?: Array<FragmentMetadata>;
    /**
     * The ending timestamp that the array was last opened at
     * @type {number}
     * @memberof ArrayData
     */
    openedAtEndTimestamp?: number;
}
/**
 * Array directory (for reads)
 * @export
 * @interface ArrayDirectory
 */
export interface ArrayDirectory {
    /**
     * fragment URIs
     * @type {Array<string>}
     * @memberof ArrayDirectory
     */
    unfilteredFragmentUris?: Array<string>;
    /**
     * consolidated commit URI set
     * @type {Array<string>}
     * @memberof ArrayDirectory
     */
    consolidatedCommitUris?: Array<string>;
    /**
     * URIs of all the array schema files
     * @type {Array<string>}
     * @memberof ArrayDirectory
     */
    arraySchemaUris?: Array<string>;
    /**
     * latest array schema URI.
     * @type {string}
     * @memberof ArrayDirectory
     */
    latestArraySchemaUri?: string;
    /**
     * the array metadata files to vacuum
     * @type {Array<string>}
     * @memberof ArrayDirectory
     */
    arrayMetaUrisToVacuum?: Array<string>;
    /**
     * the array metadata vac files to vacuum
     * @type {Array<string>}
     * @memberof ArrayDirectory
     */
    arrayMetaVacUrisToVacuum?: Array<string>;
    /**
     * the commit files to consolidate
     * @type {Array<string>}
     * @memberof ArrayDirectory
     */
    commitUrisToConsolidate?: Array<string>;
    /**
     * the commit files to vacuum
     * @type {Array<string>}
     * @memberof ArrayDirectory
     */
    commitUrisToVacuum?: Array<string>;
    /**
     * the consolidated commit files to vacuum
     * @type {Array<string>}
     * @memberof ArrayDirectory
     */
    consolidatedCommitUrisToVacuum?: Array<string>;
    /**
     * the URIs of the consolidated fragment metadata files
     * @type {Array<string>}
     * @memberof ArrayDirectory
     */
    fragmentMetaUris?: Array<string>;
    /**
     * Only the files created after timestamp_start are listed
     * @type {number}
     * @memberof ArrayDirectory
     */
    timestampStart?: number;
    /**
     * Only the files created before timestamp_end are listed
     * @type {number}
     * @memberof ArrayDirectory
     */
    timestampEnd?: number;
    /**
     * the timestamped filtered array metadata URIs, after removing the ones that need to be vacuumed and those that do not fall within
     * @type {Array<TimestampedURI>}
     * @memberof ArrayDirectory
     */
    arrayMetaUris?: Array<TimestampedURI>;
    /**
     * the location of delete tiles
     * @type {Array<DeleteAndUpdateTileLocation>}
     * @memberof ArrayDirectory
     */
    deleteAndUpdateTileLocation?: Array<DeleteAndUpdateTileLocation>;
}
/**
 * user\'s TileDB array metadata
 * @export
 * @interface ArrayMetadata
 */
export interface ArrayMetadata {
    /**
     * List of metadata entries
     * @type {Array<ArrayMetadataEntry>}
     * @memberof ArrayMetadata
     */
    entries?: Array<ArrayMetadataEntry>;
}
/**
 * key/value pair representing an array metadata map entry
 * @export
 * @interface ArrayMetadataEntry
 */
export interface ArrayMetadataEntry {
    /**
     * 
     * @type {string}
     * @memberof ArrayMetadataEntry
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof ArrayMetadataEntry
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof ArrayMetadataEntry
     */
    valueNum?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ArrayMetadataEntry
     */
    value?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof ArrayMetadataEntry
     */
    del?: boolean;
}
/**
 * ArraySchema during creation or retrieval
 * @export
 * @interface ArraySchema
 */
export interface ArraySchema {
    /**
     * URI of schema
     * @type {string}
     * @memberof ArraySchema
     */
    uri?: string;
    /**
     * name of schema
     * @type {string}
     * @memberof ArraySchema
     */
    name?: string;
    /**
     * file format version
     * @type {Array<number>}
     * @memberof ArraySchema
     */
    version: Array<number>;
    /**
     * 
     * @type {ArrayType}
     * @memberof ArraySchema
     */
    arrayType: ArrayType;
    /**
     * 
     * @type {Layout}
     * @memberof ArraySchema
     */
    tileOrder: Layout;
    /**
     * 
     * @type {Layout}
     * @memberof ArraySchema
     */
    cellOrder: Layout;
    /**
     * Capacity of array
     * @type {number}
     * @memberof ArraySchema
     */
    capacity: number;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    coordsFilterPipeline: FilterPipeline;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    offsetFilterPipeline: FilterPipeline;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    validityFilterPipeline?: FilterPipeline;
    /**
     * 
     * @type {Domain}
     * @memberof ArraySchema
     */
    domain: Domain;
    /**
     * Attributes of array
     * @type {Array<Attribute>}
     * @memberof ArraySchema
     */
    attributes: Array<Attribute>;
    /**
     * True if the array allows coordinate duplicates. Applicable only to sparse arrays.
     * @type {boolean}
     * @memberof ArraySchema
     */
    allowsDuplicates?: boolean;
    /**
     * The list of sizes per range
     * @type {Array<number>}
     * @memberof ArraySchema
     */
    timestampRange?: Array<number>;
}
/**
 * key/value pair representing an array schema map entry
 * @export
 * @interface ArraySchemaEntry
 */
export interface ArraySchemaEntry {
    /**
     * 
     * @type {string}
     * @memberof ArraySchemaEntry
     */
    key?: string;
    /**
     * 
     * @type {ArraySchema}
     * @memberof ArraySchemaEntry
     */
    value?: ArraySchema;
}
/**
 * array\'s schemas
 * @export
 * @interface ArraySchemaMap
 */
export interface ArraySchemaMap {
    /**
     * List of array schemas entries
     * @type {Array<ArraySchemaEntry>}
     * @memberof ArraySchemaMap
     */
    entries?: Array<ArraySchemaEntry>;
}
/**
 * TileDB array type
 * @export
 * @enum {string}
 */
export enum ArrayType {
    Dense = 'dense',
    Sparse = 'sparse'
}

/**
 * Attribute of array
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * Attribute name
     * @type {string}
     * @memberof Attribute
     */
    name: string;
    /**
     * 
     * @type {Datatype}
     * @memberof Attribute
     */
    type: Datatype;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof Attribute
     */
    filterPipeline: FilterPipeline;
    /**
     * Attribute number of values per cell
     * @type {number}
     * @memberof Attribute
     */
    cellValNum: number;
    /**
     * Is attribute nullable
     * @type {boolean}
     * @memberof Attribute
     */
    nullable?: boolean;
    /**
     * Default validity fill value for nullable attributes
     * @type {boolean}
     * @memberof Attribute
     */
    fillValueValidity?: boolean;
    /**
     * The default fill value
     * @type {Array<number>}
     * @memberof Attribute
     */
    fillValue?: Array<number>;
}
/**
 * Represents an attribute buffer header information
 * @export
 * @interface AttributeBufferHeader
 */
export interface AttributeBufferHeader {
    /**
     * Attribute name
     * @type {string}
     * @memberof AttributeBufferHeader
     */
    name: string;
    /**
     * Number of bytes in the fixed-length attribute data buffer (offsets for var-len attributes)
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    fixedLenBufferSizeInBytes: number;
    /**
     * Number of bytes in the var-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    varLenBufferSizeInBytes: number;
    /**
     * Number of bytes for validity in case attribute is nullable
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    validityLenBufferSizeInBytes?: number;
    /**
     * Original user set number of bytes in the fixed-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    originalFixedLenBufferSizeInBytes?: number;
    /**
     * Original user set number of bytes in the var-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    originalVarLenBufferSizeInBytes?: number;
    /**
     * Original user set number of bytes in the validity data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    originalValidityLenBufferSizeInBytes?: number;
}
/**
 * object representing buffer size of an attribute
 * @export
 * @interface AttributeBufferSize
 */
export interface AttributeBufferSize {
    /**
     * name of attribute
     * @type {string}
     * @memberof AttributeBufferSize
     */
    attribute: string;
    /**
     * buffer size (in bytes) of offset buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    offsetBytes: number;
    /**
     * buffer size (in bytes) of data buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    dataBytes: number;
}
/**
 * TileDB data type
 * @export
 * @enum {string}
 */
export enum Datatype {
    Int32 = 'INT32',
    Int64 = 'INT64',
    Float32 = 'FLOAT32',
    Float64 = 'FLOAT64',
    Char = 'CHAR',
    Int8 = 'INT8',
    Uint8 = 'UINT8',
    Int16 = 'INT16',
    Uint16 = 'UINT16',
    Uint32 = 'UINT32',
    Uint64 = 'UINT64',
    StringAscii = 'STRING_ASCII',
    StringUtf8 = 'STRING_UTF8',
    StringUtf16 = 'STRING_UTF16',
    StringUtf32 = 'STRING_UTF32',
    StringUcs2 = 'STRING_UCS2',
    StringUcs4 = 'STRING_UCS4',
    DatetimeYear = 'DATETIME_YEAR',
    DatetimeMonth = 'DATETIME_MONTH',
    DatetimeWeek = 'DATETIME_WEEK',
    DatetimeDay = 'DATETIME_DAY',
    DatetimeHr = 'DATETIME_HR',
    DatetimeMin = 'DATETIME_MIN',
    DatetimeSec = 'DATETIME_SEC',
    DatetimeMs = 'DATETIME_MS',
    DatetimeUs = 'DATETIME_US',
    DatetimeNs = 'DATETIME_NS',
    DatetimePs = 'DATETIME_PS',
    DatetimeFs = 'DATETIME_FS',
    DatetimeAs = 'DATETIME_AS',
    Any = 'ANY'
}

/**
 * the location of delete tiles
 * @export
 * @interface DeleteAndUpdateTileLocation
 */
export interface DeleteAndUpdateTileLocation {
    /**
     * the uri
     * @type {string}
     * @memberof DeleteAndUpdateTileLocation
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof DeleteAndUpdateTileLocation
     */
    conditionMarker?: string;
    /**
     * 
     * @type {number}
     * @memberof DeleteAndUpdateTileLocation
     */
    offset?: number;
}
/**
 * Dimension of array
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * Dimension name
     * @type {string}
     * @memberof Dimension
     */
    name?: string;
    /**
     * 
     * @type {Datatype}
     * @memberof Dimension
     */
    type: Datatype;
    /**
     * 
     * @type {DomainArray}
     * @memberof Dimension
     */
    domain: DomainArray;
    /**
     * Is tile extent null
     * @type {boolean}
     * @memberof Dimension
     */
    nullTileExtent: boolean;
    /**
     * 
     * @type {DimensionTileExtent}
     * @memberof Dimension
     */
    tileExtent?: DimensionTileExtent;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof Dimension
     */
    filterPipeline?: FilterPipeline;
}
/**
 * Extent of tile
 * @export
 * @interface DimensionTileExtent
 */
export interface DimensionTileExtent {
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int8?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint8?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int16?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint16?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int64?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint64?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    float32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    float64?: number;
}
/**
 * Domain of array
 * @export
 * @interface Domain
 */
export interface Domain {
    /**
     * 
     * @type {Datatype}
     * @memberof Domain
     */
    type: Datatype;
    /**
     * 
     * @type {Layout}
     * @memberof Domain
     */
    tileOrder: Layout;
    /**
     * 
     * @type {Layout}
     * @memberof Domain
     */
    cellOrder: Layout;
    /**
     * Array of dimensions
     * @type {Array<Dimension>}
     * @memberof Domain
     */
    dimensions: Array<Dimension>;
}
/**
 * Domain object for an array of each type
 * @export
 * @interface DomainArray
 */
export interface DomainArray {
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int8?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint8?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int16?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint16?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int32?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint32?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int64?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint64?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float32?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float64?: Array<number>;
}
/**
 * Filter
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {FilterType}
     * @memberof Filter
     */
    type: FilterType;
    /**
     * 
     * @type {FloatScaleConfig}
     * @memberof Filter
     */
    floatScaleConfig?: FloatScaleConfig;
    /**
     * 
     * @type {FilterData}
     * @memberof Filter
     */
    data?: FilterData;
}
/**
 * Filter data
 * @export
 * @interface FilterData
 */
export interface FilterData {
    /**
     * 
     * @type {string}
     * @memberof FilterData
     */
    text?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof FilterData
     */
    bytes?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int8?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint8?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int16?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint16?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int32?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint32?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int64?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint64?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    float32?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    float64?: number;
}
/**
 * One or more filters to apply
 * @export
 * @interface FilterPipeline
 */
export interface FilterPipeline {
    /**
     * 
     * @type {Array<Filter>}
     * @memberof FilterPipeline
     */
    filters?: Array<Filter>;
}
/**
 * TileDB filter types
 * @export
 * @enum {string}
 */
export enum FilterType {
    None = 'FILTER_NONE',
    Gzip = 'FILTER_GZIP',
    Zstd = 'FILTER_ZSTD',
    Lz4 = 'FILTER_LZ4',
    Rle = 'FILTER_RLE',
    Bzip2 = 'FILTER_BZIP2',
    DoubleDelta = 'FILTER_DOUBLE_DELTA',
    BitWidthReduction = 'FILTER_BIT_WIDTH_REDUCTION',
    Bitshuffle = 'FILTER_BITSHUFFLE',
    Byteshuffle = 'FILTER_BYTESHUFFLE',
    PositiveDelta = 'FILTER_POSITIVE_DELTA',
    ScaleFloat = 'FILTER_SCALE_FLOAT',
    Webp = 'FILTER_WEBP',
    ChecksumMd5 = 'FILTER_CHECKSUM_MD5',
    ChecksumSha256 = 'FILTER_CHECKSUM_SHA256',
    Dictionary = 'FILTER_DICTIONARY'
}

/**
 * FloatScaleConfig
 * @export
 * @interface FloatScaleConfig
 */
export interface FloatScaleConfig {
    /**
     * 
     * @type {number}
     * @memberof FloatScaleConfig
     */
    scale?: number;
    /**
     * 
     * @type {number}
     * @memberof FloatScaleConfig
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof FloatScaleConfig
     */
    byteWidth?: number;
}
/**
 * Metadata of a fragment
 * @export
 * @interface FragmentMetadata
 */
export interface FragmentMetadata {
    /**
     * The size of each attribute file
     * @type {Array<number>}
     * @memberof FragmentMetadata
     */
    fileSizes?: Array<number>;
    /**
     * The size of each var attribute file
     * @type {Array<number>}
     * @memberof FragmentMetadata
     */
    fileVarSizes?: Array<number>;
    /**
     * The size of each validity attribute file
     * @type {Array<number>}
     * @memberof FragmentMetadata
     */
    fileValiditySizes?: Array<number>;
    /**
     * The uri of the fragment this metadata belongs to
     * @type {string}
     * @memberof FragmentMetadata
     */
    fragmentUri?: string;
    /**
     * True if the fragment has timestamps
     * @type {boolean}
     * @memberof FragmentMetadata
     */
    hasTimestamps?: boolean;
    /**
     * True if the fragment has delete metadata
     * @type {boolean}
     * @memberof FragmentMetadata
     */
    hasDeleteMeta?: boolean;
    /**
     * The number of sparse tiles
     * @type {number}
     * @memberof FragmentMetadata
     */
    sparseTileNum?: number;
    /**
     * Used to track the tile index base between global order writes
     * @type {number}
     * @memberof FragmentMetadata
     */
    tileIndexBase?: number;
    /**
     * Tile offsets in their attribute files
     * @type {Array<Array<number>>}
     * @memberof FragmentMetadata
     */
    tileOffsets?: Array<Array<number>>;
    /**
     * Variable tile offsets in their attribute files
     * @type {Array<Array<number>>}
     * @memberof FragmentMetadata
     */
    tileVarOffsets?: Array<Array<number>>;
    /**
     * The sizes of the uncompressed variable tiles
     * @type {Array<Array<number>>}
     * @memberof FragmentMetadata
     */
    tileVarSizes?: Array<Array<number>>;
    /**
     * Validity tile offests in their attribute files
     * @type {Array<Array<number>>}
     * @memberof FragmentMetadata
     */
    tileValidityOffsets?: Array<Array<number>>;
    /**
     * tile min buffers
     * @type {Array<Array<number>>}
     * @memberof FragmentMetadata
     */
    tileMinBuffer?: Array<Array<number>>;
    /**
     * tile min buffers for var length data
     * @type {Array<Array<number>>}
     * @memberof FragmentMetadata
     */
    tileMinVarBuffer?: Array<Array<number>>;
    /**
     * tile max buffers
     * @type {Array<Array<number>>}
     * @memberof FragmentMetadata
     */
    tileMaxBuffer?: Array<Array<number>>;
    /**
     * tile max buffers for var length data
     * @type {Array<Array<number>>}
     * @memberof FragmentMetadata
     */
    tileMaxVarBuffer?: Array<Array<number>>;
    /**
     * tile sum values
     * @type {Array<Array<number>>}
     * @memberof FragmentMetadata
     */
    tileSums?: Array<Array<number>>;
    /**
     * tile null count values
     * @type {Array<Array<number>>}
     * @memberof FragmentMetadata
     */
    tileNullCounts?: Array<Array<number>>;
    /**
     * fragment min values
     * @type {Array<Array<number>>}
     * @memberof FragmentMetadata
     */
    fragmentMins?: Array<Array<number>>;
    /**
     * fragment max values
     * @type {Array<Array<number>>}
     * @memberof FragmentMetadata
     */
    fragmentMaxs?: Array<Array<number>>;
    /**
     * fragment sum values
     * @type {Array<number>}
     * @memberof FragmentMetadata
     */
    fragmentSums?: Array<number>;
    /**
     * fragment null count values
     * @type {Array<number>}
     * @memberof FragmentMetadata
     */
    fragmentNullCounts?: Array<number>;
    /**
     * the format version of this metadata
     * @type {number}
     * @memberof FragmentMetadata
     */
    version?: number;
    /**
     * A pair of timestamps for fragment
     * @type {Array<number>}
     * @memberof FragmentMetadata
     */
    timestampRange?: Array<number>;
    /**
     * The number of cells in the last tile
     * @type {number}
     * @memberof FragmentMetadata
     */
    lastTileCellNum?: number;
    /**
     * 
     * @type {NonEmptyDomainList}
     * @memberof FragmentMetadata
     */
    nonEmptyDomain?: NonEmptyDomainList;
    /**
     * The RTree for the MBRs serialized as a blob
     * @type {any}
     * @memberof FragmentMetadata
     */
    rtree?: any;
    /**
     * if the fragment metadata footer appears in a consolidated file
     * @type {boolean}
     * @memberof FragmentMetadata
     */
    hasConsolidatedFooter?: boolean;
    /**
     * 
     * @type {GenericTileOffsets}
     * @memberof FragmentMetadata
     */
    gtOffsets?: GenericTileOffsets;
}
/**
 * Array directory (for reads)
 * @export
 * @interface GenericTileOffsets
 */
export interface GenericTileOffsets {
    /**
     * RTree serialized as a blob
     * @type {number}
     * @memberof GenericTileOffsets
     */
    rtree?: number;
    /**
     * tile offsets
     * @type {Array<number>}
     * @memberof GenericTileOffsets
     */
    tileOffsets?: Array<number>;
    /**
     * variable tile offsets
     * @type {Array<number>}
     * @memberof GenericTileOffsets
     */
    tileVarOffsets?: Array<number>;
    /**
     * sizes of the uncompressed variable tiles offsets
     * @type {Array<number>}
     * @memberof GenericTileOffsets
     */
    tileVarSizes?: Array<number>;
    /**
     * tile validity offsets
     * @type {Array<number>}
     * @memberof GenericTileOffsets
     */
    tileValidityOffsets?: Array<number>;
    /**
     * min tile offsets
     * @type {Array<number>}
     * @memberof GenericTileOffsets
     */
    tileMinOffsets?: Array<number>;
    /**
     * max tile offsets
     * @type {Array<number>}
     * @memberof GenericTileOffsets
     */
    tileMaxOffsets?: Array<number>;
    /**
     * tile sum offsets
     * @type {Array<number>}
     * @memberof GenericTileOffsets
     */
    tileSumOffsets?: Array<number>;
    /**
     * null count offsets
     * @type {Array<number>}
     * @memberof GenericTileOffsets
     */
    tileNullCountOffsets?: Array<number>;
    /**
     * fragment min/max/sum/nullcount offsets
     * @type {number}
     * @memberof GenericTileOffsets
     */
    fragmentMinMaxSumNullCountOffset?: number;
    /**
     * processed conditions offsets
     * @type {number}
     * @memberof GenericTileOffsets
     */
    processedConditionsOffsets?: number;
}
/**
 * Layout of array
 * @export
 * @enum {string}
 */
export enum Layout {
    RowMajor = 'row-major',
    ColMajor = 'col-major',
    GlobalOrder = 'global-order',
    Unordered = 'unordered'
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
}
/**
 * object representing a non-empty domain
 * @export
 * @interface NonEmptyDomain
 */
export interface NonEmptyDomain {
    /**
     * 
     * @type {DomainArray}
     * @memberof NonEmptyDomain
     */
    nonEmptyDomain: DomainArray;
    /**
     * Is non-empty domain really empty?
     * @type {boolean}
     * @memberof NonEmptyDomain
     */
    isEmpty: boolean;
    /**
     * Number of elements in DomainArray for var length
     * @type {Array<number>}
     * @memberof NonEmptyDomain
     */
    sizes?: Array<number>;
}
/**
 * object containing non empty domains
 * @export
 * @interface NonEmptyDomainList
 */
export interface NonEmptyDomainList {
    /**
     * Array\'s non empty domain
     * @type {Array<NonEmptyDomain>}
     * @memberof NonEmptyDomainList
     */
    nonEmptyDomains?: Array<NonEmptyDomain>;
}
/**
 * 
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * 
     * @type {Querytype}
     * @memberof Query
     */
    type: Querytype;
    /**
     * 
     * @type {Layout}
     * @memberof Query
     */
    layout: Layout;
    /**
     * 
     * @type {Querystatus}
     * @memberof Query
     */
    status: Querystatus;
    /**
     * List of attribute buffer headers
     * @type {Array<AttributeBufferHeader>}
     * @memberof Query
     */
    attributeBufferHeaders: Array<AttributeBufferHeader>;
    /**
     * 
     * @type {Writer}
     * @memberof Query
     */
    writer?: Writer;
    /**
     * 
     * @type {QueryReader}
     * @memberof Query
     */
    reader?: QueryReader;
    /**
     * 
     * @type {ArrayData}
     * @memberof Query
     */
    array: ArrayData;
    /**
     * Total number of bytes in fixed size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalFixedLengthBufferBytes: number;
    /**
     * Total number of bytes in variable size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalVarLenBufferBytes: number;
    /**
     * Total number of bytes in validity buffers
     * @type {number}
     * @memberof Query
     */
    totalValidityBufferBytes?: number;
}
/**
 * Read struct (can\'t be called reader due to class name conflict)
 * @export
 * @interface QueryReader
 */
export interface QueryReader {
    /**
     * 
     * @type {Layout}
     * @memberof QueryReader
     */
    layout?: Layout;
    /**
     * 
     * @type {Subarray}
     * @memberof QueryReader
     */
    subarray?: Subarray;
    /**
     * 
     * @type {ReadState}
     * @memberof QueryReader
     */
    readState?: ReadState;
}
/**
 * Status of query
 * @export
 * @enum {string}
 */
export enum Querystatus {
    Failed = 'FAILED',
    Completed = 'COMPLETED',
    Inprogress = 'INPROGRESS',
    Incomplete = 'INCOMPLETE',
    Uninitialized = 'UNINITIALIZED'
}

/**
 * Type of query
 * @export
 * @enum {string}
 */
export enum Querytype {
    Read = 'READ',
    Write = 'WRITE'
}

/**
 * state for reads
 * @export
 * @interface ReadState
 */
export interface ReadState {
    /**
     * True if the reader has been initialized.
     * @type {boolean}
     * @memberof ReadState
     */
    initialized?: boolean;
    /**
     * True if the query produced results that could not fit in some buffer.
     * @type {boolean}
     * @memberof ReadState
     */
    overflowed?: boolean;
    /**
     * True if the current subarray partition is unsplittable.
     * @type {boolean}
     * @memberof ReadState
     */
    unsplittable?: boolean;
    /**
     * 
     * @type {SubarrayPartitioner}
     * @memberof ReadState
     */
    subarrayPartitioner?: SubarrayPartitioner;
}
/**
 * A Subarray
 * @export
 * @interface Subarray
 */
export interface Subarray {
    /**
     * 
     * @type {Layout}
     * @memberof Subarray
     */
    layout?: Layout;
    /**
     * List of 1D ranges, one per dimension
     * @type {Array<SubarrayRanges>}
     * @memberof Subarray
     */
    ranges?: Array<SubarrayRanges>;
}
/**
 * The subarray partitioner
 * @export
 * @interface SubarrayPartitioner
 */
export interface SubarrayPartitioner {
    /**
     * 
     * @type {Subarray}
     * @memberof SubarrayPartitioner
     */
    subarray?: Subarray;
    /**
     * Result size budget (in bytes) for all attributes.
     * @type {Array<AttributeBufferSize>}
     * @memberof SubarrayPartitioner
     */
    budget?: Array<AttributeBufferSize>;
    /**
     * 
     * @type {SubarrayPartitionerCurrent}
     * @memberof SubarrayPartitioner
     */
    current?: SubarrayPartitionerCurrent;
    /**
     * 
     * @type {SubarrayPartitionerState}
     * @memberof SubarrayPartitioner
     */
    state?: SubarrayPartitionerState;
    /**
     * The memory budget for the fixed-sized attributes and the offsets of the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudget?: number;
    /**
     * The memory budget for the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudgetVar?: number;
}
/**
 * The current partition info
 * @export
 * @interface SubarrayPartitionerCurrent
 */
export interface SubarrayPartitionerCurrent {
    /**
     * 
     * @type {Subarray}
     * @memberof SubarrayPartitionerCurrent
     */
    subarray?: Subarray;
    /**
     * PartitionInfo start
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    start?: number;
    /**
     * PartitionInfo end
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    end?: number;
    /**
     * PartitionInfo splitMultiRange
     * @type {boolean}
     * @memberof SubarrayPartitionerCurrent
     */
    splitMultiRange?: boolean;
}
/**
 * The state information for the remaining partitions to be produced
 * @export
 * @interface SubarrayPartitionerState
 */
export interface SubarrayPartitionerState {
    /**
     * State start
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    start?: number;
    /**
     * State end
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    end?: number;
    /**
     * State singleRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    singleRange?: Array<Subarray>;
    /**
     * State multiRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    multiRange?: Array<Subarray>;
}
/**
 * A set of 1D ranges for a subarray
 * @export
 * @interface SubarrayRanges
 */
export interface SubarrayRanges {
    /**
     * 
     * @type {Datatype}
     * @memberof SubarrayRanges
     */
    type?: Datatype;
    /**
     * True if the range is the default range
     * @type {boolean}
     * @memberof SubarrayRanges
     */
    hasDefaultRange?: boolean;
    /**
     * The bytes of the ranges
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    buffer?: Array<number>;
    /**
     * The list of sizes per range
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    bufferSizes?: Array<number>;
    /**
     * The list of start sizes per range
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    bufferStartSizes?: Array<number>;
}
/**
 * the timestamped filtered array metadata URIs, after removing the ones that need to be vacuumed and those that do not fall within
 * @export
 * @interface TimestampedURI
 */
export interface TimestampedURI {
    /**
     * the uri
     * @type {string}
     * @memberof TimestampedURI
     */
    uri?: string;
    /**
     * start of timestamp
     * @type {number}
     * @memberof TimestampedURI
     */
    timestampStart?: number;
    /**
     * end of timestamp
     * @type {number}
     * @memberof TimestampedURI
     */
    timestampEnd?: number;
}
/**
 * 
 * @export
 * @interface Writer
 */
export interface Writer {
    /**
     * 
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordDups?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordOOB?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Writer
     */
    dedupCoords?: boolean;
    /**
     * 
     * @type {Subarray}
     * @memberof Writer
     */
    subarrayRanges?: Subarray;
    /**
     * 
     * @type {DomainArray}
     * @memberof Writer
     */
    subarray?: DomainArray;
}

/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery: async (namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('submitQuery', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('submitQuery', 'array', array)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('submitQuery', 'type', type)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('submitQuery', 'contentType', contentType)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('submitQuery', 'query', query)
            const localVarPath = `/arrays/{namespace}/{array}/query/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }

            if (readAll !== undefined) {
                localVarQueryParameter['read_all'] = readAll;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(query, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration)
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryApiFp(configuration)
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any): AxiosPromise<any> {
            return localVarFp.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any) {
        return QueryApiFp(this.configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options).then((request) => request(this.axios, this.basePath));
    }
}


