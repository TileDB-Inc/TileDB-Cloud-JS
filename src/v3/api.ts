/* tslint:disable */
/* eslint-disable */
/**
 * Specification file for tiledb-server v3 API
 * This spec is exposed to the public under /v3 route group
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: info@tiledb.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../commons/configuration';
import type { AxiosPromise, AxiosInstance } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../commons/common';
import type { RequestArgs } from '../commons/base';
// @ts-ignore
import { COLLECTION_FORMATS, RequiredError } from '../commons/base';
import updateBasePathAfterRedirect from '../utils/updateBasePathAfterRedirect';

export const BASE_PATH = "https://api.tiledb.com/v3".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
        updateBasePathAfterRedirect(axios, BASE_PATH, this);
    }
};

export interface ASTNode {
    'isExpression'?: boolean;
    'fieldName'?: string;
    'value'?: Array<number>;
    'op'?: string;
    'children'?: Array<ASTNode>;
    'combinationOp'?: string;
    'useEnumeration'?: boolean;
    'offsets'?: Array<number>;
}
export interface Aggregate {
    'outputFieldName'?: string;
    'inputFieldName'?: string;
    'name'?: string;
}
export interface ArrayArraySchemasAll {
    'entries'?: Array<ArrayArraySchemasAllEntriesInner>;
}
export interface ArrayArraySchemasAllEntriesInner {
    'key'?: string;
    'value'?: ArraySchema;
}
export interface ArrayDirectory {
    'unfilteredFragmentUris'?: Array<string>;
    'consolidatedCommitUris'?: Array<string>;
    'arraySchemaUris'?: Array<string>;
    'latestArraySchemaUri'?: string;
    'arrayMetaUrisToVacuum'?: Array<string>;
    'arrayMetaVacUrisToVacuum'?: Array<string>;
    'commitUrisToConsolidate'?: Array<string>;
    'commitUrisToVacuum'?: Array<string>;
    'consolidatedCommitUrisToVacuum'?: Array<string>;
    'arrayMetaUris'?: Array<ArrayDirectoryArrayMetaUrisInner>;
    'fragmentMetaUris'?: Array<string>;
    'deleteAndUpdateTileLocation'?: Array<ArrayDirectoryDeleteAndUpdateTileLocationInner>;
    'timestampStart'?: number;
    'timestampEnd'?: number;
}
export interface ArrayDirectoryArrayMetaUrisInner {
    'uri'?: string;
    'timestampStart'?: number;
    'timestampEnd'?: number;
}
export interface ArrayDirectoryDeleteAndUpdateTileLocationInner {
    'uri'?: string;
    'conditionMarker'?: string;
    'offset'?: number;
}
export interface ArrayMetadata {
    'entries'?: Array<ArrayMetadataEntriesInner>;
}
export interface ArrayMetadataEntriesInner {
    'key'?: string;
    'type'?: string;
    'valueNum'?: number;
    'value'?: Array<number>;
    'del'?: boolean;
}
/**
 * ArraySchema during creation or retrieval
 */
export interface ArraySchema {
    'arrayType'?: ArrayType;
    'attributes'?: Array<Attribute>;
    'capacity'?: number;
    'cellOrder'?: Layout;
    'coordsFilterPipeline'?: FilterPipeline;
    'domain'?: Domain;
    'offsetFilterPipeline'?: FilterPipeline;
    'tileOrder'?: Layout;
    'uri'?: string;
    'version'?: Array<number>;
    'allowsDuplicates'?: boolean;
    'validityFilterPipeline'?: FilterPipeline;
    'name'?: string;
    'timestampRange'?: Array<number>;
    'dimensionLabels'?: Array<DimensionLabel>;
    'enumerations'?: Array<Enumeration>;
    'enumerationPathMap'?: Array<ArraySchemaEnumerationPathMapInner>;
    'currentDomain'?: CurrentDomain;
}


export interface ArraySchemaEnumerationPathMapInner {
    'key'?: string;
    'value'?: string;
}
/**
 * TileDB array type
 */

export const ArrayType = {
    Dense: 'dense',
    Sparse: 'sparse'
} as const;

export type ArrayType = typeof ArrayType[keyof typeof ArrayType];


/**
 * Attribute of array
 */
export interface Attribute {
    'cellValNum'?: number;
    'name'?: string;
    'type'?: Datatype;
    'filterPipeline'?: FilterPipeline;
    'fillValue'?: Array<number>;
    'nullable'?: boolean;
    'fillValueValidity'?: boolean;
    'order'?: Layout;
    'enumerationName'?: string;
}


/**
 * Represents an attribute buffer header information
 */
export interface AttributeBufferHeader {
    /**
     * Attribute name
     */
    'name': string;
    /**
     * Number of bytes in the fixed-length attribute data buffer
     */
    'fixedLenBufferSizeInBytes': number;
    /**
     * Number of bytes in the var-length attribute data buffer
     */
    'varLenBufferSizeInBytes': number;
    /**
     * Number of bytes in the validity data buffer
     */
    'validityLenBufferSizeInBytes'?: number;
    /**
     * Original user set number of bytes in the fixed-length attribute data buffer
     */
    'originalFixedLenBufferSizeInBytes'?: number;
    /**
     * Original user set number of bytes in the var-length attribute data buffer
     */
    'originalVarLenBufferSizeInBytes'?: number;
    /**
     * Original user set number of bytes in the validity data buffer
     */
    'originalValidityLenBufferSizeInBytes'?: number;
}
export interface AttributeBufferSize {
    'attribute'?: string;
    'offsetBytes'?: number;
    'dataBytes'?: number;
    'validityBytes'?: number;
}
export interface BufferedChunk {
    'uri'?: string;
    'size'?: number;
}
export interface CompletedPart {
    'eTag'?: string;
    'partNumber'?: number;
}
export interface Condition {
    'clauses'?: Array<ConditionClause>;
    'clauseCombinationOps'?: Array<string>;
    'tree'?: ASTNode;
}
export interface ConditionClause {
    'fieldName'?: string;
    'value'?: Array<number>;
    'op'?: string;
    'useEnumeration'?: boolean;
}
export interface Config {
    'entries'?: Array<ArraySchemaEnumerationPathMapInner>;
}
/**
 * This struct represents the current domain of an array. It is set on the schema at array creation time and can be be evolved using ArraySchemaEvolution APIs by providing an expansion of the current domain that is already set on the array schema. 
 */
export interface CurrentDomain {
    'version'?: number;
    'type'?: string;
    'ndRectangle'?: NDRectangle;
}
/**
 * TileDB data type
 */

export const Datatype = {
    Int32: 'INT32',
    Int64: 'INT64',
    Float32: 'FLOAT32',
    Float64: 'FLOAT64',
    Char: 'CHAR',
    Int8: 'INT8',
    Uint8: 'UINT8',
    Int16: 'INT16',
    Uint16: 'UINT16',
    Uint32: 'UINT32',
    Uint64: 'UINT64',
    StringAscii: 'STRING_ASCII',
    StringUtf8: 'STRING_UTF8',
    StringUtf16: 'STRING_UTF16',
    StringUtf32: 'STRING_UTF32',
    StringUcs2: 'STRING_UCS2',
    StringUcs4: 'STRING_UCS4',
    Any: 'ANY',
    DatetimeYear: 'DATETIME_YEAR',
    DatetimeMonth: 'DATETIME_MONTH',
    DatetimeWeek: 'DATETIME_WEEK',
    DatetimeDay: 'DATETIME_DAY',
    DatetimeHr: 'DATETIME_HR',
    DatetimeMin: 'DATETIME_MIN',
    DatetimeSec: 'DATETIME_SEC',
    DatetimeMs: 'DATETIME_MS',
    DatetimeUs: 'DATETIME_US',
    DatetimeNs: 'DATETIME_NS',
    DatetimePs: 'DATETIME_PS',
    DatetimeFs: 'DATETIME_FS',
    DatetimeAs: 'DATETIME_AS',
    TimeHr: 'TIME_HR',
    TimeMin: 'TIME_MIN',
    TimeSec: 'TIME_SEC',
    TimeMs: 'TIME_MS',
    TimeUs: 'TIME_US',
    TimeNs: 'TIME_NS',
    TimePs: 'TIME_PS',
    TimeFs: 'TIME_FS',
    TimeAs: 'TIME_AS',
    Blob: 'BLOB',
    Bool: 'BOOL'
} as const;

export type Datatype = typeof Datatype[keyof typeof Datatype];


export interface Delete {
    'condition'?: Condition;
    'stats'?: Stats;
}
/**
 * Dimension of array
 */
export interface Dimension {
    'name'?: string;
    'type'?: Datatype;
    'domain'?: DomainArray;
    'nullTileExtent'?: boolean;
    'tileExtent'?: DimensionTileExtent;
    'filterPipeline'?: FilterPipeline;
}


export interface DimensionLabel {
    'dimensionId'?: number;
    'name'?: string;
    'uri'?: string;
    'attributeName'?: string;
    'order'?: string;
    'type'?: Datatype;
    'cellValNum'?: number;
    'external'?: boolean;
    'relative'?: boolean;
    'schema'?: ArraySchema;
}


export interface DimensionTileExtent {
    'int8'?: number;
    'uint8'?: number;
    'int16'?: number;
    'uint16'?: number;
    'int32'?: number;
    'uint32'?: number;
    'int64'?: number;
    'uint64'?: number;
    'float32'?: number;
    'float64'?: number;
}
/**
 * Domain of array
 */
export interface Domain {
    'cellOrder'?: Layout;
    'dimensions'?: Array<Dimension>;
    'tileOrder'?: Layout;
    'type'?: Datatype;
}


/**
 * Domain object for an array of each type
 */
export interface DomainArray {
    'int8'?: Array<number>;
    'uint8'?: Array<number>;
    'int16'?: Array<number>;
    'uint16'?: Array<number>;
    'int32'?: Array<number>;
    'uint32'?: Array<number>;
    'int64'?: Array<number>;
    'uint64'?: Array<number>;
    'float32'?: Array<number>;
    'float64'?: Array<number>;
}
/**
 * Enumeration of values for use by Attributes
 */
export interface Enumeration {
    'name'?: string;
    'pathName'?: string;
    'type'?: Datatype;
    'cellValNum'?: number;
    'ordered'?: boolean;
    'data'?: Array<number>;
    'offsets'?: Array<number>;
}


export interface Filter {
    'type'?: FilterType;
    'data'?: FilterData;
    'floatScaleConfig'?: FloatScaleConfig;
    'webpConfig'?: WebpConfig;
}


export interface FilterData {
    'text'?: string;
    'bytes'?: Array<number>;
    'int8'?: number;
    'uint8'?: number;
    'int16'?: number;
    'uint16'?: number;
    'int32'?: number;
    'uint32'?: number;
    'int64'?: number;
    'uint64'?: number;
    'float32'?: number;
    'float64'?: number;
}
export interface FilterPipeline {
    'filters'?: Array<Filter>;
}
/**
 * TileDB filter types
 */

export const FilterType = {
    FilterNone: 'FILTER_NONE',
    FilterGzip: 'FILTER_GZIP',
    FilterZstd: 'FILTER_ZSTD',
    FilterLz4: 'FILTER_LZ4',
    FilterRle: 'FILTER_RLE',
    FilterBzip2: 'FILTER_BZIP2',
    FilterDoubleDelta: 'FILTER_DOUBLE_DELTA',
    FilterBitWidthReduction: 'FILTER_BIT_WIDTH_REDUCTION',
    FilterBitshuffle: 'FILTER_BITSHUFFLE',
    FilterByteshuffle: 'FILTER_BYTESHUFFLE',
    FilterPositiveDelta: 'FILTER_POSITIVE_DELTA',
    FilterScaleFloat: 'FILTER_SCALE_FLOAT',
    FilterWebp: 'FILTER_WEBP',
    FilterChecksumMd5: 'FILTER_CHECKSUM_MD5',
    FilterChecksumSha256: 'FILTER_CHECKSUM_SHA256',
    FilterDictionary: 'FILTER_DICTIONARY'
} as const;

export type FilterType = typeof FilterType[keyof typeof FilterType];


export interface FloatScaleConfig {
    'scale'?: number;
    'offset'?: number;
    'byteWidth'?: number;
}
export interface FragmentIndex {
    'tileIdx'?: number;
    'cellIdx'?: number;
}
export interface FragmentMetadata {
    'fileSizes'?: Array<number>;
    'fileVarSizes'?: Array<number>;
    'fileValiditySizes'?: Array<number>;
    'fragmentUri'?: string;
    'hasTimestamps'?: boolean;
    'hasDeleteMeta'?: boolean;
    'sparseTileNum'?: number;
    'tileIndexBase'?: number;
    'tileOffsets'?: Array<Array<number>>;
    'tileVarOffsets'?: Array<Array<number>>;
    'tileVarSizes'?: Array<Array<number>>;
    'tileValidityOffsets'?: Array<Array<number>>;
    'tileMinBuffer'?: Array<Array<number>>;
    'tileMinVarBuffer'?: Array<Array<number>>;
    'tileMaxBuffer'?: Array<Array<number>>;
    'tileMaxVarBuffer'?: Array<Array<number>>;
    'tileSums'?: Array<Array<number>>;
    'tileNullCounts'?: Array<Array<number>>;
    'fragmentMins'?: Array<Array<number>>;
    'fragmentMaxs'?: Array<Array<number>>;
    'fragmentSums'?: Array<number>;
    'fragmentNullCounts'?: Array<number>;
    'version'?: number;
    'timestampRange'?: Array<number>;
    'lastTileCellNum'?: number;
    'nonEmptyDomain'?: FragmentMetadataNonEmptyDomain;
    'rtree'?: Array<number>;
    'hasConsolidatedFooter'?: boolean;
    'gtOffsets'?: FragmentMetadataGtOffsets;
    'arraySchemaName'?: string;
}
export interface FragmentMetadataGtOffsets {
    'rtree'?: number;
    'tileOffsets'?: Array<number>;
    'tileVarOffsets'?: Array<number>;
    'tileVarSizes'?: Array<number>;
    'tileValidityOffsets'?: Array<number>;
    'tileMinOffsets'?: Array<number>;
    'tileMaxOffsets'?: Array<number>;
    'tileSumOffsets'?: Array<number>;
    'tileNullCountOffsets'?: Array<number>;
    'fragmentMinMaxSumNullCountOffset'?: number;
    'processedConditionsOffsets'?: number;
}
export interface FragmentMetadataNonEmptyDomain {
    'nonEmptyDomains'?: Array<NonEmptyDomain>;
}
export interface GlobalWriteState {
    'cellsWritten'?: MapUInt64;
    'fragMeta'?: FragmentMetadata;
    'lastCellCoords'?: SingleCoord;
    'lastHilbertValue'?: number;
    'multiPartUploadStates'?: { [key: string]: MultiPartUploadState; };
}
export interface LabelSubarrayRanges {
    'dimensionId'?: number;
    'name'?: string;
    'ranges'?: SubarrayRanges;
}
/**
 * Layout of array
 */

export const Layout = {
    RowMajor: 'row-major',
    ColMajor: 'col-major',
    GlobalOrder: 'global-order',
    Unordered: 'unordered'
} as const;

export type Layout = typeof Layout[keyof typeof Layout];


export interface MapFloat64 {
    'entries'?: Array<MapFloat64EntriesInner>;
}
export interface MapFloat64EntriesInner {
    'key'?: string;
    'value'?: number;
}
export interface MapUInt64 {
    'entries'?: Array<MapUInt64EntriesInner>;
}
export interface MapUInt64EntriesInner {
    'key'?: string;
    'value'?: number;
}
export interface ModelArray {
    'endTimestamp'?: number;
    'queryType'?: QueryType;
    'uri': string;
    'startTimestamp'?: number;
    'arraySchemaLatest': ArraySchema;
    'arraySchemasAll'?: ArrayArraySchemasAll;
    'nonEmptyDomain'?: FragmentMetadataNonEmptyDomain;
    'arrayMetadata'?: ArrayMetadata;
    'arrayDirectory'?: ArrayDirectory;
    'fragmentMetadataAll'?: Array<FragmentMetadata>;
    'openedAtEndTimestamp'?: number;
}


/**
 * Object containing data about a handled error by REST server
 */
export interface ModelError {
    /**
     * A hardcoded integer which points to a specific file/line of the code that returned the error
     */
    'code': number;
    /**
     * A friendly message to be shown to the client
     */
    'message': string;
    /**
     * The request id to be used for tracing/debugging
     */
    'request_id': string;
    'validation_error'?: ValidationError;
}
export interface MultiPartUploadState {
    'partNumber'?: number;
    'uploadId'?: string;
    'status'?: string;
    'completedParts'?: Array<CompletedPart>;
    'bufferedChunks'?: Array<BufferedChunk>;
}
export interface NDRectangle {
    /**
     * List of 1D ranges, one per dimension SubarrayRanges is designed to hold multiple ranges per dimension, For CurrentDomain\'s NDRectangle we only need one range per dimension. 
     */
    'ndranges'?: Array<SubarrayRanges>;
}
export interface NonEmptyDomain {
    'nonEmptyDomain'?: DomainArray;
    'isEmpty'?: boolean;
    'sizes'?: Array<number>;
}
export interface PartitionInfo {
    'subarray'?: Subarray;
    'start'?: number;
    'end'?: number;
    'splitMultiRange'?: boolean;
}
export interface Query {
    'attributeBufferHeaders': Array<AttributeBufferHeader>;
    'layout': Layout;
    'status': QueryStatus;
    'type': QueryType;
    'writer'?: Writer;
    'reader'?: QueryReader;
    'array': ModelArray;
    /**
     * Total number of bytes in fixed size attribute buffers.
     */
    'totalFixedLengthBufferBytes': number;
    /**
     * Total number of bytes in variable size attribute buffers.
     */
    'totalVarLenBufferBytes': number;
    /**
     * Total number of bytes in validity buffers
     */
    'totalValidityBufferBytes'?: number;
    'config'?: Config;
    'stats'?: Stats;
    'readerIndex'?: ReaderIndex;
    'denseReader'?: QueryReader;
    'delete'?: Delete;
    'writtenFragmentInfo'?: Array<WrittenFragmentInfo>;
    'writtenBuffers'?: Array<string>;
    'orderedDimLabelReader'?: QueryReader;
    'channels'?: Array<QueryChannel>;
}


export interface QueryChannel {
    'default'?: boolean;
    'aggregates'?: Array<Aggregate>;
}
/**
 * Read struct (can\'t be called reader due to class name conflict)
 */
export interface QueryReader {
    'layout'?: Layout;
    'subarray'?: Subarray;
    'readState'?: ReadState;
    'condition'?: Condition;
    'stats'?: Stats;
    /**
     * True if dim label query is using increasing order, false if decreasing order.
     */
    'dimLabelIncreasing'?: boolean;
}


/**
 * Status of query
 */

export const QueryStatus = {
    Failed: 'FAILED',
    Completed: 'COMPLETED',
    Inprogress: 'INPROGRESS',
    Incomplete: 'INCOMPLETE',
    Uninitialized: 'UNINITIALIZED'
} as const;

export type QueryStatus = typeof QueryStatus[keyof typeof QueryStatus];


/**
 * Type of query
 */

export const QueryType = {
    Read: 'READ',
    Write: 'WRITE'
} as const;

export type QueryType = typeof QueryType[keyof typeof QueryType];


export interface ReadState {
    'overflowed'?: boolean;
    'unsplittable'?: boolean;
    'initialized'?: boolean;
    'subarrayPartitioner'?: SubarrayPartitioner;
}
export interface ReadStateIndex {
    'resultCellSlab'?: Array<ResultCellSlab>;
    'fragTileIdx'?: Array<FragmentIndex>;
    'doneAddingResultTiles'?: boolean;
}
export interface ReaderIndex {
    'layout'?: Layout;
    'subarray'?: Subarray;
    'readState'?: ReadStateIndex;
    'condition'?: Condition;
    'stats'?: Stats;
}


export interface ResultCellSlab {
    'fragIdx'?: number;
    'tileIdx'?: number;
    'start'?: number;
    'length'?: number;
}
export interface SingleCoord {
    'coords'?: Array<Array<number>>;
    'sizes'?: Array<number>;
    'singleOffset'?: Array<number>;
}
export interface State {
    'start'?: number;
    'end'?: number;
    'singleRange'?: Array<Subarray>;
    'multiRange'?: Array<Subarray>;
}
export interface Stats {
    'timers'?: MapFloat64;
    'counters'?: MapUInt64;
}
export interface Subarray {
    'layout'?: Layout;
    'stats'?: Stats;
    /**
     * List of 1D ranges, one per dimension
     */
    'ranges'?: Array<SubarrayRanges>;
    'relevantFragments'?: Array<number>;
    'coalesceRanges'?: boolean;
    'labelRanges'?: Array<LabelSubarrayRanges>;
    'attributeRanges'?: SubarrayAttributeRanges;
}


export interface SubarrayAttributeRanges {
    'entries'?: Array<SubarrayAttributeRangesEntriesInner>;
}
export interface SubarrayAttributeRangesEntriesInner {
    'key'?: string;
    'value'?: SubarrayRanges;
}
export interface SubarrayPartitioner {
    'subarray'?: Subarray;
    'budget'?: Array<AttributeBufferSize>;
    'current'?: PartitionInfo;
    'state'?: State;
    'memoryBudget'?: number;
    'memoryBudgetVar'?: number;
    'memoryBudgetValidity'?: number;
    'stats'?: Stats;
}
/**
 * A set of 1D ranges for a subarray
 */
export interface SubarrayRanges {
    'type'?: Datatype;
    /**
     * True if the range is the default range
     */
    'hasDefaultRange'?: boolean;
    /**
     * The bytes of the ranges
     */
    'buffer'?: Array<number>;
    /**
     * The list of sizes per range
     */
    'bufferSizes'?: Array<number>;
    /**
     * The list of start sizes per range
     */
    'bufferStartSizes'?: Array<number>;
}


export interface UnorderedWriterState {
    'isCoordPass'?: boolean;
    'cellPos'?: Array<number>;
    'coordDups'?: Array<number>;
    'fragMeta'?: FragmentMetadata;
}
/**
 * Object containing data about a handled error by REST server
 */
export interface ValidationError {
    /**
     * The list of fields that failed validation
     */
    'fields': Array<ValidationErrorField>;
}
/**
 * Object containing data about a handled error by REST server
 */
export interface ValidationErrorField {
    /**
     * The name of the field that failed validation
     */
    'field': string;
    /**
     * A friendly message about the validation error
     */
    'message': string;
}
export interface WebpConfig {
    'quality'?: number;
    'format'?: number;
    'lossless'?: boolean;
    'extentX'?: number;
    'extentY'?: number;
}
export interface Writer {
    'checkCoordDups'?: boolean;
    'checkCoordOOB'?: boolean;
    'dedupCoords'?: boolean;
    'subarray'?: DomainArray;
    'subarrayRanges'?: Subarray;
    'stats'?: Stats;
    'globalWriteStateV1'?: GlobalWriteState;
    'unorderedWriterState'?: UnorderedWriterState;
}
export interface WrittenFragmentInfo {
    'uri'?: string;
    'timestampRange'?: Array<number>;
}


/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @summary send a query to run against a specified array/URI registered to a group/project
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} array The asset id or path for which to retrieve assets
         * @param {string} type type of query
         * @param {Query} query query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery: async (workspace: string, teamspace: string, array: string, type: string, query: Query, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('submitQuery', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('submitQuery', 'teamspace', teamspace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('submitQuery', 'array', array)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('submitQuery', 'type', type)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('submitQuery', 'query', query)
            const localVarPath = `/arrays/{workspace}/{teamspace}/{array}/query/submit`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["read", "write", "admin"], configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(query, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration)
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @summary send a query to run against a specified array/URI registered to a group/project
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} array The asset id or path for which to retrieve assets
         * @param {string} type type of query
         * @param {Query} query query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitQuery(workspace: string, teamspace: string, array: string, type: string, query: Query, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitQuery(workspace, teamspace, array, type, query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryApiFp(configuration)
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @summary send a query to run against a specified array/URI registered to a group/project
         * @param {string} workspace The workspace name or id
         * @param {string} teamspace The teamspace name or id
         * @param {string} array The asset id or path for which to retrieve assets
         * @param {string} type type of query
         * @param {Query} query query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(workspace: string, teamspace: string, array: string, type: string, query: Query, options?: any): AxiosPromise<File> {
            return localVarFp.submitQuery(workspace, teamspace, array, type, query, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @summary send a query to run against a specified array/URI registered to a group/project
     * @param {string} workspace The workspace name or id
     * @param {string} teamspace The teamspace name or id
     * @param {string} array The asset id or path for which to retrieve assets
     * @param {string} type type of query
     * @param {Query} query query to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public submitQuery(workspace: string, teamspace: string, array: string, type: string, query: Query, options?: any) {
        return QueryApiFp(this.configuration).submitQuery(workspace, teamspace, array, type, query, options).then((request) => request(this.axios, this.basePath));
    }
}

