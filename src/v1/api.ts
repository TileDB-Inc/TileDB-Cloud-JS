/* tslint:disable */
/* eslint-disable */
/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Model representing aws keys or service role, service roles are currently ignored, but will be preferred option in the future
 * @export
 * @interface AWSAccessCredentials
 */
export interface AWSAccessCredentials {
    /**
     * aws secret access key, never returned in get requests
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    secret_access_key?: string;
    /**
     * aws access key
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    access_key_id?: string;
    /**
     * aws service role to use for access
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    service_role_arn?: string;
    /**
     * human readable name
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    name?: string;
    /**
     * true if this is the default credential to be used within this namespace
     * @type {boolean}
     * @memberof AWSAccessCredentials
     */
    default?: boolean;
    /**
     * a whitelist of one or more buckets this key should access
     * @type {Array<string>}
     * @memberof AWSAccessCredentials
     */
    buckets?: Array<string>;
    /**
     * Time when UDF dependencies were created (rfc3339)
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    created_at?: string;
    /**
     * Time when UDF dependencies was last updated (rfc3339)
     * @type {string}
     * @memberof AWSAccessCredentials
     */
    updated_at?: string;
}
/**
 * Type of activity logged
 * @export
 * @enum {string}
 */
export enum ActivityEventType {
    ReadSchema = 'read_schema',
    MaxBufferSizes = 'max_buffer_sizes',
    NonEmptyDomain = 'non_empty_domain',
    QueryRead = 'query_read',
    QueryWrite = 'query_write',
    Create = 'create',
    Delete = 'delete',
    Register = 'register',
    Deregister = 'deregister',
    Udf = 'udf',
    ArrayMetadataGet = 'array_metadata_get',
    ArrayMetadataUpdate = 'array_metadata_update',
    EstimatedResultSizes = 'estimated_result_sizes'
}

/**
 * actions a user can take on an array
 * @export
 * @enum {string}
 */
export enum ArrayActions {
    Read = 'read',
    Write = 'write',
    Edit = 'edit',
    ReadArrayLogs = 'read_array_logs',
    ReadArrayInfo = 'read_array_info',
    ReadArraySchema = 'read_array_schema'
}

/**
 * Actvity of an Array
 * @export
 * @interface ArrayActivityLog
 */
export interface ArrayActivityLog {
    /**
     * time event took place (RFC3339)
     * @type {string}
     * @memberof ArrayActivityLog
     */
    event_at?: string;
    /**
     * 
     * @type {ActivityEventType}
     * @memberof ArrayActivityLog
     */
    action?: ActivityEventType;
    /**
     * User who performed action
     * @type {string}
     * @memberof ArrayActivityLog
     */
    username?: string;
    /**
     * Bytes sent to client
     * @type {number}
     * @memberof ArrayActivityLog
     */
    bytes_sent?: number;
    /**
     * Bytes recieved from client
     * @type {number}
     * @memberof ArrayActivityLog
     */
    bytes_received?: number;
    /**
     * UUID of associated array task
     * @type {string}
     * @memberof ArrayActivityLog
     */
    array_task_id?: string;
    /**
     * ID of the activity
     * @type {string}
     * @memberof ArrayActivityLog
     */
    id?: string;
    /**
     * ranges for query
     * @type {string}
     * @memberof ArrayActivityLog
     */
    query_ranges?: string;
    /**
     * stats for query
     * @type {string}
     * @memberof ArrayActivityLog
     */
    query_stats?: string;
}
/**
 * Object including array info and pagination metadata
 * @export
 * @interface ArrayBrowserData
 */
export interface ArrayBrowserData {
    /**
     * Array Info
     * @type {Array<ArrayInfo>}
     * @memberof ArrayBrowserData
     */
    arrays?: Array<ArrayInfo>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof ArrayBrowserData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * Object for ui array tasks browser page
 * @export
 * @interface ArrayBrowserSidebar
 */
export interface ArrayBrowserSidebar {
    /**
     * list of all unique namespaces to display
     * @type {Array<string>}
     * @memberof ArrayBrowserSidebar
     */
    namespaces?: Array<string>;
    /**
     * A count of \"all\" of category
     * @type {number}
     * @memberof ArrayBrowserSidebar
     */
    result_count_for_all?: number;
    /**
     * A map that includes the result count by namespace
     * @type {object}
     * @memberof ArrayBrowserSidebar
     */
    result_count_by_namespace?: object;
}
/**
 * Object including array end_timestamps (list of Unix epoch timestamps in milliseconds) and pagination metadata
 * @export
 * @interface ArrayEndTimestampData
 */
export interface ArrayEndTimestampData {
    /**
     * List of timestamps expressed in milliseconds since Unix epoch
     * @type {Array<number>}
     * @memberof ArrayEndTimestampData
     */
    end_timestamps?: Array<number>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof ArrayEndTimestampData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * A user-favorite array item
 * @export
 * @interface ArrayFavorite
 */
export interface ArrayFavorite {
    /**
     * unique UUID of the array
     * @type {string}
     * @memberof ArrayFavorite
     */
    array_uuid?: string;
    /**
     * the namespace of the array
     * @type {string}
     * @memberof ArrayFavorite
     */
    namespace?: string;
    /**
     * the name of the array
     * @type {string}
     * @memberof ArrayFavorite
     */
    name?: string;
}
/**
 * Object including array favorites and pagination metadata
 * @export
 * @interface ArrayFavoritesData
 */
export interface ArrayFavoritesData {
    /**
     * List of array infos
     * @type {Array<ArrayInfo>}
     * @memberof ArrayFavoritesData
     */
    arrays?: Array<ArrayInfo>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof ArrayFavoritesData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * metadata of an array
 * @export
 * @interface ArrayInfo
 */
export interface ArrayInfo {
    /**
     * unique ID of registered array
     * @type {string}
     * @memberof ArrayInfo
     */
    id?: string;
    /**
     * 
     * @type {FileType}
     * @memberof ArrayInfo
     */
    file_type?: FileType;
    /**
     * map of file properties created for this array
     * @type {{ [key: string]: string; }}
     * @memberof ArrayInfo
     */
    file_properties?: { [key: string]: string; };
    /**
     * uri of array
     * @type {string}
     * @memberof ArrayInfo
     */
    uri?: string;
    /**
     * namespace array is in
     * @type {string}
     * @memberof ArrayInfo
     */
    namespace?: string;
    /**
     * size in bytes of array
     * @type {number}
     * @memberof ArrayInfo
     */
    size?: number;
    /**
     * Datetime array was last accessed in UTC
     * @type {string}
     * @memberof ArrayInfo
     */
    last_accessed?: string;
    /**
     * description of array
     * @type {string}
     * @memberof ArrayInfo
     */
    description?: string | null;
    /**
     * name of array
     * @type {string}
     * @memberof ArrayInfo
     */
    name?: string;
    /**
     * list of actions user is allowed to do on this array
     * @type {Array<ArrayActions>}
     * @memberof ArrayInfo
     */
    allowed_actions?: Array<ArrayActions>;
    /**
     * list of pricing created for this array
     * @type {Array<Pricing>}
     * @memberof ArrayInfo
     */
    pricing?: Array<Pricing>;
    /**
     * list of subscriptions created for this array
     * @type {Array<Subscription>}
     * @memberof ArrayInfo
     */
    subscriptions?: Array<Subscription>;
    /**
     * logo (base64 encoded) for the array. Optional
     * @type {string}
     * @memberof ArrayInfo
     */
    logo?: string;
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used
     * @type {string}
     * @memberof ArrayInfo
     */
    access_credentials_name?: string;
    /**
     * Array type (dense, key-value, sparse)
     * @type {string}
     * @memberof ArrayInfo
     */
    type?: string;
    /**
     * number of unique namespaces this array is shared with
     * @type {number}
     * @memberof ArrayInfo
     */
    share_count?: number;
    /**
     * Suggests if the array was shared to public by owner
     * @type {boolean}
     * @memberof ArrayInfo
     */
    public_share?: boolean;
    /**
     * Depends on the namespace asking, denotes the existence of subscription of namespace to this array
     * @type {boolean}
     * @memberof ArrayInfo
     */
    namespace_subscribed?: boolean;
    /**
     * uri for access through TileDB cloud
     * @type {string}
     * @memberof ArrayInfo
     */
    tiledb_uri?: string;
    /**
     * optional tags for array
     * @type {Array<string>}
     * @memberof ArrayInfo
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom
     * @type {string}
     * @memberof ArrayInfo
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof ArrayInfo
     */
    license_text?: string;
    /**
     * Suggests if the array is in read_only mode
     * @type {boolean}
     * @memberof ArrayInfo
     */
    read_only?: boolean | null;
    /**
     * Indicates whether the array is in user favorites
     * @type {boolean}
     * @memberof ArrayInfo
     */
    is_favorite?: boolean;
}
/**
 * metadata of an array
 * @export
 * @interface ArrayInfoUpdate
 */
export interface ArrayInfoUpdate {
    /**
     * description of array
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    description?: string | null;
    /**
     * description of array
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    name?: string;
    /**
     * uri of array
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    uri?: string;
    /**
     * 
     * @type {FileType}
     * @memberof ArrayInfoUpdate
     */
    file_type?: FileType;
    /**
     * map of file properties created for this array
     * @type {{ [key: string]: string; }}
     * @memberof ArrayInfoUpdate
     */
    file_properties?: { [key: string]: string; };
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    access_credentials_name?: string;
    /**
     * logo (base64 encoded) for the array. Optional
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    logo?: string;
    /**
     * optional tags for array
     * @type {Array<string>}
     * @memberof ArrayInfoUpdate
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof ArrayInfoUpdate
     */
    license_text?: string;
    /**
     * Suggests if the array is in read_only mode
     * @type {boolean}
     * @memberof ArrayInfoUpdate
     */
    read_only?: boolean;
}
/**
 * user\'s TileDB array metadata
 * @export
 * @interface ArrayMetadata
 */
export interface ArrayMetadata {
    /**
     * List of metadata entries
     * @type {Array<ArrayMetadataEntry>}
     * @memberof ArrayMetadata
     */
    entries?: Array<ArrayMetadataEntry>;
}
/**
 * key/value pair representing an array metadata map entry
 * @export
 * @interface ArrayMetadataEntry
 */
export interface ArrayMetadataEntry {
    /**
     * 
     * @type {string}
     * @memberof ArrayMetadataEntry
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof ArrayMetadataEntry
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof ArrayMetadataEntry
     */
    valueNum?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ArrayMetadataEntry
     */
    value?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof ArrayMetadataEntry
     */
    del?: boolean;
}
/**
 * Sample data from array
 * @export
 * @interface ArraySample
 */
export interface ArraySample {
    /**
     * 
     * @type {object}
     * @memberof ArraySample
     */
    data?: object;
}
/**
 * ArraySchema during creation or retrieval
 * @export
 * @interface ArraySchema
 */
export interface ArraySchema {
    /**
     * URI of schema
     * @type {string}
     * @memberof ArraySchema
     */
    uri?: string;
    /**
     * file format version
     * @type {Array<number>}
     * @memberof ArraySchema
     */
    version: Array<number>;
    /**
     * 
     * @type {ArrayType}
     * @memberof ArraySchema
     */
    arrayType: ArrayType;
    /**
     * 
     * @type {Layout}
     * @memberof ArraySchema
     */
    tileOrder: Layout;
    /**
     * 
     * @type {Layout}
     * @memberof ArraySchema
     */
    cellOrder: Layout;
    /**
     * Capacity of array
     * @type {number}
     * @memberof ArraySchema
     */
    capacity: number;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    coordsFilterPipeline: FilterPipeline;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    offsetFilterPipeline: FilterPipeline;
    /**
     * 
     * @type {Domain}
     * @memberof ArraySchema
     */
    domain: Domain;
    /**
     * Attributes of array
     * @type {Array<Attribute>}
     * @memberof ArraySchema
     */
    attributes: Array<Attribute>;
    /**
     * True if the array allows coordinate duplicates. Applicable only to sparse arrays.
     * @type {boolean}
     * @memberof ArraySchema
     */
    allowsDuplicates?: boolean;
}
/**
 * details for sharing a given array
 * @export
 * @interface ArraySharing
 */
export interface ArraySharing {
    /**
     * List of permitted actions
     * @type {Array<ArrayActions>}
     * @memberof ArraySharing
     */
    actions?: Array<ArrayActions>;
    /**
     * namespace being granted array access can be a user or organization
     * @type {string}
     * @memberof ArraySharing
     */
    namespace?: string;
    /**
     * details on if the namespace is a organization or user
     * @type {string}
     * @memberof ArraySharing
     */
    namespace_type?: string;
}
/**
 * Synchronous Task to Run
 * @export
 * @interface ArrayTask
 */
export interface ArrayTask {
    /**
     * task ID
     * @type {string}
     * @memberof ArrayTask
     */
    id?: string;
    /**
     * Optional task name
     * @type {string}
     * @memberof ArrayTask
     */
    name?: string;
    /**
     * Optional task description (Tasks purpose)
     * @type {string}
     * @memberof ArrayTask
     */
    description?: string;
    /**
     * 
     * @type {ArrayInfo}
     * @memberof ArrayTask
     */
    array_metadata?: ArrayInfo;
    /**
     * 
     * @type {DomainArray}
     * @memberof ArrayTask
     */
    subarray?: DomainArray;
    /**
     * memory allocated to task in bytes
     * @type {number}
     * @memberof ArrayTask
     */
    memory?: number;
    /**
     * millicpu allocated to task
     * @type {number}
     * @memberof ArrayTask
     */
    cpu?: number;
    /**
     * namespace task is tied to
     * @type {string}
     * @memberof ArrayTask
     */
    namespace?: string;
    /**
     * 
     * @type {ArrayTaskStatus}
     * @memberof ArrayTask
     */
    status?: ArrayTaskStatus;
    /**
     * Start time RFC3339 for job
     * @type {string}
     * @memberof ArrayTask
     */
    start_time?: string;
    /**
     * Finish time RFC3339 for job
     * @type {string}
     * @memberof ArrayTask
     */
    finish_time?: string | null;
    /**
     * Total accumulated for task in USD, example is $0.12
     * @type {number}
     * @memberof ArrayTask
     */
    cost?: number;
    /**
     * Total accumulated for egress task in USD, example is $0.12
     * @type {number}
     * @memberof ArrayTask
     */
    egress_cost?: number;
    /**
     * Cost accumulated for access task in USD, example is $0.12
     * @type {number}
     * @memberof ArrayTask
     */
    access_cost?: number;
    /**
     * 
     * @type {Querytype}
     * @memberof ArrayTask
     */
    query_type?: Querytype;
    /**
     * Optional actual code that is going to be executed
     * @type {string}
     * @memberof ArrayTask
     */
    udf_code?: string;
    /**
     * Optional actual language used to express udf_code
     * @type {string}
     * @memberof ArrayTask
     */
    udf_language?: string;
    /**
     * Optional actual sql query that is going to be executed
     * @type {string}
     * @memberof ArrayTask
     */
    sql_query?: string;
    /**
     * 
     * @type {ArrayTaskType}
     * @memberof ArrayTask
     */
    type?: ArrayTaskType;
    /**
     * Array activity logs for task
     * @type {Array<ArrayActivityLog>}
     * @memberof ArrayTask
     */
    activity?: Array<ArrayActivityLog>;
    /**
     * logs from array task
     * @type {string}
     * @memberof ArrayTask
     */
    logs?: string;
    /**
     * duration in nanoseconds of an array task
     * @type {number}
     * @memberof ArrayTask
     */
    duration?: number;
    /**
     * SQL queries or commands to run before main sql query
     * @type {Array<string>}
     * @memberof ArrayTask
     */
    sql_init_commands?: Array<string>;
    /**
     * SQL query parameters
     * @type {Array<object>}
     * @memberof ArrayTask
     */
    sql_parameters?: Array<object>;
    /**
     * 
     * @type {ResultFormat}
     * @memberof ArrayTask
     */
    result_format?: ResultFormat;
    /**
     * If set, the ID of the log for the task graph that this was part of. 
     * @type {string}
     * @memberof ArrayTask
     */
    task_graph_uuid?: string;
    /**
     * If set, the client-defined ID of the node within this task\'s graph. 
     * @type {string}
     * @memberof ArrayTask
     */
    client_node_uuid?: string;
}
/**
 * Object for ui array tasks browser page
 * @export
 * @interface ArrayTaskBrowserSidebar
 */
export interface ArrayTaskBrowserSidebar {
    /**
     * list of all unique organizations the user is part of that have array tasks
     * @type {Array<string>}
     * @memberof ArrayTaskBrowserSidebar
     */
    organizations?: Array<string>;
    /**
     * A count of \"all\"
     * @type {number}
     * @memberof ArrayTaskBrowserSidebar
     */
    result_count_for_all?: number;
    /**
     * A map that includes the result count by namespace
     * @type {object}
     * @memberof ArrayTaskBrowserSidebar
     */
    result_count_by_namespace?: object;
}
/**
 * Object including array tasks and metadata
 * @export
 * @interface ArrayTaskData
 */
export interface ArrayTaskData {
    /**
     * Array Tasks
     * @type {Array<ArrayTask>}
     * @memberof ArrayTaskData
     */
    array_tasks?: Array<ArrayTask>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof ArrayTaskData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * Array task stderr/stdout logs
 * @export
 * @interface ArrayTaskLog
 */
export interface ArrayTaskLog {
    /**
     * ID of associated task
     * @type {string}
     * @memberof ArrayTaskLog
     */
    array_task_id?: string;
    /**
     * logs from array task
     * @type {string}
     * @memberof ArrayTaskLog
     */
    logs?: string;
}
/**
 * Status of array task
 * @export
 * @enum {string}
 */
export enum ArrayTaskStatus {
    Queued = 'QUEUED',
    Failed = 'FAILED',
    Completed = 'COMPLETED',
    Running = 'RUNNING',
    Denied = 'DENIED',
    Unknown = 'UNKNOWN'
}

/**
 * Synchronous Task Type
 * @export
 * @enum {string}
 */
export enum ArrayTaskType {
    Sql = 'SQL',
    Udf = 'UDF',
    Query = 'QUERY',
    GenericUdf = 'GENERIC_UDF'
}

/**
 * TileDB array type
 * @export
 * @enum {string}
 */
export enum ArrayType {
    Dense = 'dense',
    Sparse = 'sparse'
}

/**
 * Attribute of array
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * Attribute name
     * @type {string}
     * @memberof Attribute
     */
    name: string;
    /**
     * 
     * @type {Datatype}
     * @memberof Attribute
     */
    type: Datatype;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof Attribute
     */
    filterPipeline: FilterPipeline;
    /**
     * Attribute number of values per cell
     * @type {number}
     * @memberof Attribute
     */
    cellValNum: number;
    /**
     * Is attribute nullable
     * @type {boolean}
     * @memberof Attribute
     */
    nullable?: boolean;
    /**
     * The default fill value
     * @type {Array<number>}
     * @memberof Attribute
     */
    fillValue?: Array<number>;
}
/**
 * Represents an attribute buffer header information
 * @export
 * @interface AttributeBufferHeader
 */
export interface AttributeBufferHeader {
    /**
     * Attribute name
     * @type {string}
     * @memberof AttributeBufferHeader
     */
    name: string;
    /**
     * Number of bytes in the fixed-length attribute data buffer (offsets for var-len attributes)
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    fixedLenBufferSizeInBytes: number;
    /**
     * Number of bytes in the var-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    varLenBufferSizeInBytes: number;
}
/**
 * object representing buffer size of an attribute
 * @export
 * @interface AttributeBufferSize
 */
export interface AttributeBufferSize {
    /**
     * name of attribute
     * @type {string}
     * @memberof AttributeBufferSize
     */
    attribute: string;
    /**
     * buffer size (in bytes) of offset buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    offsetBytes: number;
    /**
     * buffer size (in bytes) of data buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    dataBytes: number;
}
/**
 * TileDB data type
 * @export
 * @enum {string}
 */
export enum Datatype {
    Int32 = 'INT32',
    Int64 = 'INT64',
    Float32 = 'FLOAT32',
    Float64 = 'FLOAT64',
    Char = 'CHAR',
    Int8 = 'INT8',
    Uint8 = 'UINT8',
    Int16 = 'INT16',
    Uint16 = 'UINT16',
    Uint32 = 'UINT32',
    Uint64 = 'UINT64',
    StringAscii = 'STRING_ASCII',
    StringUtf8 = 'STRING_UTF8',
    StringUtf16 = 'STRING_UTF16',
    StringUtf32 = 'STRING_UTF32',
    StringUcs2 = 'STRING_UCS2',
    StringUcs4 = 'STRING_UCS4',
    Any = 'ANY'
}

/**
 * Dimension of array
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * Dimension name
     * @type {string}
     * @memberof Dimension
     */
    name?: string;
    /**
     * 
     * @type {Datatype}
     * @memberof Dimension
     */
    type: Datatype;
    /**
     * 
     * @type {DomainArray}
     * @memberof Dimension
     */
    domain: DomainArray;
    /**
     * Is tile extent null
     * @type {boolean}
     * @memberof Dimension
     */
    nullTileExtent: boolean;
    /**
     * 
     * @type {DimensionTileExtent}
     * @memberof Dimension
     */
    tileExtent?: DimensionTileExtent;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof Dimension
     */
    filterPipeline?: FilterPipeline;
}
/**
 * A single, typed coordinate for a dimension
 * @export
 * @interface DimensionCoordinate
 */
export interface DimensionCoordinate {
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int8?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint8?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int16?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint16?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    int64?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    uint64?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    float32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionCoordinate
     */
    float64?: number;
}
/**
 * Extent of tile
 * @export
 * @interface DimensionTileExtent
 */
export interface DimensionTileExtent {
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int8?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint8?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int16?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint16?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int64?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint64?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    float32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    float64?: number;
}
/**
 * Domain of array
 * @export
 * @interface Domain
 */
export interface Domain {
    /**
     * 
     * @type {Datatype}
     * @memberof Domain
     */
    type: Datatype;
    /**
     * 
     * @type {Layout}
     * @memberof Domain
     */
    tileOrder: Layout;
    /**
     * 
     * @type {Layout}
     * @memberof Domain
     */
    cellOrder: Layout;
    /**
     * Array of dimensions
     * @type {Array<Dimension>}
     * @memberof Domain
     */
    dimensions: Array<Dimension>;
}
/**
 * Domain object for an array of each type
 * @export
 * @interface DomainArray
 */
export interface DomainArray {
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int8?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint8?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int16?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint16?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int32?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint32?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int64?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint64?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float32?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float64?: Array<number>;
}
/**
 * Input/Output information required to create a new file
 * @export
 * @interface FileCreate
 */
export interface FileCreate {
    /**
     * storage URI of the input file
     * @type {string}
     * @memberof FileCreate
     */
    input_uri?: string;
    /**
     * output location of the TileDB File
     * @type {string}
     * @memberof FileCreate
     */
    output_uri?: string;
    /**
     * name to set for registered file
     * @type {string}
     * @memberof FileCreate
     */
    name?: string;
}
/**
 * Created file name and information
 * @export
 * @interface FileCreated
 */
export interface FileCreated {
    /**
     * output location of the TileDB File
     * @type {string}
     * @memberof FileCreated
     */
    output_uri?: string;
    /**
     * name of the file created
     * @type {string}
     * @memberof FileCreated
     */
    file_name?: string;
}
/**
 * Output information required to export a file
 * @export
 * @interface FileExport
 */
export interface FileExport {
    /**
     * output location of the TileDB File
     * @type {string}
     * @memberof FileExport
     */
    output_uri?: string;
}
/**
 * Output uri of the exported file
 * @export
 * @interface FileExported
 */
export interface FileExported {
    /**
     * output location of the exported file
     * @type {string}
     * @memberof FileExported
     */
    output_uri?: string;
}
/**
 * File property assigned to a specific file (array)
 * @export
 * @enum {string}
 */
export enum FilePropertyName {
    Image = 'image',
    Size = 'size',
    CodeBlock = 'code_block',
    UdfLanguage = 'udf_language',
    IsDashboard = 'is_dashboard'
}

/**
 * File types represented as TileDB arrays
 * @export
 * @enum {string}
 */
export enum FileType {
    Notebook = 'notebook',
    UserDefinedFunction = 'user_defined_function',
    MlModel = 'ml_model',
    File = 'file'
}

/**
 * Filter
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {FilterType}
     * @memberof Filter
     */
    type: FilterType;
    /**
     * 
     * @type {FilterData}
     * @memberof Filter
     */
    data?: FilterData;
}
/**
 * Filter data
 * @export
 * @interface FilterData
 */
export interface FilterData {
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int8?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint8?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int16?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint16?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int32?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint32?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int64?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint64?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    float32?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    float64?: number;
}
/**
 * TileDB filter option
 * @export
 * @enum {string}
 */
export enum FilterOption {
    CompressionLevel = 'COMPRESSION_LEVEL',
    BitWidthMaxWindow = 'BIT_WIDTH_MAX_WINDOW',
    PositiveDeltaMaxWindow = 'POSITIVE_DELTA_MAX_WINDOW'
}

/**
 * One or more filters to apply
 * @export
 * @interface FilterPipeline
 */
export interface FilterPipeline {
    /**
     * 
     * @type {Array<Filter>}
     * @memberof FilterPipeline
     */
    filters?: Array<Filter>;
}
/**
 * TileDB filter types
 * @export
 * @enum {string}
 */
export enum FilterType {
    None = 'FILTER_NONE',
    Gzip = 'FILTER_GZIP',
    Zstd = 'FILTER_ZSTD',
    Lz4 = 'FILTER_LZ4',
    Rle = 'FILTER_RLE',
    Bzip2 = 'FILTER_BZIP2',
    DoubleDelta = 'FILTER_DOUBLE_DELTA',
    BitWidthReduction = 'FILTER_BIT_WIDTH_REDUCTION',
    Bitshuffle = 'FILTER_BITSHUFFLE',
    Byteshuffle = 'FILTER_BYTESHUFFLE',
    PositiveDelta = 'FILTER_POSITIVE_DELTA'
}

/**
 * User-defined function
 * @export
 * @interface GenericUDF
 */
export interface GenericUDF {
    /**
     * name of UDFInfo to run, format is {namespace}/{udf_name}. Can not be used with exec
     * @type {string}
     * @memberof GenericUDF
     */
    udf_info_name?: string;
    /**
     * 
     * @type {UDFLanguage}
     * @memberof GenericUDF
     */
    language?: UDFLanguage;
    /**
     * Type-specific version
     * @type {string}
     * @memberof GenericUDF
     */
    version?: string;
    /**
     * Docker image name to use for UDF
     * @type {string}
     * @memberof GenericUDF
     */
    image_name?: string;
    /**
     * Type-specific executable text
     * @type {string}
     * @memberof GenericUDF
     */
    exec?: string;
    /**
     * optional raw text to store of serialized function, used for showing in UI
     * @type {string}
     * @memberof GenericUDF
     */
    exec_raw?: string;
    /**
     * Argument(s) to pass to UDF function, tuple or list of args/kwargs which can be in native or JSON format
     * @type {string}
     * @memberof GenericUDF
     */
    argument?: string;
    /**
     * The UUIDs of stored input parameters (passed in a language-specific format within \"argument\") to be retrieved from the server-side cache. Serialized in standard hex format with no {}.
     * @type {Array<string>}
     * @memberof GenericUDF
     */
    stored_param_uuids?: Array<string>;
    /**
     * 
     * @type {ResultFormat}
     * @memberof GenericUDF
     */
    result_format?: ResultFormat;
    /**
     * name of task, optional
     * @type {string}
     * @memberof GenericUDF
     */
    task_name?: string;
    /**
     * store results for later retrieval
     * @type {boolean}
     * @memberof GenericUDF
     */
    store_results?: boolean;
    /**
     * UDF-type timeout in seconds (default: 900)
     * @type {number}
     * @memberof GenericUDF
     */
    timeout?: number;
    /**
     * Set to true to avoid downloading the results of this UDF. Useful for intermediate nodes in a task graph where you will not be using the results of your function. Defaults to false (\"yes download results\").
     * @type {boolean}
     * @memberof GenericUDF
     */
    dont_download_results?: boolean;
    /**
     * If set, the ID of the log for the task graph that this was part of. 
     * @type {string}
     * @memberof GenericUDF
     */
    task_graph_uuid?: string;
    /**
     * If set, the client-defined ID of the node within this task\'s graph. 
     * @type {string}
     * @memberof GenericUDF
     */
    client_node_uuid?: string;
}
/**
 * Attributes that describe the group itself, not any of the subgroups or assets
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * the globally unique id of the group
     * @type {string}
     * @memberof Group
     */
    id?: string;
    /**
     * The namespace of the group
     * @type {string}
     * @memberof Group
     */
    namespace?: string;
    /**
     * The name of the group. It is unique within the namespace. No 2 groups can have the same name
     * @type {string}
     * @memberof Group
     */
    name?: string;
    /**
     * A human readable description of the content of the group
     * @type {string}
     * @memberof Group
     */
    description?: string;
}
/**
 * Initial attributes for the creation of a new group
 * @export
 * @interface GroupCreate
 */
export interface GroupCreate {
    /**
     * The name of the parent of the group. If empty, then the new group will be a top level group.
     * @type {string}
     * @memberof GroupCreate
     */
    parent?: string;
    /**
     * A human readable description of the content of the group
     * @type {string}
     * @memberof GroupCreate
     */
    description?: string;
}
/**
 * The contents of a group i.e attributes, subgroups and assets
 * @export
 * @interface GroupListing
 */
export interface GroupListing {
    /**
     * the globally unique id of the group
     * @type {string}
     * @memberof GroupListing
     */
    id?: string;
    /**
     * The namespace of the group
     * @type {string}
     * @memberof GroupListing
     */
    namespace?: string;
    /**
     * The name of the group. It is unique within the namespace. No 2 groups can have the same name
     * @type {string}
     * @memberof GroupListing
     */
    name?: string;
    /**
     * A human readable description of the content of the group
     * @type {string}
     * @memberof GroupListing
     */
    description?: string;
    /**
     * Contains one page of subgroups of the group.
     * @type {Array<Group>}
     * @memberof GroupListing
     */
    groups?: Array<Group>;
    /**
     * Contains one page of assets of the group as ArrayInfos
     * @type {Array<ArrayInfo>}
     * @memberof GroupListing
     */
    assets?: Array<ArrayInfo>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof GroupListing
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * 
 * @export
 * @interface GroupListingAllOf
 */
export interface GroupListingAllOf {
    /**
     * Contains one page of subgroups of the group.
     * @type {Array<Group>}
     * @memberof GroupListingAllOf
     */
    groups?: Array<Group>;
    /**
     * Contains one page of assets of the group as ArrayInfos
     * @type {Array<ArrayInfo>}
     * @memberof GroupListingAllOf
     */
    assets?: Array<ArrayInfo>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof GroupListingAllOf
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * Updates for a group. New values for the attributes.
 * @export
 * @interface GroupUpdate
 */
export interface GroupUpdate {
    /**
     * The new name of the group
     * @type {string}
     * @memberof GroupUpdate
     */
    name?: string;
    /**
     * A new human readable description of the content of the group
     * @type {string}
     * @memberof GroupUpdate
     */
    description?: string;
}
/**
 * Password to update
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * password
     * @type {string}
     * @memberof InlineObject
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * string of stats from tiledb
     * @type {string}
     * @memberof InlineResponse200
     */
    stats?: string;
}
/**
 * Invitations to share or collaborate
 * @export
 * @interface Invitation
 */
export interface Invitation {
    /**
     * Unique ID of invitation added to magic link
     * @type {string}
     * @memberof Invitation
     */
    id?: string;
    /**
     * 
     * @type {InvitationType}
     * @memberof Invitation
     */
    invitation_type?: InvitationType;
    /**
     * Namespace of the owner of the invitation (user or organization)
     * @type {string}
     * @memberof Invitation
     */
    owner_namespace_uuid?: string;
    /**
     * Unique ID of the user accepted the invitation
     * @type {string}
     * @memberof Invitation
     */
    user_namespace_uuid?: string;
    /**
     * Unique ID of the organization user accepted the invitation
     * @type {string}
     * @memberof Invitation
     */
    organization_user_uuid?: string;
    /**
     * Name of the organization, does not persist in database
     * @type {string}
     * @memberof Invitation
     */
    organization_name?: string;
    /**
     * 
     * @type {OrganizationRoles}
     * @memberof Invitation
     */
    organization_role?: OrganizationRoles;
    /**
     * Unique ID of the array
     * @type {string}
     * @memberof Invitation
     */
    array_uuid?: string;
    /**
     * Name of the array, does not persist in database
     * @type {string}
     * @memberof Invitation
     */
    array_name?: string;
    /**
     * Email of the individual we send the invitation to
     * @type {string}
     * @memberof Invitation
     */
    email?: string;
    /**
     * A comma separated list of ArrayActions or NamespaceActions
     * @type {string}
     * @memberof Invitation
     */
    actions?: string;
    /**
     * 
     * @type {InvitationStatus}
     * @memberof Invitation
     */
    status?: InvitationStatus;
    /**
     * Datetime the invitation was created in UTC
     * @type {string}
     * @memberof Invitation
     */
    created_at?: string;
    /**
     * Datetime the invitation is expected to expire in UTC
     * @type {string}
     * @memberof Invitation
     */
    expires_at?: string;
    /**
     * Datetime the invitation was accepted in UTC
     * @type {string}
     * @memberof Invitation
     */
    accepted_at?: string;
}
/**
 * Encapsulates information regarding inviting people using email to share array, same permissions for all invitees
 * @export
 * @interface InvitationArrayShareEmail
 */
export interface InvitationArrayShareEmail {
    /**
     * List of permitted actions
     * @type {Array<ArrayActions>}
     * @memberof InvitationArrayShareEmail
     */
    actions: Array<ArrayActions>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InvitationArrayShareEmail
     */
    invitee_email: Array<string>;
}
/**
 * Object including invitations and metadata
 * @export
 * @interface InvitationData
 */
export interface InvitationData {
    /**
     * List of invitations
     * @type {Array<Invitation>}
     * @memberof InvitationData
     */
    invitations?: Array<Invitation>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof InvitationData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * Encapsulates information regarding inviting people using email to join organization, same permissions for all invitees
 * @export
 * @interface InvitationOrganizationJoinEmail
 */
export interface InvitationOrganizationJoinEmail {
    /**
     * List of permitted actions
     * @type {Array<NamespaceActions>}
     * @memberof InvitationOrganizationJoinEmail
     */
    actions?: Array<NamespaceActions>;
    /**
     * 
     * @type {OrganizationRoles}
     * @memberof InvitationOrganizationJoinEmail
     */
    organization_role: OrganizationRoles;
    /**
     * 
     * @type {Array<string>}
     * @memberof InvitationOrganizationJoinEmail
     */
    invitee_email: Array<string>;
}
/**
 * List of values that InvitationStatus can take
 * @export
 * @enum {string}
 */
export enum InvitationStatus {
    Pending = 'PENDING',
    Accepted = 'ACCEPTED'
}

/**
 * List of values that InvitationType can take
 * @export
 * @enum {string}
 */
export enum InvitationType {
    ArrayShare = 'ARRAY_SHARE',
    JoinOrganization = 'JOIN_ORGANIZATION'
}

/**
 * Information related to last access of an array
 * @export
 * @interface LastAccessedArray
 */
export interface LastAccessedArray {
    /**
     * unique ID of array
     * @type {string}
     * @memberof LastAccessedArray
     */
    array_id?: string;
    /**
     * name of the array
     * @type {string}
     * @memberof LastAccessedArray
     */
    array_name?: string;
    /**
     * namespace of a user or organization
     * @type {string}
     * @memberof LastAccessedArray
     */
    namespace?: string;
    /**
     * timestamp (epoch milliseconds) array is last accessed
     * @type {number}
     * @memberof LastAccessedArray
     */
    accessed_time?: number;
    /**
     * 
     * @type {ActivityEventType}
     * @memberof LastAccessedArray
     */
    access_type?: ActivityEventType;
}
/**
 * Layout of array
 * @export
 * @enum {string}
 */
export enum Layout {
    RowMajor = 'row-major',
    ColMajor = 'col-major',
    GlobalOrder = 'global-order',
    Unordered = 'unordered'
}

/**
 * A user-favorite MLModel item
 * @export
 * @interface MLModelFavorite
 */
export interface MLModelFavorite {
    /**
     * unique UUID of the MLModel
     * @type {string}
     * @memberof MLModelFavorite
     */
    mlmodel_uuid?: string;
    /**
     * the namespace of the MLModel
     * @type {string}
     * @memberof MLModelFavorite
     */
    namespace?: string;
    /**
     * the name of the MLModel
     * @type {string}
     * @memberof MLModelFavorite
     */
    name?: string;
}
/**
 * Object including MLModel favorites and pagination metadata
 * @export
 * @interface MLModelFavoritesData
 */
export interface MLModelFavoritesData {
    /**
     * List of MLModel infos
     * @type {Array<ArrayInfo>}
     * @memberof MLModelFavoritesData
     */
    mlmodels?: Array<ArrayInfo>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof MLModelFavoritesData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * a list of max buffer sizes, one per attribute
 * @export
 * @interface MaxBufferSizes
 */
export interface MaxBufferSizes {
    /**
     * 
     * @type {Array<AttributeBufferSize>}
     * @memberof MaxBufferSizes
     */
    maxBufferSizes?: Array<AttributeBufferSize>;
}
/**
 * Represents an open array
 * @export
 * @interface ModelArray
 */
export interface ModelArray {
    /**
     * timestamp (epoch milliseconds) array is opened at
     * @type {number}
     * @memberof ModelArray
     */
    timestamp: number;
    /**
     * 
     * @type {Querytype}
     * @memberof ModelArray
     */
    queryType: Querytype;
    /**
     * Array uri
     * @type {string}
     * @memberof ModelArray
     */
    uri: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    request_id?: string;
}
/**
 * User-defined function
 * @export
 * @interface MultiArrayUDF
 */
export interface MultiArrayUDF {
    /**
     * name of UDFInfo to run, format is {namespace}/{udf_name}. Can not be used with exec
     * @type {string}
     * @memberof MultiArrayUDF
     */
    udf_info_name?: string;
    /**
     * 
     * @type {UDFLanguage}
     * @memberof MultiArrayUDF
     */
    language?: UDFLanguage;
    /**
     * Type-specific version
     * @type {string}
     * @memberof MultiArrayUDF
     */
    version?: string;
    /**
     * Docker image name to use for UDF
     * @type {string}
     * @memberof MultiArrayUDF
     */
    image_name?: string;
    /**
     * Type-specific executable text
     * @type {string}
     * @memberof MultiArrayUDF
     */
    exec?: string;
    /**
     * optional raw text to store of serialized function, used for showing in UI
     * @type {string}
     * @memberof MultiArrayUDF
     */
    exec_raw?: string;
    /**
     * 
     * @type {ResultFormat}
     * @memberof MultiArrayUDF
     */
    result_format?: ResultFormat;
    /**
     * name of task, optional
     * @type {string}
     * @memberof MultiArrayUDF
     */
    task_name?: string;
    /**
     * Argument(s) to pass to UDF function, tuple or list of args/kwargs which can be in native or JSON format
     * @type {string}
     * @memberof MultiArrayUDF
     */
    argument?: string;
    /**
     * The UUIDs of stored input parameters (passed in a language-specific format within \"argument\") to be retrieved from the server-side cache. Serialized in standard hex format with no {}.
     * @type {Array<string>}
     * @memberof MultiArrayUDF
     */
    stored_param_uuids?: Array<string>;
    /**
     * store results for later retrieval
     * @type {boolean}
     * @memberof MultiArrayUDF
     */
    store_results?: boolean;
    /**
     * Set to true to avoid downloading the results of this UDF. Useful for intermediate nodes in a task graph where you will not be using the results of your function. Defaults to false (\"yes download results\").
     * @type {boolean}
     * @memberof MultiArrayUDF
     */
    dont_download_results?: boolean;
    /**
     * 
     * @type {QueryRanges}
     * @memberof MultiArrayUDF
     */
    ranges?: QueryRanges;
    /**
     * 
     * @type {UDFSubarray}
     * @memberof MultiArrayUDF
     */
    subarray?: UDFSubarray;
    /**
     * List of buffers to fetch (attributes + dimensions). Deprecated; please set arrays with `UDFArrayDetails`.
     * @type {Array<string>}
     * @memberof MultiArrayUDF
     */
    buffers?: Array<string>;
    /**
     * Array ranges/buffer into to run UDF on
     * @type {Array<UDFArrayDetails>}
     * @memberof MultiArrayUDF
     */
    arrays?: Array<UDFArrayDetails>;
    /**
     * UDF-type timeout in seconds (default: 900)
     * @type {number}
     * @memberof MultiArrayUDF
     */
    timeout?: number;
    /**
     * If set, the ID of the log for the task graph that this was part of. 
     * @type {string}
     * @memberof MultiArrayUDF
     */
    task_graph_uuid?: string;
    /**
     * If set, the client-defined ID of the node within this task\'s graph. 
     * @type {string}
     * @memberof MultiArrayUDF
     */
    client_node_uuid?: string;
}
/**
 * actions a user can take on an organization
 * @export
 * @enum {string}
 */
export enum NamespaceActions {
    Read = 'read',
    Write = 'write',
    Create = 'create',
    Delete = 'delete',
    Edit = 'edit',
    ReadArrayLogs = 'read_array_logs',
    ReadJobLogs = 'read_job_logs',
    ReadObjectLogs = 'read_object_logs',
    RunJob = 'run_job',
    DeleteOrganization = 'delete_organization',
    EditOrganization = 'edit_organization',
    EditBilling = 'edit_billing'
}

/**
 * object representing a non-empty domain
 * @export
 * @interface NonEmptyDomain
 */
export interface NonEmptyDomain {
    /**
     * 
     * @type {DomainArray}
     * @memberof NonEmptyDomain
     */
    nonEmptyDomain: DomainArray;
    /**
     * Is non-empty domain really empty?
     * @type {boolean}
     * @memberof NonEmptyDomain
     */
    isEmpty: boolean;
}
/**
 * A user-favorite notebook item
 * @export
 * @interface NotebookFavorite
 */
export interface NotebookFavorite {
    /**
     * unique UUID of the notebook
     * @type {string}
     * @memberof NotebookFavorite
     */
    notebook_uuid?: string;
    /**
     * the namespace of the notebook
     * @type {string}
     * @memberof NotebookFavorite
     */
    namespace?: string;
    /**
     * the name of the notebook
     * @type {string}
     * @memberof NotebookFavorite
     */
    name?: string;
}
/**
 * Object including notebook favorites and pagination metadata
 * @export
 * @interface NotebookFavoritesData
 */
export interface NotebookFavoritesData {
    /**
     * List of notebook infos
     * @type {Array<ArrayInfo>}
     * @memberof NotebookFavoritesData
     */
    notebooks?: Array<ArrayInfo>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof NotebookFavoritesData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * Status details of a notebook server
 * @export
 * @interface NotebookStatus
 */
export interface NotebookStatus {
    /**
     * namespace of notebook
     * @type {string}
     * @memberof NotebookStatus
     */
    namespace?: string;
    /**
     * duration notebook has been running in seconds
     * @type {number}
     * @memberof NotebookStatus
     */
    uptime?: number;
    /**
     * current cpu usage in millicpu
     * @type {number}
     * @memberof NotebookStatus
     */
    cpu_usage?: number;
    /**
     * memory usage in bytes
     * @type {number}
     * @memberof NotebookStatus
     */
    memory_usage?: number;
    /**
     * memory allocated to notebook server in bytes
     * @type {number}
     * @memberof NotebookStatus
     */
    memory_limit?: number;
    /**
     * millicpu allocated to notebook server
     * @type {number}
     * @memberof NotebookStatus
     */
    cpu_count?: number;
}
/**
 * Organization
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * unique ID of organization
     * @type {string}
     * @memberof Organization
     */
    id?: string;
    /**
     * 
     * @type {OrganizationRoles}
     * @memberof Organization
     */
    role?: OrganizationRoles;
    /**
     * organization name must be unique
     * @type {string}
     * @memberof Organization
     */
    name: string;
    /**
     * Datetime organization was created in UTC
     * @type {string}
     * @memberof Organization
     */
    created_at?: string;
    /**
     * Datetime organization was updated in UTC
     * @type {string}
     * @memberof Organization
     */
    updated_at?: string;
    /**
     * Organization logo
     * @type {string}
     * @memberof Organization
     */
    logo?: string;
    /**
     * Organization description
     * @type {string}
     * @memberof Organization
     */
    description?: string;
    /**
     * 
     * @type {Array<OrganizationUser>}
     * @memberof Organization
     */
    users?: Array<OrganizationUser>;
    /**
     * list of actions user is allowed to do on this organization
     * @type {Array<NamespaceActions>}
     * @memberof Organization
     */
    allowed_actions?: Array<NamespaceActions>;
    /**
     * number of registered arrays for this organization
     * @type {number}
     * @memberof Organization
     */
    num_of_arrays?: number;
    /**
     * List of extra/optional/beta features to enable for namespace
     * @type {Array<string>}
     * @memberof Organization
     */
    enabled_features?: Array<string>;
    /**
     * A notice that the user has an unpaid subscription
     * @type {boolean}
     * @memberof Organization
     */
    unpaid_subscription?: boolean;
    /**
     * default S3 path to store newly created notebooks
     * @type {string}
     * @memberof Organization
     */
    default_s3_path?: string;
    /**
     * Default S3 path credentials name is the credentials name to use along with default_s3_path
     * @type {string}
     * @memberof Organization
     */
    default_s3_path_credentials_name?: string;
    /**
     * Denotes that the organization is able to apply pricing to arrays by means of Stripe Connect
     * @type {boolean}
     * @memberof Organization
     */
    stripe_connect?: boolean;
}
/**
 * role user has in organization
 * @export
 * @enum {string}
 */
export enum OrganizationRoles {
    Owner = 'owner',
    Admin = 'admin',
    ReadWrite = 'read_write',
    ReadOnly = 'read_only'
}

/**
 * user in an organization
 * @export
 * @interface OrganizationUser
 */
export interface OrganizationUser {
    /**
     * unique ID of user
     * @type {string}
     * @memberof OrganizationUser
     */
    user_id?: string;
    /**
     * unique ID of organization
     * @type {string}
     * @memberof OrganizationUser
     */
    organization_id?: string;
    /**
     * username for user
     * @type {string}
     * @memberof OrganizationUser
     */
    username?: string;
    /**
     * name of organization
     * @type {string}
     * @memberof OrganizationUser
     */
    organization_name?: string;
    /**
     * 
     * @type {OrganizationRoles}
     * @memberof OrganizationUser
     */
    role?: OrganizationRoles;
    /**
     * list of actions user is allowed to do on this organization
     * @type {Array<NamespaceActions>}
     * @memberof OrganizationUser
     */
    allowed_actions?: Array<NamespaceActions>;
}
/**
 * 
 * @export
 * @interface PaginationMetadata
 */
export interface PaginationMetadata {
    /**
     * pagination offset. Use it to skip the first ((page - 1) * per_page) items
     * @type {number}
     * @memberof PaginationMetadata
     */
    page?: number;
    /**
     * pagination limit (page size)
     * @type {number}
     * @memberof PaginationMetadata
     */
    per_page?: number;
    /**
     * number of total pages with current limit
     * @type {number}
     * @memberof PaginationMetadata
     */
    total_pages?: number;
    /**
     * number of total available items
     * @type {number}
     * @memberof PaginationMetadata
     */
    total_items?: number;
}
/**
 * Pricing created by converting an array to product
 * @export
 * @interface Pricing
 */
export interface Pricing {
    /**
     * Unique ID of plan as defined by Stripe
     * @type {string}
     * @memberof Pricing
     */
    id?: string;
    /**
     * Unique ID of registered array
     * @type {string}
     * @memberof Pricing
     */
    array_uuid?: string;
    /**
     * Name of pricing
     * @type {string}
     * @memberof Pricing
     */
    pricing_name?: string;
    /**
     * 
     * @type {PricingType}
     * @memberof Pricing
     */
    pricing_type?: PricingType;
    /**
     * Name of product
     * @type {string}
     * @memberof Pricing
     */
    product_name?: string;
    /**
     * Extra information about a product which will appear on the credit card statement of the customer
     * @type {string}
     * @memberof Pricing
     */
    product_statement_descriptor?: string;
    /**
     * 
     * @type {PricingUnitLabel}
     * @memberof Pricing
     */
    product_unit_label?: PricingUnitLabel;
    /**
     * 
     * @type {PricingCurrency}
     * @memberof Pricing
     */
    currency?: PricingCurrency;
    /**
     * 
     * @type {PricingAggregateUsage}
     * @memberof Pricing
     */
    aggregate_usage?: PricingAggregateUsage;
    /**
     * 
     * @type {PricingInterval}
     * @memberof Pricing
     */
    interval?: PricingInterval;
    /**
     * Group of n product unit labels
     * @type {number}
     * @memberof Pricing
     */
    divided_by?: number;
    /**
     * Price in cents (decimal) per unitlabel
     * @type {number}
     * @memberof Pricing
     */
    charge?: number;
    /**
     * If pricing is activated
     * @type {boolean}
     * @memberof Pricing
     */
    activated?: boolean;
}
/**
 * Specifies a usage aggregation strategy for pricings of usage_type=metered
 * @export
 * @enum {string}
 */
export enum PricingAggregateUsage {
    Sum = 'sum'
}

/**
 * Currency of pricing
 * @export
 * @enum {string}
 */
export enum PricingCurrency {
    Usd = 'USD'
}

/**
 * Interval for pricing
 * @export
 * @enum {string}
 */
export enum PricingInterval {
    Month = 'month'
}

/**
 * Pricing types
 * @export
 * @enum {string}
 */
export enum PricingType {
    Egress = 'egress',
    Access = 'access'
}

/**
 * Unit label
 * @export
 * @enum {string}
 */
export enum PricingUnitLabel {
    Byte = 'byte',
    Second = 'second'
}

/**
 * Query parameter to get array metadatas
 * @export
 * @enum {string}
 */
export enum PublicShareFilter {
    Exclude = 'exclude',
    Only = 'only'
}

/**
 * 
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * 
     * @type {Querytype}
     * @memberof Query
     */
    type: Querytype;
    /**
     * 
     * @type {Layout}
     * @memberof Query
     */
    layout: Layout;
    /**
     * 
     * @type {Querystatus}
     * @memberof Query
     */
    status: Querystatus;
    /**
     * List of attribute buffer headers
     * @type {Array<AttributeBufferHeader>}
     * @memberof Query
     */
    attributeBufferHeaders: Array<AttributeBufferHeader>;
    /**
     * 
     * @type {Writer}
     * @memberof Query
     */
    writer?: Writer;
    /**
     * 
     * @type {QueryReader}
     * @memberof Query
     */
    reader?: QueryReader;
    /**
     * 
     * @type {any}
     * @memberof Query
     */
    array: any;
    /**
     * Total number of bytes in fixed size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalFixedLengthBufferBytes: number;
    /**
     * Total number of bytes in variable size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalVarLenBufferBytes: number;
}
/**
 * Query returning results as JSON
 * @export
 * @interface QueryJson
 */
export interface QueryJson {
    /**
     * 
     * @type {QueryRanges}
     * @memberof QueryJson
     */
    query_ranges?: QueryRanges;
    /**
     * List of fields to return data from, empty means return data for all fields
     * @type {Array<string>}
     * @memberof QueryJson
     */
    fields?: Array<string>;
}
/**
 * Subarray bounds to query
 * @export
 * @interface QueryRanges
 */
export interface QueryRanges {
    /**
     * 
     * @type {Layout}
     * @memberof QueryRanges
     */
    layout?: Layout;
    /**
     * List of ranges,
     * @type {Array<Array<number>>}
     * @memberof QueryRanges
     */
    ranges?: Array<Array<number>>;
}
/**
 * Read struct (can\'t be called reader due to class name conflict)
 * @export
 * @interface QueryReader
 */
export interface QueryReader {
    /**
     * 
     * @type {Layout}
     * @memberof QueryReader
     */
    layout?: Layout;
    /**
     * 
     * @type {Subarray}
     * @memberof QueryReader
     */
    subarray?: Subarray;
    /**
     * 
     * @type {ReadState}
     * @memberof QueryReader
     */
    readState?: ReadState;
    /**
     * The offsets format (bytes or elements) to be used.
     * @type {string}
     * @memberof QueryReader
     */
    varOffsetsMode?: string;
    /**
     * True if an extra element will be added to the end of the offsets buffer.
     * @type {boolean}
     * @memberof QueryReader
     */
    varOffsetsAddExtraElement?: boolean;
    /**
     * The offsets bitsize (32 or 64) to be used.
     * @type {number}
     * @memberof QueryReader
     */
    varOffsetsBitsize?: number;
}
/**
 * Status of query
 * @export
 * @enum {string}
 */
export enum Querystatus {
    Failed = 'FAILED',
    Completed = 'COMPLETED',
    Inprogress = 'INPROGRESS',
    Incomplete = 'INCOMPLETE',
    Uninitialized = 'UNINITIALIZED'
}

/**
 * Type of query
 * @export
 * @enum {string}
 */
export enum Querytype {
    Read = 'READ',
    Write = 'WRITE'
}

/**
 * state for reads
 * @export
 * @interface ReadState
 */
export interface ReadState {
    /**
     * True if the reader has been initialized.
     * @type {boolean}
     * @memberof ReadState
     */
    initialized?: boolean;
    /**
     * True if the query produced results that could not fit in some buffer.
     * @type {boolean}
     * @memberof ReadState
     */
    overflowed?: boolean;
    /**
     * True if the current subarray partition is unsplittable.
     * @type {boolean}
     * @memberof ReadState
     */
    unsplittable?: boolean;
    /**
     * 
     * @type {SubarrayPartitioner}
     * @memberof ReadState
     */
    subarrayPartitioner?: SubarrayPartitioner;
}
/**
 * Results type
 * @export
 * @enum {string}
 */
export enum ResultFormat {
    Native = 'native',
    Json = 'json',
    Arrow = 'arrow'
}

/**
 * Parameters for running sql query
 * @export
 * @interface SQLParameters
 */
export interface SQLParameters {
    /**
     * name of task, optional
     * @type {string}
     * @memberof SQLParameters
     */
    name?: string;
    /**
     * query to run
     * @type {string}
     * @memberof SQLParameters
     */
    query?: string;
    /**
     * Output array uri
     * @type {string}
     * @memberof SQLParameters
     */
    output_uri?: string;
    /**
     * store results for later retrieval
     * @type {boolean}
     * @memberof SQLParameters
     */
    store_results?: boolean;
    /**
     * Set to true to avoid downloading the results of this UDF. Useful for intermediate nodes in a task graph where you will not be using the results of your function. Defaults to false (\"yes download results\").
     * @type {boolean}
     * @memberof SQLParameters
     */
    dont_download_results?: boolean;
    /**
     * 
     * @type {ResultFormat}
     * @memberof SQLParameters
     */
    result_format?: ResultFormat;
    /**
     * Queries or commands to run before main query
     * @type {Array<string>}
     * @memberof SQLParameters
     */
    init_commands?: Array<string>;
    /**
     * SQL query parameters
     * @type {Array<object>}
     * @memberof SQLParameters
     */
    parameters?: Array<object>;
}
/**
 * Single sign on provider
 * @export
 * @enum {string}
 */
export enum SSOProvider {
    Github = 'github',
    Google = 'google',
    Stripe = 'stripe',
    Okta = 'okta'
}

/**
 * A Subarray
 * @export
 * @interface Subarray
 */
export interface Subarray {
    /**
     * 
     * @type {Layout}
     * @memberof Subarray
     */
    layout?: Layout;
    /**
     * List of 1D ranges, one per dimension
     * @type {Array<SubarrayRanges>}
     * @memberof Subarray
     */
    ranges?: Array<SubarrayRanges>;
}
/**
 * The subarray partitioner
 * @export
 * @interface SubarrayPartitioner
 */
export interface SubarrayPartitioner {
    /**
     * 
     * @type {Subarray}
     * @memberof SubarrayPartitioner
     */
    subarray?: Subarray;
    /**
     * Result size budget (in bytes) for all attributes.
     * @type {Array<AttributeBufferSize>}
     * @memberof SubarrayPartitioner
     */
    budget?: Array<AttributeBufferSize>;
    /**
     * 
     * @type {SubarrayPartitionerCurrent}
     * @memberof SubarrayPartitioner
     */
    current?: SubarrayPartitionerCurrent;
    /**
     * 
     * @type {SubarrayPartitionerState}
     * @memberof SubarrayPartitioner
     */
    state?: SubarrayPartitionerState;
    /**
     * The memory budget for the fixed-sized attributes and the offsets of the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudget?: number;
    /**
     * The memory budget for the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudgetVar?: number;
}
/**
 * The current partition info
 * @export
 * @interface SubarrayPartitionerCurrent
 */
export interface SubarrayPartitionerCurrent {
    /**
     * 
     * @type {Subarray}
     * @memberof SubarrayPartitionerCurrent
     */
    subarray?: Subarray;
    /**
     * PartitionInfo start
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    start?: number;
    /**
     * PartitionInfo end
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    end?: number;
    /**
     * PartitionInfo splitMultiRange
     * @type {boolean}
     * @memberof SubarrayPartitionerCurrent
     */
    splitMultiRange?: boolean;
}
/**
 * The state information for the remaining partitions to be produced
 * @export
 * @interface SubarrayPartitionerState
 */
export interface SubarrayPartitionerState {
    /**
     * State start
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    start?: number;
    /**
     * State end
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    end?: number;
    /**
     * State singleRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    singleRange?: Array<Subarray>;
    /**
     * State multiRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    multiRange?: Array<Subarray>;
}
/**
 * A set of 1D ranges for a subarray
 * @export
 * @interface SubarrayRanges
 */
export interface SubarrayRanges {
    /**
     * 
     * @type {Datatype}
     * @memberof SubarrayRanges
     */
    type?: Datatype;
    /**
     * True if the range is the default range
     * @type {boolean}
     * @memberof SubarrayRanges
     */
    hasDefaultRange?: boolean;
    /**
     * The bytes of the ranges
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    buffer?: Array<number>;
}
/**
 * Subscription of a user (customer) to another user\'s arrays
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * Unique ID of subscription as defined by Stripe
     * @type {string}
     * @memberof Subscription
     */
    id?: string;
    /**
     * Unique ID of the array (product) owner
     * @type {string}
     * @memberof Subscription
     */
    owner_namespace_uuid?: string;
    /**
     * Unique ID of the array (product) user (customer)
     * @type {string}
     * @memberof Subscription
     */
    customer_namespace_uuid?: string;
    /**
     * list of pricing used by this subscription
     * @type {Array<Pricing>}
     * @memberof Subscription
     */
    pricing?: Array<Pricing>;
}
/**
 * Logging information about the execution of a task graph.
 * @export
 * @interface TaskGraphLog
 */
export interface TaskGraphLog {
    /**
     * The server-generated UUID of the task graph.
     * @type {string}
     * @memberof TaskGraphLog
     */
    uuid?: string;
    /**
     * The namespace that owns this task graph log. When creating a task graph log, this is used as the namespace to create the log in; thereafter it is read-only. 
     * @type {string}
     * @memberof TaskGraphLog
     */
    namespace?: string;
    /**
     * The name of the user who created this task graph log.
     * @type {string}
     * @memberof TaskGraphLog
     */
    created_by?: string;
    /**
     * A name for this task graph log, displayed in the UI. Does not need to be unique. 
     * @type {string}
     * @memberof TaskGraphLog
     */
    name?: string;
    /**
     * The date/time when this task graph log was originally created. This is distinct from the execution start_time. 
     * @type {string}
     * @memberof TaskGraphLog
     */
    created_at?: string;
    /**
     * The start time of the task graph, recorded when the server starts executing the first node. 
     * @type {string}
     * @memberof TaskGraphLog
     */
    start_time?: string | null;
    /**
     * The end time of the task graph, recorded when the client reports completion. 
     * @type {string}
     * @memberof TaskGraphLog
     */
    end_time?: string | null;
    /**
     * 
     * @type {TaskGraphLogStatus}
     * @memberof TaskGraphLog
     */
    status?: TaskGraphLogStatus;
    /**
     * The structure of the graph. This is provided by the client when first setting up the task graph. Thereafter, it is read-only. This must be topographically sorted; that is, each node must appear after all nodes that it depends upon. 
     * @type {Array<TaskGraphNodeMetadata>}
     * @memberof TaskGraphLog
     */
    nodes?: Array<TaskGraphNodeMetadata>;
}
/**
 * The status of a given task graph execution.
 * @export
 * @enum {string}
 */
export enum TaskGraphLogStatus {
    Submitted = 'submitted',
    Running = 'running',
    Idle = 'idle',
    Abandoned = 'abandoned',
    Succeeded = 'succeeded',
    Failed = 'failed',
    Cancelled = 'cancelled'
}

/**
 * Response data for a task graph list, including pagination metadata.
 * @export
 * @interface TaskGraphLogsData
 */
export interface TaskGraphLogsData {
    /**
     * The requested task graph logs.
     * @type {Array<TaskGraphLog>}
     * @memberof TaskGraphLogsData
     */
    task_graph_logs?: Array<TaskGraphLog>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof TaskGraphLogsData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * Metadata about an individual node in a task graph.
 * @export
 * @interface TaskGraphNodeMetadata
 */
export interface TaskGraphNodeMetadata {
    /**
     * The client-generated UUID of the given graph node.
     * @type {string}
     * @memberof TaskGraphNodeMetadata
     */
    client_node_uuid?: string;
    /**
     * The client-generated name of the node. This is not guaranteed to be unique. 
     * @type {string}
     * @memberof TaskGraphNodeMetadata
     */
    name?: string;
    /**
     * The client_node_uuid of each node that this node depends upon. Used to define the structure of the graph. 
     * @type {Array<string>}
     * @memberof TaskGraphNodeMetadata
     */
    depends_on?: Array<string>;
    /**
     * ArrayTasks representing each execution attempt for this node. For nodes that have never been submitted, this will be empty. For nodes that have been retried, this may have multiple entries. The last one in the list represents the most recent execution. This is read-only and generated by the server based on the tasks it has actually executed. 
     * @type {Array<ArrayTask>}
     * @memberof TaskGraphNodeMetadata
     */
    executions?: Array<ArrayTask>;
}
/**
 * user\'s TileDB config
 * @export
 * @interface TileDBConfig
 */
export interface TileDBConfig {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TileDBConfig
     */
    configs?: { [key: string]: string; };
}
/**
 * A api token and its metadata
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * A api token
     * @type {string}
     * @memberof Token
     */
    token?: string;
    /**
     * Name of token to revoke
     * @type {string}
     * @memberof Token
     */
    name?: string;
    /**
     * datetime the token was created
     * @type {string}
     * @memberof Token
     */
    issued_at?: string;
    /**
     * datetime the token when token will expire
     * @type {string}
     * @memberof Token
     */
    expires_at?: string;
    /**
     * Optional scope to limit token, defaults to all permissions, current supported values are password_reset or *
     * @type {string}
     * @memberof Token
     */
    scope?: string;
}
/**
 * A request from a user for an api token
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
    /**
     * Expiration date for token, if empty token defaults to 30 minutes
     * @type {string}
     * @memberof TokenRequest
     */
    expires?: string;
    /**
     * Optional name for token, if the name already exists for the user it will be auto incremented (i.e. myToken-1)
     * @type {string}
     * @memberof TokenRequest
     */
    name?: string;
    /**
     * Optional scope to limit token, defaults to all permissions, current supported values are password_reset or *
     * @type {string}
     * @memberof TokenRequest
     */
    scope?: string;
}
/**
 * An api token scope available for creation
 * @export
 * @enum {string}
 */
export enum TokenScope {
    PasswordReset = 'password_reset',
    ConfirmEmail = 'confirm_email',
    Star = '*',
    Userread = 'user:read',
    UserreadWrite = 'user:read-write',
    Useradmin = 'user:admin',
    Arrayread = 'array:read',
    ArrayreadWrite = 'array:read-write',
    Arrayadmin = 'array:admin'
}

/**
 * actions a user can take on a UDF
 * @export
 * @enum {string}
 */
export enum UDFActions {
    FetchUdf = 'fetch_udf',
    ShareUdf = 'share_udf'
}

/**
 * Contains array details for multi-array query including uri, ranges buffers
 * @export
 * @interface UDFArrayDetails
 */
export interface UDFArrayDetails {
    /**
     * array to set ranges and buffers on, must be in tiledb:// format
     * @type {string}
     * @memberof UDFArrayDetails
     */
    uri?: string;
    /**
     * 
     * @type {QueryRanges}
     * @memberof UDFArrayDetails
     */
    ranges?: QueryRanges;
    /**
     * List of buffers to fetch (attributes + dimensions)
     * @type {Array<string>}
     * @memberof UDFArrayDetails
     */
    buffers?: Array<string>;
}
/**
 * A user-favorite UDF item
 * @export
 * @interface UDFFavorite
 */
export interface UDFFavorite {
    /**
     * unique UUID of the UDF
     * @type {string}
     * @memberof UDFFavorite
     */
    udf_uuid?: string;
    /**
     * the namespace of the UDF
     * @type {string}
     * @memberof UDFFavorite
     */
    namespace?: string;
    /**
     * the name of the UDF
     * @type {string}
     * @memberof UDFFavorite
     */
    name?: string;
}
/**
 * Object including UDF favorites and pagination metadata
 * @export
 * @interface UDFFavoritesData
 */
export interface UDFFavoritesData {
    /**
     * List of UDF infos
     * @type {Array<ArrayInfo>}
     * @memberof UDFFavoritesData
     */
    udfs?: Array<ArrayInfo>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof UDFFavoritesData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * Defines a set of images related to a specific name
 * @export
 * @interface UDFImage
 */
export interface UDFImage {
    /**
     * Unique ID of set of images
     * @type {string}
     * @memberof UDFImage
     */
    id?: string;
    /**
     * name of UDF
     * @type {string}
     * @memberof UDFImage
     */
    name?: string;
    /**
     * 
     * @type {UDFLanguage}
     * @memberof UDFImage
     */
    language?: UDFLanguage;
}
/**
 * Defines an image that belongs to a set of images having a version
 * @export
 * @interface UDFImageVersion
 */
export interface UDFImageVersion {
    /**
     * Unique ID of a versioned image
     * @type {string}
     * @memberof UDFImageVersion
     */
    id?: string;
    /**
     * name of UDFImageVersion
     * @type {string}
     * @memberof UDFImageVersion
     */
    name?: string;
    /**
     * Unique ID of the UDF image set
     * @type {string}
     * @memberof UDFImageVersion
     */
    udf_image_uuid?: string;
    /**
     * Uri of docker image related to current entry
     * @type {string}
     * @memberof UDFImageVersion
     */
    docker_image?: string;
    /**
     * Image-specific version
     * @type {number}
     * @memberof UDFImageVersion
     */
    version?: number;
    /**
     * If current image is default version
     * @type {boolean}
     * @memberof UDFImageVersion
     */
    default?: boolean;
    /**
     * If current image is latest version
     * @type {boolean}
     * @memberof UDFImageVersion
     */
    latest?: boolean;
}
/**
 * User-defined function that can persist in db, used and shared multiple times
 * @export
 * @interface UDFInfo
 */
export interface UDFInfo {
    /**
     * Unique ID of UDF
     * @type {string}
     * @memberof UDFInfo
     */
    id?: string;
    /**
     * name of UDF
     * @type {string}
     * @memberof UDFInfo
     */
    name?: string;
    /**
     * 
     * @type {UDFLanguage}
     * @memberof UDFInfo
     */
    language?: UDFLanguage;
    /**
     * 
     * @type {UDFType}
     * @memberof UDFInfo
     */
    type?: UDFType;
    /**
     * Markdown readme of UDFs
     * @type {string}
     * @memberof UDFInfo
     */
    readme?: string;
    /**
     * License identifier from SPDX License List or Custom
     * @type {string}
     * @memberof UDFInfo
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof UDFInfo
     */
    license_text?: string;
    /**
     * optional tags for UDF
     * @type {Array<string>}
     * @memberof UDFInfo
     */
    tags?: Array<string>;
}
/**
 * User-defined function that can persist in db, used and shared multiple times
 * @export
 * @interface UDFInfoUpdate
 */
export interface UDFInfoUpdate {
    /**
     * name of UDF
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    name?: string;
    /**
     * 
     * @type {UDFLanguage}
     * @memberof UDFInfoUpdate
     */
    language?: UDFLanguage;
    /**
     * Type-specific version
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    version?: string;
    /**
     * Docker image name to use for UDF
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    image_name?: string;
    /**
     * 
     * @type {UDFType}
     * @memberof UDFInfoUpdate
     */
    type?: UDFType;
    /**
     * Type-specific executable text
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    exec?: string;
    /**
     * optional raw text to store of serialized function, used for showing in UI
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    exec_raw?: string;
    /**
     * Markdown readme of UDFs
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    readme?: string;
    /**
     * License identifier from SPDX License List or Custom
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof UDFInfoUpdate
     */
    license_text?: string;
    /**
     * optional tags for UDF
     * @type {Array<string>}
     * @memberof UDFInfoUpdate
     */
    tags?: Array<string>;
}
/**
 * UDF Type
 * @export
 * @enum {string}
 */
export enum UDFLanguage {
    Python = 'python',
    R = 'r'
}

/**
 * details for sharing a given UDF
 * @export
 * @interface UDFSharing
 */
export interface UDFSharing {
    /**
     * List of permitted actions
     * @type {Array<UDFActions>}
     * @memberof UDFSharing
     */
    actions?: Array<UDFActions>;
    /**
     * namespace being granted array access can be a user or organization
     * @type {string}
     * @memberof UDFSharing
     */
    namespace?: string;
    /**
     * details on if the namespace is a organization or user
     * @type {string}
     * @memberof UDFSharing
     */
    namespace_type?: string;
}
/**
 * Subarray bounds to query for a UDF to operate on
 * @export
 * @interface UDFSubarray
 */
export interface UDFSubarray {
    /**
     * 
     * @type {Layout}
     * @memberof UDFSubarray
     */
    layout?: Layout;
    /**
     * List of ranges,
     * @type {Array<UDFSubarrayRange>}
     * @memberof UDFSubarray
     */
    ranges?: Array<UDFSubarrayRange>;
}
/**
 * A dimension range to query
 * @export
 * @interface UDFSubarrayRange
 */
export interface UDFSubarrayRange {
    /**
     * The dimension index
     * @type {number}
     * @memberof UDFSubarrayRange
     */
    dimension_id?: number;
    /**
     * 
     * @type {DimensionCoordinate}
     * @memberof UDFSubarrayRange
     */
    range_start?: DimensionCoordinate;
    /**
     * 
     * @type {DimensionCoordinate}
     * @memberof UDFSubarrayRange
     */
    range_end?: DimensionCoordinate;
}
/**
 * UDF Type
 * @export
 * @enum {string}
 */
export enum UDFType {
    MultiArray = 'multi_array',
    SingleArray = 'single_array',
    Generic = 'generic'
}

/**
 * User
 * @export
 * @interface User
 */
export interface User {
    /**
     * unique ID of user
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * username must be unique
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * password
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * the user\'s full, real name
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * the user\'s email
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * user\'s email is validated to be correct
     * @type {boolean}
     * @memberof User
     */
    is_valid_email?: boolean;
    /**
     * Denotes that the user is able to apply pricing to arrays by means of Stripe Connect
     * @type {boolean}
     * @memberof User
     */
    stripe_connect?: boolean;
    /**
     * the user\'s company
     * @type {string}
     * @memberof User
     */
    company?: string;
    /**
     * the user\'s logo
     * @type {string}
     * @memberof User
     */
    logo?: string;
    /**
     * when the user last logged in (set by the server)
     * @type {string}
     * @memberof User
     */
    last_activity_date?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    timezone?: string;
    /**
     * Array of organizations a user is part of and their roles
     * @type {Array<OrganizationUser>}
     * @memberof User
     */
    organizations?: Array<OrganizationUser>;
    /**
     * list of actions user is allowed to do on this organization
     * @type {Array<NamespaceActions>}
     * @memberof User
     */
    allowed_actions?: Array<NamespaceActions>;
    /**
     * List of extra/optional/beta features to enable for namespace
     * @type {Array<string>}
     * @memberof User
     */
    enabled_features?: Array<string>;
    /**
     * A notice that the user has an unpaid subscription
     * @type {boolean}
     * @memberof User
     */
    unpaid_subscription?: boolean;
    /**
     * default S3 path to store newly created notebooks
     * @type {string}
     * @memberof User
     */
    default_s3_path?: string;
    /**
     * Default S3 path credentials name is the credentials name to use along with default_s3_path
     * @type {string}
     * @memberof User
     */
    default_s3_path_credentials_name?: string;
    /**
     * Override the default namespace charged for actions when no namespace is specified
     * @type {string}
     * @memberof User
     */
    default_namespace_charged?: string;
}
/**
 * 
 * @export
 * @interface Writer
 */
export interface Writer {
    /**
     * 
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordDups?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordOOB?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Writer
     */
    dedupCoords?: boolean;
    /**
     * 
     * @type {DomainArray}
     * @memberof Writer
     */
    subarray?: DomainArray;
}

/**
 * ArrayApi - axios parameter creator
 * @export
 */
export const ArrayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task ID To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog: async (namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, hasTaskId?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('arrayActivityLog', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('arrayActivityLog', 'array', array)
            const localVarPath = `/arrays/{namespace}/{array}/activity`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (eventTypes !== undefined) {
                localVarQueryParameter['event_types'] = eventTypes;
            }

            if (taskId !== undefined) {
                localVarQueryParameter['task_id'] = taskId;
            }

            if (hasTaskId !== undefined) {
                localVarQueryParameter['has_task_id'] = hasTaskId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet: async (page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/arrays/browser/owned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }

            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }

            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }

            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }

            if (fileProperty) {
                localVarQueryParameter['file_property'] = fileProperty;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/arrays/browser/owned/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet: async (page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/arrays/browser/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }

            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }

            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }

            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }

            if (fileProperty) {
                localVarQueryParameter['file_property'] = fileProperty;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/arrays/browser/public/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet: async (page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/arrays/browser/shared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }

            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }

            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }

            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }

            if (fileProperty) {
                localVarQueryParameter['file_property'] = fileProperty;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/arrays/browser/shared/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysNamespaceArrayEndTimestampsGet: async (namespace: string, array: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('arraysNamespaceArrayEndTimestampsGet', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('arraysNamespaceArrayEndTimestampsGet', 'array', array)
            const localVarPath = `/arrays/{namespace}/{array}/end_timestamps`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consolidateArray: async (namespace: string, array: string, tiledbConfig: TileDBConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('consolidateArray', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('consolidateArray', 'array', array)
            // verify required parameter 'tiledbConfig' is not null or undefined
            assertParamExists('consolidateArray', 'tiledbConfig', tiledbConfig)
            const localVarPath = `/arrays/{namespace}/{array}/consolidate`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(tiledbConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray: async (namespace: string, array: string, contentType: string, arraySchema: ArraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('createArray', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('createArray', 'array', array)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('createArray', 'contentType', contentType)
            // verify required parameter 'arraySchema' is not null or undefined
            assertParamExists('createArray', 'arraySchema', arraySchema)
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(arraySchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray: async (namespace: string, array: string, contentType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteArray', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('deleteArray', 'array', array)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('deleteArray', 'contentType', contentType)
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray: async (namespace: string, array: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deregisterArray', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('deregisterArray', 'array', array)
            const localVarPath = `/arrays/{namespace}/{array}/deregister`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get activity log by ID
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} id ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityLogById: async (namespace: string, array: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getActivityLogById', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getActivityLogById', 'array', array)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getActivityLogById', 'id', id)
            const localVarPath = `/arrays/{namespace}/{array}/activity/{id}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata: async (publicShare?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/arrays`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (publicShare !== undefined) {
                localVarQueryParameter['public_share'] = publicShare;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray: async (namespace: string, array: string, contentType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getArray', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getArray', 'array', array)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getArray', 'contentType', contentType)
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes: async (namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getArrayMaxBufferSizes', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getArrayMaxBufferSizes', 'array', array)
            // verify required parameter 'subarray' is not null or undefined
            assertParamExists('getArrayMaxBufferSizes', 'subarray', subarray)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getArrayMaxBufferSizes', 'contentType', contentType)
            const localVarPath = `/arrays/{namespace}/{array}/max_buffer_sizes`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (subarray !== undefined) {
                localVarQueryParameter['subarray'] = subarray;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get metadata from the array in JSON format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson: async (namespace: string, array: string, length?: number, endTimestamp?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getArrayMetaDataJson', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getArrayMetaDataJson', 'array', array)
            const localVarPath = `/arrays/{namespace}/{array}/metadata_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }

            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata: async (namespace: string, array: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getArrayMetadata', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getArrayMetadata', 'array', array)
            const localVarPath = `/arrays/{namespace}/{array}/metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadataCapnp: async (namespace: string, array: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getArrayMetadataCapnp', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getArrayMetadataCapnp', 'array', array)
            const localVarPath = `/arrays/{namespace}/{array}/array_metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain: async (namespace: string, array: string, contentType: string, xPayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getArrayNonEmptyDomain', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getArrayNonEmptyDomain', 'array', array)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getArrayNonEmptyDomain', 'contentType', contentType)
            const localVarPath = `/arrays/{namespace}/{array}/non_empty_domain`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomainJson: async (namespace: string, array: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getArrayNonEmptyDomainJson', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getArrayNonEmptyDomainJson', 'array', array)
            const localVarPath = `/arrays/{namespace}/{array}/non_empty_domain_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData: async (namespace: string, array: string, samples?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getArraySampleData', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getArraySampleData', 'array', array)
            const localVarPath = `/arrays/{namespace}/{array}/sample`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (samples !== undefined) {
                localVarQueryParameter['samples'] = samples;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies: async (namespace: string, array: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getArraySharingPolicies', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getArraySharingPolicies', 'array', array)
            const localVarPath = `/arrays/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace: async (namespace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getArraysInNamespace', 'namespace', namespace)
            const localVarPath = `/arrays/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFragmentEndTimestamp: async (namespace: string, array: string, endTimestamp?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getFragmentEndTimestamp', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getFragmentEndTimestamp', 'array', array)
            const localVarPath = `/arrays/{namespace}/{array}/fragment_end_timestamp`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/arrays/last_accessed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray: async (namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('registerArray', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('registerArray', 'array', array)
            // verify required parameter 'arrayMetadata' is not null or undefined
            assertParamExists('registerArray', 'arrayMetadata', arrayMetadata)
            const localVarPath = `/arrays/{namespace}/{array}/register`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(arrayMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray: async (namespace: string, array: string, arraySharing: ArraySharing, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('shareArray', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('shareArray', 'array', array)
            // verify required parameter 'arraySharing' is not null or undefined
            assertParamExists('shareArray', 'arraySharing', arraySharing)
            const localVarPath = `/arrays/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(arraySharing, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata: async (namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateArrayMetadata', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('updateArrayMetadata', 'array', array)
            // verify required parameter 'arrayMetadata' is not null or undefined
            assertParamExists('updateArrayMetadata', 'arrayMetadata', arrayMetadata)
            const localVarPath = `/arrays/{namespace}/{array}/metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(arrayMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadataCapnp: async (namespace: string, array: string, arrayMetadataEntries: ArrayMetadata, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateArrayMetadataCapnp', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('updateArrayMetadataCapnp', 'array', array)
            // verify required parameter 'arrayMetadataEntries' is not null or undefined
            assertParamExists('updateArrayMetadataCapnp', 'arrayMetadataEntries', arrayMetadataEntries)
            const localVarPath = `/arrays/{namespace}/{array}/array_metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(arrayMetadataEntries, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vacuumArray: async (namespace: string, array: string, tiledbConfig: TileDBConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('vacuumArray', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('vacuumArray', 'array', array)
            // verify required parameter 'tiledbConfig' is not null or undefined
            assertParamExists('vacuumArray', 'tiledbConfig', tiledbConfig)
            const localVarPath = `/arrays/{namespace}/{array}/vacuum`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(tiledbConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArrayApi - functional programming interface
 * @export
 */
export const ArrayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArrayApiAxiosParamCreator(configuration)
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task ID To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, hasTaskId?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArrayActivityLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async arraysBrowserOwnedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayBrowserData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async arraysBrowserOwnedSidebarGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayBrowserSidebar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.arraysBrowserOwnedSidebarGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async arraysBrowserPublicGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayBrowserData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async arraysBrowserPublicSidebarGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayBrowserSidebar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.arraysBrowserPublicSidebarGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async arraysBrowserSharedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayBrowserData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async arraysBrowserSharedSidebarGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayBrowserSidebar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.arraysBrowserSharedSidebarGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async arraysNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayEndTimestampData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consolidateArray(namespace: string, array: string, tiledbConfig: TileDBConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consolidateArray(namespace, array, tiledbConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArray(namespace: string, array: string, contentType: string, arraySchema: ArraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArray(namespace: string, array: string, contentType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArray(namespace, array, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deregisterArray(namespace: string, array: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deregisterArray(namespace, array, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get activity log by ID
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} id ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityLogById(namespace: string, array: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayActivityLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityLogById(namespace, array, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllArrayMetadata(publicShare?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArrayInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllArrayMetadata(publicShare, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArray(namespace: string, array: string, contentType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArraySchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArray(namespace, array, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArrayMaxBufferSizes(namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaxBufferSizes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get metadata from the array in JSON format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArrayMetaDataJson(namespace: string, array: string, length?: number, endTimestamp?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArrayMetaDataJson(namespace, array, length, endTimestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArrayMetadata(namespace: string, array: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArrayMetadata(namespace, array, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArrayMetadataCapnp(namespace: string, array: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArrayMetadataCapnp(namespace, array, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArrayNonEmptyDomain(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonEmptyDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArrayNonEmptyDomainJson(namespace: string, array: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArrayNonEmptyDomainJson(namespace, array, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArraySampleData(namespace: string, array: string, samples?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArraySample>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArraySampleData(namespace, array, samples, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArraySharingPolicies(namespace: string, array: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArraySharing>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArraySharingPolicies(namespace, array, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArraysInNamespace(namespace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArrayInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArraysInNamespace(namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFragmentEndTimestamp(namespace: string, array: string, endTimestamp?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFragmentEndTimestamp(namespace, array, endTimestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLastAccessedArrays(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LastAccessedArray>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLastAccessedArrays(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerArray(namespace, array, arrayMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareArray(namespace: string, array: string, arraySharing: ArraySharing, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareArray(namespace, array, arraySharing, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArrayMetadata(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArrayMetadata(namespace, array, arrayMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArrayMetadataCapnp(namespace: string, array: string, arrayMetadataEntries: ArrayMetadata, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vacuumArray(namespace: string, array: string, tiledbConfig: TileDBConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vacuumArray(namespace, array, tiledbConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArrayApi - factory interface
 * @export
 */
export const ArrayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArrayApiFp(configuration)
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task ID To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, hasTaskId?: boolean, options?: any): AxiosPromise<Array<ArrayActivityLog>> {
            return localVarFp.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any): AxiosPromise<ArrayBrowserData> {
            return localVarFp.arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet(options?: any): AxiosPromise<ArrayBrowserSidebar> {
            return localVarFp.arraysBrowserOwnedSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any): AxiosPromise<ArrayBrowserData> {
            return localVarFp.arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet(options?: any): AxiosPromise<ArrayBrowserSidebar> {
            return localVarFp.arraysBrowserPublicSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any): AxiosPromise<ArrayBrowserData> {
            return localVarFp.arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet(options?: any): AxiosPromise<ArrayBrowserSidebar> {
            return localVarFp.arraysBrowserSharedSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): AxiosPromise<ArrayEndTimestampData> {
            return localVarFp.arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consolidateArray(namespace: string, array: string, tiledbConfig: TileDBConfig, options?: any): AxiosPromise<void> {
            return localVarFp.consolidateArray(namespace, array, tiledbConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray(namespace: string, array: string, contentType: string, arraySchema: ArraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): AxiosPromise<void> {
            return localVarFp.createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray(namespace: string, array: string, contentType: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArray(namespace, array, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray(namespace: string, array: string, options?: any): AxiosPromise<void> {
            return localVarFp.deregisterArray(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get activity log by ID
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} id ID of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityLogById(namespace: string, array: string, id: string, options?: any): AxiosPromise<ArrayActivityLog> {
            return localVarFp.getActivityLogById(namespace, array, id, options).then((request) => request(axios, basePath));
        },
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata(publicShare?: string, options?: any): AxiosPromise<Array<ArrayInfo>> {
            return localVarFp.getAllArrayMetadata(publicShare, options).then((request) => request(axios, basePath));
        },
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray(namespace: string, array: string, contentType: string, options?: any): AxiosPromise<ArraySchema> {
            return localVarFp.getArray(namespace, array, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes(namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options?: any): AxiosPromise<MaxBufferSizes> {
            return localVarFp.getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata from the array in JSON format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson(namespace: string, array: string, length?: number, endTimestamp?: number, options?: any): AxiosPromise<object> {
            return localVarFp.getArrayMetaDataJson(namespace, array, length, endTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata(namespace: string, array: string, options?: any): AxiosPromise<ArrayInfo> {
            return localVarFp.getArrayMetadata(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadataCapnp(namespace: string, array: string, options?: any): AxiosPromise<ArrayMetadata> {
            return localVarFp.getArrayMetadataCapnp(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): AxiosPromise<NonEmptyDomain> {
            return localVarFp.getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomainJson(namespace: string, array: string, options?: any): AxiosPromise<object> {
            return localVarFp.getArrayNonEmptyDomainJson(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData(namespace: string, array: string, samples?: number, options?: any): AxiosPromise<ArraySample> {
            return localVarFp.getArraySampleData(namespace, array, samples, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies(namespace: string, array: string, options?: any): AxiosPromise<Array<ArraySharing>> {
            return localVarFp.getArraySharingPolicies(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace(namespace: string, options?: any): AxiosPromise<Array<ArrayInfo>> {
            return localVarFp.getArraysInNamespace(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [endTimestamp] Milliseconds since Unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFragmentEndTimestamp(namespace: string, array: string, endTimestamp?: number, options?: any): AxiosPromise<number> {
            return localVarFp.getFragmentEndTimestamp(namespace, array, endTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays(options?: any): AxiosPromise<Array<LastAccessedArray>> {
            return localVarFp.getLastAccessedArrays(options).then((request) => request(axios, basePath));
        },
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.registerArray(namespace, array, arrayMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray(namespace: string, array: string, arraySharing: ArraySharing, options?: any): AxiosPromise<void> {
            return localVarFp.shareArray(namespace, array, arraySharing, options).then((request) => request(axios, basePath));
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.updateArrayMetadata(namespace, array, arrayMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadataCapnp(namespace: string, array: string, arrayMetadataEntries: ArrayMetadata, options?: any): AxiosPromise<void> {
            return localVarFp.updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options).then((request) => request(axios, basePath));
        },
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vacuumArray(namespace: string, array: string, tiledbConfig: TileDBConfig, options?: any): AxiosPromise<void> {
            return localVarFp.vacuumArray(namespace, array, tiledbConfig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
export class ArrayApi extends BaseAPI {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task ID To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that do not contain an array task UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: string, taskId?: string, hasTaskId?: boolean, options?: any) {
        return ArrayApiFp(this.configuration).arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of all arrays that are owned directly by user or user\'s organizations
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arraysBrowserOwnedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any) {
        return ArrayApiFp(this.configuration).arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arraysBrowserOwnedSidebarGet(options?: any) {
        return ArrayApiFp(this.configuration).arraysBrowserOwnedSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of all arrays that have been shared publically
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arraysBrowserPublicGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any) {
        return ArrayApiFp(this.configuration).arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a sidebar of all arrays that have been shared publically
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arraysBrowserPublicSidebarGet(options?: any) {
        return ArrayApiFp(this.configuration).arraysBrowserPublicSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arraysBrowserSharedGet(page?: number, perPage?: number, search?: string, namespace?: string, orderby?: string, permissions?: string, tag?: Array<string>, excludeTag?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, fileProperty?: Array<string>, options?: any) {
        return ArrayApiFp(this.configuration).arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arraysBrowserSharedSidebarGet(options?: any) {
        return ArrayApiFp(this.configuration).arraysBrowserSharedSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arraysNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any) {
        return ArrayApiFp(this.configuration).arraysNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * consolidate an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public consolidateArray(namespace: string, array: string, tiledbConfig: TileDBConfig, options?: any) {
        return ArrayApiFp(this.configuration).consolidateArray(namespace, array, tiledbConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create a array schema at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArraySchema} arraySchema ArraySchema being created
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public createArray(namespace: string, array: string, contentType: string, arraySchema: ArraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any) {
        return ArrayApiFp(this.configuration).createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public deleteArray(namespace: string, array: string, contentType: string, options?: any) {
        return ArrayApiFp(this.configuration).deleteArray(namespace, array, contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * deregister a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public deregisterArray(namespace: string, array: string, options?: any) {
        return ArrayApiFp(this.configuration).deregisterArray(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get activity log by ID
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} id ID of the activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getActivityLogById(namespace: string, array: string, id: string, options?: any) {
        return ArrayApiFp(this.configuration).getActivityLogById(namespace, array, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get all array metadata user has access to
     * @param {string} [publicShare] Public share values can be one of exclude, only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getAllArrayMetadata(publicShare?: string, options?: any) {
        return ArrayApiFp(this.configuration).getAllArrayMetadata(publicShare, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get an ArraySchema using a url encoded uri
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArray(namespace: string, array: string, contentType: string, options?: any) {
        return ArrayApiFp(this.configuration).getArray(namespace, array, contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get the max buffer sizes of an array for a subarray
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} subarray CSV string of subarray to get max buffer sizes for
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArrayMaxBufferSizes(namespace: string, array: string, subarray: string, contentType: string, xPayer?: string, options?: any) {
        return ArrayApiFp(this.configuration).getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get metadata from the array in JSON format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [length] (optional) limit character length of returned values
     * @param {number} [endTimestamp] Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArrayMetaDataJson(namespace: string, array: string, length?: number, endTimestamp?: number, options?: any) {
        return ArrayApiFp(this.configuration).getArrayMetaDataJson(namespace, array, length, endTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArrayMetadata(namespace: string, array: string, options?: any) {
        return ArrayApiFp(this.configuration).getArrayMetadata(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArrayMetadataCapnp(namespace: string, array: string, options?: any) {
        return ArrayApiFp(this.configuration).getArrayMetadataCapnp(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get the non empty domain of an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArrayNonEmptyDomain(namespace: string, array: string, contentType: string, xPayer?: string, options?: any) {
        return ArrayApiFp(this.configuration).getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get non-empty domain from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArrayNonEmptyDomainJson(namespace: string, array: string, options?: any) {
        return ArrayApiFp(this.configuration).getArrayNonEmptyDomainJson(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get an sample set of data from the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [samples] Number of sample results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArraySampleData(namespace: string, array: string, samples?: number, options?: any) {
        return ArrayApiFp(this.configuration).getArraySampleData(namespace, array, samples, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all sharing details of the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArraySharingPolicies(namespace: string, array: string, options?: any) {
        return ArrayApiFp(this.configuration).getArraySharingPolicies(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get metadata on all arrays in a namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArraysInNamespace(namespace: string, options?: any) {
        return ArrayApiFp(this.configuration).getArraysInNamespace(namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [endTimestamp] Milliseconds since Unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getFragmentEndTimestamp(namespace: string, array: string, endTimestamp?: number, options?: any) {
        return ArrayApiFp(this.configuration).getFragmentEndTimestamp(namespace, array, endTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getLastAccessedArrays(options?: any) {
        return ArrayApiFp(this.configuration).getLastAccessedArrays(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * register an array at a specified URI registered to the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public registerArray(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any) {
        return ArrayApiFp(this.configuration).registerArray(namespace, array, arrayMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Share an array with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the array will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public shareArray(namespace: string, array: string, arraySharing: ArraySharing, options?: any) {
        return ArrayApiFp(this.configuration).shareArray(namespace, array, arraySharing, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public updateArrayMetadata(namespace: string, array: string, arrayMetadata: ArrayInfoUpdate, options?: any) {
        return ArrayApiFp(this.configuration).updateArrayMetadata(namespace, array, arrayMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public updateArrayMetadataCapnp(namespace: string, array: string, arrayMetadataEntries: ArrayMetadata, options?: any) {
        return ArrayApiFp(this.configuration).updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * vacuum an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public vacuumArray(namespace: string, array: string, tiledbConfig: TileDBConfig, options?: any) {
        return ArrayApiFp(this.configuration).vacuumArray(namespace, array, tiledbConfig, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArrayTasksApi - axios parameter creator
 * @export
 */
export const ArrayTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar: async (start?: number, end?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArrayTasksApi - functional programming interface
 * @export
 */
export const ArrayTasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArrayTasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArrayTasksSidebar(start?: number, end?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayTaskBrowserSidebar>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArrayTasksSidebar(start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArrayTasksApi - factory interface
 * @export
 */
export const ArrayTasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArrayTasksApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar(start?: number, end?: number, options?: any): AxiosPromise<ArrayTaskBrowserSidebar> {
            return localVarFp.getArrayTasksSidebar(start, end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArrayTasksApi - object-oriented interface
 * @export
 * @class ArrayTasksApi
 * @extends {BaseAPI}
 */
export class ArrayTasksApi extends BaseAPI {
    /**
     * 
     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayTasksApi
     */
    public getArrayTasksSidebar(start?: number, end?: number, options?: any) {
        return ArrayTasksApiFp(this.configuration).getArrayTasksSidebar(start, end, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FavoritesApi - axios parameter creator
 * @export
 */
export const FavoritesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArrayFavorite: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('addArrayFavorite', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addArrayFavorite', 'name', name)
            const localVarPath = `/arrays/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMLModelFavorite: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('addMLModelFavorite', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addMLModelFavorite', 'name', name)
            const localVarPath = `/ml_models/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNotebookFavorite: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('addNotebookFavorite', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addNotebookFavorite', 'name', name)
            const localVarPath = `/notebooks/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUDFFavorite: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('addUDFFavorite', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addUDFFavorite', 'name', name)
            const localVarPath = `/udfs/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete specific array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArrayFavorite: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteArrayFavorite', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteArrayFavorite', 'name', name)
            const localVarPath = `/arrays/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete specific ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMLModelFavorite: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteMLModelFavorite', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteMLModelFavorite', 'name', name)
            const localVarPath = `/ml_models/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete specific notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotebookFavorite: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteNotebookFavorite', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteNotebookFavorite', 'name', name)
            const localVarPath = `/notebooks/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete specific UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFFavorite: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteUDFFavorite', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteUDFFavorite', 'name', name)
            const localVarPath = `/udfs/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch array favorite of a specific array
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayFavorite: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getArrayFavorite', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getArrayFavorite', 'name', name)
            const localVarPath = `/arrays/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch ML model favorite of a specific ML model
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMLModelFavorite: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getMLModelFavorite', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getMLModelFavorite', 'name', name)
            const localVarPath = `/ml_models/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch notebook favorite of a specific notebook
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookFavorite: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getNotebookFavorite', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getNotebookFavorite', 'name', name)
            const localVarPath = `/notebooks/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch UDF favorite of a specific UDF
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFFavorite: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getUDFFavorite', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getUDFFavorite', 'name', name)
            const localVarPath = `/udfs/favorites/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a page of array favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavorites: async (page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/arrays/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch all favorite array uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavoritesUUIDs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/arrays/favorites/uuids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a page of ML models favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavorites: async (page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ml_models/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch all favorite ML models uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavoritesUUIDs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ml_models/favorites/uuids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a page of notebook favorites of connected user
         * @param {boolean} [isDashboard] return only dashboards
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavorites: async (isDashboard?: boolean, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/notebooks/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (isDashboard !== undefined) {
                localVarQueryParameter['is_dashboard'] = isDashboard;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch all favorite notebook uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavoritesUUIDs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/notebooks/favorites/uuids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a page of UDF favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavorites: async (page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/udfs/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch all favorite UDF uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavoritesUUIDs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/udfs/favorites/uuids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FavoritesApi - functional programming interface
 * @export
 */
export const FavoritesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FavoritesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addArrayFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addArrayFavorite(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMLModelFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMLModelFavorite(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNotebookFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNotebookFavorite(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a new UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUDFFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUDFFavorite(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete specific array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArrayFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArrayFavorite(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete specific ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMLModelFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMLModelFavorite(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete specific notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotebookFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotebookFavorite(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete specific UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUDFFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUDFFavorite(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch array favorite of a specific array
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArrayFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayFavorite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArrayFavorite(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch ML model favorite of a specific ML model
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMLModelFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MLModelFavorite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMLModelFavorite(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch notebook favorite of a specific notebook
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotebookFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotebookFavorite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotebookFavorite(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch UDF favorite of a specific UDF
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUDFFavorite(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UDFFavorite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUDFFavorite(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a page of array favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArrayFavorites(page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayFavoritesData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArrayFavorites(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch all favorite array uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArrayFavoritesUUIDs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArrayFavorite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArrayFavoritesUUIDs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a page of ML models favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMLModelFavorites(page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MLModelFavoritesData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMLModelFavorites(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch all favorite ML models uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMLModelFavoritesUUIDs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MLModelFavorite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMLModelFavoritesUUIDs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a page of notebook favorites of connected user
         * @param {boolean} [isDashboard] return only dashboards
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNotebookFavorites(isDashboard?: boolean, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotebookFavoritesData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNotebookFavorites(isDashboard, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch all favorite notebook uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNotebookFavoritesUUIDs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotebookFavorite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNotebookFavoritesUUIDs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a page of UDF favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUDFFavorites(page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UDFFavoritesData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUDFFavorites(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch all favorite UDF uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUDFFavoritesUUIDs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UDFFavorite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUDFFavoritesUUIDs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FavoritesApi - factory interface
 * @export
 */
export const FavoritesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FavoritesApiFp(configuration)
    return {
        /**
         * Add a new array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArrayFavorite(namespace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.addArrayFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMLModelFavorite(namespace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.addMLModelFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNotebookFavorite(namespace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.addNotebookFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUDFFavorite(namespace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.addUDFFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific array favorite
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArrayFavorite(namespace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArrayFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific ML model favorite
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMLModelFavorite(namespace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMLModelFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific notebook favorite
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotebookFavorite(namespace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNotebookFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific UDF favorite
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFFavorite(namespace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUDFFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch array favorite of a specific array
         * @param {string} namespace The namespace of the array
         * @param {string} name The name of the array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayFavorite(namespace: string, name: string, options?: any): AxiosPromise<ArrayFavorite> {
            return localVarFp.getArrayFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch ML model favorite of a specific ML model
         * @param {string} namespace The namespace of the ML model
         * @param {string} name The name of the ML model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMLModelFavorite(namespace: string, name: string, options?: any): AxiosPromise<MLModelFavorite> {
            return localVarFp.getMLModelFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch notebook favorite of a specific notebook
         * @param {string} namespace The namespace of the notebook
         * @param {string} name The name of the notebook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookFavorite(namespace: string, name: string, options?: any): AxiosPromise<NotebookFavorite> {
            return localVarFp.getNotebookFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch UDF favorite of a specific UDF
         * @param {string} namespace The namespace of the UDF
         * @param {string} name The name of the UDF
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFFavorite(namespace: string, name: string, options?: any): AxiosPromise<UDFFavorite> {
            return localVarFp.getUDFFavorite(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a page of array favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavorites(page?: number, perPage?: number, options?: any): AxiosPromise<ArrayFavoritesData> {
            return localVarFp.listArrayFavorites(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all favorite array uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArrayFavoritesUUIDs(options?: any): AxiosPromise<Array<ArrayFavorite>> {
            return localVarFp.listArrayFavoritesUUIDs(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a page of ML models favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavorites(page?: number, perPage?: number, options?: any): AxiosPromise<MLModelFavoritesData> {
            return localVarFp.listMLModelFavorites(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all favorite ML models uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMLModelFavoritesUUIDs(options?: any): AxiosPromise<Array<MLModelFavorite>> {
            return localVarFp.listMLModelFavoritesUUIDs(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a page of notebook favorites of connected user
         * @param {boolean} [isDashboard] return only dashboards
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavorites(isDashboard?: boolean, page?: number, perPage?: number, options?: any): AxiosPromise<NotebookFavoritesData> {
            return localVarFp.listNotebookFavorites(isDashboard, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all favorite notebook uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNotebookFavoritesUUIDs(options?: any): AxiosPromise<Array<NotebookFavorite>> {
            return localVarFp.listNotebookFavoritesUUIDs(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a page of UDF favorites of connected user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavorites(page?: number, perPage?: number, options?: any): AxiosPromise<UDFFavoritesData> {
            return localVarFp.listUDFFavorites(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all favorite UDF uuids of connected user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUDFFavoritesUUIDs(options?: any): AxiosPromise<Array<UDFFavorite>> {
            return localVarFp.listUDFFavoritesUUIDs(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FavoritesApi - object-oriented interface
 * @export
 * @class FavoritesApi
 * @extends {BaseAPI}
 */
export class FavoritesApi extends BaseAPI {
    /**
     * Add a new array favorite
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public addArrayFavorite(namespace: string, name: string, options?: any) {
        return FavoritesApiFp(this.configuration).addArrayFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new ML model favorite
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public addMLModelFavorite(namespace: string, name: string, options?: any) {
        return FavoritesApiFp(this.configuration).addMLModelFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new notebook favorite
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public addNotebookFavorite(namespace: string, name: string, options?: any) {
        return FavoritesApiFp(this.configuration).addNotebookFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new UDF favorite
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public addUDFFavorite(namespace: string, name: string, options?: any) {
        return FavoritesApiFp(this.configuration).addUDFFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete specific array favorite
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public deleteArrayFavorite(namespace: string, name: string, options?: any) {
        return FavoritesApiFp(this.configuration).deleteArrayFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete specific ML model favorite
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public deleteMLModelFavorite(namespace: string, name: string, options?: any) {
        return FavoritesApiFp(this.configuration).deleteMLModelFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete specific notebook favorite
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public deleteNotebookFavorite(namespace: string, name: string, options?: any) {
        return FavoritesApiFp(this.configuration).deleteNotebookFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete specific UDF favorite
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public deleteUDFFavorite(namespace: string, name: string, options?: any) {
        return FavoritesApiFp(this.configuration).deleteUDFFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch array favorite of a specific array
     * @param {string} namespace The namespace of the array
     * @param {string} name The name of the array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public getArrayFavorite(namespace: string, name: string, options?: any) {
        return FavoritesApiFp(this.configuration).getArrayFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch ML model favorite of a specific ML model
     * @param {string} namespace The namespace of the ML model
     * @param {string} name The name of the ML model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public getMLModelFavorite(namespace: string, name: string, options?: any) {
        return FavoritesApiFp(this.configuration).getMLModelFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch notebook favorite of a specific notebook
     * @param {string} namespace The namespace of the notebook
     * @param {string} name The name of the notebook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public getNotebookFavorite(namespace: string, name: string, options?: any) {
        return FavoritesApiFp(this.configuration).getNotebookFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch UDF favorite of a specific UDF
     * @param {string} namespace The namespace of the UDF
     * @param {string} name The name of the UDF
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public getUDFFavorite(namespace: string, name: string, options?: any) {
        return FavoritesApiFp(this.configuration).getUDFFavorite(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a page of array favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public listArrayFavorites(page?: number, perPage?: number, options?: any) {
        return FavoritesApiFp(this.configuration).listArrayFavorites(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch all favorite array uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public listArrayFavoritesUUIDs(options?: any) {
        return FavoritesApiFp(this.configuration).listArrayFavoritesUUIDs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a page of ML models favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public listMLModelFavorites(page?: number, perPage?: number, options?: any) {
        return FavoritesApiFp(this.configuration).listMLModelFavorites(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch all favorite ML models uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public listMLModelFavoritesUUIDs(options?: any) {
        return FavoritesApiFp(this.configuration).listMLModelFavoritesUUIDs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a page of notebook favorites of connected user
     * @param {boolean} [isDashboard] return only dashboards
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public listNotebookFavorites(isDashboard?: boolean, page?: number, perPage?: number, options?: any) {
        return FavoritesApiFp(this.configuration).listNotebookFavorites(isDashboard, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch all favorite notebook uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public listNotebookFavoritesUUIDs(options?: any) {
        return FavoritesApiFp(this.configuration).listNotebookFavoritesUUIDs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a page of UDF favorites of connected user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public listUDFFavorites(page?: number, perPage?: number, options?: any) {
        return FavoritesApiFp(this.configuration).listUDFFavorites(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch all favorite UDF uuids of connected user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public listUDFFavoritesUUIDs(options?: any) {
        return FavoritesApiFp(this.configuration).listUDFFavoritesUUIDs(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCreateFile: async (namespace: string, fileCreate: FileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('handleCreateFile', 'namespace', namespace)
            // verify required parameter 'fileCreate' is not null or undefined
            assertParamExists('handleCreateFile', 'fileCreate', fileCreate)
            const localVarPath = `/files/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(fileCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export a TileDB File back to its original file format
         * @param {string} namespace The namespace of the file
         * @param {string} file The file identifier
         * @param {FileExport} fileExport Export configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExportFile: async (namespace: string, file: string, fileExport: FileExport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('handleExportFile', 'namespace', namespace)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('handleExportFile', 'file', file)
            // verify required parameter 'fileExport' is not null or undefined
            assertParamExists('handleExportFile', 'fileExport', fileExport)
            const localVarPath = `/files/{namespace}/{file}/export`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"file"}}`, encodeURIComponent(String(file)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(fileExport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleCreateFile(namespace: string, fileCreate: FileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileCreated>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Export a TileDB File back to its original file format
         * @param {string} namespace The namespace of the file
         * @param {string} file The file identifier
         * @param {FileExport} fileExport Export configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleExportFile(namespace: string, file: string, fileExport: FileExport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileExported>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleExportFile(namespace, file, fileExport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * Create a tiledb file at the specified location
         * @param {string} namespace The namespace of the file
         * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleCreateFile(namespace: string, fileCreate: FileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): AxiosPromise<FileCreated> {
            return localVarFp.handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(axios, basePath));
        },
        /**
         * Export a TileDB File back to its original file format
         * @param {string} namespace The namespace of the file
         * @param {string} file The file identifier
         * @param {FileExport} fileExport Export configuration information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExportFile(namespace: string, file: string, fileExport: FileExport, options?: any): AxiosPromise<FileExported> {
            return localVarFp.handleExportFile(namespace, file, fileExport, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Create a tiledb file at the specified location
     * @param {string} namespace The namespace of the file
     * @param {FileCreate} fileCreate Input/Output information to create a new TileDB file
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public handleCreateFile(namespace: string, fileCreate: FileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any) {
        return FilesApiFp(this.configuration).handleCreateFile(namespace, fileCreate, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export a TileDB File back to its original file format
     * @param {string} namespace The namespace of the file
     * @param {string} file The file identifier
     * @param {FileExport} fileExport Export configuration information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public handleExportFile(namespace: string, file: string, fileExport: FileExport, options?: any) {
        return FilesApiFp(this.configuration).handleExportFile(namespace, file, fileExport, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an asset(array, notebook, udf etc) to a group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {string} assetNamespace The namespace of the asset
         * @param {string} assetName The name of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAsset: async (namespace: string, name: string, assetNamespace: string, assetName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('addAsset', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addAsset', 'name', name)
            // verify required parameter 'assetNamespace' is not null or undefined
            assertParamExists('addAsset', 'assetNamespace', assetNamespace)
            // verify required parameter 'assetName' is not null or undefined
            assertParamExists('addAsset', 'assetName', assetName)
            const localVarPath = `/groups/{namespace}/{name}/{asset_namespace}/{asset_name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"asset_namespace"}}`, encodeURIComponent(String(assetNamespace)))
                .replace(`{${"asset_name"}}`, encodeURIComponent(String(assetName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new, empty group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {GroupCreate} [groupCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (namespace: string, name: string, groupCreate?: GroupCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('createGroup', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createGroup', 'name', name)
            const localVarPath = `/groups/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(groupCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the group and all the subgroups recursively. The assets are not deleted nor are not relocated to any other group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteGroup', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteGroup', 'name', name)
            const localVarPath = `/groups/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the contents, assets and subgroups, of the group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {'attributes' | 'groups' | 'assets'} [output] 
         * @param {number} [page] pagination offset for assets
         * @param {number} [perPage] pagination limit for assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroup: async (namespace: string, name: string, output?: 'attributes' | 'groups' | 'assets', page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listGroup', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listGroup', 'name', name)
            const localVarPath = `/groups/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (output !== undefined) {
                localVarQueryParameter['output'] = output;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns one page of top level groups in namespace.
         * @param {string} namespace The namespace to operate on
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTopLevelGroups: async (namespace: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listTopLevelGroups', 'namespace', namespace)
            const localVarPath = `/groups/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an asset from a group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {string} assetNamespace The namespace of the asset
         * @param {string} assetName The name of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAsset: async (namespace: string, name: string, assetNamespace: string, assetName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('removeAsset', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('removeAsset', 'name', name)
            // verify required parameter 'assetNamespace' is not null or undefined
            assertParamExists('removeAsset', 'assetNamespace', assetNamespace)
            // verify required parameter 'assetName' is not null or undefined
            assertParamExists('removeAsset', 'assetName', assetName)
            const localVarPath = `/groups/{namespace}/{name}/{asset_namespace}/{asset_name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"asset_namespace"}}`, encodeURIComponent(String(assetNamespace)))
                .replace(`{${"asset_name"}}`, encodeURIComponent(String(assetName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes attributes of the group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {GroupUpdate} [groupUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup: async (namespace: string, name: string, groupUpdate?: GroupUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateGroup', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateGroup', 'name', name)
            const localVarPath = `/groups/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(groupUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds an asset(array, notebook, udf etc) to a group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {string} assetNamespace The namespace of the asset
         * @param {string} assetName The name of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAsset(namespace: string, name: string, assetNamespace: string, assetName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAsset(namespace, name, assetNamespace, assetName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new, empty group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {GroupCreate} [groupCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(namespace: string, name: string, groupCreate?: GroupCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(namespace, name, groupCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the group and all the subgroups recursively. The assets are not deleted nor are not relocated to any other group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the contents, assets and subgroups, of the group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {'attributes' | 'groups' | 'assets'} [output] 
         * @param {number} [page] pagination offset for assets
         * @param {number} [perPage] pagination limit for assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroup(namespace: string, name: string, output?: 'attributes' | 'groups' | 'assets', page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupListing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroup(namespace, name, output, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns one page of top level groups in namespace.
         * @param {string} namespace The namespace to operate on
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTopLevelGroups(namespace: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupListing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTopLevelGroups(namespace, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes an asset from a group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {string} assetNamespace The namespace of the asset
         * @param {string} assetName The name of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAsset(namespace: string, name: string, assetNamespace: string, assetName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAsset(namespace, name, assetNamespace, assetName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes attributes of the group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {GroupUpdate} [groupUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroup(namespace: string, name: string, groupUpdate?: GroupUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroup(namespace, name, groupUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * Adds an asset(array, notebook, udf etc) to a group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {string} assetNamespace The namespace of the asset
         * @param {string} assetName The name of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAsset(namespace: string, name: string, assetNamespace: string, assetName: string, options?: any): AxiosPromise<void> {
            return localVarFp.addAsset(namespace, name, assetNamespace, assetName, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new, empty group in the namespace.
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {GroupCreate} [groupCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(namespace: string, name: string, groupCreate?: GroupCreate, options?: any): AxiosPromise<void> {
            return localVarFp.createGroup(namespace, name, groupCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the group and all the subgroups recursively. The assets are not deleted nor are not relocated to any other group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(namespace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroup(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the contents, assets and subgroups, of the group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {'attributes' | 'groups' | 'assets'} [output] 
         * @param {number} [page] pagination offset for assets
         * @param {number} [perPage] pagination limit for assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroup(namespace: string, name: string, output?: 'attributes' | 'groups' | 'assets', page?: number, perPage?: number, options?: any): AxiosPromise<GroupListing> {
            return localVarFp.listGroup(namespace, name, output, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns one page of top level groups in namespace.
         * @param {string} namespace The namespace to operate on
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTopLevelGroups(namespace: string, page?: number, perPage?: number, options?: any): AxiosPromise<GroupListing> {
            return localVarFp.listTopLevelGroups(namespace, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes an asset from a group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {string} assetNamespace The namespace of the asset
         * @param {string} assetName The name of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAsset(namespace: string, name: string, assetNamespace: string, assetName: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAsset(namespace, name, assetNamespace, assetName, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes attributes of the group
         * @param {string} namespace The namespace of the group
         * @param {string} name The name of the group
         * @param {GroupUpdate} [groupUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(namespace: string, name: string, groupUpdate?: GroupUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.updateGroup(namespace, name, groupUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * Adds an asset(array, notebook, udf etc) to a group
     * @param {string} namespace The namespace of the group
     * @param {string} name The name of the group
     * @param {string} assetNamespace The namespace of the asset
     * @param {string} assetName The name of the asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public addAsset(namespace: string, name: string, assetNamespace: string, assetName: string, options?: any) {
        return GroupsApiFp(this.configuration).addAsset(namespace, name, assetNamespace, assetName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new, empty group in the namespace.
     * @param {string} namespace The namespace of the group
     * @param {string} name The name of the group
     * @param {GroupCreate} [groupCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(namespace: string, name: string, groupCreate?: GroupCreate, options?: any) {
        return GroupsApiFp(this.configuration).createGroup(namespace, name, groupCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the group and all the subgroups recursively. The assets are not deleted nor are not relocated to any other group
     * @param {string} namespace The namespace of the group
     * @param {string} name The name of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroup(namespace: string, name: string, options?: any) {
        return GroupsApiFp(this.configuration).deleteGroup(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the contents, assets and subgroups, of the group
     * @param {string} namespace The namespace of the group
     * @param {string} name The name of the group
     * @param {'attributes' | 'groups' | 'assets'} [output] 
     * @param {number} [page] pagination offset for assets
     * @param {number} [perPage] pagination limit for assets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public listGroup(namespace: string, name: string, output?: 'attributes' | 'groups' | 'assets', page?: number, perPage?: number, options?: any) {
        return GroupsApiFp(this.configuration).listGroup(namespace, name, output, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns one page of top level groups in namespace.
     * @param {string} namespace The namespace to operate on
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public listTopLevelGroups(namespace: string, page?: number, perPage?: number, options?: any) {
        return GroupsApiFp(this.configuration).listTopLevelGroups(namespace, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes an asset from a group
     * @param {string} namespace The namespace of the group
     * @param {string} name The name of the group
     * @param {string} assetNamespace The namespace of the asset
     * @param {string} assetName The name of the asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public removeAsset(namespace: string, name: string, assetNamespace: string, assetName: string, options?: any) {
        return GroupsApiFp(this.configuration).removeAsset(namespace, name, assetNamespace, assetName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes attributes of the group
     * @param {string} namespace The namespace of the group
     * @param {string} name The name of the group
     * @param {GroupUpdate} [groupUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroup(namespace: string, name: string, groupUpdate?: GroupUpdate, options?: any) {
        return GroupsApiFp(this.configuration).updateGroup(namespace, name, groupUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvitationApi - axios parameter creator
 * @export
 */
export const InvitationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the ID of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation: async (invitation: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invitation' is not null or undefined
            assertParamExists('acceptInvitation', 'invitation', invitation)
            const localVarPath = `/invitations/{invitation}`
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels join organization invitation
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} organization name or UUID of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization: async (invitation: string, organization: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invitation' is not null or undefined
            assertParamExists('cancelJoinOrganization', 'invitation', invitation)
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('cancelJoinOrganization', 'organization', organization)
            const localVarPath = `/invitations/{invitation}/{organization}/join`
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)))
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite: async (namespace: string, invitation: string, array: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('cancelShareArrayByInvite', 'namespace', namespace)
            // verify required parameter 'invitation' is not null or undefined
            assertParamExists('cancelShareArrayByInvite', 'invitation', invitation)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('cancelShareArrayByInvite', 'array', array)
            const localVarPath = `/invitations/{invitation}/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or ID of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations: async (organization?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, orderby?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (organization !== undefined) {
                localVarQueryParameter['organization'] = organization;
            }

            if (array !== undefined) {
                localVarQueryParameter['array'] = array;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or UUID of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization: async (organization: string, emailInvite: InvitationOrganizationJoinEmail, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('joinOrganization', 'organization', organization)
            // verify required parameter 'emailInvite' is not null or undefined
            assertParamExists('joinOrganization', 'emailInvite', emailInvite)
            const localVarPath = `/invitations/{organization}/join`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(emailInvite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite: async (namespace: string, array: string, emailInvite: InvitationArrayShareEmail, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('shareArrayByInvite', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('shareArrayByInvite', 'array', array)
            // verify required parameter 'emailInvite' is not null or undefined
            assertParamExists('shareArrayByInvite', 'emailInvite', emailInvite)
            const localVarPath = `/invitations/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(emailInvite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitationApi - functional programming interface
 * @export
 */
export const InvitationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitationApiAxiosParamCreator(configuration)
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the ID of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvitation(invitation: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvitation(invitation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels join organization invitation
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} organization name or UUID of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelJoinOrganization(invitation: string, organization: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelJoinOrganization(invitation, organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelShareArrayByInvite(namespace: string, invitation: string, array: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelShareArrayByInvite(namespace, invitation, array, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or ID of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchInvitations(organization?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, orderby?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvitationData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or UUID of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinOrganization(organization: string, emailInvite: InvitationOrganizationJoinEmail, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinOrganization(organization, emailInvite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareArrayByInvite(namespace: string, array: string, emailInvite: InvitationArrayShareEmail, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareArrayByInvite(namespace, array, emailInvite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvitationApi - factory interface
 * @export
 */
export const InvitationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitationApiFp(configuration)
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the ID of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(invitation: string, options?: any): AxiosPromise<void> {
            return localVarFp.acceptInvitation(invitation, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels join organization invitation
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} organization name or UUID of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization(invitation: string, organization: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelJoinOrganization(invitation, organization, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the ID of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite(namespace: string, invitation: string, array: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelShareArrayByInvite(namespace, invitation, array, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or ID of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations(organization?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, orderby?: string, options?: any): AxiosPromise<InvitationData> {
            return localVarFp.fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or UUID of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization(organization: string, emailInvite: InvitationOrganizationJoinEmail, options?: any): AxiosPromise<void> {
            return localVarFp.joinOrganization(organization, emailInvite, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite(namespace: string, array: string, emailInvite: InvitationArrayShareEmail, options?: any): AxiosPromise<void> {
            return localVarFp.shareArrayByInvite(namespace, array, emailInvite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitationApi - object-oriented interface
 * @export
 * @class InvitationApi
 * @extends {BaseAPI}
 */
export class InvitationApi extends BaseAPI {
    /**
     * Accepts invitation
     * @param {string} invitation the ID of invitation about to be accepted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public acceptInvitation(invitation: string, options?: any) {
        return InvitationApiFp(this.configuration).acceptInvitation(invitation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels join organization invitation
     * @param {string} invitation the ID of invitation about to be cancelled
     * @param {string} organization name or UUID of organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public cancelJoinOrganization(invitation: string, organization: string, options?: any) {
        return InvitationApiFp(this.configuration).cancelJoinOrganization(invitation, organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels array sharing invitation
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} invitation the ID of invitation about to be cancelled
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public cancelShareArrayByInvite(namespace: string, invitation: string, array: string, options?: any) {
        return InvitationApiFp(this.configuration).cancelShareArrayByInvite(namespace, invitation, array, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of invitations
     * @param {string} [organization] name or ID of organization to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
     * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
     * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public fetchInvitations(organization?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, status?: string, orderby?: string, options?: any) {
        return InvitationApiFp(this.configuration).fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends email to multiple recipients with joining information regarding an organization
     * @param {string} organization name or UUID of organization
     * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public joinOrganization(organization: string, emailInvite: InvitationOrganizationJoinEmail, options?: any) {
        return InvitationApiFp(this.configuration).joinOrganization(organization, emailInvite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends email to multiple recipients with sharing information regarding an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {InvitationArrayShareEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public shareArrayByInvite(namespace: string, array: string, emailInvite: InvitationArrayShareEmail, options?: any) {
        return InvitationApiFp(this.configuration).shareArrayByInvite(namespace, array, emailInvite, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotebookApi - axios parameter creator
 * @export
 */
export const NotebookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus: async (namespace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getNotebookServerStatus', 'namespace', namespace)
            const localVarPath = `/notebooks/server/{namespace}/status`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer: async (namespace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('shutdownNotebookServer', 'namespace', namespace)
            const localVarPath = `/notebooks/server/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update name on a notebok, moving related S3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotebookName: async (namespace: string, array: string, notebookMetadata: ArrayInfoUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateNotebookName', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('updateNotebookName', 'array', array)
            // verify required parameter 'notebookMetadata' is not null or undefined
            assertParamExists('updateNotebookName', 'notebookMetadata', notebookMetadata)
            const localVarPath = `/notebooks/{namespace}/{array}/rename`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(notebookMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotebookApi - functional programming interface
 * @export
 */
export const NotebookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotebookApiAxiosParamCreator(configuration)
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotebookServerStatus(namespace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotebookStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotebookServerStatus(namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shutdownNotebookServer(namespace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shutdownNotebookServer(namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update name on a notebok, moving related S3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotebookName(namespace: string, array: string, notebookMetadata: ArrayInfoUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotebookName(namespace, array, notebookMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotebookApi - factory interface
 * @export
 */
export const NotebookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotebookApiFp(configuration)
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus(namespace: string, options?: any): AxiosPromise<NotebookStatus> {
            return localVarFp.getNotebookServerStatus(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer(namespace: string, options?: any): AxiosPromise<void> {
            return localVarFp.shutdownNotebookServer(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * update name on a notebok, moving related S3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotebookName(namespace: string, array: string, notebookMetadata: ArrayInfoUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.updateNotebookName(namespace, array, notebookMetadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotebookApi - object-oriented interface
 * @export
 * @class NotebookApi
 * @extends {BaseAPI}
 */
export class NotebookApi extends BaseAPI {
    /**
     * Get status of the notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    public getNotebookServerStatus(namespace: string, options?: any) {
        return NotebookApiFp(this.configuration).getNotebookServerStatus(namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Shutdown a notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    public shutdownNotebookServer(namespace: string, options?: any) {
        return NotebookApiFp(this.configuration).shutdownNotebookServer(namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update name on a notebok, moving related S3 object to new location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of notebook (array) that is url-encoded
     * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    public updateNotebookName(namespace: string, array: string, notebookMetadata: ArrayInfoUpdate, options?: any) {
        return NotebookApiFp(this.configuration).updateNotebookName(namespace, array, notebookMetadata, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotebooksApi - axios parameter creator
 * @export
 */
export const NotebooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notebooksNamespaceArrayEndTimestampsGet: async (namespace: string, array: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('notebooksNamespaceArrayEndTimestampsGet', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('notebooksNamespaceArrayEndTimestampsGet', 'array', array)
            const localVarPath = `/notebooks/{namespace}/{array}/end_timestamps`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotebooksApi - functional programming interface
 * @export
 */
export const NotebooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotebooksApiAxiosParamCreator(configuration)
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notebooksNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayEndTimestampData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotebooksApi - factory interface
 * @export
 */
export const NotebooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotebooksApiFp(configuration)
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notebooksNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): AxiosPromise<ArrayEndTimestampData> {
            return localVarFp.notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotebooksApi - object-oriented interface
 * @export
 * @class NotebooksApi
 * @extends {BaseAPI}
 */
export class NotebooksApi extends BaseAPI {
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    public notebooksNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any) {
        return NotebooksApiFp(this.configuration).notebooksNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials: async (namespace: string, awsAccessCredentials: AWSAccessCredentials, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('addAWSAccessCredentials', 'namespace', namespace)
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            assertParamExists('addAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials)
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization: async (organization: string, user: OrganizationUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('addUserToOrganization', 'organization', organization)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('addUserToOrganization', 'user', user)
            const localVarPath = `/organizations/{organization}/user`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials: async (namespace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('checkAWSAccessCredentials', 'namespace', namespace)
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('checkAWSAccessCredentialsByName', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('checkAWSAccessCredentialsByName', 'name', name)
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (organization: Organization, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('createOrganization', 'organization', organization)
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteAWSAccessCredentials', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteAWSAccessCredentials', 'name', name)
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: async (organization: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('deleteOrganization', 'organization', organization)
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization: async (organization: string, username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('deleteUserFromOrganization', 'organization', organization)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteUserFromOrganization', 'username', username)
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (organization: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getOrganization', 'organization', organization)
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser: async (organization: string, username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getOrganizationUser', 'organization', organization)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getOrganizationUser', 'username', username)
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials: async (namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateAWSAccessCredentials', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateAWSAccessCredentials', 'name', name)
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            assertParamExists('updateAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials)
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a organization
         * @param {string} organization organization name or ID
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (organization: string, organizationDetails: Organization, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('updateOrganization', 'organization', organization)
            // verify required parameter 'organizationDetails' is not null or undefined
            assertParamExists('updateOrganization', 'organizationDetails', organizationDetails)
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(organizationDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization: async (organization: string, username: string, user: OrganizationUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('updateUserInOrganization', 'organization', organization)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateUserInOrganization', 'username', username)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUserInOrganization', 'user', user)
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAWSAccessCredentials(namespace, awsAccessCredentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToOrganization(organization: string, user: OrganizationUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToOrganization(organization, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkAWSAccessCredentials(namespace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AWSAccessCredentials>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkAWSAccessCredentials(namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSAccessCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkAWSAccessCredentialsByName(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(organization: Organization, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganization(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAWSAccessCredentials(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAWSAccessCredentials(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganization(organization: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserFromOrganization(organization: string, username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFromOrganization(organization, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOrganizations(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOrganizations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(organization: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationUser(organization: string, username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationUser(organization, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update a organization
         * @param {string} organization organization name or ID
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(organization: string, organizationDetails: Organization, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(organization, organizationDetails, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserInOrganization(organization, username, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void> {
            return localVarFp.addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization: string, user: OrganizationUser, options?: any): AxiosPromise<void> {
            return localVarFp.addUserToOrganization(organization, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace: string, options?: any): AxiosPromise<Array<AWSAccessCredentials>> {
            return localVarFp.checkAWSAccessCredentials(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): AxiosPromise<AWSAccessCredentials> {
            return localVarFp.checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organization: Organization, options?: any): AxiosPromise<void> {
            return localVarFp.createOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAWSAccessCredentials(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organization: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization: string, username: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserFromOrganization(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations(options?: any): AxiosPromise<Array<Organization>> {
            return localVarFp.getAllOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * get a organization
         * @param {string} organization organization name or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organization: string, options?: any): AxiosPromise<Organization> {
            return localVarFp.getOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization: string, username: string, options?: any): AxiosPromise<OrganizationUser> {
            return localVarFp.getOrganizationUser(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void> {
            return localVarFp.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * update a organization
         * @param {string} organization organization name or ID
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organization: string, organizationDetails: Organization, options?: any): AxiosPromise<void> {
            return localVarFp.updateOrganization(organization, organizationDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserInOrganization(organization, username, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any) {
        return OrganizationApiFp(this.configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public addUserToOrganization(organization: string, user: OrganizationUser, options?: any) {
        return OrganizationApiFp(this.configuration).addUserToOrganization(organization, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public checkAWSAccessCredentials(namespace: string, options?: any) {
        return OrganizationApiFp(this.configuration).checkAWSAccessCredentials(namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any) {
        return OrganizationApiFp(this.configuration).checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create a organization, the user creating will be listed as owner
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrganization(organization: Organization, options?: any) {
        return OrganizationApiFp(this.configuration).createOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteAWSAccessCredentials(namespace: string, name: string, options?: any) {
        return OrganizationApiFp(this.configuration).deleteAWSAccessCredentials(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a organization
     * @param {string} organization organization name or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteOrganization(organization: string, options?: any) {
        return OrganizationApiFp(this.configuration).deleteOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteUserFromOrganization(organization: string, username: string, options?: any) {
        return OrganizationApiFp(this.configuration).deleteUserFromOrganization(organization, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get all organizations that the user is member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getAllOrganizations(options?: any) {
        return OrganizationApiFp(this.configuration).getAllOrganizations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get a organization
     * @param {string} organization organization name or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganization(organization: string, options?: any) {
        return OrganizationApiFp(this.configuration).getOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationUser(organization: string, username: string, options?: any) {
        return OrganizationApiFp(this.configuration).getOrganizationUser(organization, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any) {
        return OrganizationApiFp(this.configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a organization
     * @param {string} organization organization name or ID
     * @param {Organization} organizationDetails organization details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganization(organization: string, organizationDetails: Organization, options?: any) {
        return OrganizationApiFp(this.configuration).updateOrganization(organization, organizationDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any) {
        return OrganizationApiFp(this.configuration).updateUserInOrganization(organization, username, user, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery: async (namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('finalizeQuery', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('finalizeQuery', 'array', array)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('finalizeQuery', 'type', type)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('finalizeQuery', 'contentType', contentType)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('finalizeQuery', 'query', query)
            const localVarPath = `/arrays/{namespace}/{array}/query/finalize`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(query, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes: async (namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getEstResultSizes', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getEstResultSizes', 'array', array)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getEstResultSizes', 'type', type)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getEstResultSizes', 'contentType', contentType)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getEstResultSizes', 'query', query)
            const localVarPath = `/arrays/{namespace}/{array}/query/est_result_sizes`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(query, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (namespace: string, array: string, contentType: string, xPayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getFile', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getFile', 'array', array)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getFile', 'contentType', contentType)
            const localVarPath = `/arrays/{namespace}/{array}/query/get_file`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery: async (namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('submitQuery', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('submitQuery', 'array', array)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('submitQuery', 'type', type)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('submitQuery', 'contentType', contentType)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('submitQuery', 'query', query)
            const localVarPath = `/arrays/{namespace}/{array}/query/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(query, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns JSON results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQueryJson: async (namespace: string, array: string, contentType: string, queryJson: QueryJson, xPayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('submitQueryJson', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('submitQueryJson', 'array', array)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('submitQueryJson', 'contentType', contentType)
            // verify required parameter 'queryJson' is not null or undefined
            assertParamExists('submitQueryJson', 'queryJson', queryJson)
            const localVarPath = `/arrays/{namespace}/{array}/query/submit_query_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(queryJson, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration)
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finalizeQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Query>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEstResultSizes(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Query>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(namespace, array, contentType, xPayer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Query>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns JSON results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitQueryJson(namespace: string, array: string, contentType: string, queryJson: QueryJson, xPayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitQueryJson(namespace, array, contentType, queryJson, xPayer, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryApiFp(configuration)
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): AxiosPromise<Query> {
            return localVarFp.finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): AxiosPromise<Query> {
            return localVarFp.getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(namespace: string, array: string, contentType: string, xPayer?: string, options?: any): AxiosPromise<any> {
            return localVarFp.getFile(namespace, array, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any): AxiosPromise<Query> {
            return localVarFp.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns JSON results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQueryJson(namespace: string, array: string, contentType: string, queryJson: QueryJson, xPayer?: string, options?: any): AxiosPromise<object> {
            return localVarFp.submitQueryJson(namespace, array, contentType, queryJson, xPayer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public finalizeQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any) {
        return QueryApiFp(this.configuration).finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public getEstResultSizes(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any) {
        return QueryApiFp(this.configuration).getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * send a query to run against a specified array/URI registered to a group/project, returns file bytes
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public getFile(namespace: string, array: string, contentType: string, xPayer?: string, options?: any) {
        return QueryApiFp(this.configuration).getFile(namespace, array, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, options?: any) {
        return QueryApiFp(this.configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * send a query to run against a specified array/URI registered to a group/project, returns JSON results
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {QueryJson} queryJson query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public submitQueryJson(namespace: string, array: string, contentType: string, queryJson: QueryJson, xPayer?: string, options?: any) {
        return QueryApiFp(this.configuration).submitQueryJson(namespace, array, contentType, queryJson, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SqlApi - axios parameter creator
 * @export
 */
export const SqlApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL: async (namespace: string, sql: SQLParameters, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('runSQL', 'namespace', namespace)
            // verify required parameter 'sql' is not null or undefined
            assertParamExists('runSQL', 'sql', sql)
            const localVarPath = `/sql/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(sql, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SqlApi - functional programming interface
 * @export
 */
export const SqlApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SqlApiAxiosParamCreator(configuration)
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runSQL(namespace, sql, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SqlApi - factory interface
 * @export
 */
export const SqlApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SqlApiFp(configuration)
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.runSQL(namespace, sql, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SqlApi - object-oriented interface
 * @export
 * @class SqlApi
 * @extends {BaseAPI}
 */
export class SqlApi extends BaseAPI {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SqlApi
     */
    public runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any) {
        return SqlApiFp(this.configuration).runSQL(namespace, sql, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatsApi - axios parameter creator
 * @export
 */
export const StatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/.stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatsApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTiledbStats(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTiledbStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatsApiFp(configuration)
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getTiledbStats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI {
    /**
     * Fetch libtiledb stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public getTiledbStats(options?: any) {
        return StatsApiFp(this.configuration).getTiledbStats(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskGraphLogsApi - axios parameter creator
 * @export
 */
export const TaskGraphLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a task graph log.
         * @param {string} namespace The namespace that will own this task graph log.
         * @param {TaskGraphLog} log 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskGraphLog: async (namespace: string, log: TaskGraphLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('createTaskGraphLog', 'namespace', namespace)
            // verify required parameter 'log' is not null or undefined
            assertParamExists('createTaskGraphLog', 'log', log)
            const localVarPath = `/taskgraphs/{namespace}/log`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(log, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch information about a single task graph execution. 
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskGraphLog: async (namespace: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getTaskGraphLog', 'namespace', namespace)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskGraphLog', 'id', id)
            const localVarPath = `/taskgraphs/{namespace}/logs/{id}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata. 
         * @param {string} [namespace] Include logs for this namespace.
         * @param {string} [createdBy] Include logs from only this user.
         * @param {string} [search] search string that will look at name.
         * @param {string} [startTime] Include logs created after this time.
         * @param {string} [endTime] Include logs created before this time.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaskGraphLogs: async (namespace?: string, createdBy?: string, search?: string, startTime?: string, endTime?: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/taskgraphs/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information about a single task graph execution. 
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskGraphLog: async (namespace: string, id: string, log: TaskGraphLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateTaskGraphLog', 'namespace', namespace)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTaskGraphLog', 'id', id)
            // verify required parameter 'log' is not null or undefined
            assertParamExists('updateTaskGraphLog', 'log', log)
            const localVarPath = `/taskgraphs/{namespace}/logs/{id}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(log, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskGraphLogsApi - functional programming interface
 * @export
 */
export const TaskGraphLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskGraphLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a task graph log.
         * @param {string} namespace The namespace that will own this task graph log.
         * @param {TaskGraphLog} log 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskGraphLog(namespace: string, log: TaskGraphLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskGraphLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskGraphLog(namespace, log, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch information about a single task graph execution. 
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskGraphLog(namespace: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskGraphLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskGraphLog(namespace, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata. 
         * @param {string} [namespace] Include logs for this namespace.
         * @param {string} [createdBy] Include logs from only this user.
         * @param {string} [search] search string that will look at name.
         * @param {string} [startTime] Include logs created after this time.
         * @param {string} [endTime] Include logs created before this time.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTaskGraphLogs(namespace?: string, createdBy?: string, search?: string, startTime?: string, endTime?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskGraphLogsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update information about a single task graph execution. 
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTaskGraphLog(namespace: string, id: string, log: TaskGraphLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTaskGraphLog(namespace, id, log, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskGraphLogsApi - factory interface
 * @export
 */
export const TaskGraphLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskGraphLogsApiFp(configuration)
    return {
        /**
         * Create a task graph log.
         * @param {string} namespace The namespace that will own this task graph log.
         * @param {TaskGraphLog} log 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskGraphLog(namespace: string, log: TaskGraphLog, options?: any): AxiosPromise<TaskGraphLog> {
            return localVarFp.createTaskGraphLog(namespace, log, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch information about a single task graph execution. 
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskGraphLog(namespace: string, id: string, options?: any): AxiosPromise<TaskGraphLog> {
            return localVarFp.getTaskGraphLog(namespace, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata. 
         * @param {string} [namespace] Include logs for this namespace.
         * @param {string} [createdBy] Include logs from only this user.
         * @param {string} [search] search string that will look at name.
         * @param {string} [startTime] Include logs created after this time.
         * @param {string} [endTime] Include logs created before this time.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaskGraphLogs(namespace?: string, createdBy?: string, search?: string, startTime?: string, endTime?: string, page?: number, perPage?: number, options?: any): AxiosPromise<TaskGraphLogsData> {
            return localVarFp.listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update information about a single task graph execution. 
         * @param {string} namespace The namespace that owns this task graph log.
         * @param {string} id The UUID of the task graph log entry.
         * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskGraphLog(namespace: string, id: string, log: TaskGraphLog, options?: any): AxiosPromise<void> {
            return localVarFp.updateTaskGraphLog(namespace, id, log, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskGraphLogsApi - object-oriented interface
 * @export
 * @class TaskGraphLogsApi
 * @extends {BaseAPI}
 */
export class TaskGraphLogsApi extends BaseAPI {
    /**
     * Create a task graph log.
     * @param {string} namespace The namespace that will own this task graph log.
     * @param {TaskGraphLog} log 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    public createTaskGraphLog(namespace: string, log: TaskGraphLog, options?: any) {
        return TaskGraphLogsApiFp(this.configuration).createTaskGraphLog(namespace, log, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch information about a single task graph execution. 
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    public getTaskGraphLog(namespace: string, id: string, options?: any) {
        return TaskGraphLogsApiFp(this.configuration).getTaskGraphLog(namespace, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the task graph logs of a namespace the user has access to. The returned entries will include only summary data, and will not include information about the individual tasks that were executed. (This information is available when requesting an individual task graph log.) Entries in the response are ordered from newest to oldest. Pagination parameters work as in other API methods; see PaginationMetadata. 
     * @param {string} [namespace] Include logs for this namespace.
     * @param {string} [createdBy] Include logs from only this user.
     * @param {string} [search] search string that will look at name.
     * @param {string} [startTime] Include logs created after this time.
     * @param {string} [endTime] Include logs created before this time.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    public listTaskGraphLogs(namespace?: string, createdBy?: string, search?: string, startTime?: string, endTime?: string, page?: number, perPage?: number, options?: any) {
        return TaskGraphLogsApiFp(this.configuration).listTaskGraphLogs(namespace, createdBy, search, startTime, endTime, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update information about a single task graph execution. 
     * @param {string} namespace The namespace that owns this task graph log.
     * @param {string} id The UUID of the task graph log entry.
     * @param {TaskGraphLog} log Updates to make to the task graph log. The only manual update that a client should need to make to a task graph log is to update its completion status to &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskGraphLogsApi
     */
    public updateTaskGraphLog(namespace: string, id: string, log: TaskGraphLog, options?: any) {
        return TaskGraphLogsApiFp(this.configuration).updateTaskGraphLog(namespace, id, log, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL: async (namespace: string, sql: SQLParameters, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('runSQL', 'namespace', namespace)
            // verify required parameter 'sql' is not null or undefined
            assertParamExists('runSQL', 'sql', sql)
            const localVarPath = `/sql/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(sql, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch an array task
         * @param {string} id task ID to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taskIdGet', 'id', id)
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve results of an array task
         * @param {string} id task ID to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdResultGet: async (id: string, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('taskIdResultGet', 'id', id)
            const localVarPath = `/task/{id}/result`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet: async (namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, excludeType?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, status?: string, search?: string, orderby?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (array !== undefined) {
                localVarQueryParameter['array'] = array;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (excludeType) {
                localVarQueryParameter['exclude_type'] = excludeType.join(COLLECTION_FORMATS.csv);
            }

            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }

            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runSQL(namespace, sql, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch an array task
         * @param {string} id task ID to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskIdGet(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve results of an array task
         * @param {string} id task ID to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskIdResultGet(id: string, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskIdResultGet(id, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksGet(namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, excludeType?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, status?: string, search?: string, orderby?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayTaskData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.runSQL(namespace, sql, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch an array task
         * @param {string} id task ID to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet(id: string, options?: any): AxiosPromise<ArrayTask> {
            return localVarFp.taskIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve results of an array task
         * @param {string} id task ID to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdResultGet(id: string, acceptEncoding?: string, options?: any): AxiosPromise<string> {
            return localVarFp.taskIdResultGet(id, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, excludeType?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, status?: string, search?: string, orderby?: string, options?: any): AxiosPromise<ArrayTaskData> {
            return localVarFp.tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public runSQL(namespace: string, sql: SQLParameters, acceptEncoding?: string, options?: any) {
        return TasksApiFp(this.configuration).runSQL(namespace, sql, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch an array task
     * @param {string} id task ID to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public taskIdGet(id: string, options?: any) {
        return TasksApiFp(this.configuration).taskIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve results of an array task
     * @param {string} id task ID to retrieve stored results
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public taskIdResultGet(id: string, acceptEncoding?: string, options?: any) {
        return TasksApiFp(this.configuration).taskIdResultGet(id, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of all array tasks a user has access to
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
     * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
     * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
     * @param {string} [status] Filter to only return these statuses
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include start_time, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksGet(namespace?: string, createdBy?: string, array?: string, start?: number, end?: number, page?: number, perPage?: number, type?: string, excludeType?: Array<string>, fileType?: Array<string>, excludeFileType?: Array<string>, status?: string, search?: string, orderby?: string, options?: any) {
        return TasksApiFp(this.configuration).tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UdfApi - axios parameter creator
 * @export
 */
export const UdfApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete a registered UDF -- this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFInfo: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteUDFInfo', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteUDFInfo', 'name', name)
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getUDFInfo', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getUDFInfo', 'name', name)
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all sharing details of the UDF
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getUDFInfoSharingPolicies', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getUDFInfoSharingPolicies', 'name', name)
            const localVarPath = `/udf/{namespace}/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo: async (namespace: string, name: string, udf: UDFInfoUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('registerUDFInfo', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('registerUDFInfo', 'name', name)
            // verify required parameter 'udf' is not null or undefined
            assertParamExists('registerUDFInfo', 'udf', udf)
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(udf, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo: async (namespace: string, name: string, udfSharing: UDFSharing, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('shareUDFInfo', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('shareUDFInfo', 'name', name)
            // verify required parameter 'udfSharing' is not null or undefined
            assertParamExists('shareUDFInfo', 'udfSharing', udfSharing)
            const localVarPath = `/udf/{namespace}/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(udfSharing, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF: async (namespace: string, udf: GenericUDF, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('submitGenericUDF', 'namespace', namespace)
            // verify required parameter 'udf' is not null or undefined
            assertParamExists('submitGenericUDF', 'udf', udf)
            const localVarPath = `/udfs/generic/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(udf, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiArrayUDF: async (namespace: string, udf: MultiArrayUDF, acceptEncoding?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('submitMultiArrayUDF', 'namespace', namespace)
            // verify required parameter 'udf' is not null or undefined
            assertParamExists('submitMultiArrayUDF', 'udf', udf)
            const localVarPath = `/udfs/arrays/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(udf, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF: async (namespace: string, array: string, udf: MultiArrayUDF, xPayer?: string, acceptEncoding?: string, v2?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('submitUDF', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('submitUDF', 'array', array)
            // verify required parameter 'udf' is not null or undefined
            assertParamExists('submitUDF', 'udf', udf)
            const localVarPath = `/arrays/{namespace}/{array}/udf/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (v2 !== undefined) {
                localVarQueryParameter['v2'] = v2;
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }

            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(udf, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        udfNamespaceArrayEndTimestampsGet: async (namespace: string, array: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('udfNamespaceArrayEndTimestampsGet', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('udfNamespaceArrayEndTimestampsGet', 'array', array)
            const localVarPath = `/udf/{namespace}/{array}/end_timestamps`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update an existing registered UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo: async (namespace: string, name: string, udf: UDFInfoUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateUDFInfo', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateUDFInfo', 'name', name)
            // verify required parameter 'udf' is not null or undefined
            assertParamExists('updateUDFInfo', 'udf', udf)
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(udf, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UdfApi - functional programming interface
 * @export
 */
export const UdfApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UdfApiAxiosParamCreator(configuration)
    return {
        /**
         * delete a registered UDF -- this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUDFInfo(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUDFInfo(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUDFInfo(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UDFInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUDFInfo(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all sharing details of the UDF
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUDFInfoSharingPolicies(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UDFSharing>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUDFInfoSharingPolicies(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUDFInfo(namespace, name, udf, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareUDFInfo(namespace: string, name: string, udfSharing: UDFSharing, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareUDFInfo(namespace, name, udfSharing, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitGenericUDF(namespace: string, udf: GenericUDF, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitGenericUDF(namespace, udf, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitMultiArrayUDF(namespace: string, udf: MultiArrayUDF, acceptEncoding?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitMultiArrayUDF(namespace, udf, acceptEncoding, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitUDF(namespace: string, array: string, udf: MultiArrayUDF, xPayer?: string, acceptEncoding?: string, v2?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async udfNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayEndTimestampData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update an existing registered UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUDFInfo(namespace, name, udf, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UdfApi - factory interface
 * @export
 */
export const UdfApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UdfApiFp(configuration)
    return {
        /**
         * delete a registered UDF -- this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFInfo(namespace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUDFInfo(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo(namespace: string, name: string, options?: any): AxiosPromise<UDFInfo> {
            return localVarFp.getUDFInfo(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sharing details of the UDF
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies(namespace: string, name: string, options?: any): AxiosPromise<Array<UDFSharing>> {
            return localVarFp.getUDFInfoSharingPolicies(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.registerUDFInfo(namespace, name, udf, options).then((request) => request(axios, basePath));
        },
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo(namespace: string, name: string, udfSharing: UDFSharing, options?: any): AxiosPromise<void> {
            return localVarFp.shareUDFInfo(namespace, name, udfSharing, options).then((request) => request(axios, basePath));
        },
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF(namespace: string, udf: GenericUDF, acceptEncoding?: string, options?: any): AxiosPromise<any> {
            return localVarFp.submitGenericUDF(namespace, udf, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiArrayUDF(namespace: string, udf: MultiArrayUDF, acceptEncoding?: string, options?: any): AxiosPromise<any> {
            return localVarFp.submitMultiArrayUDF(namespace, udf, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf UDF to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF(namespace: string, array: string, udf: MultiArrayUDF, xPayer?: string, acceptEncoding?: string, v2?: string, options?: any): AxiosPromise<any> {
            return localVarFp.submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options).then((request) => request(axios, basePath));
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        udfNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any): AxiosPromise<ArrayEndTimestampData> {
            return localVarFp.udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * update an existing registered UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register UDF under
         * @param {UDFInfoUpdate} udf UDF to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any): AxiosPromise<void> {
            return localVarFp.updateUDFInfo(namespace, name, udf, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UdfApi - object-oriented interface
 * @export
 * @class UdfApi
 * @extends {BaseAPI}
 */
export class UdfApi extends BaseAPI {
    /**
     * delete a registered UDF -- this will remove all sharing and can not be undone
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public deleteUDFInfo(namespace: string, name: string, options?: any) {
        return UdfApiFp(this.configuration).deleteUDFInfo(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get a specific UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public getUDFInfo(namespace: string, name: string, options?: any) {
        return UdfApiFp(this.configuration).getUDFInfo(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all sharing details of the UDF
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public getUDFInfoSharingPolicies(namespace: string, name: string, options?: any) {
        return UdfApiFp(this.configuration).getUDFInfoSharingPolicies(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * register a UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {UDFInfoUpdate} udf UDF to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public registerUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any) {
        return UdfApiFp(this.configuration).registerUDFInfo(namespace, name, udf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Share a UDF with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it\&#39;s likely the UDF will not be shared with the namespace at all.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public shareUDFInfo(namespace: string, name: string, udfSharing: UDFSharing, options?: any) {
        return UdfApiFp(this.configuration).shareUDFInfo(namespace, name, udfSharing, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * submit a generic UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {GenericUDF} udf UDF to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public submitGenericUDF(namespace: string, udf: GenericUDF, acceptEncoding?: string, options?: any) {
        return UdfApiFp(this.configuration).submitGenericUDF(namespace, udf, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * submit a multi-array UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {MultiArrayUDF} udf UDF to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public submitMultiArrayUDF(namespace: string, udf: MultiArrayUDF, acceptEncoding?: string, options?: any) {
        return UdfApiFp(this.configuration).submitMultiArrayUDF(namespace, udf, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * send a UDF to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {MultiArrayUDF} udf UDF to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {string} [acceptEncoding] Encoding to use
     * @param {string} [v2] flag to indicate if v2 array UDFs should be used, currently in beta testing. Setting any value will enable v2 array UDFs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public submitUDF(namespace: string, array: string, udf: MultiArrayUDF, xPayer?: string, acceptEncoding?: string, v2?: string, options?: any) {
        return UdfApiFp(this.configuration).submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public udfNamespaceArrayEndTimestampsGet(namespace: string, array: string, page?: number, perPage?: number, options?: any) {
        return UdfApiFp(this.configuration).udfNamespaceArrayEndTimestampsGet(namespace, array, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update an existing registered UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register UDF under
     * @param {UDFInfoUpdate} udf UDF to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    public updateUDFInfo(namespace: string, name: string, udf: UDFInfoUpdate, options?: any) {
        return UdfApiFp(this.configuration).updateUDFInfo(namespace, name, udf, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials: async (namespace: string, awsAccessCredentials: AWSAccessCredentials, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('addAWSAccessCredentials', 'namespace', namespace)
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            assertParamExists('addAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials)
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization: async (organization: string, user: OrganizationUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('addUserToOrganization', 'organization', organization)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('addUserToOrganization', 'user', user)
            const localVarPath = `/organizations/{organization}/user`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials: async (namespace: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('checkAWSAccessCredentials', 'namespace', namespace)
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('checkAWSAccessCredentialsByName', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('checkAWSAccessCredentialsByName', 'name', name)
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/confirm_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUser', 'user', user)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteAWSAccessCredentials', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteAWSAccessCredentials', 'name', name)
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteUser', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization: async (organization: string, username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('deleteUserFromOrganization', 'organization', organization)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteUserFromOrganization', 'username', username)
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser: async (organization: string, username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('getOrganizationUser', 'organization', organization)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getOrganizationUser', 'username', username)
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (rememberMe?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (rememberMe !== undefined) {
                localVarQueryParameter['remember_me'] = rememberMe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * retrieves available token scopes for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenScopes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens/scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername: async (username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserWithUsername', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken: async (tokenRequest?: TokenRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * reset user password
         * @param {InlineObject} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword: async (user: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('resetUserPassword', 'user', user)
            const localVarPath = `/user/password_reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('revokeToken', 'token', token)
            const localVarPath = `/tokens/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensSessionGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials: async (namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateAWSAccessCredentials', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateAWSAccessCredentials', 'name', name)
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            assertParamExists('updateAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials)
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a user
         * @param {string} username username or ID
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (username: string, user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateUser', 'username', username)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization: async (organization: string, username: string, user: OrganizationUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('updateUserInOrganization', 'organization', organization)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateUserInOrganization', 'username', username)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUserInOrganization', 'user', user)
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAWSAccessCredentials(namespace, awsAccessCredentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToOrganization(organization: string, user: OrganizationUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToOrganization(organization, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkAWSAccessCredentials(namespace: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AWSAccessCredentials>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkAWSAccessCredentials(namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AWSAccessCredentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkAWSAccessCredentialsByName(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmEmail(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmEmail(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAWSAccessCredentials(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAWSAccessCredentials(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserFromOrganization(organization: string, username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserFromOrganization(organization, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationUser(organization: string, username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationUser(organization, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(rememberMe?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(rememberMe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * retrieves available token scopes for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenScopes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenScope>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenScopes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWithUsername(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWithUsername(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestToken(tokenRequest?: TokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestToken(tokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * reset user password
         * @param {InlineObject} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetUserPassword(user: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetUserPassword(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeToken(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeToken(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Token>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensSessionGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Token>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensSessionGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update a user
         * @param {string} username username or ID
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(username: string, user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(username, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserInOrganization(organization, username, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void> {
            return localVarFp.addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization: string, user: OrganizationUser, options?: any): AxiosPromise<void> {
            return localVarFp.addUserToOrganization(organization, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace: string, options?: any): AxiosPromise<Array<AWSAccessCredentials>> {
            return localVarFp.checkAWSAccessCredentials(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any): AxiosPromise<AWSAccessCredentials> {
            return localVarFp.checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail(options?: any): AxiosPromise<void> {
            return localVarFp.confirmEmail(options).then((request) => request(axios, basePath));
        },
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: User, options?: any): AxiosPromise<void> {
            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAWSAccessCredentials(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization: string, username: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserFromOrganization(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization: string, username: string, options?: any): AxiosPromise<OrganizationUser> {
            return localVarFp.getOrganizationUser(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(rememberMe?: string, options?: any): AxiosPromise<Token> {
            return localVarFp.getSession(rememberMe, options).then((request) => request(axios, basePath));
        },
        /**
         * retrieves available token scopes for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenScopes(options?: any): AxiosPromise<Array<TokenScope>> {
            return localVarFp.getTokenScopes(options).then((request) => request(axios, basePath));
        },
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): AxiosPromise<User> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * get a user
         * @param {string} username username or ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername(username: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUserWithUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken(tokenRequest?: TokenRequest, options?: any): AxiosPromise<Token> {
            return localVarFp.requestToken(tokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * reset user password
         * @param {InlineObject} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(user: InlineObject, options?: any): AxiosPromise<void> {
            return localVarFp.resetUserPassword(user, options).then((request) => request(axios, basePath));
        },
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(token: string, options?: any): AxiosPromise<void> {
            return localVarFp.revokeToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options?: any): AxiosPromise<Array<Token>> {
            return localVarFp.tokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensSessionGet(options?: any): AxiosPromise<Array<Token>> {
            return localVarFp.tokensSessionGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any): AxiosPromise<void> {
            return localVarFp.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user
         * @param {string} username username or ID
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username: string, user: User, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(username, user, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserInOrganization(organization, username, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addAWSAccessCredentials(namespace: string, awsAccessCredentials: AWSAccessCredentials, options?: any) {
        return UserApiFp(this.configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUserToOrganization(organization: string, user: OrganizationUser, options?: any) {
        return UserApiFp(this.configuration).addUserToOrganization(organization, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public checkAWSAccessCredentials(namespace: string, options?: any) {
        return UserApiFp(this.configuration).checkAWSAccessCredentials(namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public checkAWSAccessCredentialsByName(namespace: string, name: string, options?: any) {
        return UserApiFp(this.configuration).checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * confirm user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public confirmEmail(options?: any) {
        return UserApiFp(this.configuration).confirmEmail(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(user: User, options?: any) {
        return UserApiFp(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteAWSAccessCredentials(namespace: string, name: string, options?: any) {
        return UserApiFp(this.configuration).deleteAWSAccessCredentials(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a user
     * @param {string} username username or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(username: string, options?: any) {
        return UserApiFp(this.configuration).deleteUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUserFromOrganization(organization: string, username: string, options?: any) {
        return UserApiFp(this.configuration).deleteUserFromOrganization(organization, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getOrganizationUser(organization: string, username: string, options?: any) {
        return UserApiFp(this.configuration).getOrganizationUser(organization, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get session token for user
     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getSession(rememberMe?: string, options?: any) {
        return UserApiFp(this.configuration).getSession(rememberMe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * retrieves available token scopes for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getTokenScopes(options?: any) {
        return UserApiFp(this.configuration).getTokenScopes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(options?: any) {
        return UserApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get a user
     * @param {string} username username or ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserWithUsername(username: string, options?: any) {
        return UserApiFp(this.configuration).getUserWithUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
     * @param {TokenRequest} [tokenRequest] token request object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public requestToken(tokenRequest?: TokenRequest, options?: any) {
        return UserApiFp(this.configuration).requestToken(tokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * reset user password
     * @param {InlineObject} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public resetUserPassword(user: InlineObject, options?: any) {
        return UserApiFp(this.configuration).resetUserPassword(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * revoke an authorization token
     * @param {string} token token name or token itself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public revokeToken(token: string, options?: any) {
        return UserApiFp(this.configuration).revokeToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of user tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public tokensGet(options?: any) {
        return UserApiFp(this.configuration).tokensGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of user session tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public tokensSessionGet(options?: any) {
        return UserApiFp(this.configuration).tokensSessionGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateAWSAccessCredentials(namespace: string, name: string, awsAccessCredentials: AWSAccessCredentials, options?: any) {
        return UserApiFp(this.configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a user
     * @param {string} username username or ID
     * @param {User} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(username: string, user: User, options?: any) {
        return UserApiFp(this.configuration).updateUser(username, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserInOrganization(organization: string, username: string, user: OrganizationUser, options?: any) {
        return UserApiFp(this.configuration).updateUserInOrganization(organization, username, user, options).then((request) => request(this.axios, this.basePath));
    }
}


