/* tslint:disable */
/* eslint-disable */
/**
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Credential information to access Amazon Web Services
 * @export
 * @interface AWSCredential
 */
export interface AWSCredential {
    /**
     * The ID of the access key
     * @type {string}
     * @memberof AWSCredential
     */
    access_key_id?: string;
    /**
     * The access key\'s secret. Never returned in responses.
     * @type {string}
     * @memberof AWSCredential
     */
    secret_access_key?: string;
    /**
     * The endpoint used for this credential
     * @type {string}
     * @memberof AWSCredential
     */
    endpoint?: string | null;
}
/**
 * Role information to access Amazon Web Services
 * @export
 * @interface AWSRole
 */
export interface AWSRole {
    /**
     * The role arn used to access
     * @type {string}
     * @memberof AWSRole
     */
    role_arn?: string;
    /**
     * The role external id used to access
     * @type {string}
     * @memberof AWSRole
     */
    external_id?: string;
    /**
     * The endpoint used for this role
     * @type {string}
     * @memberof AWSRole
     */
    endpoint?: string | null;
}
/**
 * A union type which may contain a credential to access any one cloud provider.
 * @export
 * @interface AccessCredential
 */
export interface AccessCredential {
    /**
     * A user-specified name for the key
     * @type {string}
     * @memberof AccessCredential
     */
    name?: string;
    /**
     * 
     * @type {CloudProvider}
     * @memberof AccessCredential
     */
    provider?: CloudProvider;
    /**
     * True if this is the namespace\'s default credential to be used when connecting to the given cloud provider. There can be at most one default for each unique provider.
     * @type {boolean}
     * @memberof AccessCredential
     */
    provider_default?: boolean | null;
    /**
     * Time when the credential was created (rfc3339)
     * @type {string}
     * @memberof AccessCredential
     */
    created_at?: string;
    /**
     * Time when the credential was last updated (rfc3339)
     * @type {string}
     * @memberof AccessCredential
     */
    updated_at?: string;
    /**
     * 
     * @type {AccessCredentialCredential}
     * @memberof AccessCredential
     */
    credential?: AccessCredentialCredential;
    /**
     * 
     * @type {AccessCredentialRole}
     * @memberof AccessCredential
     */
    role?: AccessCredentialRole;
}
/**
 * The credential information itself. Exactly one sub-field may be set. The names match those in the CloudProvider enum.
 * @export
 * @interface AccessCredentialCredential
 */
export interface AccessCredentialCredential {
    /**
     * 
     * @type {AWSCredential}
     * @memberof AccessCredentialCredential
     */
    aws?: AWSCredential | null;
    /**
     * 
     * @type {AzureCredential}
     * @memberof AccessCredentialCredential
     */
    azure?: AzureCredential | null;
}
/**
 * The role information itself. Exactly one sub-field may be set. The names match those in the CloudProvider enum.
 * @export
 * @interface AccessCredentialRole
 */
export interface AccessCredentialRole {
    /**
     * 
     * @type {AWSRole}
     * @memberof AccessCredentialRole
     */
    aws?: AWSRole | null;
}
/**
 * Object including credentials and pagination metadata
 * @export
 * @interface AccessCredentialsData
 */
export interface AccessCredentialsData {
    /**
     * List of credentials
     * @type {Array<AccessCredential>}
     * @memberof AccessCredentialsData
     */
    credentials?: Array<AccessCredential>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof AccessCredentialsData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * Type of activity logged
 * @export
 * @enum {string}
 */
export enum ActivityEventType {
    ReadSchema = 'read_schema',
    MaxBufferSizes = 'max_buffer_sizes',
    NonEmptyDomain = 'non_empty_domain',
    QueryRead = 'query_read',
    QueryWrite = 'query_write',
    Create = 'create',
    Delete = 'delete',
    Register = 'register',
    Deregister = 'deregister',
    Udf = 'udf',
    ArrayMetadataGet = 'array_metadata_get',
    ArrayMetadataUpdate = 'array_metadata_update',
    EstimatedResultSizes = 'estimated_result_sizes',
    Update = 'update',
    Info = 'info',
    Run = 'run'
}

/**
 * Actvity of an Array
 * @export
 * @interface ArrayActivityLog
 */
export interface ArrayActivityLog {
    /**
     * time event took place (RFC3339)
     * @type {string}
     * @memberof ArrayActivityLog
     */
    event_at?: string;
    /**
     * 
     * @type {ActivityEventType}
     * @memberof ArrayActivityLog
     */
    action?: ActivityEventType;
    /**
     * User who performed action
     * @type {string}
     * @memberof ArrayActivityLog
     */
    username?: string;
    /**
     * Bytes sent to client
     * @type {number}
     * @memberof ArrayActivityLog
     */
    bytes_sent?: number;
    /**
     * Bytes recieved from client
     * @type {number}
     * @memberof ArrayActivityLog
     */
    bytes_received?: number;
    /**
     * uuid of associated array task
     * @type {string}
     * @memberof ArrayActivityLog
     */
    array_task_id?: string;
    /**
     * id of the activity
     * @type {string}
     * @memberof ArrayActivityLog
     */
    id?: string;
    /**
     * ranges for query
     * @type {string}
     * @memberof ArrayActivityLog
     */
    query_ranges?: string;
    /**
     * stats for query
     * @type {string}
     * @memberof ArrayActivityLog
     */
    query_stats?: string;
}
/**
 * Object including array tasks and metadata
 * @export
 * @interface ArrayActivityLogData
 */
export interface ArrayActivityLogData {
    /**
     * Array ArrayActivityLog
     * @type {Array<ArrayActivityLog>}
     * @memberof ArrayActivityLogData
     */
    activitylogs?: Array<ArrayActivityLog>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof ArrayActivityLogData
     */
    pagination_metadata?: PaginationMetadata;
}
/**
 * Represents an open array
 * @export
 * @interface ArrayData
 */
export interface ArrayData {
    /**
     * 
     * @type {Querytype}
     * @memberof ArrayData
     */
    queryType: Querytype;
    /**
     * Array uri
     * @type {string}
     * @memberof ArrayData
     */
    uri: string;
    /**
     * Ending timestamp (epoch milliseconds) array is opened at
     * @type {number}
     * @memberof ArrayData
     */
    endTimestamp?: number;
    /**
     * Starting timestamp (epoch milliseconds) array is opened at
     * @type {number}
     * @memberof ArrayData
     */
    startTimestamp?: number;
    /**
     * 
     * @type {ArraySchema}
     * @memberof ArrayData
     */
    arraySchemaLatest?: ArraySchema;
    /**
     * 
     * @type {ArrayMetadata}
     * @memberof ArrayData
     */
    arrayMetadata?: ArrayMetadata;
    /**
     * 
     * @type {NonEmptyDomainList}
     * @memberof ArrayData
     */
    nonEmptyDomain?: NonEmptyDomainList;
}
/**
 * Model for opening an array v2
 * @export
 * @interface ArrayFetch
 */
export interface ArrayFetch {
    /**
     * 
     * @type {TileDBConfig}
     * @memberof ArrayFetch
     */
    config?: TileDBConfig;
    /**
     * 
     * @type {Querytype}
     * @memberof ArrayFetch
     */
    queryType?: Querytype;
}
/**
 * user\'s TileDB array metadata
 * @export
 * @interface ArrayMetadata
 */
export interface ArrayMetadata {
    /**
     * List of metadata entries
     * @type {Array<ArrayMetadataEntry>}
     * @memberof ArrayMetadata
     */
    entries?: Array<ArrayMetadataEntry>;
}
/**
 * key/value pair representing an array metadata map entry
 * @export
 * @interface ArrayMetadataEntry
 */
export interface ArrayMetadataEntry {
    /**
     * 
     * @type {string}
     * @memberof ArrayMetadataEntry
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof ArrayMetadataEntry
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof ArrayMetadataEntry
     */
    valueNum?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ArrayMetadataEntry
     */
    value?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof ArrayMetadataEntry
     */
    del?: boolean;
}
/**
 * ArraySchema during creation or retrieval
 * @export
 * @interface ArraySchema
 */
export interface ArraySchema {
    /**
     * URI of schema
     * @type {string}
     * @memberof ArraySchema
     */
    uri?: string;
    /**
     * name of schema
     * @type {string}
     * @memberof ArraySchema
     */
    name?: string;
    /**
     * file format version
     * @type {Array<number>}
     * @memberof ArraySchema
     */
    version: Array<number>;
    /**
     * 
     * @type {ArrayType}
     * @memberof ArraySchema
     */
    arrayType: ArrayType;
    /**
     * 
     * @type {Layout}
     * @memberof ArraySchema
     */
    tileOrder: Layout;
    /**
     * 
     * @type {Layout}
     * @memberof ArraySchema
     */
    cellOrder: Layout;
    /**
     * Capacity of array
     * @type {number}
     * @memberof ArraySchema
     */
    capacity: number;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    coordsFilterPipeline: FilterPipeline;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    offsetFilterPipeline: FilterPipeline;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof ArraySchema
     */
    validityFilterPipeline?: FilterPipeline;
    /**
     * 
     * @type {Domain}
     * @memberof ArraySchema
     */
    domain: Domain;
    /**
     * Attributes of array
     * @type {Array<Attribute>}
     * @memberof ArraySchema
     */
    attributes: Array<Attribute>;
    /**
     * True if the array allows coordinate duplicates. Applicable only to sparse arrays.
     * @type {boolean}
     * @memberof ArraySchema
     */
    allowsDuplicates?: boolean;
    /**
     * The list of sizes per range
     * @type {Array<number>}
     * @memberof ArraySchema
     */
    timestampRange?: Array<number>;
}
/**
 * TileDB array type
 * @export
 * @enum {string}
 */
export enum ArrayType {
    Dense = 'dense',
    Sparse = 'sparse'
}

/**
 * Attribute of array
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * Attribute name
     * @type {string}
     * @memberof Attribute
     */
    name: string;
    /**
     * 
     * @type {Datatype}
     * @memberof Attribute
     */
    type: Datatype;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof Attribute
     */
    filterPipeline: FilterPipeline;
    /**
     * Attribute number of values per cell
     * @type {number}
     * @memberof Attribute
     */
    cellValNum: number;
    /**
     * Is attribute nullable
     * @type {boolean}
     * @memberof Attribute
     */
    nullable?: boolean;
    /**
     * Default validity fill value for nullable attributes
     * @type {boolean}
     * @memberof Attribute
     */
    fillValueValidity?: boolean;
    /**
     * The default fill value
     * @type {Array<number>}
     * @memberof Attribute
     */
    fillValue?: Array<number>;
}
/**
 * Represents an attribute buffer header information
 * @export
 * @interface AttributeBufferHeader
 */
export interface AttributeBufferHeader {
    /**
     * Attribute name
     * @type {string}
     * @memberof AttributeBufferHeader
     */
    name: string;
    /**
     * Number of bytes in the fixed-length attribute data buffer (offsets for var-len attributes)
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    fixedLenBufferSizeInBytes: number;
    /**
     * Number of bytes in the var-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    varLenBufferSizeInBytes: number;
    /**
     * Number of bytes for validity in case attribute is nullable
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    validityLenBufferSizeInBytes?: number;
    /**
     * Original user set number of bytes in the fixed-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    originalFixedLenBufferSizeInBytes?: number;
    /**
     * Original user set number of bytes in the var-length attribute data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    originalVarLenBufferSizeInBytes?: number;
    /**
     * Original user set number of bytes in the validity data buffer
     * @type {number}
     * @memberof AttributeBufferHeader
     */
    originalValidityLenBufferSizeInBytes?: number;
}
/**
 * object representing buffer size of an attribute
 * @export
 * @interface AttributeBufferSize
 */
export interface AttributeBufferSize {
    /**
     * name of attribute
     * @type {string}
     * @memberof AttributeBufferSize
     */
    attribute: string;
    /**
     * buffer size (in bytes) of offset buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    offsetBytes: number;
    /**
     * buffer size (in bytes) of data buffer
     * @type {number}
     * @memberof AttributeBufferSize
     */
    dataBytes: number;
}
/**
 * Credential information to access Microsoft Azure. Each supported property is the snake_case version of its name in an Azure Storage connection string.
 * @export
 * @interface AzureCredential
 */
export interface AzureCredential {
    /**
     * The name of the Azure account to access
     * @type {string}
     * @memberof AzureCredential
     */
    account_name?: string;
    /**
     * The secret key. Never returned in responses.
     * @type {string}
     * @memberof AzureCredential
     */
    account_key?: string;
}
/**
 * A service where data is stored or computations take place.
 * @export
 * @enum {string}
 */
export enum CloudProvider {
    Aws = 'AWS',
    Azure = 'AZURE'
}

/**
 * TileDB data type
 * @export
 * @enum {string}
 */
export enum Datatype {
    Int32 = 'INT32',
    Int64 = 'INT64',
    Float32 = 'FLOAT32',
    Float64 = 'FLOAT64',
    Char = 'CHAR',
    Int8 = 'INT8',
    Uint8 = 'UINT8',
    Int16 = 'INT16',
    Uint16 = 'UINT16',
    Uint32 = 'UINT32',
    Uint64 = 'UINT64',
    StringAscii = 'STRING_ASCII',
    StringUtf8 = 'STRING_UTF8',
    StringUtf16 = 'STRING_UTF16',
    StringUtf32 = 'STRING_UTF32',
    StringUcs2 = 'STRING_UCS2',
    StringUcs4 = 'STRING_UCS4',
    DatetimeYear = 'DATETIME_YEAR',
    DatetimeMonth = 'DATETIME_MONTH',
    DatetimeWeek = 'DATETIME_WEEK',
    DatetimeDay = 'DATETIME_DAY',
    DatetimeHr = 'DATETIME_HR',
    DatetimeMin = 'DATETIME_MIN',
    DatetimeSec = 'DATETIME_SEC',
    DatetimeMs = 'DATETIME_MS',
    DatetimeUs = 'DATETIME_US',
    DatetimeNs = 'DATETIME_NS',
    DatetimePs = 'DATETIME_PS',
    DatetimeFs = 'DATETIME_FS',
    DatetimeAs = 'DATETIME_AS',
    Any = 'ANY'
}

/**
 * Dimension of array
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * Dimension name
     * @type {string}
     * @memberof Dimension
     */
    name?: string;
    /**
     * 
     * @type {Datatype}
     * @memberof Dimension
     */
    type: Datatype;
    /**
     * 
     * @type {DomainArray}
     * @memberof Dimension
     */
    domain: DomainArray;
    /**
     * Is tile extent null
     * @type {boolean}
     * @memberof Dimension
     */
    nullTileExtent: boolean;
    /**
     * 
     * @type {DimensionTileExtent}
     * @memberof Dimension
     */
    tileExtent?: DimensionTileExtent;
    /**
     * 
     * @type {FilterPipeline}
     * @memberof Dimension
     */
    filterPipeline?: FilterPipeline;
}
/**
 * Extent of tile
 * @export
 * @interface DimensionTileExtent
 */
export interface DimensionTileExtent {
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int8?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint8?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int16?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint16?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    int64?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    uint64?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    float32?: number;
    /**
     * 
     * @type {number}
     * @memberof DimensionTileExtent
     */
    float64?: number;
}
/**
 * Domain of array
 * @export
 * @interface Domain
 */
export interface Domain {
    /**
     * 
     * @type {Datatype}
     * @memberof Domain
     */
    type: Datatype;
    /**
     * 
     * @type {Layout}
     * @memberof Domain
     */
    tileOrder: Layout;
    /**
     * 
     * @type {Layout}
     * @memberof Domain
     */
    cellOrder: Layout;
    /**
     * Array of dimensions
     * @type {Array<Dimension>}
     * @memberof Domain
     */
    dimensions: Array<Dimension>;
}
/**
 * Domain object for an array of each type
 * @export
 * @interface DomainArray
 */
export interface DomainArray {
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int8?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint8?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int16?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint16?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int32?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint32?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    int64?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    uint64?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float32?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DomainArray
     */
    float64?: Array<number>;
}
/**
 * Uploaded file name and information
 * @export
 * @interface FileUploaded
 */
export interface FileUploaded {
    /**
     * output location of the TileDB File
     * @type {string}
     * @memberof FileUploaded
     */
    output_uri?: string;
    /**
     * name of the file uploaded
     * @type {string}
     * @memberof FileUploaded
     */
    file_name?: string;
    /**
     * unique ID of the uploaded file
     * @type {string}
     * @memberof FileUploaded
     */
    id: string;
}
/**
 * Filter
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {FilterType}
     * @memberof Filter
     */
    type: FilterType;
    /**
     * 
     * @type {FilterData}
     * @memberof Filter
     */
    data?: FilterData;
}
/**
 * Filter data
 * @export
 * @interface FilterData
 */
export interface FilterData {
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int8?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint8?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int16?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint16?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int32?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint32?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    int64?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    uint64?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    float32?: number;
    /**
     * 
     * @type {number}
     * @memberof FilterData
     */
    float64?: number;
}
/**
 * One or more filters to apply
 * @export
 * @interface FilterPipeline
 */
export interface FilterPipeline {
    /**
     * 
     * @type {Array<Filter>}
     * @memberof FilterPipeline
     */
    filters?: Array<Filter>;
}
/**
 * TileDB filter types
 * @export
 * @enum {string}
 */
export enum FilterType {
    None = 'FILTER_NONE',
    Gzip = 'FILTER_GZIP',
    Zstd = 'FILTER_ZSTD',
    Lz4 = 'FILTER_LZ4',
    Rle = 'FILTER_RLE',
    Bzip2 = 'FILTER_BZIP2',
    DoubleDelta = 'FILTER_DOUBLE_DELTA',
    BitWidthReduction = 'FILTER_BIT_WIDTH_REDUCTION',
    Bitshuffle = 'FILTER_BITSHUFFLE',
    Byteshuffle = 'FILTER_BYTESHUFFLE',
    PositiveDelta = 'FILTER_POSITIVE_DELTA'
}

/**
 * Updates the contents group
 * @export
 * @interface GroupContentsChangesRequest
 */
export interface GroupContentsChangesRequest {
    /**
     * 
     * @type {TileDBConfig}
     * @memberof GroupContentsChangesRequest
     */
    config?: TileDBConfig;
    /**
     * 
     * @type {GroupContentsChangesRequestGroupChanges}
     * @memberof GroupContentsChangesRequest
     */
    group_changes?: GroupContentsChangesRequestGroupChanges;
}
/**
 * 
 * @export
 * @interface GroupContentsChangesRequestGroupChanges
 */
export interface GroupContentsChangesRequestGroupChanges {
    /**
     * optional series of members to remove
     * @type {Array<string>}
     * @memberof GroupContentsChangesRequestGroupChanges
     */
    members_to_remove?: Array<string>;
    /**
     * optional series of members to add
     * @type {Array<GroupMember>}
     * @memberof GroupContentsChangesRequestGroupChanges
     */
    members_to_add?: Array<GroupMember>;
}
/**
 * Request the contents of a group
 * @export
 * @interface GroupContentsRetrievalRequest
 */
export interface GroupContentsRetrievalRequest {
    /**
     * 
     * @type {TileDBConfig}
     * @memberof GroupContentsRetrievalRequest
     */
    config?: TileDBConfig;
}
/**
 * Object including a page of members of a group and pagination metadata
 * @export
 * @interface GroupContentsRetrievalResponse
 */
export interface GroupContentsRetrievalResponse {
    /**
     * Groups members
     * @type {Array<GroupMember>}
     * @memberof GroupContentsRetrievalResponse
     */
    members?: Array<GroupMember>;
    /**
     * 
     * @type {Metadata}
     * @memberof GroupContentsRetrievalResponse
     */
    metadata?: Metadata;
}
/**
 * information for creating a new group with the passed configuration
 * @export
 * @interface GroupCreationRequest
 */
export interface GroupCreationRequest {
    /**
     * 
     * @type {TileDBConfig}
     * @memberof GroupCreationRequest
     */
    config?: TileDBConfig;
    /**
     * 
     * @type {GroupCreationRequestGroupDetails}
     * @memberof GroupCreationRequest
     */
    group_details: GroupCreationRequestGroupDetails;
}
/**
 * Initial attributes for the creation of a group.
 * @export
 * @interface GroupCreationRequestGroupDetails
 */
export interface GroupCreationRequestGroupDetails {
    /**
     * A human readable description of the contents of the group.
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    description?: string;
    /**
     * The name of the group. If must be unique within the group.
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    name?: string;
    /**
     * uri of group.
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    uri?: string;
    /**
     * logo (base64 encoded) for the group. Optional
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    logo?: string;
    /**
     * optional tags for groups.
     * @type {Array<string>}
     * @memberof GroupCreationRequestGroupDetails
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom.
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof GroupCreationRequestGroupDetails
     */
    license_text?: string;
}
/**
 * A groups member, array or another groups, to add or remove from an existing group.
 * @export
 * @interface GroupMember
 */
export interface GroupMember {
    /**
     * The name of the member
     * @type {string}
     * @memberof GroupMember
     */
    name?: string;
    /**
     * The uri of the member
     * @type {string}
     * @memberof GroupMember
     */
    uri?: string;
    /**
     * 
     * @type {GroupMemberType}
     * @memberof GroupMember
     */
    type?: GroupMemberType;
}
/**
 * Specific file types of group members
 * @export
 * @enum {string}
 */
export enum GroupMemberAssetType {
    Group = 'group',
    Array = 'array',
    Notebook = 'notebook',
    Dashboard = 'dashboard',
    UserDefinedFunction = 'user_defined_function',
    MlModel = 'ml_model',
    File = 'file'
}

/**
 * File types that can be included in groups
 * @export
 * @enum {string}
 */
export enum GroupMemberType {
    Group = 'GROUP',
    Array = 'ARRAY'
}

/**
 * Retrieves the metadata of a group
 * @export
 * @interface GroupMetadataRetrievalRequest
 */
export interface GroupMetadataRetrievalRequest {
    /**
     * 
     * @type {TileDBConfig}
     * @memberof GroupMetadataRetrievalRequest
     */
    config?: TileDBConfig;
}
/**
 * Updates the metadata of a group
 * @export
 * @interface GroupMetadataUpdateRequest
 */
export interface GroupMetadataUpdateRequest {
    /**
     * 
     * @type {TileDBConfig}
     * @memberof GroupMetadataUpdateRequest
     */
    config?: TileDBConfig;
    /**
     * 
     * @type {Metadata}
     * @memberof GroupMetadataUpdateRequest
     */
    metadata: Metadata;
}
/**
 * information for creating a new group with the passed configuration
 * @export
 * @interface GroupRegistrationRequest
 */
export interface GroupRegistrationRequest {
    /**
     * 
     * @type {TileDBConfig}
     * @memberof GroupRegistrationRequest
     */
    config?: TileDBConfig;
    /**
     * 
     * @type {GroupRegistrationRequestGroupDetails}
     * @memberof GroupRegistrationRequest
     */
    group_details: GroupRegistrationRequestGroupDetails;
}
/**
 * Initial attributes for the creation of a group.
 * @export
 * @interface GroupRegistrationRequestGroupDetails
 */
export interface GroupRegistrationRequestGroupDetails {
    /**
     * A human readable description of the contents of the group.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    description?: string;
    /**
     * The name of the group. If must be unique within the group.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    name?: string;
    /**
     * The unique name or id of the parent of the group. If empty, then the new group will be a top level group.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    parent?: string;
    /**
     * uri of group.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    uri?: string;
    /**
     * logo (base64 encoded) for the group. Optional
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    logo?: string;
    /**
     * optional tags for groups.
     * @type {Array<string>}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    tags?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    license_id?: string;
    /**
     * License text
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    license_text?: string;
    /**
     * region of the group
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    region?: string;
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used.
     * @type {string}
     * @memberof GroupRegistrationRequestGroupDetails
     */
    access_credentials_name?: string;
}
/**
 * Layout of array
 * @export
 * @enum {string}
 */
export enum Layout {
    RowMajor = 'row-major',
    ColMajor = 'col-major',
    GlobalOrder = 'global-order',
    Unordered = 'unordered'
}

/**
 * user\'s TileDB metadata
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * List of metadata entries
     * @type {Array<MetadataEntry>}
     * @memberof Metadata
     */
    entries?: Array<MetadataEntry>;
}
/**
 * key/value pair representing a group metadata map entry
 * @export
 * @interface MetadataEntry
 */
export interface MetadataEntry {
    /**
     * 
     * @type {string}
     * @memberof MetadataEntry
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataEntry
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof MetadataEntry
     */
    valueNum?: number;
    /**
     * 
     * @type {object}
     * @memberof MetadataEntry
     */
    value?: object;
    /**
     * 
     * @type {boolean}
     * @memberof MetadataEntry
     */
    del?: boolean;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
}
/**
 * object representing a non-empty domain
 * @export
 * @interface NonEmptyDomain
 */
export interface NonEmptyDomain {
    /**
     * 
     * @type {DomainArray}
     * @memberof NonEmptyDomain
     */
    nonEmptyDomain: DomainArray;
    /**
     * Is non-empty domain really empty?
     * @type {boolean}
     * @memberof NonEmptyDomain
     */
    isEmpty: boolean;
}
/**
 * object containing non empty domains
 * @export
 * @interface NonEmptyDomainList
 */
export interface NonEmptyDomainList {
    /**
     * Array\'s non empty domain
     * @type {Array<NonEmptyDomain>}
     * @memberof NonEmptyDomainList
     */
    nonEmptyDomains?: Array<NonEmptyDomain>;
}
/**
 * 
 * @export
 * @interface PaginationMetadata
 */
export interface PaginationMetadata {
    /**
     * pagination offset. Use it to skip the first ((page - 1) * per_page) items
     * @type {number}
     * @memberof PaginationMetadata
     */
    page?: number;
    /**
     * pagination limit (page size)
     * @type {number}
     * @memberof PaginationMetadata
     */
    per_page?: number;
    /**
     * number of total pages with current limit
     * @type {number}
     * @memberof PaginationMetadata
     */
    total_pages?: number;
    /**
     * number of total available items
     * @type {number}
     * @memberof PaginationMetadata
     */
    total_items?: number;
}
/**
 * 
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * 
     * @type {Querytype}
     * @memberof Query
     */
    type: Querytype;
    /**
     * 
     * @type {Layout}
     * @memberof Query
     */
    layout: Layout;
    /**
     * 
     * @type {Querystatus}
     * @memberof Query
     */
    status: Querystatus;
    /**
     * List of attribute buffer headers
     * @type {Array<AttributeBufferHeader>}
     * @memberof Query
     */
    attributeBufferHeaders: Array<AttributeBufferHeader>;
    /**
     * 
     * @type {Writer}
     * @memberof Query
     */
    writer?: Writer;
    /**
     * 
     * @type {QueryReader}
     * @memberof Query
     */
    reader?: QueryReader;
    /**
     * 
     * @type {ArrayData}
     * @memberof Query
     */
    array: ArrayData;
    /**
     * Total number of bytes in fixed size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalFixedLengthBufferBytes: number;
    /**
     * Total number of bytes in variable size attribute buffers.
     * @type {number}
     * @memberof Query
     */
    totalVarLenBufferBytes: number;
    /**
     * Total number of bytes in validity buffers
     * @type {number}
     * @memberof Query
     */
    totalValidityBufferBytes?: number;
}
/**
 * Read struct (can\'t be called reader due to class name conflict)
 * @export
 * @interface QueryReader
 */
export interface QueryReader {
    /**
     * 
     * @type {Layout}
     * @memberof QueryReader
     */
    layout?: Layout;
    /**
     * 
     * @type {Subarray}
     * @memberof QueryReader
     */
    subarray?: Subarray;
    /**
     * 
     * @type {ReadState}
     * @memberof QueryReader
     */
    readState?: ReadState;
}
/**
 * Status of query
 * @export
 * @enum {string}
 */
export enum Querystatus {
    Failed = 'FAILED',
    Completed = 'COMPLETED',
    Inprogress = 'INPROGRESS',
    Incomplete = 'INCOMPLETE',
    Uninitialized = 'UNINITIALIZED'
}

/**
 * Type of query
 * @export
 * @enum {string}
 */
export enum Querytype {
    Read = 'READ',
    Write = 'WRITE'
}

/**
 * state for reads
 * @export
 * @interface ReadState
 */
export interface ReadState {
    /**
     * True if the reader has been initialized.
     * @type {boolean}
     * @memberof ReadState
     */
    initialized?: boolean;
    /**
     * True if the query produced results that could not fit in some buffer.
     * @type {boolean}
     * @memberof ReadState
     */
    overflowed?: boolean;
    /**
     * True if the current subarray partition is unsplittable.
     * @type {boolean}
     * @memberof ReadState
     */
    unsplittable?: boolean;
    /**
     * 
     * @type {SubarrayPartitioner}
     * @memberof ReadState
     */
    subarrayPartitioner?: SubarrayPartitioner;
}
/**
 * A Subarray
 * @export
 * @interface Subarray
 */
export interface Subarray {
    /**
     * 
     * @type {Layout}
     * @memberof Subarray
     */
    layout?: Layout;
    /**
     * List of 1D ranges, one per dimension
     * @type {Array<SubarrayRanges>}
     * @memberof Subarray
     */
    ranges?: Array<SubarrayRanges>;
}
/**
 * The subarray partitioner
 * @export
 * @interface SubarrayPartitioner
 */
export interface SubarrayPartitioner {
    /**
     * 
     * @type {Subarray}
     * @memberof SubarrayPartitioner
     */
    subarray?: Subarray;
    /**
     * Result size budget (in bytes) for all attributes.
     * @type {Array<AttributeBufferSize>}
     * @memberof SubarrayPartitioner
     */
    budget?: Array<AttributeBufferSize>;
    /**
     * 
     * @type {SubarrayPartitionerCurrent}
     * @memberof SubarrayPartitioner
     */
    current?: SubarrayPartitionerCurrent;
    /**
     * 
     * @type {SubarrayPartitionerState}
     * @memberof SubarrayPartitioner
     */
    state?: SubarrayPartitionerState;
    /**
     * The memory budget for the fixed-sized attributes and the offsets of the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudget?: number;
    /**
     * The memory budget for the var-sized attributes
     * @type {number}
     * @memberof SubarrayPartitioner
     */
    memoryBudgetVar?: number;
}
/**
 * The current partition info
 * @export
 * @interface SubarrayPartitionerCurrent
 */
export interface SubarrayPartitionerCurrent {
    /**
     * 
     * @type {Subarray}
     * @memberof SubarrayPartitionerCurrent
     */
    subarray?: Subarray;
    /**
     * PartitionInfo start
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    start?: number;
    /**
     * PartitionInfo end
     * @type {number}
     * @memberof SubarrayPartitionerCurrent
     */
    end?: number;
    /**
     * PartitionInfo splitMultiRange
     * @type {boolean}
     * @memberof SubarrayPartitionerCurrent
     */
    splitMultiRange?: boolean;
}
/**
 * The state information for the remaining partitions to be produced
 * @export
 * @interface SubarrayPartitionerState
 */
export interface SubarrayPartitionerState {
    /**
     * State start
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    start?: number;
    /**
     * State end
     * @type {number}
     * @memberof SubarrayPartitionerState
     */
    end?: number;
    /**
     * State singleRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    singleRange?: Array<Subarray>;
    /**
     * State multiRange
     * @type {Array<Subarray>}
     * @memberof SubarrayPartitionerState
     */
    multiRange?: Array<Subarray>;
}
/**
 * A set of 1D ranges for a subarray
 * @export
 * @interface SubarrayRanges
 */
export interface SubarrayRanges {
    /**
     * 
     * @type {Datatype}
     * @memberof SubarrayRanges
     */
    type?: Datatype;
    /**
     * True if the range is the default range
     * @type {boolean}
     * @memberof SubarrayRanges
     */
    hasDefaultRange?: boolean;
    /**
     * The bytes of the ranges
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    buffer?: Array<number>;
    /**
     * The list of sizes per range
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    bufferSizes?: Array<number>;
    /**
     * The list of start sizes per range
     * @type {Array<number>}
     * @memberof SubarrayRanges
     */
    bufferStartSizes?: Array<number>;
}
/**
 * TileDB config used for interaction with the embedded library
 * @export
 * @interface TileDBConfig
 */
export interface TileDBConfig {
    /**
     * 
     * @type {Array<TileDBConfigEntries>}
     * @memberof TileDBConfig
     */
    entries?: Array<TileDBConfigEntries>;
}
/**
 * 
 * @export
 * @interface TileDBConfigEntries
 */
export interface TileDBConfigEntries {
    /**
     * 
     * @type {string}
     * @memberof TileDBConfigEntries
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof TileDBConfigEntries
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface Writer
 */
export interface Writer {
    /**
     * 
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordDups?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Writer
     */
    checkCoordOOB?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Writer
     */
    dedupCoords?: boolean;
    /**
     * 
     * @type {Subarray}
     * @memberof Writer
     */
    subarrayRanges?: Subarray;
    /**
     * 
     * @type {DomainArray}
     * @memberof Writer
     */
    subarray?: DomainArray;
}

/**
 * ArrayApi - axios parameter creator
 * @export
 */
export const ArrayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog: async (namespace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('arrayActivityLog', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('arrayActivityLog', 'array', array)
            const localVarPath = `/arrays/{namespace}/{array}/activity`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (eventTypes) {
                localVarQueryParameter['event_types'] = eventTypes;
            }

            if (taskId !== undefined) {
                localVarQueryParameter['task_id'] = taskId;
            }

            if (hasTaskId !== undefined) {
                localVarQueryParameter['has_task_id'] = hasTaskId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a array at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArrayFetch} arrayFetch Details for array being fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray: async (namespace: string, array: string, contentType: string, arrayFetch: ArrayFetch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getArray', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getArray', 'array', array)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getArray', 'contentType', contentType)
            // verify required parameter 'arrayFetch' is not null or undefined
            assertParamExists('getArray', 'arrayFetch', arrayFetch)
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(arrayFetch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArrayApi - functional programming interface
 * @export
 */
export const ArrayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArrayApiAxiosParamCreator(configuration)
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayActivityLogData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a array at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArrayFetch} arrayFetch Details for array being fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArray(namespace: string, array: string, contentType: string, arrayFetch: ArrayFetch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArray(namespace, array, contentType, arrayFetch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArrayApi - factory interface
 * @export
 */
export const ArrayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArrayApiFp(configuration)
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options?: any): AxiosPromise<ArrayActivityLogData> {
            return localVarFp.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a array at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArrayFetch} arrayFetch Details for array being fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray(namespace: string, array: string, contentType: string, arrayFetch: ArrayFetch, options?: any): AxiosPromise<ArrayData> {
            return localVarFp.getArray(namespace, array, contentType, arrayFetch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
export class ArrayApi extends BaseAPI {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arrayActivityLog(namespace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options?: any) {
        return ArrayApiFp(this.configuration).arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a array at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArrayFetch} arrayFetch Details for array being fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArray(namespace: string, array: string, contentType: string, arrayFetch: ArrayFetch, options?: any) {
        return ArrayApiFp(this.configuration).getArray(namespace, array, contentType, arrayFetch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload a file at the specified location and wrap it in TileDB Array
         * @param {string} namespace The namespace of the file
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input
         * @param {number} filesize size of the file to upload in bytes
         * @param {any} file file to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [name] name of the TileDB array to create, if missing {array} is used
         * @param {string} [filename] original file name
         * @param {string} [mimetype] Mime type of the uploaded file. Autogenerated clients do not always support changing the content type param. Server will always use mimetype query param to set mimetype for file, if it is not set Content-Type will be used 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadFile: async (namespace: string, array: string, contentType: string, filesize: number, file: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, filename?: string, mimetype?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('handleUploadFile', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('handleUploadFile', 'array', array)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('handleUploadFile', 'contentType', contentType)
            // verify required parameter 'filesize' is not null or undefined
            assertParamExists('handleUploadFile', 'filesize', filesize)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('handleUploadFile', 'file', file)
            const localVarPath = `/files/{namespace}/{array}/upload`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (filesize !== undefined) {
                localVarQueryParameter['filesize'] = filesize;
            }

            if (mimetype !== undefined) {
                localVarQueryParameter['mimetype'] = mimetype;
            }

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(file, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload a file at the specified location and wrap it in TileDB Array
         * @param {string} namespace The namespace of the file
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input
         * @param {number} filesize size of the file to upload in bytes
         * @param {any} file file to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [name] name of the TileDB array to create, if missing {array} is used
         * @param {string} [filename] original file name
         * @param {string} [mimetype] Mime type of the uploaded file. Autogenerated clients do not always support changing the content type param. Server will always use mimetype query param to set mimetype for file, if it is not set Content-Type will be used 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleUploadFile(namespace: string, array: string, contentType: string, filesize: number, file: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, filename?: string, mimetype?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploaded>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleUploadFile(namespace, array, contentType, filesize, file, xTILEDBCLOUDACCESSCREDENTIALSNAME, name, filename, mimetype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * Upload a file at the specified location and wrap it in TileDB Array
         * @param {string} namespace The namespace of the file
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input
         * @param {number} filesize size of the file to upload in bytes
         * @param {any} file file to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [name] name of the TileDB array to create, if missing {array} is used
         * @param {string} [filename] original file name
         * @param {string} [mimetype] Mime type of the uploaded file. Autogenerated clients do not always support changing the content type param. Server will always use mimetype query param to set mimetype for file, if it is not set Content-Type will be used 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadFile(namespace: string, array: string, contentType: string, filesize: number, file: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, filename?: string, mimetype?: string, options?: any): AxiosPromise<FileUploaded> {
            return localVarFp.handleUploadFile(namespace, array, contentType, filesize, file, xTILEDBCLOUDACCESSCREDENTIALSNAME, name, filename, mimetype, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Upload a file at the specified location and wrap it in TileDB Array
     * @param {string} namespace The namespace of the file
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input
     * @param {number} filesize size of the file to upload in bytes
     * @param {any} file file to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [name] name of the TileDB array to create, if missing {array} is used
     * @param {string} [filename] original file name
     * @param {string} [mimetype] Mime type of the uploaded file. Autogenerated clients do not always support changing the content type param. Server will always use mimetype query param to set mimetype for file, if it is not set Content-Type will be used 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public handleUploadFile(namespace: string, array: string, contentType: string, filesize: number, file: any, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, filename?: string, mimetype?: string, options?: any) {
        return FilesApiFp(this.configuration).handleUploadFile(namespace, array, contentType, filesize, file, xTILEDBCLOUDACCESSCREDENTIALSNAME, name, filename, mimetype, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an empty group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupCreationRequest} [groupCreation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('createGroup', 'groupNamespace', groupNamespace)
            const localVarPath = `/groups/{group_namespace}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(groupCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deregisters a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterGroup: async (groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('deregisterGroup', 'groupNamespace', groupNamespace)
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('deregisterGroup', 'groupName', groupName)
            const localVarPath = `/groups/{group_namespace}/{group_name}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get metadata on a group using the requested config
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupMetadataRetrievalRequest} [metadataRetrieval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMetadata: async (groupNamespace: string, groupName: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('getGroupMetadata', 'groupNamespace', groupNamespace)
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('getGroupMetadata', 'groupName', groupName)
            const localVarPath = `/groups/{group_namespace}/{group_name}/metadata`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(metadataRetrieval, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * can be used to check if the resource exists
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupNamespaceGroupNameOptions: async (groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('groupsGroupNamespaceGroupNameOptions', 'groupNamespace', groupNamespace)
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('groupsGroupNamespaceGroupNameOptions', 'groupName', groupName)
            const localVarPath = `/groups/{group_namespace}/{group_name}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers an already existing group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupRegistrationRequest} [groupRegistration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGroup: async (groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('registerGroup', 'groupNamespace', groupNamespace)
            const localVarPath = `/groups/{group_namespace}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(groupRegistration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the contents of a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsRetrievalRequest} [groupRetrieval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroup: async (groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('retrieveGroup', 'groupNamespace', groupNamespace)
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('retrieveGroup', 'groupName', groupName)
            const localVarPath = `/groups/{group_namespace}/{group_name}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(groupRetrieval, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the contents of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsChangesRequest} [groupUpdateContents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupContents: async (groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('updateGroupContents', 'groupNamespace', groupNamespace)
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('updateGroupContents', 'groupName', groupName)
            const localVarPath = `/groups/{group_namespace}/{group_name}`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(groupUpdateContents, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update metadata on a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupMetadataUpdateRequest} [metadataUpdating] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMetadata: async (groupNamespace: string, groupName: string, metadataUpdating?: GroupMetadataUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupNamespace' is not null or undefined
            assertParamExists('updateGroupMetadata', 'groupNamespace', groupNamespace)
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('updateGroupMetadata', 'groupName', groupName)
            const localVarPath = `/groups/{group_namespace}/{group_name}/metadata`
                .replace(`{${"group_namespace"}}`, encodeURIComponent(String(groupNamespace)))
                .replace(`{${"group_name"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(metadataUpdating, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an empty group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupCreationRequest} [groupCreation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupCreation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deregisters a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deregisterGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deregisterGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get metadata on a group using the requested config
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupMetadataRetrievalRequest} [metadataRetrieval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupMetadata(groupNamespace: string, groupName: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupMetadata(groupNamespace, groupName, metadataRetrieval, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * can be used to check if the resource exists
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGroupNamespaceGroupNameOptions(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGroupNamespaceGroupNameOptions(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers an already existing group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupRegistrationRequest} [groupRegistration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRegistration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the contents of a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsRetrievalRequest} [groupRetrieval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupContentsRetrievalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRetrieval, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change the contents of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsChangesRequest} [groupUpdateContents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupContents(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupContents(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupUpdateContents, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update metadata on a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupMetadataUpdateRequest} [metadataUpdating] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupMetadata(groupNamespace: string, groupName: string, metadataUpdating?: GroupMetadataUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupMetadata(groupNamespace, groupName, metadataUpdating, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * Creates an empty group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupCreationRequest} [groupCreation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupCreation, options).then((request) => request(axios, basePath));
        },
        /**
         * Deregisters a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deregisterGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on a group using the requested config
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupMetadataRetrievalRequest} [metadataRetrieval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMetadata(groupNamespace: string, groupName: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options?: any): AxiosPromise<Metadata> {
            return localVarFp.getGroupMetadata(groupNamespace, groupName, metadataRetrieval, options).then((request) => request(axios, basePath));
        },
        /**
         * can be used to check if the resource exists
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupNamespaceGroupNameOptions(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): AxiosPromise<void> {
            return localVarFp.groupsGroupNamespaceGroupNameOptions(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers an already existing group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupRegistrationRequest} [groupRegistration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.registerGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRegistration, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the contents of a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsRetrievalRequest} [groupRetrieval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options?: any): AxiosPromise<GroupContentsRetrievalResponse> {
            return localVarFp.retrieveGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRetrieval, options).then((request) => request(axios, basePath));
        },
        /**
         * Change the contents of the group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsChangesRequest} [groupUpdateContents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupContents(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateGroupContents(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupUpdateContents, options).then((request) => request(axios, basePath));
        },
        /**
         * update metadata on a group
         * @param {string} groupNamespace The namespace of the group
         * @param {string} groupName The unique name or id of the group
         * @param {GroupMetadataUpdateRequest} [metadataUpdating] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMetadata(groupNamespace: string, groupName: string, metadataUpdating?: GroupMetadataUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateGroupMetadata(groupNamespace, groupName, metadataUpdating, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * Creates an empty group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupCreationRequest} [groupCreation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options?: any) {
        return GroupsApiFp(this.configuration).createGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupCreation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deregisters a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deregisterGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any) {
        return GroupsApiFp(this.configuration).deregisterGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get metadata on a group using the requested config
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataRetrievalRequest} [metadataRetrieval] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupMetadata(groupNamespace: string, groupName: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options?: any) {
        return GroupsApiFp(this.configuration).getGroupMetadata(groupNamespace, groupName, metadataRetrieval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * can be used to check if the resource exists
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGroupNamespaceGroupNameOptions(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any) {
        return GroupsApiFp(this.configuration).groupsGroupNamespaceGroupNameOptions(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers an already existing group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupRegistrationRequest} [groupRegistration] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public registerGroup(groupNamespace: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options?: any) {
        return GroupsApiFp(this.configuration).registerGroup(groupNamespace, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRegistration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the contents of a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsRetrievalRequest} [groupRetrieval] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public retrieveGroup(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options?: any) {
        return GroupsApiFp(this.configuration).retrieveGroup(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRetrieval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change the contents of the group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsChangesRequest} [groupUpdateContents] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupContents(groupNamespace: string, groupName: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options?: any) {
        return GroupsApiFp(this.configuration).updateGroupContents(groupNamespace, groupName, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupUpdateContents, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update metadata on a group
     * @param {string} groupNamespace The namespace of the group
     * @param {string} groupName The unique name or id of the group
     * @param {GroupMetadataUpdateRequest} [metadataUpdating] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupMetadata(groupNamespace: string, groupName: string, metadataUpdating?: GroupMetadataUpdateRequest, options?: any) {
        return GroupsApiFp(this.configuration).updateGroupMetadata(groupNamespace, groupName, metadataUpdating, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential: async (namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('addCredential', 'namespace', namespace)
            // verify required parameter 'accessCredential' is not null or undefined
            assertParamExists('addCredential', 'accessCredential', accessCredential)
            const localVarPath = `/credentials/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteCredential', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteCredential', 'name', name)
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getCredential', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getCredential', 'name', name)
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials: async (namespace: string, provider?: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listCredentials', 'namespace', namespace)
            const localVarPath = `/credentials/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential: async (namespace: string, name: string, accessCredential: AccessCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateCredential', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateCredential', 'name', name)
            // verify required parameter 'accessCredential' is not null or undefined
            assertParamExists('updateCredential', 'accessCredential', accessCredential)
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCredential(namespace, accessCredential, provider, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCredential(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredential(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCredential(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCredential(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredentialsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredentials(namespace, provider, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCredential(namespace, name, accessCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): AxiosPromise<void> {
            return localVarFp.addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(namespace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCredential(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential(namespace: string, name: string, options?: any): AxiosPromise<AccessCredential> {
            return localVarFp.getCredential(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): AxiosPromise<AccessCredentialsData> {
            return localVarFp.listCredentials(namespace, provider, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): AxiosPromise<void> {
            return localVarFp.updateCredential(namespace, name, accessCredential, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any) {
        return OrganizationApiFp(this.configuration).addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteCredential(namespace: string, name: string, options?: any) {
        return OrganizationApiFp(this.configuration).deleteCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getCredential(namespace: string, name: string, options?: any) {
        return OrganizationApiFp(this.configuration).getCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any) {
        return OrganizationApiFp(this.configuration).listCredentials(namespace, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any) {
        return OrganizationApiFp(this.configuration).updateCredential(namespace, name, accessCredential, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery: async (namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('submitQuery', 'namespace', namespace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('submitQuery', 'array', array)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('submitQuery', 'type', type)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('submitQuery', 'contentType', contentType)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('submitQuery', 'query', query)
            const localVarPath = `/arrays/{namespace}/{array}/query/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }

            if (readAll !== undefined) {
                localVarQueryParameter['read_all'] = readAll;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(query, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration)
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryApiFp(configuration)
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any): AxiosPromise<any> {
            return localVarFp.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public submitQuery(namespace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any) {
        return QueryApiFp(this.configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential: async (namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('addCredential', 'namespace', namespace)
            // verify required parameter 'accessCredential' is not null or undefined
            assertParamExists('addCredential', 'accessCredential', accessCredential)
            const localVarPath = `/credentials/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteCredential', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteCredential', 'name', name)
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential: async (namespace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getCredential', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getCredential', 'name', name)
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials: async (namespace: string, provider?: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listCredentials', 'namespace', namespace)
            const localVarPath = `/credentials/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential: async (namespace: string, name: string, accessCredential: AccessCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateCredential', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateCredential', 'name', name)
            // verify required parameter 'accessCredential' is not null or undefined
            assertParamExists('updateCredential', 'accessCredential', accessCredential)
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCredential(namespace, accessCredential, provider, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCredential(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredential(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCredential(namespace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCredential(namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredentialsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredentials(namespace, provider, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCredential(namespace, name, accessCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any): AxiosPromise<void> {
            return localVarFp.addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(namespace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCredential(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential(namespace: string, name: string, options?: any): AxiosPromise<AccessCredential> {
            return localVarFp.getCredential(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any): AxiosPromise<AccessCredentialsData> {
            return localVarFp.listCredentials(namespace, provider, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any): AxiosPromise<void> {
            return localVarFp.updateCredential(namespace, name, accessCredential, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addCredential(namespace: string, accessCredential: AccessCredential, provider?: string, page?: number, perPage?: number, options?: any) {
        return UserApiFp(this.configuration).addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteCredential(namespace: string, name: string, options?: any) {
        return UserApiFp(this.configuration).deleteCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCredential(namespace: string, name: string, options?: any) {
        return UserApiFp(this.configuration).getCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listCredentials(namespace: string, provider?: string, page?: number, perPage?: number, options?: any) {
        return UserApiFp(this.configuration).listCredentials(namespace, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateCredential(namespace: string, name: string, accessCredential: AccessCredential, options?: any) {
        return UserApiFp(this.configuration).updateCredential(namespace, name, accessCredential, options).then((request) => request(this.axios, this.basePath));
    }
}


