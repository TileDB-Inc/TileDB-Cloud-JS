/* tslint:disable */
/* eslint-disable */
/**
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../commons/configuration';
import type { AxiosPromise, AxiosInstance } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../commons/common';
import type { RequestArgs } from '../commons/base';
// @ts-ignore
import { COLLECTION_FORMATS, RequiredError } from '../commons/base';
import updateBasePathAfterRedirect from '../utils/updateBasePathAfterRedirect';

export const BASE_PATH = "http://localhost/v2".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
        updateBasePathAfterRedirect(axios, BASE_PATH, this);
    }
};

/**
 * Credential information to access Amazon Web Services
 */
export interface AWSCredential {
    /**
     * The ID of the access key
     */
    'access_key_id'?: string;
    /**
     * The access key\'s secret. Never returned in responses.
     */
    'secret_access_key'?: string;
    /**
     * The endpoint used for this credential
     */
    'endpoint'?: string | null;
}
/**
 * Role information to access Amazon Web Services
 */
export interface AWSRole {
    /**
     * The role arn used to access
     */
    'role_arn'?: string;
    /**
     * The role external id used to access
     */
    'external_id'?: string;
    /**
     * The endpoint used for this role
     */
    'endpoint'?: string | null;
}
/**
 * A union type which may contain a credential to access any one cloud provider.
 */
export interface AccessCredential {
    /**
     * The UUID of the credential
     */
    'uuid'?: string;
    /**
     * A user-specified name for the key
     */
    'name'?: string;
    'provider'?: CloudProvider;
    /**
     * True if this is the namespace\'s default credential to be used when connecting to the given cloud provider. There can be at most one default for each unique provider.
     */
    'provider_default'?: boolean | null;
    /**
     * Time when the credential was created (rfc3339)
     */
    'created_at'?: string;
    /**
     * Time when the credential was last updated (rfc3339)
     */
    'updated_at'?: string;
    /**
     * Is this credential allowed to be used in tasks
     */
    'allowed_in_tasks'?: boolean | null;
    'credential'?: AccessCredentialCredential;
    'role'?: AccessCredentialRole;
    'token'?: AccessCredentialToken;
}


/**
 * The credential information itself. Exactly one sub-field may be set. The names match those in the CloudProvider enum.
 */
export interface AccessCredentialCredential {
    'aws'?: AWSCredential | null;
    'azure'?: AzureCredential | null;
    'gcp'?: GCPInteroperabilityCredential | null;
}
/**
 * The role information itself. Exactly one sub-field may be set. The names match those in the CloudProvider enum.
 */
export interface AccessCredentialRole {
    'aws'?: AWSRole | null;
}
/**
 * The token information itself. Exactly one sub-field may be set. The names match those in the CloudProvider enum.
 */
export interface AccessCredentialToken {
    'azure'?: AzureToken | null;
    'gcp'?: GCPServiceAccountKey | null;
}
/**
 * The types of an access credential
 */

export const AccessCredentialType = {
    Key: 'key',
    Arn: 'arn',
    Token: 'token',
    AzureToken: 'azure_token'
} as const;

export type AccessCredentialType = typeof AccessCredentialType[keyof typeof AccessCredentialType];


/**
 * Object including credentials and pagination metadata
 */
export interface AccessCredentialsData {
    /**
     * List of credentials
     */
    'credentials'?: Array<AccessCredential>;
    'pagination_metadata'?: PaginationMetadata;
}
/**
 * Type of activity logged
 */

export const ActivityEventType = {
    ReadSchema: 'read_schema',
    MaxBufferSizes: 'max_buffer_sizes',
    NonEmptyDomain: 'non_empty_domain',
    QueryRead: 'query_read',
    QueryWrite: 'query_write',
    Create: 'create',
    Delete: 'delete',
    Register: 'register',
    Deregister: 'deregister',
    Udf: 'udf',
    ArrayMetadataGet: 'array_metadata_get',
    ArrayMetadataUpdate: 'array_metadata_update',
    EstimatedResultSizes: 'estimated_result_sizes',
    Update: 'update',
    Info: 'info',
    Run: 'run'
} as const;

export type ActivityEventType = typeof ActivityEventType[keyof typeof ActivityEventType];


/**
 * Activity of an Array
 */
export interface ArrayActivityLog {
    /**
     * time event took place (RFC3339)
     */
    'event_at'?: string;
    'action'?: ActivityEventType;
    /**
     * User who performed action
     */
    'username'?: string;
    /**
     * Bytes sent to client
     */
    'bytes_sent'?: number;
    /**
     * Bytes recieved from client
     */
    'bytes_received'?: number;
    /**
     * uuid of associated array task
     */
    'array_task_id'?: string;
    /**
     * id of the activity
     */
    'id'?: string;
    /**
     * ranges for query
     */
    'query_ranges'?: string;
    /**
     * stats for query
     */
    'query_stats'?: string;
}


/**
 * Object including array tasks and metadata
 */
export interface ArrayActivityLogData {
    /**
     * Array ArrayActivityLog
     */
    'activitylogs'?: Array<ArrayActivityLog>;
    'pagination_metadata'?: PaginationMetadata;
}
/**
 * ArraySchema during creation or retrieval
 */
export interface ArrayCreateRequest {
    /**
     * Storage location for the array, or empty to use default storage.
     */
    'uri'?: string;
}
/**
 * Array directory (for reads)
 */
export interface ArrayDirectory {
    /**
     * fragment URIs
     */
    'unfilteredFragmentUris'?: Array<string>;
    /**
     * consolidated commit URI set
     */
    'consolidatedCommitUris'?: Array<string>;
    /**
     * URIs of all the array schema files
     */
    'arraySchemaUris'?: Array<string>;
    /**
     * latest array schema URI.
     */
    'latestArraySchemaUri'?: string;
    /**
     * the array metadata files to vacuum
     */
    'arrayMetaUrisToVacuum'?: Array<string>;
    /**
     * the array metadata vac files to vacuum
     */
    'arrayMetaVacUrisToVacuum'?: Array<string>;
    /**
     * the commit files to consolidate
     */
    'commitUrisToConsolidate'?: Array<string>;
    /**
     * the commit files to vacuum
     */
    'commitUrisToVacuum'?: Array<string>;
    /**
     * the consolidated commit files to vacuum
     */
    'consolidatedCommitUrisToVacuum'?: Array<string>;
    /**
     * the URIs of the consolidated fragment metadata files
     */
    'fragmentMetaUris'?: Array<string>;
    /**
     * Only the files created after timestamp_start are listed
     */
    'timestampStart'?: number;
    /**
     * Only the files created before timestamp_end are listed
     */
    'timestampEnd'?: number;
    /**
     * the timestamped filtered array metadata URIs, after removing the ones that need to be vacuumed and those that do not fall within
     */
    'arrayMetaUris'?: Array<TimestampedURI>;
    /**
     * the location of delete tiles
     */
    'deleteAndUpdateTileLocation'?: Array<DeleteAndUpdateTileLocation>;
}
/**
 * Model for opening an array v2
 */
export interface ArrayFetch {
    'config'?: TileDBConfig;
    'queryType'?: Querytype;
}


/**
 * user\'s TileDB array metadata
 */
export interface ArrayMetadata {
    /**
     * List of metadata entries
     */
    'entries'?: Array<ArrayMetadataEntry>;
}
/**
 * key/value pair representing an array metadata map entry
 */
export interface ArrayMetadataEntry {
    'key'?: string;
    'type'?: string;
    'valueNum'?: number;
    'value'?: Array<number>;
    'del'?: boolean;
}
/**
 * ArraySchema during creation or retrieval
 */
export interface ArraySchema {
    /**
     * URI of schema
     */
    'uri'?: string;
    /**
     * name of schema
     */
    'name'?: string;
    /**
     * file format version
     */
    'version': Array<number>;
    'arrayType': ArrayType;
    'tileOrder': Layout;
    'cellOrder': Layout;
    /**
     * Capacity of array
     */
    'capacity': number;
    'coordsFilterPipeline': FilterPipeline;
    'offsetFilterPipeline': FilterPipeline;
    'validityFilterPipeline'?: FilterPipeline;
    'domain': Domain;
    /**
     * Attributes of array
     */
    'attributes': Array<Attribute>;
    /**
     * True if the array allows coordinate duplicates. Applicable only to sparse arrays.
     */
    'allowsDuplicates'?: boolean;
    /**
     * The list of sizes per range
     */
    'timestampRange'?: Array<number>;
}


/**
 * key/value pair representing an array schema map entry
 */
export interface ArraySchemaEntry {
    'key'?: string;
    'value'?: ArraySchema;
}
/**
 * array\'s schemas
 */
export interface ArraySchemaMap {
    /**
     * List of array schemas entries
     */
    'entries'?: Array<ArraySchemaEntry>;
}
/**
 * TileDB array type
 */

export const ArrayType = {
    Dense: 'dense',
    Sparse: 'sparse'
} as const;

export type ArrayType = typeof ArrayType[keyof typeof ArrayType];


export interface AssetActivityLog {
    /**
     * The ID of the activity
     */
    'id': string;
    /**
     * time event took place (RFC3339)
     */
    'event_at': string;
    /**
     * type of the event
     */
    'action': string;
    /**
     * User who performed action
     */
    'username': string;
    /**
     * uuid of associated array task
     */
    'array_task_id'?: string;
    'asset': AssetActivityLogAsset;
}
/**
 * The asset details
 */
export interface AssetActivityLogAsset {
    /**
     * The asset ID
     */
    'id'?: string;
    /**
     * The asset name
     */
    'name'?: string;
    /**
     * The namespace that the asset belongs to
     */
    'namespace'?: string;
    'asset_type'?: AssetType;
}


/**
 * Asset types represented as TileDB arrays
 */

export const AssetType = {
    Array: 'array',
    Notebook: 'notebook',
    Dashboard: 'dashboard',
    UserDefinedFunction: 'user_defined_function',
    MlModel: 'ml_model',
    File: 'file',
    RegisteredTaskGraph: 'registered_task_graph',
    Group: 'group',
    Vcf: 'vcf',
    Soma: 'soma',
    Pointcloud: 'pointcloud',
    Bioimg: 'bioimg',
    Geometry: 'geometry',
    Raster: 'raster',
    VectorSearch: 'vector_search'
} as const;

export type AssetType = typeof AssetType[keyof typeof AssetType];


/**
 * Attribute of array
 */
export interface Attribute {
    /**
     * Attribute name
     */
    'name': string;
    /**
     * Enumeration name
     */
    'enumerationName'?: string;
    'type': Datatype;
    'filterPipeline': FilterPipeline;
    /**
     * Attribute number of values per cell
     */
    'cellValNum': number;
    /**
     * Is attribute nullable
     */
    'nullable'?: boolean;
    /**
     * Default validity fill value for nullable attributes
     */
    'fillValueValidity'?: boolean;
    /**
     * The default fill value
     */
    'fillValue'?: Array<number>;
}


/**
 * Represents an attribute buffer header information
 */
export interface AttributeBufferHeader {
    /**
     * Attribute name
     */
    'name': string;
    /**
     * Number of bytes in the fixed-length attribute data buffer (offsets for var-len attributes)
     */
    'fixedLenBufferSizeInBytes': number;
    /**
     * Number of bytes in the var-length attribute data buffer
     */
    'varLenBufferSizeInBytes': number;
    /**
     * Number of bytes for validity in case attribute is nullable
     */
    'validityLenBufferSizeInBytes'?: number;
    /**
     * Original user set number of bytes in the fixed-length attribute data buffer
     */
    'originalFixedLenBufferSizeInBytes'?: number;
    /**
     * Original user set number of bytes in the var-length attribute data buffer
     */
    'originalVarLenBufferSizeInBytes'?: number;
    /**
     * Original user set number of bytes in the validity data buffer
     */
    'originalValidityLenBufferSizeInBytes'?: number;
}
/**
 * object representing buffer size of an attribute
 */
export interface AttributeBufferSize {
    /**
     * name of attribute
     */
    'attribute': string;
    /**
     * buffer size (in bytes) of offset buffer
     */
    'offsetBytes': number;
    /**
     * buffer size (in bytes) of data buffer
     */
    'dataBytes': number;
}
/**
 * Credential information to access Microsoft Azure. Each supported property is the snake_case version of its name in an Azure Storage connection string.
 */
export interface AzureCredential {
    /**
     * The name of the Azure account to access
     */
    'account_name'?: string;
    /**
     * The secret key. Never returned in responses.
     */
    'account_key'?: string;
}
/**
 * Token information to access Azure services
 */
export interface AzureToken {
    /**
     * The account name of the configuration
     */
    'account_name'?: string;
    /**
     * The token to use for this account
     */
    'sas_token'?: string;
}
/**
 * A service where data is stored or computations take place.
 */

export const CloudProvider = {
    Aws: 'AWS',
    Azure: 'AZURE',
    Gcp: 'GCP'
} as const;

export type CloudProvider = typeof CloudProvider[keyof typeof CloudProvider];


/**
 * The query condition
 */
export interface Condition {
    /**
     * The operation that combines each condition
     */
    'clauseCombinationOps'?: Array<string>;
    /**
     * All clauses in this condition
     */
    'clauses'?: Array<ConditionClause>;
}
/**
 * A clause within a condition
 */
export interface ConditionClause {
    /**
     * The name of the field this clause applies to
     */
    'fieldName'?: string;
    /**
     * The comparison value
     */
    'value'?: Array<number>;
    /**
     * The comparison operation
     */
    'op'?: string;
}
/**
 * TileDB data type
 */

export const Datatype = {
    Int32: 'INT32',
    Int64: 'INT64',
    Float32: 'FLOAT32',
    Float64: 'FLOAT64',
    Char: 'CHAR',
    Int8: 'INT8',
    Uint8: 'UINT8',
    Int16: 'INT16',
    Uint16: 'UINT16',
    Uint32: 'UINT32',
    Uint64: 'UINT64',
    StringAscii: 'STRING_ASCII',
    StringUtf8: 'STRING_UTF8',
    StringUtf16: 'STRING_UTF16',
    StringUtf32: 'STRING_UTF32',
    StringUcs2: 'STRING_UCS2',
    StringUcs4: 'STRING_UCS4',
    Any: 'ANY',
    DatetimeYear: 'DATETIME_YEAR',
    DatetimeMonth: 'DATETIME_MONTH',
    DatetimeWeek: 'DATETIME_WEEK',
    DatetimeDay: 'DATETIME_DAY',
    DatetimeHr: 'DATETIME_HR',
    DatetimeMin: 'DATETIME_MIN',
    DatetimeSec: 'DATETIME_SEC',
    DatetimeMs: 'DATETIME_MS',
    DatetimeUs: 'DATETIME_US',
    DatetimeNs: 'DATETIME_NS',
    DatetimePs: 'DATETIME_PS',
    DatetimeFs: 'DATETIME_FS',
    DatetimeAs: 'DATETIME_AS',
    TimeHr: 'TIME_HR',
    TimeMin: 'TIME_MIN',
    TimeSec: 'TIME_SEC',
    TimeMs: 'TIME_MS',
    TimeUs: 'TIME_US',
    TimeNs: 'TIME_NS',
    TimePs: 'TIME_PS',
    TimeFs: 'TIME_FS',
    TimeAs: 'TIME_AS',
    Blob: 'BLOB',
    Bool: 'BOOL'
} as const;

export type Datatype = typeof Datatype[keyof typeof Datatype];


/**
 * the location of delete tiles
 */
export interface DeleteAndUpdateTileLocation {
    /**
     * the uri
     */
    'uri'?: string;
    'conditionMarker'?: string;
    'offset'?: number;
}
/**
 * Dimension of array
 */
export interface Dimension {
    /**
     * Dimension name
     */
    'name'?: string;
    'type': Datatype;
    'domain': DomainArray;
    /**
     * Is tile extent null
     */
    'nullTileExtent': boolean;
    'tileExtent'?: DimensionTileExtent;
    'filterPipeline'?: FilterPipeline;
}


/**
 * Extent of tile
 */
export interface DimensionTileExtent {
    'int8'?: number;
    'uint8'?: number;
    'int16'?: number;
    'uint16'?: number;
    'int32'?: number;
    'uint32'?: number;
    'int64'?: number;
    'uint64'?: number;
    'float32'?: number;
    'float64'?: number;
}
/**
 * Domain of array
 */
export interface Domain {
    'type': Datatype;
    'tileOrder': Layout;
    'cellOrder': Layout;
    /**
     * Array of dimensions
     */
    'dimensions': Array<Dimension>;
}


/**
 * Domain object for an array of each type
 */
export interface DomainArray {
    'int8'?: Array<number>;
    'uint8'?: Array<number>;
    'int16'?: Array<number>;
    'uint16'?: Array<number>;
    'int32'?: Array<number>;
    'uint32'?: Array<number>;
    'int64'?: Array<number>;
    'uint64'?: Array<number>;
    'float32'?: Array<number>;
    'float64'?: Array<number>;
}
/**
 * Uploaded file name and information
 */
export interface FileUploaded {
    /**
     * output location of the TileDB File
     */
    'output_uri'?: string;
    /**
     * name of the file uploaded
     */
    'file_name'?: string;
    /**
     * The asset id of the created Group
     */
    'asset_id': string;
    /**
     * unique ID of the uploaded file
     */
    'id': string;
}
/**
 * Filter
 */
export interface Filter {
    'type': FilterType;
    'floatScaleConfig'?: FloatScaleConfig;
    'data'?: FilterData;
}


/**
 * Filter data
 */
export interface FilterData {
    'text'?: string;
    'bytes'?: Array<number>;
    'int8'?: number;
    'uint8'?: number;
    'int16'?: number;
    'uint16'?: number;
    'int32'?: number;
    'uint32'?: number;
    'int64'?: number;
    'uint64'?: number;
    'float32'?: number;
    'float64'?: number;
}
/**
 * One or more filters to apply
 */
export interface FilterPipeline {
    'filters'?: Array<Filter>;
}
/**
 * TileDB filter types
 */

export const FilterType = {
    FilterNone: 'FILTER_NONE',
    FilterGzip: 'FILTER_GZIP',
    FilterZstd: 'FILTER_ZSTD',
    FilterLz4: 'FILTER_LZ4',
    FilterRle: 'FILTER_RLE',
    FilterBzip2: 'FILTER_BZIP2',
    FilterDoubleDelta: 'FILTER_DOUBLE_DELTA',
    FilterBitWidthReduction: 'FILTER_BIT_WIDTH_REDUCTION',
    FilterBitshuffle: 'FILTER_BITSHUFFLE',
    FilterByteshuffle: 'FILTER_BYTESHUFFLE',
    FilterPositiveDelta: 'FILTER_POSITIVE_DELTA',
    FilterScaleFloat: 'FILTER_SCALE_FLOAT',
    FilterWebp: 'FILTER_WEBP',
    FilterChecksumMd5: 'FILTER_CHECKSUM_MD5',
    FilterChecksumSha256: 'FILTER_CHECKSUM_SHA256',
    FilterDictionary: 'FILTER_DICTIONARY'
} as const;

export type FilterType = typeof FilterType[keyof typeof FilterType];


/**
 * FloatScaleConfig
 */
export interface FloatScaleConfig {
    'scale'?: number;
    'offset'?: number;
    'byteWidth'?: number;
}
/**
 * Tile/cell index for fragment
 */
export interface FragmentIndex {
    /**
     * Tile index
     */
    'tileIdx'?: number;
    /**
     * Cell index
     */
    'cellIdx'?: number;
}
/**
 * Metadata of a fragment
 */
export interface FragmentMetadata {
    /**
     * The size of each attribute file
     */
    'fileSizes'?: Array<number>;
    /**
     * The size of each var attribute file
     */
    'fileVarSizes'?: Array<number>;
    /**
     * The size of each validity attribute file
     */
    'fileValiditySizes'?: Array<number>;
    /**
     * The uri of the fragment this metadata belongs to
     */
    'fragmentUri'?: string;
    /**
     * True if the fragment has timestamps
     */
    'hasTimestamps'?: boolean;
    /**
     * True if the fragment has delete metadata
     */
    'hasDeleteMeta'?: boolean;
    /**
     * The number of sparse tiles
     */
    'sparseTileNum'?: number;
    /**
     * Used to track the tile index base between global order writes
     */
    'tileIndexBase'?: number;
    /**
     * Tile offsets in their attribute files
     */
    'tileOffsets'?: Array<Array<number>>;
    /**
     * Variable tile offsets in their attribute files
     */
    'tileVarOffsets'?: Array<Array<number>>;
    /**
     * The sizes of the uncompressed variable tiles
     */
    'tileVarSizes'?: Array<Array<number>>;
    /**
     * Validity tile offests in their attribute files
     */
    'tileValidityOffsets'?: Array<Array<number>>;
    /**
     * tile min buffers
     */
    'tileMinBuffer'?: Array<Array<number>>;
    /**
     * tile min buffers for var length data
     */
    'tileMinVarBuffer'?: Array<Array<number>>;
    /**
     * tile max buffers
     */
    'tileMaxBuffer'?: Array<Array<number>>;
    /**
     * tile max buffers for var length data
     */
    'tileMaxVarBuffer'?: Array<Array<number>>;
    /**
     * tile sum values
     */
    'tileSums'?: Array<Array<number>>;
    /**
     * tile null count values
     */
    'tileNullCounts'?: Array<Array<number>>;
    /**
     * fragment min values
     */
    'fragmentMins'?: Array<Array<number>>;
    /**
     * fragment max values
     */
    'fragmentMaxs'?: Array<Array<number>>;
    /**
     * fragment sum values
     */
    'fragmentSums'?: Array<number>;
    /**
     * fragment null count values
     */
    'fragmentNullCounts'?: Array<number>;
    /**
     * the format version of this metadata
     */
    'version'?: number;
    /**
     * A pair of timestamps for fragment
     */
    'timestampRange'?: Array<number>;
    /**
     * The number of cells in the last tile
     */
    'lastTileCellNum'?: number;
    'nonEmptyDomain'?: NonEmptyDomainList;
    /**
     * The RTree for the MBRs serialized as a blob
     */
    'rtree'?: File;
    /**
     * if the fragment metadata footer appears in a consolidated file
     */
    'hasConsolidatedFooter'?: boolean;
    'gtOffsets'?: GenericTileOffsets;
}
/**
 * Credential information to access Google Cloud. using well knows key/secret pair to access storage.
 */
export interface GCPInteroperabilityCredential {
    /**
     * The ID of the access key
     */
    'access_key_id'?: string;
    /**
     * The access key\'s secret. Never returned in responses.
     */
    'secret_access_key'?: string;
}
/**
 * The key to a Google Cloud Platform service account.
 */
export interface GCPServiceAccountKey {
    /**
     * The ID of the service account (i.e., its email address).  This is ignored when uploading key information, and is only provided by the server when downloading metadata about an existing key. 
     */
    'account_id'?: string;
    /**
     * The ID of the particular key. This identifies it among other keys issued for this service account.  This is ignored when uploading key information, and is only provided by the server when downloading metadata about an existing key. 
     */
    'key_id'?: string;
    /**
     * The full file provided by Google Cloud. This is usually in the form of a JSON document, but TileDB Cloud treats it as opaque (except to attempt to extract the service account ID and the key ID). 
     */
    'key_text'?: string;
}
/**
 * Array directory (for reads)
 */
export interface GenericTileOffsets {
    /**
     * RTree serialized as a blob
     */
    'rtree'?: number;
    /**
     * tile offsets
     */
    'tileOffsets'?: Array<number>;
    /**
     * variable tile offsets
     */
    'tileVarOffsets'?: Array<number>;
    /**
     * sizes of the uncompressed variable tiles offsets
     */
    'tileVarSizes'?: Array<number>;
    /**
     * tile validity offsets
     */
    'tileValidityOffsets'?: Array<number>;
    /**
     * min tile offsets
     */
    'tileMinOffsets'?: Array<number>;
    /**
     * max tile offsets
     */
    'tileMaxOffsets'?: Array<number>;
    /**
     * tile sum offsets
     */
    'tileSumOffsets'?: Array<number>;
    /**
     * null count offsets
     */
    'tileNullCountOffsets'?: Array<number>;
    /**
     * fragment min/max/sum/nullcount offsets
     */
    'fragmentMinMaxSumNullCountOffset'?: number;
    /**
     * processed conditions offsets
     */
    'processedConditionsOffsets'?: number;
}
/**
 * Event type of Group activity
 */

export const GroupActivityEventType = {
    Create: 'create',
    Update: 'update',
    Delete: 'delete',
    Register: 'register',
    Deregister: 'deregister',
    GroupMemberAdd: 'group_member_add',
    GroupMemberGet: 'group_member_get',
    GroupMemberRemove: 'group_member_remove',
    GroupMetadataGet: 'group_metadata_get',
    GroupMetadataUpdate: 'group_metadata_update',
    GroupMetadataDelete: 'group_metadata_delete',
    GroupMetadataSerialize: 'group_metadata_serialize',
    GroupMetadataDeserialize: 'group_metadata_deserialize',
    GroupMetadataConsolidate: 'group_metadata_consolidate',
    GroupMetadataVacuum: 'group_metadata_vacuum',
    ConfigSet: 'config_set',
    ConfigGet: 'config_get'
} as const;

export type GroupActivityEventType = typeof GroupActivityEventType[keyof typeof GroupActivityEventType];


/**
 * Object containing activity logs of a group and its content (arrays and subgroups) along with pagination metadata
 */
export interface GroupActivityResponse {
    /**
     * Array of activity logs, including both group and array activities
     */
    'activity_logs'?: Array<AssetActivityLog>;
    'pagination_metadata'?: PaginationMetadata;
}
/**
 * Object containing activity of an asset of a group
 */
export interface GroupContentActivity {
    'asset'?: AssetActivityLogAsset;
    'activity_log'?: ArrayActivityLog;
}
/**
 * Object containing activity logs of group content along with the pagination metadata
 */
export interface GroupContentActivityResponse {
    /**
     * Activity of a group\'s content
     */
    'activity'?: Array<GroupContentActivity>;
    'pagination_metadata'?: PaginationMetadata;
}
/**
 * Updates the contents group
 */
export interface GroupContentsChangesRequest {
    'config'?: TileDBConfig;
    'group_changes'?: GroupContentsChangesRequestGroupChanges;
}
export interface GroupContentsChangesRequestGroupChanges {
    /**
     * optional series of members to remove
     */
    'members_to_remove'?: Array<string>;
    /**
     * optional series of members to add
     */
    'members_to_add'?: Array<GroupMember>;
}
/**
 * Request the contents of a group
 */
export interface GroupContentsRetrievalRequest {
    'config'?: TileDBConfig;
}
/**
 * Object including a page of members of a group and pagination metadata
 */
export interface GroupContentsRetrievalResponse {
    /**
     * Groups members
     */
    'members'?: Array<GroupMember>;
    'metadata'?: Metadata;
}
/**
 * information for creating a new group with the passed configuration
 */
export interface GroupCreationRequest {
    'config'?: TileDBConfig;
    'group_details': GroupCreationRequestGroupDetails;
}
/**
 * Initial attributes for the creation of a group.
 */
export interface GroupCreationRequestGroupDetails {
    /**
     * A human readable description of the contents of the group.
     */
    'description'?: string;
    /**
     * The name of the group. If must be unique within the group.
     */
    'name'?: string;
    /**
     * uri of group.
     */
    'uri'?: string;
    /**
     * logo (base64 encoded) for the group. Optional
     */
    'logo'?: string;
    /**
     * optional tags for groups.
     */
    'tags'?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom.
     */
    'license_id'?: string;
    /**
     * License text
     */
    'license_text'?: string;
}
/**
 * Information of the created group
 */
export interface GroupCreationResponse {
    /**
     * The UUID of the created Group
     */
    'id'?: string;
    /**
     * The asset id of the created Group
     */
    'asset_id'?: string;
    /**
     * The name of the created Group
     */
    'name'?: string;
    /**
     * TileDB URI for access
     */
    'tiledb_uri'?: string;
}
/**
 * A groups member, array or another groups, to add or remove from an existing group.
 */
export interface GroupMember {
    /**
     * The name of the member
     */
    'name'?: string;
    /**
     * The uri of the member
     */
    'uri'?: string;
    'type'?: GroupMemberType;
}


/**
 * Specific file types of group members
 */

export const GroupMemberAssetType = {
    Group: 'group',
    Array: 'array',
    Notebook: 'notebook',
    Dashboard: 'dashboard',
    UserDefinedFunction: 'user_defined_function',
    MlModel: 'ml_model',
    File: 'file',
    Bioimg: 'bioimg',
    Soma: 'soma',
    Vcf: 'vcf',
    Pointcloud: 'pointcloud',
    Raster: 'raster',
    Geometry: 'geometry',
    VectorSearch: 'vector_search'
} as const;

export type GroupMemberAssetType = typeof GroupMemberAssetType[keyof typeof GroupMemberAssetType];


/**
 * File types that can be included in groups
 */

export const GroupMemberType = {
    Group: 'GROUP',
    Array: 'ARRAY'
} as const;

export type GroupMemberType = typeof GroupMemberType[keyof typeof GroupMemberType];


/**
 * Retrieves the metadata of a group
 */
export interface GroupMetadataRetrievalRequest {
    'config'?: TileDBConfig;
}
/**
 * Updates the metadata of a group
 */
export interface GroupMetadataUpdateRequest {
    'config'?: TileDBConfig;
    'metadata': Metadata;
}
/**
 * information for creating a new group with the passed configuration
 */
export interface GroupRegistrationRequest {
    'config'?: TileDBConfig;
    'group_details': GroupRegistrationRequestGroupDetails;
}
/**
 * Initial attributes for the creation of a group.
 */
export interface GroupRegistrationRequestGroupDetails {
    /**
     * A human readable description of the contents of the group.
     */
    'description'?: string;
    /**
     * The name of the group. If must be unique within the group.
     */
    'name'?: string;
    /**
     * The unique name or id of the parent of the group. If empty, then the new group will be a top level group.
     */
    'parent'?: string;
    /**
     * uri of group.
     */
    'uri'?: string;
    /**
     * logo (base64 encoded) for the group. Optional
     */
    'logo'?: string;
    /**
     * optional tags for groups.
     */
    'tags'?: Array<string>;
    /**
     * License identifier from SPDX License List or Custom.
     */
    'license_id'?: string;
    /**
     * License text
     */
    'license_text'?: string;
    /**
     * region of the group
     */
    'region'?: string;
    /**
     * the name of the access credentials to use. if unset, the default credentials will be used.
     */
    'access_credentials_name'?: string;
}
/**
 * Information of the created group
 */
export interface GroupRegistrationResponse {
    /**
     * The UUID of the created Group
     */
    'id'?: string;
    /**
     * The asset id of the created Group
     */
    'asset_id'?: string;
    /**
     * The name of the created Group
     */
    'name'?: string;
    /**
     * TileDB URI for access
     */
    'tiledb_uri'?: string;
}
/**
 * Layout of array
 */

export const Layout = {
    RowMajor: 'row-major',
    ColMajor: 'col-major',
    GlobalOrder: 'global-order',
    Unordered: 'unordered'
} as const;

export type Layout = typeof Layout[keyof typeof Layout];


/**
 * Stats struct
 */
export interface MapFloat64 {
    'entries'?: Array<MapFloat64EntriesInner>;
}
export interface MapFloat64EntriesInner {
    'key'?: string;
    'value'?: number;
}
/**
 * Stats struct
 */
export interface MapUInt64 {
    'entries'?: Array<MapUInt64EntriesInner>;
}
export interface MapUInt64EntriesInner {
    'key'?: string;
    'value'?: number;
}
/**
 * user\'s TileDB metadata
 */
export interface Metadata {
    /**
     * List of metadata entries
     */
    'entries'?: Array<MetadataEntry>;
}
/**
 * key/value pair representing a group metadata map entry
 */
export interface MetadataEntry {
    'key'?: string;
    'type'?: string;
    'valueNum'?: number;
    'value'?: object;
    'del'?: boolean;
}
/**
 * Represents an open array
 */
export interface ModelArray {
    'queryType': Querytype;
    /**
     * Array uri
     */
    'uri': string;
    /**
     * Ending timestamp (epoch milliseconds) array is opened at
     */
    'endTimestamp'?: number;
    /**
     * Starting timestamp (epoch milliseconds) array is opened at
     */
    'startTimestamp'?: number;
    'arraySchemaLatest'?: ArraySchema;
    'arraySchemasAll'?: ArraySchemaMap;
    'arrayMetadata'?: ArrayMetadata;
    'nonEmptyDomain'?: NonEmptyDomainList;
    'arrayDirectory'?: ArrayDirectory;
    /**
     * metadata for all fragments (for reads)
     */
    'fragmentMetadataAll'?: Array<FragmentMetadata>;
    /**
     * The ending timestamp that the array was last opened at
     */
    'openedAtEndTimestamp'?: number;
}


export interface ModelError {
    'code'?: number;
    'message'?: string;
    'request_id'?: string;
}
/**
 * object representing a non-empty domain
 */
export interface NonEmptyDomain {
    'nonEmptyDomain': DomainArray;
    /**
     * Is non-empty domain really empty?
     */
    'isEmpty': boolean;
    /**
     * Number of elements in DomainArray for var length
     */
    'sizes'?: Array<number>;
}
/**
 * object containing non empty domains
 */
export interface NonEmptyDomainList {
    /**
     * Array\'s non empty domain
     */
    'nonEmptyDomains'?: Array<NonEmptyDomain>;
}
/**
 * Uploaded notebook name and information
 */
export interface NotebookUploaded {
    /**
     * output location of the TileDB Notebook
     */
    'output_uri'?: string;
    /**
     * name of the notebook uploaded
     */
    'name'?: string;
    /**
     * The asset id of the created Group
     */
    'asset_id': string;
    /**
     * unique ID of the uploaded notebook
     */
    'id': string;
}
export interface PaginationMetadata {
    /**
     * pagination offset. Use it to skip the first ((page - 1) * per_page) items
     */
    'page'?: number;
    /**
     * pagination limit (page size)
     */
    'per_page'?: number;
    /**
     * number of total pages with current limit
     */
    'total_pages'?: number;
    /**
     * number of total available items
     */
    'total_items'?: number;
}
export interface Query {
    'type': Querytype;
    'layout': Layout;
    'status': Querystatus;
    /**
     * List of attribute buffer headers
     */
    'attributeBufferHeaders': Array<AttributeBufferHeader>;
    'writer'?: Writer;
    'reader'?: QueryReader;
    'denseReader'?: QueryReader;
    'readerIndex'?: ReaderIndex;
    'array': ModelArray;
    /**
     * Total number of bytes in fixed size attribute buffers.
     */
    'totalFixedLengthBufferBytes': number;
    /**
     * Total number of bytes in variable size attribute buffers.
     */
    'totalVarLenBufferBytes': number;
    /**
     * Total number of bytes in validity buffers
     */
    'totalValidityBufferBytes'?: number;
}


/**
 * Read struct (can\'t be called reader due to class name conflict)
 */
export interface QueryReader {
    'layout'?: Layout;
    'subarray'?: Subarray;
    'readState'?: ReadState;
}


/**
 * Status of query
 */

export const Querystatus = {
    Failed: 'FAILED',
    Completed: 'COMPLETED',
    Inprogress: 'INPROGRESS',
    Incomplete: 'INCOMPLETE',
    Uninitialized: 'UNINITIALIZED'
} as const;

export type Querystatus = typeof Querystatus[keyof typeof Querystatus];


/**
 * Type of query
 */

export const Querytype = {
    Read: 'READ',
    Write: 'WRITE'
} as const;

export type Querytype = typeof Querytype[keyof typeof Querytype];


/**
 * state for reads
 */
export interface ReadState {
    /**
     * True if the reader has been initialized.
     */
    'initialized'?: boolean;
    /**
     * True if the query produced results that could not fit in some buffer.
     */
    'overflowed'?: boolean;
    /**
     * True if the current subarray partition is unsplittable.
     */
    'unsplittable'?: boolean;
    'subarrayPartitioner'?: SubarrayPartitioner;
}
/**
 * State of reader
 */
export interface ReadStateIndex {
    /**
     * Is the reader done adding result tiles.
     */
    'doneAddingResultTiles'?: boolean;
    /**
     * Tile/cell index for each fragments.
     */
    'fragTileIdx'?: Array<FragmentIndex>;
    /**
     * Result cell slab.
     */
    'resultCellSlab'?: Array<ResultCellSlab>;
}
/**
 * Contains data needed for continuation of incomplete sparse reads with index readers
 */
export interface ReaderIndex {
    'layout'?: Layout;
    'subarray'?: Subarray;
    'readState'?: ReadStateIndex;
    'stats'?: Stats;
    'condition'?: Condition;
}


/**
 * Result cell slab
 */
export interface ResultCellSlab {
    /**
     * Fragment index
     */
    'fragIdx'?: number;
    /**
     * Tile index
     */
    'tileIdx'?: number;
    /**
     * Start of the cell slab
     */
    'start'?: number;
    /**
     * length of the cell slab
     */
    'length'?: number;
}
/**
 * Stats struct
 */
export interface Stats {
    'timers'?: MapFloat64;
    'counters'?: MapUInt64;
}
/**
 * A Subarray
 */
export interface Subarray {
    'layout'?: Layout;
    'stats'?: Stats;
    /**
     * List of 1D ranges, one per dimension
     */
    'ranges'?: Array<SubarrayRanges>;
    'relevantFragments'?: Array<number>;
    'coalesceRanges'?: boolean;
}


/**
 * The subarray partitioner
 */
export interface SubarrayPartitioner {
    'subarray'?: Subarray;
    /**
     * Result size budget (in bytes) for all attributes.
     */
    'budget'?: Array<AttributeBufferSize>;
    'current'?: SubarrayPartitionerCurrent;
    'state'?: SubarrayPartitionerState;
    /**
     * The memory budget for the fixed-sized attributes and the offsets of the var-sized attributes
     */
    'memoryBudget'?: number;
    /**
     * The memory budget for the var-sized attributes
     */
    'memoryBudgetVar'?: number;
}
/**
 * The current partition info
 */
export interface SubarrayPartitionerCurrent {
    'subarray'?: Subarray;
    /**
     * PartitionInfo start
     */
    'start'?: number;
    /**
     * PartitionInfo end
     */
    'end'?: number;
    /**
     * PartitionInfo splitMultiRange
     */
    'splitMultiRange'?: boolean;
}
/**
 * The state information for the remaining partitions to be produced
 */
export interface SubarrayPartitionerState {
    /**
     * State start
     */
    'start'?: number;
    /**
     * State end
     */
    'end'?: number;
    /**
     * State singleRange
     */
    'singleRange'?: Array<Subarray>;
    /**
     * State multiRange
     */
    'multiRange'?: Array<Subarray>;
}
/**
 * A set of 1D ranges for a subarray
 */
export interface SubarrayRanges {
    'type'?: Datatype;
    /**
     * True if the range is the default range
     */
    'hasDefaultRange'?: boolean;
    /**
     * The bytes of the ranges
     */
    'buffer'?: Array<number>;
    /**
     * The list of sizes per range
     */
    'bufferSizes'?: Array<number>;
    /**
     * The list of start sizes per range
     */
    'bufferStartSizes'?: Array<number>;
}


/**
 * TileDB config used for interaction with the embedded library
 */
export interface TileDBConfig {
    'entries'?: Array<TileDBConfigEntriesInner>;
}
export interface TileDBConfigEntriesInner {
    'key'?: string;
    'value'?: string;
}
/**
 * the timestamped filtered array metadata URIs, after removing the ones that need to be vacuumed and those that do not fall within
 */
export interface TimestampedURI {
    /**
     * the uri
     */
    'uri'?: string;
    /**
     * start of timestamp
     */
    'timestampStart'?: number;
    /**
     * end of timestamp
     */
    'timestampEnd'?: number;
}
export interface Writer {
    'checkCoordDups'?: boolean;
    'checkCoordOOB'?: boolean;
    'dedupCoords'?: boolean;
    'subarrayRanges'?: Subarray;
    'subarray'?: DomainArray;
}


/**
 * ArrayApi - axios parameter creator
 * @export
 */
export const ArrayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get array activity logs
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Refer to ActivityEventType for possible values
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog: async (workspace: string, teamspace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('arrayActivityLog', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('arrayActivityLog', 'teamspace', teamspace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('arrayActivityLog', 'array', array)
            const localVarPath = `/arrays/{workspace}/{teamspace}/{array}/activity`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (eventTypes) {
                localVarQueryParameter['event_types'] = eventTypes;
            }

            if (taskId !== undefined) {
                localVarQueryParameter['task_id'] = taskId;
            }

            if (hasTaskId !== undefined) {
                localVarQueryParameter['has_task_id'] = hasTaskId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a array at a specified URI registered to a group/project
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArrayFetch} arrayFetch Details for array being fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray: async (workspace: string, teamspace: string, array: string, contentType: string, arrayFetch: ArrayFetch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getArray', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('getArray', 'teamspace', teamspace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('getArray', 'array', array)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('getArray', 'contentType', contentType)
            // verify required parameter 'arrayFetch' is not null or undefined
            assertParamExists('getArray', 'arrayFetch', arrayFetch)
            const localVarPath = `/arrays/{workspace}/{teamspace}/{array}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(arrayFetch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArrayApi - functional programming interface
 * @export
 */
export const ArrayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArrayApiAxiosParamCreator(configuration)
    return {
        /**
         * get array activity logs
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Refer to ActivityEventType for possible values
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async arrayActivityLog(workspace: string, teamspace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArrayActivityLogData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.arrayActivityLog(workspace, teamspace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a array at a specified URI registered to a group/project
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArrayFetch} arrayFetch Details for array being fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArray(workspace: string, teamspace: string, array: string, contentType: string, arrayFetch: ArrayFetch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArray(workspace, teamspace, array, contentType, arrayFetch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArrayApi - factory interface
 * @export
 */
export const ArrayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArrayApiFp(configuration)
    return {
        /**
         * get array activity logs
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Refer to ActivityEventType for possible values
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(workspace: string, teamspace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options?: any): AxiosPromise<ArrayActivityLogData> {
            return localVarFp.arrayActivityLog(workspace, teamspace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a array at a specified URI registered to a group/project
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArrayFetch} arrayFetch Details for array being fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray(workspace: string, teamspace: string, array: string, contentType: string, arrayFetch: ArrayFetch, options?: any): AxiosPromise<ModelArray> {
            return localVarFp.getArray(workspace, teamspace, array, contentType, arrayFetch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
export class ArrayApi extends BaseAPI {
    /**
     * get array activity logs
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {string} array asset ID or hierarchical path of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {Array<string>} [eventTypes] Refer to ActivityEventType for possible values
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public arrayActivityLog(workspace: string, teamspace: string, array: string, start?: number, end?: number, eventTypes?: Array<string>, taskId?: string, hasTaskId?: boolean, page?: number, perPage?: number, options?: any) {
        return ArrayApiFp(this.configuration).arrayActivityLog(workspace, teamspace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a array at a specified URI registered to a group/project
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {string} array asset ID or hierarchical path of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArrayFetch} arrayFetch Details for array being fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    public getArray(workspace: string, teamspace: string, array: string, contentType: string, arrayFetch: ArrayFetch, options?: any) {
        return ArrayApiFp(this.configuration).getArray(workspace, teamspace, array, contentType, arrayFetch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload a file at the specified location and wrap it in TileDB Array
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {string} contentType Content Type of input
         * @param {number} filesize size of the file to upload in bytes
         * @param {File} file file to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [name] name of the TileDB array to create, if missing {array} is used
         * @param {string} [filename] original file name
         * @param {string} [mimetype] Mime type of the uploaded file. Autogenerated clients do not always support changing the content type param. Server will always use mimetype query param to set mimetype for file, if it is not set Content-Type will be used 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadFile: async (workspace: string, teamspace: string, array: string, contentType: string, filesize: number, file: File, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, filename?: string, mimetype?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('handleUploadFile', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('handleUploadFile', 'teamspace', teamspace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('handleUploadFile', 'array', array)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('handleUploadFile', 'contentType', contentType)
            // verify required parameter 'filesize' is not null or undefined
            assertParamExists('handleUploadFile', 'filesize', filesize)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('handleUploadFile', 'file', file)
            const localVarPath = `/files/{workspace}/{teamspace}/{array}/upload`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (filesize !== undefined) {
                localVarQueryParameter['filesize'] = filesize;
            }

            if (mimetype !== undefined) {
                localVarQueryParameter['mimetype'] = mimetype;
            }

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(file, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload a file at the specified location and wrap it in TileDB Array
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {string} contentType Content Type of input
         * @param {number} filesize size of the file to upload in bytes
         * @param {File} file file to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [name] name of the TileDB array to create, if missing {array} is used
         * @param {string} [filename] original file name
         * @param {string} [mimetype] Mime type of the uploaded file. Autogenerated clients do not always support changing the content type param. Server will always use mimetype query param to set mimetype for file, if it is not set Content-Type will be used 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleUploadFile(workspace: string, teamspace: string, array: string, contentType: string, filesize: number, file: File, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, filename?: string, mimetype?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploaded>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleUploadFile(workspace, teamspace, array, contentType, filesize, file, xTILEDBCLOUDACCESSCREDENTIALSNAME, name, filename, mimetype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * Upload a file at the specified location and wrap it in TileDB Array
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {string} contentType Content Type of input
         * @param {number} filesize size of the file to upload in bytes
         * @param {File} file file to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [name] name of the TileDB array to create, if missing {array} is used
         * @param {string} [filename] original file name
         * @param {string} [mimetype] Mime type of the uploaded file. Autogenerated clients do not always support changing the content type param. Server will always use mimetype query param to set mimetype for file, if it is not set Content-Type will be used 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadFile(workspace: string, teamspace: string, array: string, contentType: string, filesize: number, file: File, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, filename?: string, mimetype?: string, options?: any): AxiosPromise<FileUploaded> {
            return localVarFp.handleUploadFile(workspace, teamspace, array, contentType, filesize, file, xTILEDBCLOUDACCESSCREDENTIALSNAME, name, filename, mimetype, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Upload a file at the specified location and wrap it in TileDB Array
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {string} array asset ID or hierarchical path of array that is url-encoded
     * @param {string} contentType Content Type of input
     * @param {number} filesize size of the file to upload in bytes
     * @param {File} file file to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [name] name of the TileDB array to create, if missing {array} is used
     * @param {string} [filename] original file name
     * @param {string} [mimetype] Mime type of the uploaded file. Autogenerated clients do not always support changing the content type param. Server will always use mimetype query param to set mimetype for file, if it is not set Content-Type will be used 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public handleUploadFile(workspace: string, teamspace: string, array: string, contentType: string, filesize: number, file: File, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, filename?: string, mimetype?: string, options?: any) {
        return FilesApiFp(this.configuration).handleUploadFile(workspace, teamspace, array, contentType, filesize, file, xTILEDBCLOUDACCESSCREDENTIALSNAME, name, filename, mimetype, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an empty group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupCreationRequest} [groupCreation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createGroup', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('createGroup', 'teamspace', teamspace)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('createGroup', 'group', group)
            const localVarPath = `/groups/{workspace}/{teamspace}/{group}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(groupCreation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deregisters and physically deletes a group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [recursive] If true, it descends in the group and deletes every subgroup and subarray
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (workspace: string, teamspace: string, group: string, recursive?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteGroup', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('deleteGroup', 'teamspace', teamspace)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('deleteGroup', 'group', group)
            const localVarPath = `/groups/{workspace}/{teamspace}/{group}/delete`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deregisters a group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [recursive] If true, it descends in the group and deregisters every subgroup and subarray
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterGroup: async (workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, recursive?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deregisterGroup', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('deregisterGroup', 'teamspace', teamspace)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('deregisterGroup', 'group', group)
            const localVarPath = `/groups/{workspace}/{teamspace}/{group}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves activity logs for all assets contained in a group (arrays and other groups) including the parent group itself.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupActivity: async (workspace: string, teamspace: string, group: string, start?: number, end?: number, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getGroupActivity', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('getGroupActivity', 'teamspace', teamspace)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('getGroupActivity', 'group', group)
            const localVarPath = `/groups/{workspace}/{teamspace}/{group}/activity`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves combined activity logs for all assets contained in a group.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupContentActivity: async (workspace: string, teamspace: string, group: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getGroupContentActivity', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('getGroupContentActivity', 'teamspace', teamspace)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('getGroupContentActivity', 'group', group)
            const localVarPath = `/groups/{workspace}/{teamspace}/{group}/content_activity`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get metadata on a group using the requested config
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {GroupMetadataRetrievalRequest} [metadataRetrieval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMetadata: async (workspace: string, teamspace: string, group: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getGroupMetadata', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('getGroupMetadata', 'teamspace', teamspace)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('getGroupMetadata', 'group', group)
            const localVarPath = `/groups/{workspace}/{teamspace}/{group}/metadata`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(metadataRetrieval, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * can be used to check if the resource exists
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsWorkspaceTeamspaceGroupOptions: async (workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('groupsWorkspaceTeamspaceGroupOptions', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('groupsWorkspaceTeamspaceGroupOptions', 'teamspace', teamspace)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('groupsWorkspaceTeamspaceGroupOptions', 'group', group)
            const localVarPath = `/groups/{workspace}/{teamspace}/{group}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers an already existing group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupRegistrationRequest} [groupRegistration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGroup: async (workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('registerGroup', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('registerGroup', 'teamspace', teamspace)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('registerGroup', 'group', group)
            const localVarPath = `/groups/{workspace}/{teamspace}/{group}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(groupRegistration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the contents of a group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsRetrievalRequest} [groupRetrieval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroup: async (workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('retrieveGroup', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('retrieveGroup', 'teamspace', teamspace)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('retrieveGroup', 'group', group)
            const localVarPath = `/groups/{workspace}/{teamspace}/{group}/contents`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(groupRetrieval, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the contents of the group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsChangesRequest} [groupUpdateContents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupContents: async (workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateGroupContents', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('updateGroupContents', 'teamspace', teamspace)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('updateGroupContents', 'group', group)
            const localVarPath = `/groups/{workspace}/{teamspace}/{group}/contents`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(groupUpdateContents, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update metadata on a group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {GroupMetadataUpdateRequest} [metadataUpdating] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMetadata: async (workspace: string, teamspace: string, group: string, metadataUpdating?: GroupMetadataUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateGroupMetadata', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('updateGroupMetadata', 'teamspace', teamspace)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('updateGroupMetadata', 'group', group)
            const localVarPath = `/groups/{workspace}/{teamspace}/{group}/metadata`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(metadataUpdating, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an empty group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupCreationRequest} [groupCreation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupCreationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupCreation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deregisters and physically deletes a group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [recursive] If true, it descends in the group and deletes every subgroup and subarray
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(workspace: string, teamspace: string, group: string, recursive?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(workspace, teamspace, group, recursive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deregisters a group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [recursive] If true, it descends in the group and deregisters every subgroup and subarray
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deregisterGroup(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, recursive?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deregisterGroup(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, recursive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves activity logs for all assets contained in a group (arrays and other groups) including the parent group itself.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupActivity(workspace: string, teamspace: string, group: string, start?: number, end?: number, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupActivityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupActivity(workspace, teamspace, group, start, end, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves combined activity logs for all assets contained in a group.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupContentActivity(workspace: string, teamspace: string, group: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupContentActivityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupContentActivity(workspace, teamspace, group, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get metadata on a group using the requested config
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {GroupMetadataRetrievalRequest} [metadataRetrieval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupMetadata(workspace: string, teamspace: string, group: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupMetadata(workspace, teamspace, group, metadataRetrieval, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * can be used to check if the resource exists
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsWorkspaceTeamspaceGroupOptions(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsWorkspaceTeamspaceGroupOptions(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Registers an already existing group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupRegistrationRequest} [groupRegistration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerGroup(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupRegistrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerGroup(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRegistration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the contents of a group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsRetrievalRequest} [groupRetrieval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveGroup(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupContentsRetrievalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveGroup(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRetrieval, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change the contents of the group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsChangesRequest} [groupUpdateContents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupContents(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupContents(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupUpdateContents, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update metadata on a group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {GroupMetadataUpdateRequest} [metadataUpdating] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupMetadata(workspace: string, teamspace: string, group: string, metadataUpdating?: GroupMetadataUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupMetadata(workspace, teamspace, group, metadataUpdating, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * Creates an empty group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupCreationRequest} [groupCreation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options?: any): AxiosPromise<GroupCreationResponse> {
            return localVarFp.createGroup(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupCreation, options).then((request) => request(axios, basePath));
        },
        /**
         * Deregisters and physically deletes a group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [recursive] If true, it descends in the group and deletes every subgroup and subarray
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(workspace: string, teamspace: string, group: string, recursive?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroup(workspace, teamspace, group, recursive, options).then((request) => request(axios, basePath));
        },
        /**
         * Deregisters a group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [recursive] If true, it descends in the group and deregisters every subgroup and subarray
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterGroup(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, recursive?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deregisterGroup(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, recursive, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves activity logs for all assets contained in a group (arrays and other groups) including the parent group itself.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupActivity(workspace: string, teamspace: string, group: string, start?: number, end?: number, page?: number, perPage?: number, options?: any): AxiosPromise<GroupActivityResponse> {
            return localVarFp.getGroupActivity(workspace, teamspace, group, start, end, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves combined activity logs for all assets contained in a group.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupContentActivity(workspace: string, teamspace: string, group: string, page?: number, perPage?: number, options?: any): AxiosPromise<GroupContentActivityResponse> {
            return localVarFp.getGroupContentActivity(workspace, teamspace, group, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on a group using the requested config
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {GroupMetadataRetrievalRequest} [metadataRetrieval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMetadata(workspace: string, teamspace: string, group: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options?: any): AxiosPromise<Metadata> {
            return localVarFp.getGroupMetadata(workspace, teamspace, group, metadataRetrieval, options).then((request) => request(axios, basePath));
        },
        /**
         * can be used to check if the resource exists
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsWorkspaceTeamspaceGroupOptions(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any): AxiosPromise<void> {
            return localVarFp.groupsWorkspaceTeamspaceGroupOptions(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers an already existing group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupRegistrationRequest} [groupRegistration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerGroup(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options?: any): AxiosPromise<GroupRegistrationResponse> {
            return localVarFp.registerGroup(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRegistration, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the contents of a group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsRetrievalRequest} [groupRetrieval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroup(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options?: any): AxiosPromise<GroupContentsRetrievalResponse> {
            return localVarFp.retrieveGroup(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRetrieval, options).then((request) => request(axios, basePath));
        },
        /**
         * Change the contents of the group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {GroupContentsChangesRequest} [groupUpdateContents] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupContents(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateGroupContents(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupUpdateContents, options).then((request) => request(axios, basePath));
        },
        /**
         * update metadata on a group
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the group belongs to
         * @param {string} group The unique path or asset id of the group
         * @param {GroupMetadataUpdateRequest} [metadataUpdating] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMetadata(workspace: string, teamspace: string, group: string, metadataUpdating?: GroupMetadataUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateGroupMetadata(workspace, teamspace, group, metadataUpdating, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * Creates an empty group
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the group belongs to
     * @param {string} group The unique path or asset id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupCreationRequest} [groupCreation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupCreation?: GroupCreationRequest, options?: any) {
        return GroupsApiFp(this.configuration).createGroup(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupCreation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deregisters and physically deletes a group
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the group belongs to
     * @param {string} group The unique path or asset id of the group
     * @param {string} [recursive] If true, it descends in the group and deletes every subgroup and subarray
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroup(workspace: string, teamspace: string, group: string, recursive?: string, options?: any) {
        return GroupsApiFp(this.configuration).deleteGroup(workspace, teamspace, group, recursive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deregisters a group
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the group belongs to
     * @param {string} group The unique path or asset id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [recursive] If true, it descends in the group and deregisters every subgroup and subarray
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deregisterGroup(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, recursive?: string, options?: any) {
        return GroupsApiFp(this.configuration).deregisterGroup(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, recursive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves activity logs for all assets contained in a group (arrays and other groups) including the parent group itself.
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the group belongs to
     * @param {string} group The unique path or asset id of the group
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupActivity(workspace: string, teamspace: string, group: string, start?: number, end?: number, page?: number, perPage?: number, options?: any) {
        return GroupsApiFp(this.configuration).getGroupActivity(workspace, teamspace, group, start, end, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves combined activity logs for all assets contained in a group.
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the group belongs to
     * @param {string} group The unique path or asset id of the group
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupContentActivity(workspace: string, teamspace: string, group: string, page?: number, perPage?: number, options?: any) {
        return GroupsApiFp(this.configuration).getGroupContentActivity(workspace, teamspace, group, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get metadata on a group using the requested config
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the group belongs to
     * @param {string} group The unique path or asset id of the group
     * @param {GroupMetadataRetrievalRequest} [metadataRetrieval] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupMetadata(workspace: string, teamspace: string, group: string, metadataRetrieval?: GroupMetadataRetrievalRequest, options?: any) {
        return GroupsApiFp(this.configuration).getGroupMetadata(workspace, teamspace, group, metadataRetrieval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * can be used to check if the resource exists
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the group belongs to
     * @param {string} group The unique path or asset id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsWorkspaceTeamspaceGroupOptions(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, options?: any) {
        return GroupsApiFp(this.configuration).groupsWorkspaceTeamspaceGroupOptions(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers an already existing group
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the group belongs to
     * @param {string} group The unique path or asset id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupRegistrationRequest} [groupRegistration] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public registerGroup(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRegistration?: GroupRegistrationRequest, options?: any) {
        return GroupsApiFp(this.configuration).registerGroup(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRegistration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the contents of a group
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the group belongs to
     * @param {string} group The unique path or asset id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsRetrievalRequest} [groupRetrieval] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public retrieveGroup(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupRetrieval?: GroupContentsRetrievalRequest, options?: any) {
        return GroupsApiFp(this.configuration).retrieveGroup(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupRetrieval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change the contents of the group
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the group belongs to
     * @param {string} group The unique path or asset id of the group
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {GroupContentsChangesRequest} [groupUpdateContents] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupContents(workspace: string, teamspace: string, group: string, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, groupUpdateContents?: GroupContentsChangesRequest, options?: any) {
        return GroupsApiFp(this.configuration).updateGroupContents(workspace, teamspace, group, xTILEDBCLOUDACCESSCREDENTIALSNAME, groupUpdateContents, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update metadata on a group
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the group belongs to
     * @param {string} group The unique path or asset id of the group
     * @param {GroupMetadataUpdateRequest} [metadataUpdating] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupMetadata(workspace: string, teamspace: string, group: string, metadataUpdating?: GroupMetadataUpdateRequest, options?: any) {
        return GroupsApiFp(this.configuration).updateGroupMetadata(workspace, teamspace, group, metadataUpdating, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotebooksApi - axios parameter creator
 * @export
 */
export const NotebooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload a notebook at the specified location and wrap it in TileDB Array
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {number} filesize size of the notebook to upload in bytes
         * @param {File} notebook notebook to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [name] name of the TileDB array to create, if missing {array} is used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadNotebook: async (workspace: string, teamspace: string, array: string, filesize: number, notebook: File, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('handleUploadNotebook', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('handleUploadNotebook', 'teamspace', teamspace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('handleUploadNotebook', 'array', array)
            // verify required parameter 'filesize' is not null or undefined
            assertParamExists('handleUploadNotebook', 'filesize', filesize)
            // verify required parameter 'notebook' is not null or undefined
            assertParamExists('handleUploadNotebook', 'notebook', notebook)
            const localVarPath = `/notebooks/{workspace}/{teamspace}/{array}/upload`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (filesize !== undefined) {
                localVarQueryParameter['filesize'] = filesize;
            }

            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(notebook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotebooksApi - functional programming interface
 * @export
 */
export const NotebooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotebooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload a notebook at the specified location and wrap it in TileDB Array
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {number} filesize size of the notebook to upload in bytes
         * @param {File} notebook notebook to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [name] name of the TileDB array to create, if missing {array} is used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleUploadNotebook(workspace: string, teamspace: string, array: string, filesize: number, notebook: File, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotebookUploaded>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleUploadNotebook(workspace, teamspace, array, filesize, notebook, xTILEDBCLOUDACCESSCREDENTIALSNAME, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotebooksApi - factory interface
 * @export
 */
export const NotebooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotebooksApiFp(configuration)
    return {
        /**
         * Upload a notebook at the specified location and wrap it in TileDB Array
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {number} filesize size of the notebook to upload in bytes
         * @param {File} notebook notebook to upload
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {string} [name] name of the TileDB array to create, if missing {array} is used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleUploadNotebook(workspace: string, teamspace: string, array: string, filesize: number, notebook: File, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, options?: any): AxiosPromise<NotebookUploaded> {
            return localVarFp.handleUploadNotebook(workspace, teamspace, array, filesize, notebook, xTILEDBCLOUDACCESSCREDENTIALSNAME, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotebooksApi - object-oriented interface
 * @export
 * @class NotebooksApi
 * @extends {BaseAPI}
 */
export class NotebooksApi extends BaseAPI {
    /**
     * Upload a notebook at the specified location and wrap it in TileDB Array
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {string} array asset ID or hierarchical path of array that is url-encoded
     * @param {number} filesize size of the notebook to upload in bytes
     * @param {File} notebook notebook to upload
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {string} [name] name of the TileDB array to create, if missing {array} is used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    public handleUploadNotebook(workspace: string, teamspace: string, array: string, filesize: number, notebook: File, xTILEDBCLOUDACCESSCREDENTIALSNAME?: string, name?: string, options?: any) {
        return NotebooksApiFp(this.configuration).handleUploadNotebook(workspace, teamspace, array, filesize, notebook, xTILEDBCLOUDACCESSCREDENTIALSNAME, name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential: async (workspace: string, teamspace: string, accessCredential: AccessCredential, provider?: string, type?: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('addCredential', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('addCredential', 'teamspace', teamspace)
            // verify required parameter 'accessCredential' is not null or undefined
            assertParamExists('addCredential', 'accessCredential', accessCredential)
            const localVarPath = `/credentials/{workspace}/{teamspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential: async (workspace: string, teamspace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteCredential', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('deleteCredential', 'teamspace', teamspace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteCredential', 'name', name)
            const localVarPath = `/credentials/{workspace}/{teamspace}/{name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an access credential by name
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential: async (workspace: string, teamspace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getCredential', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('getCredential', 'teamspace', teamspace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getCredential', 'name', name)
            const localVarPath = `/credentials/{workspace}/{teamspace}/{name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the credentials available in the namespace
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials: async (workspace: string, teamspace: string, provider?: string, type?: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('listCredentials', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('listCredentials', 'teamspace', teamspace)
            const localVarPath = `/credentials/{workspace}/{teamspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential: async (workspace: string, teamspace: string, name: string, accessCredential: AccessCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateCredential', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('updateCredential', 'teamspace', teamspace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateCredential', 'name', name)
            // verify required parameter 'accessCredential' is not null or undefined
            assertParamExists('updateCredential', 'accessCredential', accessCredential)
            const localVarPath = `/credentials/{workspace}/{teamspace}/{name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCredential(workspace: string, teamspace: string, accessCredential: AccessCredential, provider?: string, type?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCredential(workspace, teamspace, accessCredential, provider, type, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCredential(workspace: string, teamspace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredential(workspace, teamspace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an access credential by name
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCredential(workspace: string, teamspace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCredential(workspace, teamspace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the credentials available in the namespace
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredentials(workspace: string, teamspace: string, provider?: string, type?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredentialsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredentials(workspace, teamspace, provider, type, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCredential(workspace: string, teamspace: string, name: string, accessCredential: AccessCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCredential(workspace, teamspace, name, accessCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential(workspace: string, teamspace: string, accessCredential: AccessCredential, provider?: string, type?: string, page?: number, perPage?: number, options?: any): AxiosPromise<void> {
            return localVarFp.addCredential(workspace, teamspace, accessCredential, provider, type, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(workspace: string, teamspace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCredential(workspace, teamspace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an access credential by name
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential(workspace: string, teamspace: string, name: string, options?: any): AxiosPromise<AccessCredential> {
            return localVarFp.getCredential(workspace, teamspace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List the credentials available in the namespace
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(workspace: string, teamspace: string, provider?: string, type?: string, page?: number, perPage?: number, options?: any): AxiosPromise<AccessCredentialsData> {
            return localVarFp.listCredentials(workspace, teamspace, provider, type, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(workspace: string, teamspace: string, name: string, accessCredential: AccessCredential, options?: any): AxiosPromise<void> {
            return localVarFp.updateCredential(workspace, teamspace, name, accessCredential, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * Create a new credential for the namespace
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public addCredential(workspace: string, teamspace: string, accessCredential: AccessCredential, provider?: string, type?: string, page?: number, perPage?: number, options?: any) {
        return OrganizationApiFp(this.configuration).addCredential(workspace, teamspace, accessCredential, provider, type, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteCredential(workspace: string, teamspace: string, name: string, options?: any) {
        return OrganizationApiFp(this.configuration).deleteCredential(workspace, teamspace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an access credential by name
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getCredential(workspace: string, teamspace: string, name: string, options?: any) {
        return OrganizationApiFp(this.configuration).getCredential(workspace, teamspace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the credentials available in the namespace
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public listCredentials(workspace: string, teamspace: string, provider?: string, type?: string, page?: number, perPage?: number, options?: any) {
        return OrganizationApiFp(this.configuration).listCredentials(workspace, teamspace, provider, type, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateCredential(workspace: string, teamspace: string, name: string, accessCredential: AccessCredential, options?: any) {
        return OrganizationApiFp(this.configuration).updateCredential(workspace, teamspace, name, accessCredential, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery: async (workspace: string, teamspace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('submitQuery', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('submitQuery', 'teamspace', teamspace)
            // verify required parameter 'array' is not null or undefined
            assertParamExists('submitQuery', 'array', array)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('submitQuery', 'type', type)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('submitQuery', 'contentType', contentType)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('submitQuery', 'query', query)
            const localVarPath = `/arrays/{workspace}/{teamspace}/{array}/query/submit`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }

            if (readAll !== undefined) {
                localVarQueryParameter['read_all'] = readAll;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(query, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration)
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitQuery(workspace: string, teamspace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitQuery(workspace, teamspace, array, type, contentType, query, xPayer, openAt, readAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryApiFp(configuration)
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} array asset ID or hierarchical path of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(workspace: string, teamspace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any): AxiosPromise<File> {
            return localVarFp.submitQuery(workspace, teamspace, array, type, contentType, query, xPayer, openAt, readAll, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {string} array asset ID or hierarchical path of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public submitQuery(workspace: string, teamspace: string, array: string, type: string, contentType: string, query: Query, xPayer?: string, openAt?: number, readAll?: string, options?: any) {
        return QueryApiFp(this.configuration).submitQuery(workspace, teamspace, array, type, contentType, query, xPayer, openAt, readAll, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential: async (workspace: string, teamspace: string, accessCredential: AccessCredential, provider?: string, type?: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('addCredential', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('addCredential', 'teamspace', teamspace)
            // verify required parameter 'accessCredential' is not null or undefined
            assertParamExists('addCredential', 'accessCredential', accessCredential)
            const localVarPath = `/credentials/{workspace}/{teamspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential: async (workspace: string, teamspace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('deleteCredential', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('deleteCredential', 'teamspace', teamspace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteCredential', 'name', name)
            const localVarPath = `/credentials/{workspace}/{teamspace}/{name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an access credential by name
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential: async (workspace: string, teamspace: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('getCredential', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('getCredential', 'teamspace', teamspace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getCredential', 'name', name)
            const localVarPath = `/credentials/{workspace}/{teamspace}/{name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the credentials available in the namespace
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials: async (workspace: string, teamspace: string, provider?: string, type?: string, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('listCredentials', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('listCredentials', 'teamspace', teamspace)
            const localVarPath = `/credentials/{workspace}/{teamspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential: async (workspace: string, teamspace: string, name: string, accessCredential: AccessCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateCredential', 'workspace', workspace)
            // verify required parameter 'teamspace' is not null or undefined
            assertParamExists('updateCredential', 'teamspace', teamspace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateCredential', 'name', name)
            // verify required parameter 'accessCredential' is not null or undefined
            assertParamExists('updateCredential', 'accessCredential', accessCredential)
            const localVarPath = `/credentials/{workspace}/{teamspace}/{name}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"teamspace"}}`, encodeURIComponent(String(teamspace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCredential(workspace: string, teamspace: string, accessCredential: AccessCredential, provider?: string, type?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCredential(workspace, teamspace, accessCredential, provider, type, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCredential(workspace: string, teamspace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredential(workspace, teamspace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an access credential by name
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCredential(workspace: string, teamspace: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCredential(workspace, teamspace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the credentials available in the namespace
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCredentials(workspace: string, teamspace: string, provider?: string, type?: string, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessCredentialsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredentials(workspace, teamspace, provider, type, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCredential(workspace: string, teamspace: string, name: string, accessCredential: AccessCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCredential(workspace, teamspace, name, accessCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential(workspace: string, teamspace: string, accessCredential: AccessCredential, provider?: string, type?: string, page?: number, perPage?: number, options?: any): AxiosPromise<void> {
            return localVarFp.addCredential(workspace, teamspace, accessCredential, provider, type, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(workspace: string, teamspace: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCredential(workspace, teamspace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an access credential by name
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential(workspace: string, teamspace: string, name: string, options?: any): AxiosPromise<AccessCredential> {
            return localVarFp.getCredential(workspace, teamspace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List the credentials available in the namespace
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(workspace: string, teamspace: string, provider?: string, type?: string, page?: number, perPage?: number, options?: any): AxiosPromise<AccessCredentialsData> {
            return localVarFp.listCredentials(workspace, teamspace, provider, type, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} workspace the workspace containing the teamspace the array belongs to
         * @param {string} teamspace the teamspace the array belongs to
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(workspace: string, teamspace: string, name: string, accessCredential: AccessCredential, options?: any): AxiosPromise<void> {
            return localVarFp.updateCredential(workspace, teamspace, name, accessCredential, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Create a new credential for the namespace
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addCredential(workspace: string, teamspace: string, accessCredential: AccessCredential, provider?: string, type?: string, page?: number, perPage?: number, options?: any) {
        return UserApiFp(this.configuration).addCredential(workspace, teamspace, accessCredential, provider, type, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteCredential(workspace: string, teamspace: string, name: string, options?: any) {
        return UserApiFp(this.configuration).deleteCredential(workspace, teamspace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an access credential by name
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCredential(workspace: string, teamspace: string, name: string, options?: any) {
        return UserApiFp(this.configuration).getCredential(workspace, teamspace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the credentials available in the namespace
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {string} [type] Show only the credentials of this type. This should be one of the AccessCredentialType enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listCredentials(workspace: string, teamspace: string, provider?: string, type?: string, page?: number, perPage?: number, options?: any) {
        return UserApiFp(this.configuration).listCredentials(workspace, teamspace, provider, type, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} workspace the workspace containing the teamspace the array belongs to
     * @param {string} teamspace the teamspace the array belongs to
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateCredential(workspace: string, teamspace: string, name: string, accessCredential: AccessCredential, options?: any) {
        return UserApiFp(this.configuration).updateCredential(workspace, teamspace, name, accessCredential, options).then((request) => request(this.axios, this.basePath));
    }
}

